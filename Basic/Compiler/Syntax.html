<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Syntax Analyzer - Reticence&#x27;s Notes</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../../index.html">Index</a></li><li class="chapter-item "><a href="../../Advanced/index.html">Advanced</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Advanced/Blockchain/index.html">Block Chain</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Advanced/Blockchain/Basic/index.html">区块链技术</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Advanced/Blockchain/Basic/Consensus.html">共识机制</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/Basic/Crypto.html">加密</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/Basic/Distribute.html">分布式存储</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/Basic/P2P.html">P2P</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/Basic/SmartContract.html">如何执行智能合约</a></li></ol></li><li class="chapter-item "><a href="../../Advanced/Blockchain/Defi/index.html">DeFi</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Advanced/Blockchain/Defi/DAO.html">Decentralized Autonomous Organization</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/Defi/Derivative.html">Decentralized Derivative</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/Defi/Exchange.html">Decentralized Exchange</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/Defi/FundManagement.html">Decentralized Fund Management</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/Defi/Insurance.html">Decentralized Insurance</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/Defi/LendBorrow.html">Decentralized Lending & Borrowing</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/Defi/Lottery.html">Decentralized Lottery</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/Defi/Payments.html">Decentralized Payments</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/Defi/StableCoin.html">Stable Coins</a></li></ol></li><li class="chapter-item "><a href="../../Advanced/Blockchain/Ethernet/index.html">Ethernet</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Advanced/Blockchain/Ethernet/Solidity.html">Solidity简介</a></li></ol></li><li class="chapter-item "><a href="../../Advanced/Blockchain/NEAR/index.html">Hello NEAR</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Advanced/Blockchain/NEAR/PoS.html">Proof-of-Stake</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/NEAR/Promise.html">异步模型</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/NEAR/Secure.html">Secure</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/NEAR/Snippets.html">Snippets</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/NEAR/Standards.html">标准实现代码分析</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/NEAR/dao.html">dao</a></li><li class="chapter-item "><a href="../../Advanced/Blockchain/NEAR/wasm.html">wasm</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../Advanced/Linux/index.html">Linux</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Advanced/Linux/LinuxKernel/index.html">Linux</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Advanced/Linux/LinuxKernel/Credential.html">Credential</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxKernel/Debug笔记.html">Debug笔记</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxKernel/File_System.html">File System</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxKernel/Linux内核设计与实现笔记.html">《Linux内核设计与实现》笔记</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxKernel/Linux设备驱动笔记.html">《Linux设备驱动》笔记</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxKernel/RCU.html">RCU</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxKernel/Rust_for_linux.html">Rust for linux</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxKernel/System_Call.html">System Call</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxKernel/context_switch.html">进程调度时的context_switch</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxKernel/内核编程笔记.html">Linux内核编程笔记</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxKernel/数据结构.html">数据结构</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxKernel/调试Linux内核环境搭建.html">调试Linux内核环境搭建</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxKernel/调试时如何获取current.html">调试Linux内核，寻找current</a></li></ol></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxPlay/index.html">LinuxPlay</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Advanced/Linux/LinuxPlay/Linux使用笔记.html">Linux使用笔记</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxPlay/使用SSH远程登录.html">Linux使用SSH远程登录</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxPlay/在Linux中找到可用的网络接口.html">在Linux中找到可用的网络接口</a></li></ol></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/index.html">Linux Program</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/Deamon.html">Daemon</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/Fanotify.html">Fanotify</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/File.html">File Program</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/IObound.html">I/O bound 程序优化</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/Linux目录结构.html">Linux目录结构</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/NetLink.html">Netlink</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/Socket.html">Socket</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/eBPF.html">eBPF</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/prctl.html">进程</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/信号.html">信号</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/共享库.html">共享库</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/凭证.html">Credential 凭证</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/反向Shell和伪终端.html">反向Shell和伪终端</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/性能监控.html">性能监控</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/桌面应用开发.html">桌面应用开发</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/管道和重定向.html">管道和重定向</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/系统限制和选项.html">系统限制和选项</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/终端.html">终端</a></li><li class="chapter-item "><a href="../../Advanced/Linux/LinuxProgram/进程间通信.html">进程间通信</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../Advanced/Windows/index.html">Windows Programming</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Advanced/Windows/Unicode.html">Unicode</a></li><li class="chapter-item "><a href="../../Advanced/Windows/hungarian.html">匈牙利命名法</a></li><li class="chapter-item "><a href="../../Advanced/Windows/文件.html">文件</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../Basic/index.html">Basic</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/8086汇编笔记.html">8086汇编笔记</a></li><li class="chapter-item "><a href="../../Basic/Architecture/index.html">Architecture</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/Architecture/ARM内存管理.html">AArch64 memory management</a></li><li class="chapter-item "><a href="../../Basic/Architecture/ARM寄存器.html">ARM中的寄存器</a></li><li class="chapter-item "><a href="../../Basic/Architecture/ARM异常.html">AArch64 Exception Model</a></li><li class="chapter-item "><a href="../../Basic/Architecture/ARM虚拟化.html">Armv8-A virtualization</a></li><li class="chapter-item "><a href="../../Basic/Architecture/ARM调试.html">ARM self-hosted debug</a></li><li class="chapter-item "><a href="../../Basic/Architecture/CPU设计.html">CPU设计</a></li><li class="chapter-item "><a href="../../Basic/Architecture/Cache.html">Cache</a></li><li class="chapter-item "><a href="../../Basic/Architecture/ILP.html">ILP</a></li><li class="chapter-item "><a href="../../Basic/Architecture/SIMD和MIMD.html">SIMD和MIMD</a></li><li class="chapter-item "><a href="../../Basic/Architecture/TLP.html">TLP</a></li><li class="chapter-item "><a href="../../Basic/Architecture/存储器设计.html">存储器设计</a></li><li class="chapter-item "><a href="../../Basic/Architecture/数字逻辑.html">Notes-数字逻辑</a></li><li class="chapter-item "><a href="../../Basic/Architecture/计算机体系结构.html">计算机组成&计算机体系结构</a></li></ol></li><li class="chapter-item "><a href="../../Basic/C/index.html">C/C++</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/C/Cpp标准库.html">C++_标准库</a></li><li class="chapter-item "><a href="../../Basic/C/Cpp课程笔记.html">C++ 基础知识</a></li><li class="chapter-item "><a href="../../Basic/C/GCC内嵌汇编.html">C-内嵌汇编</a></li><li class="chapter-item "><a href="../../Basic/C/变量在ELF段中的位置.html">变量在ELF段中的位置</a></li><li class="chapter-item "><a href="../../Basic/C/可变参数的使用和原理.html">可变参数的使用和原理</a></li><li class="chapter-item "><a href="../../Basic/C/在C程序中调用汇编程序.html">在C程序中调用汇编程序</a></li><li class="chapter-item "><a href="../../Basic/C/链接器.html">链接器</a></li></ol></li><li class="chapter-item "><a href="../../Basic/Client/index.html">Client Development</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/Client/Chromium.html">Chromium</a></li><li class="chapter-item "><a href="../../Basic/Client/CodeReview.html">CodeReview</a></li><li class="chapter-item "><a href="../../Basic/Client/Config.html">Config</a></li><li class="chapter-item "><a href="../../Basic/Client/CrossLanguage.html">跨语言</a></li><li class="chapter-item "><a href="../../Basic/Client/DataStore.html">本地存储</a></li><li class="chapter-item "><a href="../../Basic/Client/Database.html">Database</a></li><li class="chapter-item "><a href="../../Basic/Client/Flutter.html">Flutter</a></li><li class="chapter-item "><a href="../../Basic/Client/Log.html">日志</a></li><li class="chapter-item "><a href="../../Basic/Client/Multimedia/index.html">Multimedia</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/Client/Multimedia/Graph.html">图形学</a></li><li class="chapter-item "><a href="../../Basic/Client/Multimedia/Image.html">图像处理技术</a></li><li class="chapter-item "><a href="../../Basic/Client/Multimedia/Video.html">视频</a></li><li class="chapter-item "><a href="../../Basic/Client/Multimedia/Voice.html">Voice</a></li></ol></li><li class="chapter-item "><a href="../../Basic/Client/Network.html">网络能力</a></li><li class="chapter-item "><a href="../../Basic/Client/Performance.html">性能监控</a></li><li class="chapter-item "><a href="../../Basic/Client/Platform/index.html">Platform</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/Client/Platform/Android.html">Android</a></li><li class="chapter-item "><a href="../../Basic/Client/Platform/iOS.html">iOS</a></li></ol></li><li class="chapter-item "><a href="../../Basic/Client/SQLite.html">SQLite</a></li></ol></li><li class="chapter-item expanded "><a href="../../Basic/Compiler/index.html">Compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/Compiler/Codegen.html">代码生成</a></li><li class="chapter-item "><a href="../../Basic/Compiler/Lex.html">Lex</a></li><li class="chapter-item "><a href="../../Basic/Compiler/Lexical.html">Lexical Analyze</a></li><li class="chapter-item "><a href="../../Basic/Compiler/Runtime.html">Runtime</a></li><li class="chapter-item "><a href="../../Basic/Compiler/Sematic.html">Sematic Analyzing</a></li><li class="chapter-item expanded "><a href="../../Basic/Compiler/Syntax.html" class="active">Syntax Analyzer</a></li><li class="chapter-item "><a href="../../Basic/Compiler/llvm-ir.html">LLVM-IR</a></li><li class="chapter-item "><a href="../../Basic/Compiler/llvm.html">LLVM</a></li><li class="chapter-item "><a href="../../Basic/Compiler/pest.html">PEST</a></li><li class="chapter-item "><a href="../../Basic/Compiler/yacc.html">Yacc</a></li></ol></li><li class="chapter-item "><a href="../../Basic/DataStructure/index.html">Data Structure And Algorithm</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/DataStructure/Algorithm/index.html">Algorithm</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/DataStructure/Algorithm/Approximation.html">近似算法</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Algorithm/Backtracking.html">递归回溯</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Algorithm/DivideAndConquer.html">分治算法</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Algorithm/DynamicProgramming.html">动态规划</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Algorithm/Greedy.html">贪心算法</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Algorithm/LocalSearch.html">本地搜索</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Algorithm/Parallel.html">并行算法</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Algorithm/Randomized.html">随机化算法</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Algorithm/Sort.html">排序算法</a></li></ol></li><li class="chapter-item "><a href="../../Basic/DataStructure/Graph/index.html">Graph</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/DataStructure/Graph/Bipartite.html">Bipartite</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Graph/NetworkFlow.html">NetworkFlow</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Graph/ShortPath.html">最短路</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Graph/SpanningTree.html">最小生成树</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Graph/关键路径.html">关键路径</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Graph/拓扑排序.html">拓扑排序</a></li></ol></li><li class="chapter-item "><a href="../../Basic/DataStructure/Hash/index.html">Hash</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/DataStructure/Hash/HashTree.html">HashTree</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Hash/Hashing.html">Hashing</a></li></ol></li><li class="chapter-item "><a href="../../Basic/DataStructure/Heap/index.html">Heap</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/DataStructure/Heap/BinomialHeap.html">Binomial Heap</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Heap/FibonacciHeap.html">FibonacciHeap</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Heap/Heap.html">DS-Heap</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Heap/斜堆.html">Leftist_Heap_and_Skew_Heap</a></li></ol></li><li class="chapter-item "><a href="../../Basic/DataStructure/Inverted_File_Index.html">Inverted_File_Index</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Linear/index.html">Linear</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/DataStructure/Linear/Bitmap.html">DS-Bitmap</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Linear/List.html">DS-Linear_List</a></li></ol></li><li class="chapter-item "><a href="../../Basic/DataStructure/NPProblem.html">DS-NP_problem</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/String/index.html">字符串匹配相关算法</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/DataStructure/String/match.html">字符串匹配算法</a></li></ol></li><li class="chapter-item "><a href="../../Basic/DataStructure/Tree/index.html">Tree and BST</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/DataStructure/Tree/BTree.html">B Tree and B+ Tree</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Tree/BalancedTree.html">AVL Tree and Splay Tree</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Tree/DisjointSet.html">Disjoint Set</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Tree/HuffmanTree.html">Huffman Tree</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Tree/RBTree.html">红黑树 B树 B+树</a></li><li class="chapter-item "><a href="../../Basic/DataStructure/Tree/ThreadedTree.html">Threaded Binary Tree</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../Basic/Database/index.html">Database</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/Database/Object.html">Database-Object-Based_Databases</a></li><li class="chapter-item "><a href="../../Basic/Database/PostgreSQL-Conflict-reticenceji_Win10.html">Database-PostgreSQL</a></li><li class="chapter-item "><a href="../../Basic/Database/PostgreSQL.html">Database-PostgreSQL</a></li><li class="chapter-item "><a href="../../Basic/Database/SQL-Conflict-reticenceji_Win10.html">基础SQL</a></li><li class="chapter-item "><a href="../../Basic/Database/SQL.html">基础SQL</a></li><li class="chapter-item "><a href="../../Basic/Database/XML-Conflict-reticenceji_Win10.html">Database,Web-XML</a></li><li class="chapter-item "><a href="../../Basic/Database/XML.html">Database,Web-XML</a></li><li class="chapter-item "><a href="../../Basic/Database/事务.html">Database-事务</a></li><li class="chapter-item "><a href="../../Basic/Database/关系代数.html">Database-关系代数</a></li><li class="chapter-item "><a href="../../Basic/Database/存储和查询.html">Database-存储和查询</a></li><li class="chapter-item "><a href="../../Basic/Database/导论.html">Database-导论</a></li><li class="chapter-item "><a href="../../Basic/Database/数据库设计.html">Database-数据库设计</a></li></ol></li><li class="chapter-item "><a href="../../Basic/Maths/index.html">Maths</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/Maths/大数定理和中心极限定理.html">大数定理和中心极限定理</a></li><li class="chapter-item "><a href="../../Basic/Maths/微积分下.html">微积分下</a></li><li class="chapter-item "><a href="../../Basic/Maths/数值计算方法.html">数值计算方法</a></li><li class="chapter-item "><a href="../../Basic/Maths/最小二乘法.html">最小二乘法</a></li><li class="chapter-item "><a href="../../Basic/Maths/有限自动机介绍.html">有限自动机介绍</a></li><li class="chapter-item "><a href="../../Basic/Maths/概统复习.html">概统复习</a></li><li class="chapter-item "><a href="../../Basic/Maths/群论简介.html">群论简介</a></li></ol></li><li class="chapter-item "><a href="../../Basic/Networking/index.html">Networking</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/Networking/ARP.html">Networking-ARP</a></li><li class="chapter-item "><a href="../../Basic/Networking/CDN.html">CDN</a></li><li class="chapter-item "><a href="../../Basic/Networking/DNS.html">DNS</a></li><li class="chapter-item "><a href="../../Basic/Networking/FTP.html">FTP</a></li><li class="chapter-item "><a href="../../Basic/Networking/HTTP.html">HTTP</a></li><li class="chapter-item "><a href="../../Basic/Networking/ICMP.html">Internet Control Message Protocol</a></li><li class="chapter-item "><a href="../../Basic/Networking/Mail.html">邮件协议</a></li><li class="chapter-item "><a href="../../Basic/Networking/NAT.html">Network Address Translation</a></li><li class="chapter-item "><a href="../../Basic/Networking/P2P.html">P2P</a></li><li class="chapter-item "><a href="../../Basic/Networking/QUIC.html">QUIC</a></li><li class="chapter-item "><a href="../../Basic/Networking/RTC.html">RTC</a></li><li class="chapter-item "><a href="../../Basic/Networking/Socket.html">Socket</a></li><li class="chapter-item "><a href="../../Basic/Networking/TCP.html">TCP</a></li><li class="chapter-item "><a href="../../Basic/Networking/UDP.html">UDP</a></li><li class="chapter-item "><a href="../../Basic/Networking/VMWare虚拟机网络配置.html">VMWare虚拟机网络配置</a></li><li class="chapter-item "><a href="../../Basic/Networking/VPN.html">VPN</a></li><li class="chapter-item "><a href="../../Basic/Networking/WebSocket.html">WebSocket</a></li><li class="chapter-item "><a href="../../Basic/Networking/介质访问子层.html">Medium Access Sublayer</a></li><li class="chapter-item "><a href="../../Basic/Networking/可靠传输.html">可靠传输</a></li><li class="chapter-item "><a href="../../Basic/Networking/差错控制.html">差错控制</a></li><li class="chapter-item "><a href="../../Basic/Networking/拥塞控制和流量控制.html">拥塞控制和流量控制</a></li><li class="chapter-item "><a href="../../Basic/Networking/物理层.html">物理层</a></li><li class="chapter-item "><a href="../../Basic/Networking/网络层.html">网络层 IP</a></li><li class="chapter-item "><a href="../../Basic/Networking/网络设备.html">Networking-网络设备</a></li><li class="chapter-item "><a href="../../Basic/Networking/路由协议.html">路由协议</a></li><li class="chapter-item "><a href="../../Basic/Networking/链路层.html">链路层</a></li></ol></li><li class="chapter-item "><a href="../../Basic/OS/index.html">OS</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/OS/Bootloader.html">OS-Bootloader</a></li><li class="chapter-item "><a href="../../Basic/OS/Buddy_System&Slub.html">OS-Buddy_System&Slub</a></li><li class="chapter-item "><a href="../../Basic/OS/Deadlock.html">OS-Deadlock</a></li><li class="chapter-item "><a href="../../Basic/OS/IO.html">OS-IO</a></li><li class="chapter-item "><a href="../../Basic/OS/Introduction.html">OS-Introduction</a></li><li class="chapter-item "><a href="../../Basic/OS/Memory_Management.html">OS-Memory_Management</a></li><li class="chapter-item "><a href="../../Basic/OS/Process.html">OS-Process</a></li><li class="chapter-item "><a href="../../Basic/OS/Q&A.html">OS-Q&A</a></li><li class="chapter-item "><a href="../../Basic/OS/RISCV学习笔记.html">OS-RISCV学习笔记</a></li><li class="chapter-item "><a href="../../Basic/OS/SBI.html">OS-SBI</a></li><li class="chapter-item "><a href="../../Basic/OS/Synchronization.html">OS-Synchronization</a></li><li class="chapter-item "><a href="../../Basic/OS/Thread.html">OS-Thread</a></li><li class="chapter-item "><a href="../../Basic/OS/UnixLinux中的IO模型.html">Linux中的I/O模型</a></li><li class="chapter-item "><a href="../../Basic/OS/在K210运行裸机程序.html">OS-在K210运行裸机程序</a></li><li class="chapter-item "><a href="../../Basic/OS/地址空间(一).html">OS-地址空间(一)</a></li><li class="chapter-item "><a href="../../Basic/OS/操作系统.html">OS-操作系统</a></li></ol></li><li class="chapter-item "><a href="../../Basic/Secure/index.html">Secure</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/Secure/Crypto/index.html">Crypto</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/Secure/Crypto/Federated_Learning.html">Federated Learning</a></li><li class="chapter-item "><a href="../../Basic/Secure/Crypto/Oblivious_RAM.html">Oblivious RAM</a></li><li class="chapter-item "><a href="../../Basic/Secure/Crypto/PIR.html">PIR</a></li><li class="chapter-item "><a href="../../Basic/Secure/Crypto/PSI.html">Private set intersection</a></li><li class="chapter-item "><a href="../../Basic/Secure/Crypto/加密和哈希.html">Crypto-加密和哈希</a></li><li class="chapter-item "><a href="../../Basic/Secure/Crypto/加密数据库.html">Encrypted Database</a></li><li class="chapter-item "><a href="../../Basic/Secure/Crypto/区块链技术.html">Bitcoin-区块链技术</a></li><li class="chapter-item "><a href="../../Basic/Secure/Crypto/可证明安全.html">可证明安全</a></li><li class="chapter-item "><a href="../../Basic/Secure/Crypto/安全多方计算.html">安全多方计算</a></li><li class="chapter-item "><a href="../../Basic/Secure/Crypto/密码学基础.html">密码学算法介绍</a></li><li class="chapter-item "><a href="../../Basic/Secure/Crypto/密码学进阶.html">密码学进阶</a></li><li class="chapter-item "><a href="../../Basic/Secure/Crypto/差分隐私.html">差分隐私</a></li></ol></li><li class="chapter-item "><a href="../../Basic/Secure/CryptoBasic.html">密码学基础</a></li><li class="chapter-item "><a href="../../Basic/Secure/CtyptoProtocol.html">密码学协议</a></li><li class="chapter-item "><a href="../../Basic/Secure/Forensics/index.html">电子取证</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/Secure/Forensics/FAT.html">FAT文件系统</a></li><li class="chapter-item "><a href="../../Basic/Secure/Forensics/FileCarving.html">文件雕复</a></li><li class="chapter-item "><a href="../../Basic/Secure/Forensics/Linux取证.html">Linux取证</a></li><li class="chapter-item "><a href="../../Basic/Secure/Forensics/Memory.html">内存取证</a></li><li class="chapter-item "><a href="../../Basic/Secure/Forensics/NTFS.html">NTFS文件系统</a></li><li class="chapter-item "><a href="../../Basic/Secure/Forensics/Windows取证.html">Windows取证</a></li><li class="chapter-item "><a href="../../Basic/Secure/Forensics/数据隐藏.html">数据隐藏</a></li><li class="chapter-item "><a href="../../Basic/Secure/Forensics/文件系统取证.html">文件系统取证</a></li><li class="chapter-item "><a href="../../Basic/Secure/Forensics/硬盘分析.html">硬盘分析</a></li><li class="chapter-item "><a href="../../Basic/Secure/Forensics/移动设备取证.html">移动设备取证</a></li><li class="chapter-item "><a href="../../Basic/Secure/Forensics/网络取证.html">网络取证</a></li></ol></li><li class="chapter-item "><a href="../../Basic/Secure/IoT.html">无线与物联网安全</a></li><li class="chapter-item "><a href="../../Basic/Secure/Network.html">网络安全</a></li><li class="chapter-item "><a href="../../Basic/Secure/OperatingSystem.html">操作系统安全</a></li><li class="chapter-item "><a href="../../Basic/Secure/Software/index.html">软件安全</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Basic/Secure/Software/ASLR.html">ASLR</a></li><li class="chapter-item "><a href="../../Basic/Secure/Software/CodeQL.html">CodeQL</a></li><li class="chapter-item "><a href="../../Basic/Secure/Software/GlibcHeap.html">glibc heap allocator</a></li><li class="chapter-item "><a href="../../Basic/Secure/Software/PIC.html">位置无关代码和共享库</a></li><li class="chapter-item "><a href="../../Basic/Secure/Software/RELRO.html">RELRO</a></li><li class="chapter-item "><a href="../../Basic/Secure/Software/pwntools.html">pwntools</a></li><li class="chapter-item "><a href="../../Basic/Secure/Software/攻击视角.html">攻击软件安全</a></li><li class="chapter-item "><a href="../../Basic/Secure/Software/程序分析.html">程序分析</a></li><li class="chapter-item "><a href="../../Basic/Secure/Software/防御视角.html">软件安全防护</a></li></ol></li><li class="chapter-item "><a href="../../Basic/Secure/SupplyChain.html">供应链安全</a></li></ol></li><li class="chapter-item "><a href="../../Basic/软件保护技术.html">Reverse</a></li></ol></li><li class="chapter-item "><a href="../../Language/index.html">Language</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Language/Java/index.html">Java</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Language/Java/基础.html">Java</a></li><li class="chapter-item "><a href="../../Language/Java/鸿蒙应用开发.html">Java-鸿蒙应用开发</a></li></ol></li><li class="chapter-item "><a href="../../Language/JavaScript/index.html">JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Language/JavaScript/Electron.html">Electron</a></li><li class="chapter-item "><a href="../../Language/JavaScript/JavaScript简介.html">JavaScript简介</a></li><li class="chapter-item "><a href="../../Language/JavaScript/Runtime.html">Runtime</a></li></ol></li><li class="chapter-item "><a href="../../Language/Python/index.html">Python</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Language/Python/0内置类型/index.html">内置对象</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Language/Python/0内置类型/1字符串.html">字符串和字节串</a></li><li class="chapter-item "><a href="../../Language/Python/0内置类型/2数值.html">数值</a></li><li class="chapter-item "><a href="../../Language/Python/0内置类型/3列表和元组.html">序列</a></li><li class="chapter-item "><a href="../../Language/Python/0内置类型/4字典和集合.html">映射</a></li><li class="chapter-item "><a href="../../Language/Python/0内置类型/5迭代器和生成器.html">迭代器和生成器</a></li><li class="chapter-item "><a href="../../Language/Python/0内置类型/6上下文管理器.html">上下文管理器</a></li></ol></li><li class="chapter-item "><a href="../../Language/Python/1工作原理/index.html">工作原理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Language/Python/1工作原理/0对象模型.html">OOP模型</a></li><li class="chapter-item "><a href="../../Language/Python/1工作原理/1类型.html">类型</a></li><li class="chapter-item "><a href="../../Language/Python/1工作原理/2变量.html">变量</a></li><li class="chapter-item "><a href="../../Language/Python/1工作原理/3特殊方法和重载.html">特殊方法和重载</a></li><li class="chapter-item "><a href="../../Language/Python/1工作原理/4参数.html">参数</a></li><li class="chapter-item "><a href="../../Language/Python/1工作原理/5多继承.html">多继承</a></li></ol></li><li class="chapter-item "><a href="../../Language/Python/3高级写法/index.html">高级写法</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Language/Python/3高级写法/1异常.html">Exception</a></li><li class="chapter-item "><a href="../../Language/Python/3高级写法/2装饰器.html">装饰器</a></li></ol></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/index.html">PythonLib</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Language/Python/4好用的库/Argparse.html">命令行参数</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/Bisect.html">Bisect</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/Builtin.html">Builtin</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/Container.html">Container</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/Crypto.html">Crypto</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/Enum.html">enum</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/FS.html">File System</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/Flask.html">Python-Flask</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/HTTP.html">Internet</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/IO.html">File IO</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/PyQt5.html">PySide2</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/Regex.html">Regex</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/Socket.html">Socket编程</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/Thread.html">多线程</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/Time.html">时间和日期</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/Trio.html">Trio</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/format.html">Format String</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/venv.html">Virtual Environment</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/数据持久化.html">简单的数据持久化</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/文档和测试.html">文档和测试</a></li><li class="chapter-item "><a href="../../Language/Python/4好用的库/计算器.html">把Python当计算器</a></li></ol></li><li class="chapter-item "><a href="../../Language/Python/运算符.html">运算符</a></li></ol></li><li class="chapter-item "><a href="../../Language/Rust/index.html">Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Language/Rust/Basic/index.html">Basic</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Language/Rust/Basic/Any.html">Any</a></li><li class="chapter-item "><a href="../../Language/Rust/Basic/Async.html">异步编程</a></li><li class="chapter-item "><a href="../../Language/Rust/Basic/Casting.html">Casting</a></li><li class="chapter-item "><a href="../../Language/Rust/Basic/ClosureAndIter.html">迭代器和闭包</a></li><li class="chapter-item "><a href="../../Language/Rust/Basic/CratesAndModules.html">Crates and Modules</a></li><li class="chapter-item "><a href="../../Language/Rust/Basic/Error.html">Rust-错误处理</a></li><li class="chapter-item "><a href="../../Language/Rust/Basic/Macro.html">宏</a></li><li class="chapter-item "><a href="../../Language/Rust/Basic/Trait.html">Trait</a></li><li class="chapter-item "><a href="../../Language/Rust/Basic/TypeAndLifetime.html">从类型系统看生命周期</a></li><li class="chapter-item "><a href="../../Language/Rust/Basic/Unsafe.html">Unsafe</a></li><li class="chapter-item "><a href="../../Language/Rust/Basic/pattern.html">模式匹配</a></li></ol></li><li class="chapter-item "><a href="../../Language/Rust/Build.html">Build</a></li><li class="chapter-item "><a href="../../Language/Rust/Cargo/index.html">Cargo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Language/Rust/Cargo/clippy.html">Clippy</a></li><li class="chapter-item "><a href="../../Language/Rust/Cargo/fix.html">Cargo fix</a></li><li class="chapter-item "><a href="../../Language/Rust/Cargo/make.html">Cargo make</a></li></ol></li><li class="chapter-item "><a href="../../Language/Rust/Compiler.html">Compiler</a></li><li class="chapter-item "><a href="../../Language/Rust/Crate/index.html">Crates</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Language/Rust/Crate/Anyhow.html">AnyHow & ThisError</a></li><li class="chapter-item "><a href="../../Language/Rust/Crate/Cell.html">Cell</a></li><li class="chapter-item "><a href="../../Language/Rust/Crate/Diesel.html">Diesel</a></li><li class="chapter-item "><a href="../../Language/Rust/Crate/Dioxus.html">Dioxus</a></li><li class="chapter-item "><a href="../../Language/Rust/Crate/EnumDispatch.html">Dispatch</a></li><li class="chapter-item "><a href="../../Language/Rust/Crate/IO.html">IO</a></li><li class="chapter-item "><a href="../../Language/Rust/Crate/collections.html">容器的增删改查</a></li><li class="chapter-item "><a href="../../Language/Rust/Crate/gtk-rs.html">gtk-rs</a></li><li class="chapter-item "><a href="../../Language/Rust/Crate/r2d2.html">r2d2</a></li><li class="chapter-item "><a href="../../Language/Rust/Crate/stdsync.html">std::sync</a></li><li class="chapter-item "><a href="../../Language/Rust/Crate/字符串.html">字符串/字节流</a></li><li class="chapter-item "><a href="../../Language/Rust/Crate/打包.html">打包</a></li><li class="chapter-item "><a href="../../Language/Rust/Crate/智能指针.html">Rust-智能指针</a></li></ol></li><li class="chapter-item "><a href="../../Language/Rust/FFI.html">FFI</a></li><li class="chapter-item "><a href="../../Language/Rust/IO.html">Rust-IO</a></li><li class="chapter-item "><a href="../../Language/Rust/Practice/index.html">Practice</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Language/Rust/Practice/BestPractice.html">Rust最佳实践</a></li><li class="chapter-item "><a href="../../Language/Rust/Practice/Debug.html">调试</a></li><li class="chapter-item "><a href="../../Language/Rust/Practice/DesignPattern.html">设计模式</a></li><li class="chapter-item "><a href="../../Language/Rust/Practice/Performance.html">性能优化</a></li><li class="chapter-item "><a href="../../Language/Rust/Practice/Size.html">代码体积优化</a></li><li class="chapter-item "><a href="../../Language/Rust/Practice/Test.html">测试最佳实践</a></li><li class="chapter-item "><a href="../../Language/Rust/Practice/Type.html">类型转换</a></li><li class="chapter-item "><a href="../../Language/Rust/Practice/Unsafe.html">Unsafe最佳实践</a></li></ol></li><li class="chapter-item "><a href="../../Language/Rust/gtk.html">Rust-gtk-rs介绍</a></li><li class="chapter-item "><a href="../../Language/Rust/函数参数匹配.html">函数参数匹配</a></li><li class="chapter-item "><a href="../../Language/Rust/基础知识.html">基础知识</a></li><li class="chapter-item "><a href="../../Language/Rust/多线程.html">多线程支持</a></li><li class="chapter-item "><a href="../../Language/Rust/混合编程.html">混合编程</a></li><li class="chapter-item "><a href="../../Language/Rust/精髓.html">Rust-精髓</a></li></ol></li><li class="chapter-item "><a href="../../Language/Scala/index.html">Scala</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Language/Scala/0控制结构.html">控制结构</a></li><li class="chapter-item "><a href="../../Language/Scala/1数据结构.html">数据结构</a></li><li class="chapter-item "><a href="../../Language/Scala/2_0类和对象.html">Class</a></li><li class="chapter-item "><a href="../../Language/Scala/2_1继承.html">继承</a></li><li class="chapter-item "><a href="../../Language/Scala/2_2特质.html">Trait</a></li><li class="chapter-item "><a href="../../Language/Scala/3_1花里胡哨的函数.html">花里胡哨的函数</a></li><li class="chapter-item "><a href="../../Language/Scala/3_2匿名函数和闭包.html">函数</a></li><li class="chapter-item "><a href="../../Language/Scala/3_3模式匹配.html">模式匹配</a></li><li class="chapter-item "><a href="../../Language/Scala/3_4容器的函数式操作.html">容器的函数式操作</a></li><li class="chapter-item "><a href="../../Language/Scala/ScalaDepth/index.html">ScalaDepth</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Language/Scala/ScalaDepth/Class文件.html">Class文件</a></li><li class="chapter-item "><a href="../../Language/Scala/ScalaDepth/ScalaInDepth.html">Scala in Depth 读书笔记</a></li><li class="chapter-item "><a href="../../Language/Scala/ScalaDepth/Spark.html">Spark</a></li><li class="chapter-item "><a href="../../Language/Scala/ScalaDepth/jvm.html">《深入理解Java虚拟机读书》笔记</a></li><li class="chapter-item "><a href="../../Language/Scala/ScalaDepth/函数式的一些概念.html">Scala中一些函数式概念</a></li><li class="chapter-item "><a href="../../Language/Scala/ScalaDepth/泛型擦除.html">泛型擦除</a></li><li class="chapter-item "><a href="../../Language/Scala/ScalaDepth/简单的类型原理.html">类型</a></li></ol></li><li class="chapter-item "><a href="../../Language/Scala/sbt.html">sbt</a></li><li class="chapter-item "><a href="../../Language/Scala/trait.html">trait</a></li><li class="chapter-item "><a href="../../Language/Scala/枚举.html">枚举</a></li><li class="chapter-item "><a href="../../Language/Scala/样例类和模式匹配.html">样例类和模式匹配</a></li><li class="chapter-item "><a href="../../Language/Scala/测试和文档.html">测试和文档</a></li><li class="chapter-item "><a href="../../Language/Scala/组合和继承.html">类的组合和继承</a></li></ol></li><li class="chapter-item "><a href="../../Language/Snippet/index.html">Snippets</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Language/Snippet/c.html">c</a></li><li class="chapter-item "><a href="../../Language/Snippet/linux.html">linux</a></li><li class="chapter-item "><a href="../../Language/Snippet/python.html">python</a></li><li class="chapter-item "><a href="../../Language/Snippet/rust.html">rust</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../Tools/index.html">Tools</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../Tools/Docker.html">Docker</a></li><li class="chapter-item "><a href="../../Tools/GDB.html">GDB</a></li><li class="chapter-item "><a href="../../Tools/Git/index.html">Git</a></li><li class="chapter-item "><a href="../../Tools/Git.html">Git</a></li><li class="chapter-item "><a href="../../Tools/Githook.html">Githook</a></li><li class="chapter-item "><a href="../../Tools/GithubCI.html">Github-CI</a></li><li class="chapter-item "><a href="../../Tools/Latex.html">Latex</a></li><li class="chapter-item "><a href="../../Tools/Make.html">Make与Makefile</a></li><li class="chapter-item "><a href="../../Tools/VSCode.html">VSCode</a></li><li class="chapter-item "><a href="../../Tools/Vim.html">Vim</a></li><li class="chapter-item "><a href="../../Tools/WSL.html">WSL</a></li><li class="chapter-item "><a href="../../Tools/双系统.html">双系统使用经历</a></li><li class="chapter-item "><a href="../../Tools/软件打包.html">软件打包</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Reticence&#x27;s Notes</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="syntax-analyzer"><a class="header" href="#syntax-analyzer">Syntax Analyzer</a></h1>
<p>在我们的编译器模型中，语法分析器从词法分析器获得一个Token Stream。语法分析器的工作是根据Token Stream构造出一个语法分析树，将它传递给编译器的其他部分进一步处理。语法分析器大致分为通用的、自顶向下的和自底向上的，而通用的因为效率太低不被使用，下面会介绍后二者，<strong>自顶向下分析</strong>和<strong>自底向上分析</strong>。</p>
<h2 id="context-free-grammar"><a class="header" href="#context-free-grammar">Context Free Grammar</a></h2>
<p>首先了解<strong>文法Grammar</strong>的概念。文法是形式语言中字符串的一套产生式规则。这些规则描述了如何用语言的字母表生成符合语法的有效的字符串。文法不描述字符串的含义，也不描述在任何上下文中可以用它们做什么——只描述它们的形式。</p>
<p><strong>Grammar</strong>: <code>G=(Vt,Vn,P,S)</code>。意思是说，一个Grammar由下面四个元素组成：</p>
<ol>
<li>一个<strong>终结符号(terminal symbol)<strong>集合，有时也叫</strong>词法单元(token)</strong>。</li>
<li>一个**非终结符号(nonterminal symbol)**集合，又是也叫语法变量。每个非终结符号表示一个终结符号串的集合。</li>
<li>一个产生式(production)集合。</li>
<li>指定一个非终结符号位<strong>开始符号(start symbol)</strong>。开始符号表示的是该Grammar中最大的语法成分。</li>
</ol>
<p>例如：<code>stmt -&gt; if (expr) stmt else stmt</code>这样的规则叫做<strong>production</strong>，<code>if</code>和<code>()</code>被称为<strong>terminal symbol</strong>，<code>expr</code>和<code>stmt</code>这样的变量表示终结符号的序列，称为<strong>nonterminal symbol</strong>。<code>stmt</code>就是<strong>start symbol</strong>。</p>
<p><strong>上下文无关文法 Context Free Grammar</strong>指的是<strong>产生式左侧只能包含一个符号，并且该符号为非终结符号的文法</strong>。这个限制是非常重要的。</p>
<blockquote>
<p>事实上一共有四种文法，逐级限制。对于α→β：</p>
<ul>
<li>0型文法：α中至少包含1个非终结符</li>
<li>1型文法（CSG 上下文有关） ：｜α｜≤｜β｜</li>
<li>2型文法（CFG 上下文无关文法） ：α ∈ 非终结符</li>
<li>3型文法（RG 正则）：A→wB 或 A→w (A→Bw 或A→w) A/B代表非终结符</li>
</ul>
<p>程序设计语言的语法通常是<strong>CFG</strong>，通常用<strong>RG</strong>匹配Token。</p>
</blockquote>
<p>还有一些非常重要的概念需要了解：</p>
<ul>
<li>
<p><strong>推导Derivation</strong>: 简单的说，就是把production的右部替换成左部，只替换1次就是directly derive。记做$\Rightarrow^0$，若干次替换记做$\Rightarrow^*$。相反的过程就是<strong>归约Reduction</strong>。parsing tree是推导的图形化表示。</p>
</li>
<li>
<p>Language: 由grammar <code>G</code>的start symbol <code>S</code>推导出的所有sentence构成的集合称为grammar<code>G</code>生成的language，记为<code>L(G)</code>。<code>L(G) = {w /S =&gt;*, w ∈ Vt*}</code>。要证明一个Language和Grammar对应，需要证明Grammar所有能产生的sentence都属于Language，Language中所有的string都能被Grammar产生。</p>
</li>
<li>
<p><strong>Ambiguous(二义性)</strong>: 若grammar对同一sentence可以产生不止一棵parsing tree，则称G是ambiguous。要改写二义性文法为非二义性文法</p>
<ul>
<li>划分优先级和结合性</li>
<li>引入一个新的非终结符，<strong>增加一个子结构并提高一级优先级</strong>（优先级的判断）</li>
<li><strong>递归非终结符在终结符左边，运算具有左结合性，否则具有右结合性</strong>。</li>
</ul>
</li>
</ul>
<p>回顾一下，Syntax Analyzer的作用是生成AST或Parsing Tree。其实parsing tree是推导的图形化表示。AST则是精简的Parsing Tree，一般我们生产AST。</p>
<p>现在我们手头有一个Token Stream。那么我们如何进行推导呢去构建parse tree呢？主要有两个问题：<strong>换哪个nonterminal symbol? 用哪条production?</strong>。常用的有两种办法：</p>
<ol>
<li>在<strong>Left-most Derivation</strong>最左推导中，总是选择每个句型的最左nonterminal symbol进行替换。这个和<strong>top-down parsing</strong>一起使用，也就是从Parse Tree的顶向下分析。**左句型(left sentential form)**是指推导至该句子的全部左推导。</li>
<li>在<strong>Right-most Derivation</strong>最右推导中，总是选择每个句型的最右nonterminal symbol进行替换，最右推导也被称为<strong>规范推导</strong>。这个和<strong>down-top parsing</strong>一起使用，也就是从Token Stream向上构造Parse Tree。**右句型(right sentential form)**是指推导至该句子的全部右推导。</li>
</ol>
<h2 id="top-down-parsing"><a class="header" href="#top-down-parsing">top-down parsing</a></h2>
<p>在<strong>top-down parsing</strong>中，总是采用<strong>Left-most Derivation</strong>。自顶向下语法分析可以被看做寻找输入串的<strong>最左推导</strong>(若符号串α中有两个以上的非终结符号，则对推导的每一步坚持把α中的最左非终结符号进行替换，称为最左推导)的过程。</p>
<p>具体怎么做，使用的是<strong>Recursive-Descent Parsing(递归下降分析)</strong>，这是自顶向下分析的通用形式。他由一组过程组成，每个过程对应一个nonterminal symbol。Rust例程如下。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Symbol{
    Terminal(TerminalSymbol),
    Nonterminal(NonterminalSymbol),
}
enum TerminalSymbol {
    ...
};
struct NonterminalSymbol {
    productions: Vec&lt;Vec&lt;Symbol&gt;&gt;&gt;,
}

impl NonterminalSymbol {
	fn parse(&amp;self,mut tokenstream: &amp;[TerminalSymbol]) {
    	for production in self.productions {
            for symbol in production {
                match symbol {
                    Terminal(ts) =&gt; {
                        if ts == tokenstream[0] {
                            tokenstream = &amp;tokenstream[1..];
                        } else {
               				// 如果所有的production中，只有1个在匹配到第k个symbol不会return，
                            // 其实也可以通过向前看k个symbol来实现确定的递归，不需要回溯。
                            // 这就是所谓的预测分析技术。
                            // 即使有多个可能匹配的也可以向前看若干个symbol进行剪枝，不过我就懒得写了
                            return;
                        }
                    }
                    Nonterminal(ns) =&gt; {
                        // 是需要递归的
                        ns.parse(tokenstream);
                    }
                }
            }
        }
	}    
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="消除左递归"><a class="header" href="#消除左递归">消除左递归</a></h3>
<p><strong>自顶向下语法分析不能处理左递归（left recursion）的文法</strong>：如果存在如<code>A=&gt;Ax</code>这样的production，或者可以间接推导出这样的production，那么递归下降就会出现死递归。不过左递归是可以消除的。消除左递归算法</p>
<ul>
<li>
<p>消除产生式中的<strong>直接左递归</strong>是比较容易的。例如假设非终结符P的规则为</p>
<p><code>P -&gt; Pα | β</code></p>
<p>其中，β是不以P开头的符号串。那么，我们可以把P的规则改写为如下的非直接左递归形式：</p>
<p><code>P -&gt; βP’</code> ,<code>P’-&gt; αP’ | ε</code></p>
</li>
<li>
<p>消除<strong>间接左递归</strong>，可以先把所有的左递归转化成直接左递归消除。</p>
</li>
<li>
<p>综上，消除左递归的算法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 0..n {
    for j in 0..i {
        if 有 A[i] -&gt; A[j]β 这样的式子
			for 所有的A[i] -&gt; a[1]|a[2]...|a[k]
        		改写成 A[i] -&gt; a[1]β | a[2]β | ... | a[k]β;
    }
    移除 A[i]本身的左递归;
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<h3 id="提取左公因子"><a class="header" href="#提取左公因子">提取左公因子</a></h3>
<p><strong>提取左公因子</strong>是一种文法转换方法。他可以产生适用于预测分析分析技术的文法。比如下面的例子，当不清楚如何在<code>S</code>的两个产生式中选择的时候，我们可以通过改写产生式来推后这个决定。例如：</p>
<pre><code>S -&gt; acd | abe   遇到a咋办，选哪个？
-----------------改写
S  -&gt; aS'
S' -&gt; cd | be
</code></pre>
<h3 id="ll1"><a class="header" href="#ll1">LL(1)</a></h3>
<p><strong>LL(1)文法</strong>，表示从左向右的扫描输入，产生最左推导，<strong>每一步向前看一个输入符号来确定语法分析动作</strong>，就不用回溯了。显然，LL(1)文法不可能是左递归的，也不可能是有二义性的。他等价于下面的约束：</p>
<p>对于G的任意两个产生式<code>A -&gt; alpha | beta</code></p>
<ol>
<li><code>alpha</code>和<code>beta</code>不能都推导出以token <code>a</code> 开头的串。</li>
<li><code>alpha</code>和<code>beta</code>最多只有一个能推导出空串。</li>
</ol>
<p><strong>分析表的构造过程</strong>：构造FIRST集-&gt;构造FOLLOW集-&gt;构造SELECT集-&gt;构造分析表 :star2:</p>
<ul>
<li><code>FIRST(α)</code>：给定一个符号串<code>α</code>，<code>α</code>的串首终结符集<code>FIRST(α)</code>被定义为可以从<code>α</code>推导出的<strong>所有串</strong> <strong>首终结符</strong>构成的集合。如果<code>α =&gt;* ε</code>，那么<code>ε</code>也在<code>FIRST(α)</code>中。</li>
<li><code>FOLLOW(A)</code>：可能在某个句型中<strong>紧跟在A后面的终结符a的集合</strong>。<code>FOLLOW(A)={a| S =&gt;* αAaβ, a∈Vt, α,β∈(Vt∪Vn)*}</code>。另外，如果A是某个句型的最右符号，则将结束符<code>$</code>加入<code>FOLLOW(A)</code>。</li>
<li><code>SELECT(A -&gt; α)</code>，production <code>A -&gt; α</code>的<strong>可选集</strong>是指可以选用该production进行derive的输入符号的集合，记做<code>SELECT(A -&gt; α)</code>。
<ul>
<li>如果 <code>ε∉FIRST(α)</code>, 那么<code>SELECT(A -&gt; α) = FIRST(α)</code></li>
<li>如果 <code>ε∈FIRST(α)</code>，那么<code>SELECT(A -&gt; α) =  (FIRST(α) - {ε}) ∪ FOLLOW(A)</code>。</li>
</ul>
</li>
<li>可以由这三个概念定义<strong>LL(1)文法</strong>。<strong>就是文法G的任意两个具有相同左部的production <code>A-&gt; α | β</code>，满足<code>SELECT(A -&gt; α)</code>和<code>SELECT(A -&gt; β)</code>不相交</strong>。根据SELECT集，我们可以构造parsing table。</li>
</ul>
<p>下面是一个例子：</p>
<p><img src="../images/image-20220321131438918.png" alt="image-20220321131438918" /></p>
<pre><code>E  -&gt; TE'
E' -&gt; +TE' | ε
T  -&gt; FT'
T' -&gt; *FT' | ε
F  -&gt; (E) | id
-------------------------
FIRST(E ) = {(, id}
FIRST(E') = {+, ε}
FIRST(T ) = {(, id}
FIRST(T') = {*, ε}
FIRST(F ) = {(, id}

- 如果X是一个终结符，那么FIRST ( X ) = { X } 
- 如果X是一个非终结符，且 X-&gt;Y1Y2...Yk∈P (k≥1) 
                  FISRT(X) = FIRST(Y1)
  如果ε在Y1中，     FISRT(X) = FIRST(Y1)+FIRST(Y2)
  如果ε在Y1,Y2中，  FISRT(X) = FIRST(Y1)+FIRST(Y2)+FIRST(Y3)
  ...
- 如果 X-&gt;ε∈P，那么将ε加入到FIRST( X )中
--------------------------
FOLLOW(E ) = {$, )}
FOLLOW(E') = {$, )}
FOLLOW(T ) = {+, $, )}
FOLLOW(T') = {+, $, )}
FOLLOW(F ) = {*, +, $, )}

不断应用下列规则，直到没有新的终结符可以被加入到任何FOLLOW集合中为止
1. 将$放入FOLLOW( S )中，其中S是开始符号，$是输入右端的结束标记
2. 如果存在一个产生式A-&gt;αBβ，那么FIRST(β)中除ε之外的所有符号都在FOLLOW(B)中 
3. 如果存在一个产生式A-&gt;αB，或存在产生式A→αBβ且FIRST(β)包含ε，那么FOLLOW(A)中的所有符号都在FOLLOW(B)中
---------------------------
SELECT
</code></pre>
<p><strong>下推自动机</strong>，可以理解为一个有栈的有穷自动机。用下推自动机解析LL(1)文法，就不需要递归了。Rust例程如下，但是这里的错误处理都panic了，没有处理。更科学一点的做法是给出错误原因。用文字描述是：</p>
<ol>
<li>先将开始符号入栈</li>
<li>每次弹出栈顶元素
<ul>
<li>如果是非终结符，那么我们查表，将对应的产生式入栈（Generate）。如果表为空则报错（Error）。</li>
<li>如果是终结符，那么进行匹配（Match）。如果不匹配则报错（Error）。</li>
</ul>
</li>
<li>直到栈为空，如果此时输入流正好匹配完，则匹配成功。（Accept）</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::{HashMap, VecDeque};

#[derive(PartialEq, Eq, Hash)]
pub enum Term {
    Token(String),
    Empty,
    End,
}
#[derive(PartialEq, Eq, Hash)]
pub struct NonTerm&lt;'a&gt; {
    productions: Vec&lt;Vec&lt;Symbol&lt;'a&gt;&gt;&gt;,
}

#[derive(PartialEq, Eq, Hash)]
pub enum Symbol&lt;'a&gt; {
    NonTerm(&amp;'a NonTerm&lt;'a&gt;),
    Term(&amp;'a Term),
}
// input: 输入缓冲区
// start: 开始符号
// table: 预测分析表
pub fn parse(
    mut input: &amp;[Term],
    start: &amp;Symbol,
    table: &amp;HashMap&lt;NonTerm, HashMap&lt;Term, Vec&lt;Symbol&gt;&gt;&gt;,
) {
    let mut stack = VecDeque::new();
    stack.push_front(start);
    while !stack.is_empty() {
        let s = stack.pop_front().unwrap(); // 弹出栈顶符号
        let i = &amp;input[0]; // Token流第一个符号
        match s {
            Symbol::NonTerm(nonterm) =&gt; {
                if let Some(production) = table.get(&amp;nonterm).unwrap().get(&amp;i) {
                    for sym in production.iter().rev() {
                        stack.push_front(&amp;sym);
                    }
                } else {
                    panic!()
                }
            }
            Symbol::Term(token) =&gt; {
                if *token == i {
                	input = &amp;input[1..];
                } else {
                    panic!()
            	}
            },
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="bottom-up-parsing"><a class="header" href="#bottom-up-parsing">bottom-up parsing</a></h2>
<p>在bottom-up parsing中，总是采用的是<strong>Leftmost-reduction</strong>的方式，也就是反向构造的<strong>Rightmost-derivation</strong>。自底向上的语法分析过程，可以看作是<strong>将一个串w归约为文法开始符号的过程</strong>。</p>
<p>具体怎么做，使用的是**Shift-reduce(移入-归约)**分析，这时自底向上语法分析的通用框架。所有重要的自底向上方法对于手工编码而言都太复杂了，但是对于诸如Yacc的分析程序生成器却很合适。移入-归约分析：</p>
<ul>
<li>他用一个栈来保存文法符号，用一个输入缓冲区来存放将要进行语法分析的其他符号。</li>
<li>在对输入串的一次从左到右的扫描中，语法分析器逐个将<em>输入符号</em> <strong>移入</strong>到栈顶，直到可以对栈顶的一个<em>文法符号串β</em>进行<strong>归约</strong>为止。他将β归约为某个产生式的头。</li>
<li>语法分析器不断的重复着上面的扫描过程，知道它检测到一个语法错误，或者栈中包含了开始符号并且输入缓冲区空了，这说明分析成功。</li>
</ul>
<p>所以，怎么根据Token和所谓的当前状态决定下一个动作呢？我们有两个表，<code>ACTION</code>和<code>GOTO</code>，统称<strong>LR分析表</strong>。</p>
<ol>
<li><code>ACTION[s][t]</code>表示，在当前state为<code>s</code>，而下一个输入的token为<code>t</code>时，要执行的动作，有4种
<ol>
<li>Shift. Shift the next input symbol onto the top of the stack.</li>
<li>Reduce. The right end of the string to be reduced must be at the top of the stack. Locate the left end of the string within the stack and decide with what nonterminal to replace the string.</li>
<li>Accept. Announce successful completion of parsing.</li>
<li>Error. Discover a syntax error and call an error recovery routine.</li>
</ol>
</li>
<li><code>GOTO[n]</code>，表示在归约到<code>n</code>之后，状态的转移。</li>
</ol>
<p>关于如何构造LR分析表，不同的文法有不同的构造方式，一会儿再介绍，不过利用他们我们可以完成分析，分析过程的代码如下。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Action {
    Shift,  // 第几个状态
    Reduce(u32), // 第几条产生式
    Error(&amp;'static str),
    Accept
}

fn parse(input: &amp;[Token]) {
    let mut state = 0;       // 一开始的状态是初始状态
    let mut stack = vec![];  // 一开始符号栈是空的
    let mut input = input.iter();
    loop {
        let token = input.next().unwrap();
        match ACTION(state, token) {
        	Action::Reduce(pr) =&gt; {
                let (A, beta) = PRODUCTION[pr]; // 这个的类型还没有考虑，A-&gt;beta
                for _ in 0..beta.len() {        // 弹出栈顶的|beta|个符号
                    stack.pop();
                }
                stack.push(A);
                state = GOTO[state][A];
                ...
            },
        	Action::Shift =&gt; {
                stack.push(token);
            },
            Action::Accept =&gt; break,
        	Action::Error(e) =&gt; panic!(&quot;Error: {}&quot;,e),
    	}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>​	<img src="../images/image-20220619205202318.png" alt="image-20220619205202318" /></p>
<p>P.S. 浙江大学的课件中符号栈叫做parsing stack</p>
<h3 id="冲突"><a class="header" href="#冲突">冲突</a></h3>
<!-- 用LR文法需要消除右递归？ -->
<p>就像top-down parsing不能解决左递归的文法，并不是所有的CFG都能使用移入-归约语法分析技术。对于这样的文法，直接使用移入归约分析会陷入下面的问题：即使知道了栈中的所有内容和接下来的k个输入符号，我们仍然<strong>无法判断应该进行移入操作还是归约操作，或者无法在多个可能的归约方法中选择正确的归约动作</strong>，这就是冲突。</p>
<p>冲突反应在LR(1)/LALR状态机上，就是对同一个状态，里面有1-n个归约动作和0-m个移入动作。如果<em>归约动作的展望符</em>和<em>移入的字符</em>彼此都不同则没有冲突，如果彼此之间的展望符相同则发生冲突。冲突反应在LR(0)/SLR(1)状态机上，如果对同一个状态，里面有归约动作，但是还有别的动作，那么LR(0)就会发生冲突；如果对同一个状态，里面有1-n个归约动作和0-m个移入动作，如果<em>归约动作的FOLLOW集</em>和<em>移入的字符</em>彼此都不同则没有冲突。</p>
<p>接下来，将要介绍4种分析表的构造方式，分别是LR(0), SLR, LR(1)和LALR。<strong>如果一个文法，使用LR(0)的构造方式没有产生冲突，那么就说该文法是LL(0)的，其他亦然</strong>。下面会介绍每个文法的</p>
<ol>
<li>自动机状态(项目集闭包)的构造方法。</li>
<li>自动机的构造方法。</li>
<li>分析表的构造方法。</li>
</ol>
<p>分析能力上，LR(0) &lt; SLR &lt; LALR(1) &lt; LR(1)</p>
<h3 id="lr0"><a class="header" href="#lr0">LR(0)</a></h3>
<p>在介绍LR(0)分析表构造方法之前，要先了解下面这些概念：</p>
<ul>
<li>增广文法：如果G 是一个以S为开始符号的文法，则G的增广文法 G' 就是在G中加上新开始符号S' 和产生式S' → S而得到的文法。</li>
<li>初始项目：如下面的<code>·S'</code>。</li>
<li>接收项目：如下面的<code>S'·</code>。</li>
<li>归约项目：原点的位置在最后。<code>A-&gt; XYZ·</code>就是归约项目，是时候把<code>XYZ</code>归约成<code>A</code>了</li>
<li>后继项目：同属于一个产生式的项目，但圆点的位置只相差一个符号，则称后者是前者的后继项目。比如<code>A-&gt; XYZ·</code>就是<code>A-&gt; XY·Z</code>的后继项目。</li>
<li>等价项目：凡是圆点后面存在非终结符的时候就存在等价项目，如下面例子中的<code>S' -&gt; ·S</code>，那么也就是在等待S能推导出的式子，<code>S -&gt; ·BB</code>，这两个项目就是等价项目。</li>
</ul>
<p>最后是一个例子。例子中的每一个黄色的框就是一个项目集闭包，对应LR(0)自动机的一个状态。</p>
<p><code>closure</code>的构造：LR(0) 项目集闭包的构造还是很简单的。<code>·</code>的意思是“等待”，如果等待的是非终结符，如上面例子中的<code>S' -&gt; ·S</code>，那么也就是在等待S能推导出的式子，<code>S -&gt; ·BB</code>，也加入到项目集中（其实就是上面说的等价项目）。伪代码如下，输入项目集（若干个项目的集合），输出该项目集闭包。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// I: 某个项目
fn closure (I: HashSet&lt;Item&gt;) -&gt; HashSet&lt;Item&gt; {
	let mut J = I;
    let mut continue = true;
	while (continue){
        continue = false;
        for A → α·Bβ in J {
            // G 指的是该文法
        	for (G的每个产生式B → γ) {
                // insert如果已经存在返回false
                continue ||= J.insert(B → ·γ);     
            }
        }
    }
	J
}
<span class="boring">}
</span></code></pre></pre>
<p>我们知道了状态(项目集闭包)的构造，那么LR(0)自动机的构造，其实就是将<strong>项目集闭包</strong>和<strong>他的某个符号的后继项目的项目集闭包</strong>，用<strong>正在等待的符号</strong>连接。不过中间还涉及到两个过程。是<code>goto</code>的构造和Canonical LR(0) Collection的构造，其实就是状态的转移和所有状态的构造。</p>
<blockquote>
<p>其实从上面的表述就可以看出潜在的冲突。“他的某个符号的后继项目”，可能对于某个项目集闭包，不只有一个。而且，如果不只一个，且不是等价项目，那么就会出问题。这个可以看后面的其他文法。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn goto(I: HashSet&lt;Item&gt;,X:Symbol) -&gt; HashSet&lt;Item&gt;{
    let J = HashSet::new();
    for A → α·Bβ in I {
        J.insert(A → α·Bβ);
    }
}
fn collection() {
    let C:HashSet&lt;HashSet&lt;Item&gt;&gt; = set![closure(set![S' -&gt; ·S])];
    let mut continue = true;
    while continue{
        continue = false;
        for I in C {
            for G的每一个文法符号X，别忘了结束符$ {
                let a = goto(I,X);
                if !a.is_empty() {
                    continue ||= C.insert(a);
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>令$I_i$对应状态$i$。状态$i$的语法分析表按照下面的方法构造，$sj$表示移入，$rj$表示使用第$j$条产生式归约。$V_T$指的是Terminal集合。</p>
<ul>
<li>
<p>if $A→α·aβ∈I_i$ and $GOTO( I_i , a )=I_j$ then $ACTION[ i, a ]=sj$</p>
</li>
<li>
<p>if $A→α·Bβ∈I_i$ and $GOTO( I_i , B )=I_j$ then $GOTO[i,B]=j$</p>
</li>
<li>
<p>if $A→α·∈I_i$ 且 $A ≠ S'$ then for $a∈V_T∪{$}$ do $ACTION[i,a]=rj$（j是产生式A→α的编号） </p>
</li>
<li>
<p>if $S'→S· ∈I_i$ then $ACTION [ i, $ ]=acc$</p>
</li>
<li>
<p>没有定义的所有条目都设置为$error$</p>
</li>
</ul>
<p>LR0自动机构造例子，https://www.bilibili.com/video/BV1zW411t7YE?p=28&amp;t=396.6。</p>
<p><img src="../images/image-20220228131409573.png" alt="image-20220228131409573" /></p>
<h3 id="slr1"><a class="header" href="#slr1">SLR(1)</a></h3>
<p>比LR(0)更强的一点的是SLR(1)，也叫SLR。SLR的基本思想是，LR(0)对于归约规则太草率，怎么<code>A-&gt;B·</code>后面无论跟着什么终结符都可以进行归约呢？显然后面的终结符，一定是<code>FOLLOW(A)</code>的元素嘛。还记得FOLLOW集吗，在某个句型紧跟在A后面的非终结符的集合。</p>
<p>SLR的状态机和LR(0)是一样的。不过在构造分析表的时候有所不同，其实只有第三条不同。</p>
<ul>
<li>if $A→α·aβ∈I_i$ and $GOTO(I_i,a)=I_j$ then $ACTION[i,a]=sj$</li>
<li>if $A→α·Bβ∈I_i$ and $GOTO(I_i,B)=I_j$ then $GOTO[i,B]=j$</li>
<li>if $A→α·∈I_i$ and $A ≠ S'$ then for $\forall a ∈ FOLLOW(A)$ do $ACTION[i,a]=rj$ （$j$是产生式$A→α$的编号） </li>
<li>if $S'→S·∈I_i$ then $ACTION [ i , $ ]=acc$</li>
<li>没有定义的所有条目都设置为$error$</li>
</ul>
<p><img src="../images/image-20220411222052512.png" alt="image-20220411222052512" /></p>
<h3 id="lr1-star2"><a class="header" href="#lr1-star2">LR(1) :star2:</a></h3>
<p>SLR只是简单地考察下一个输入符号$b$是否属于与归约项目$A→α$相关联的$FOLLOW(A)$，但$b∈FOLLOW(A)$只是归约$α$的一个必要条件，而非充分条件。</p>
<p><strong>LR(1):<strong>不过并不是所有的Context-free grammar都是上面介绍的</strong>LR(0)<strong>或SLR有时我们需要向前查看k个符号才知道该执行什么动作，有价值的是k=1，就是</strong>LR(1)</strong>。</p>
<p>LR(1)状态机的状态和之前两个就不一样了。我们要了解<strong>规范LR(1)项目</strong>和<strong>展望符</strong>的概念。将一般形式为 $[A→α·β, a]$的项称为 <strong>LR(1)项(规范LR(1)项目)</strong>，其中$A→αβ$ 是一个产生式，$a$是一个终结符(这里将$视为一个特殊的终结符)它表示在当前状态下，A后面必须紧跟的终结符，称为该项的<strong>展望符(lookahead)</strong> 。LR(1) 中的1指的是项的展望符的长度。</p>
<ul>
<li>在形如$[A→α·β, a]$且$β ≠ ε$的项中，展望符$a$没有任何作用</li>
<li>但是一个形如$[A→α·, a]$的项在只有在下一个输入符号等于$a$时才可以按照$A→α$ 进行归约，这样的a的集合总是FOLLOW(A)的子集，而且它通常是一个真子集。（SLR就是简单的认为a的集合就是FOLLOW(A)）</li>
</ul>
<p>那么，LR(1)的项目集闭包（closure函数）, 状态机（goto函数和collection函数）又要怎么构造呢？代码如下，意思其实也很简单。之前是如果在<code>·B</code>就把B的产生式<code>B-&gt;·γ</code>也加进来；现在对<code>[·Bβ,a]</code>是把<code>[B-&gt;·y, FIRST(βa)]</code>加进来，其实就是对展望符多了限制。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// I: 某个项目
fn closure (I: HashSet&lt;Item&gt;) -&gt; HashSet&lt;Item&gt; {
    let mut J = I;
    let mut continue = true;
    while (continue){
        continue = false;
        for [A → α·Bβ,a] in J {
            // G 指的是该文法
            for G的每个产生式B → γ {
                // 注意这里是和LR(0)不同的地方
                // β如果不是空，FIRST(β)就和a没有任何关系
                for b in FISRT(βa) { 
                    continue ||= J.insert([B-&gt;·y,b]);
                }
            }
        }
    }
    J
}
<span class="boring">}
</span></code></pre></pre>
<p>那么LR(1)自动机的构造，和LR(0)就很相似了。其实就是将<strong>项目集闭包</strong>和<strong>他的某个符号的后继项目的项目集闭包</strong>，用<strong>正在等待的符号</strong>连接。不过中间还涉及到两个过程。是<code>goto</code>的构造和Canonical LR(1) Collection的构造。和LR(0)很相似。看下面的代码，只有第3、4、8行不同。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn goto(I: HashSet&lt;Item&gt;,X:Symbol) -&gt; HashSet&lt;Item&gt;{
    let J = HashSet::new();
    for [A → α·Bβ, a] in I {
        J.insert([A → α·Bβ, a]);
    }
}
fn collection() {
    let C:HashSet&lt;HashSet&lt;Item&gt;&gt; = set![closure(set![S' -&gt; ·S, $])];
    let mut continue = true;
    while continue{
        continue = false;
        for I in C {
            for G的每一个文法符号X，别忘了结束符$ {
                let a = goto(I,X);
                if !a.is_empty() {
                    continue ||= C.insert(a);
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>令$I_i$对应状态$i$。状态$i$的语法分析表按照下面的方法构造，$sj$表示移入，$rj$表示使用第$j$条产生式归约。</p>
<ul>
<li>if $[A→α·aβ, b ] ∈I_i$ and $GOTO( Ii , a )=I_j$ then $ACTION[ i, a ]=sj$</li>
<li>if $[A→α·Bβ,b ] ∈I_i$ and $GOTO( Ii , B )=I_j$ then $GOTO[ i, B ]=j$</li>
<li>if $[A→α·, a ] ∈Ii$且$A ≠ S'$ then $ACTION[ i, a ]=rj$（j是产生式A→α的编号） </li>
<li>if $[S'→S·, $] ∈Ii$ then $ACTION [ i, $ ]=acc$;</li>
<li>没有定义的所有条目都设置为$error$</li>
</ul>
<p><img src="../images/image-20220411222333300.png" alt="image-20220411222333300" /></p>
<h3 id="lalr分析法"><a class="header" href="#lalr分析法">LALR分析法</a></h3>
<p>LALR(lookahead LR)的思想是合并LR(1)中的一些状态，准确的说是合并<strong>同心项集</strong>，因为LR(1)的状态非常的多。如果合并之后分析表没有产生冲突那么文法就是LALR的。其实所谓的“心”，指的是项目的第一分量。比如LR(1)例子中的I8和I10，里面的项的“心”都是<code>R-&gt;L·</code>，所以说他们是同心的。</p>
<p>LALR分析法可能会作多余的reduce动作，但绝不会作错误的shift操作。如果一个文法是LR(1)的，想把他转化成LALR(1)，可能会带来reduce-reduce冲突，但是不会带来shit-reduce冲突。</p>
<p>这个例子的文法和LR(1)的是一样的。</p>
<p><img src="../images/image-20220411231617051.png" alt="image-20220411231617051" /></p>
<h2 id="ambiguous-grammar"><a class="header" href="#ambiguous-grammar">Ambiguous grammar</a></h2>
<p>可生成带有两个不同分析树的串的文法称作<strong>二义性文法(Ambiguous grammar)</strong>。每个二义性文法都不是LR的。但是某些类型的二义性文法在语言的描述和实现中很有用。</p>
<p>重写文法以消除二义性的方法，通常我们通过优先级和结合律来消除二义性：</p>
<ol>
<li>为了处理文法中的运算优先权问题，就必须把具有相同优先权的算符归纳在一组中，并为每一种优先权规定不同的规则。</li>
<li>左递归规则使得它的算符在左边结合，而右递归规则使得它们在右边结合（Left recursion is commonly used to make operations left associative）。</li>
</ol>
<p>比如，对于一个简单算术的文法，二义性版本。这个的二义性是显然的。</p>
<pre><code>E  -&gt; E op E | E | number
op -&gt; * | - | + 
</code></pre>
<p>先给他来一个优先级，不过还是二义性的。比如10-5-2，分析树可以是(- (- 10 5) 2)，也可以是(- 10 (- 5 2))。</p>
<pre><code>E -&gt; E opadd E | T
opadd -&gt; + | -
T -&gt; T * T | number
</code></pre>
<p>在给他加上左结合，这样就消除了二义性。比如10-5-2，分析树就只能是(- (- 10 5) 2)。有时候二义性是无关紧要的，比如对于10+5+2，无论是(+ (+ 10 5) 2)还是(+ 10 (+ 5 2))的结果是一样的，不过对于分析算法来说，总是要选一个。</p>
<pre><code>E -&gt; E opadd T | T
opadd -&gt; + | -
T -&gt; T * number | number
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../Basic/Compiler/Sematic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../Basic/Compiler/llvm-ir.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../Basic/Compiler/Sematic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../Basic/Compiler/llvm-ir.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
