<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>《Linux内核设计与实现》笔记 - Reticence&#x27;s Notes</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../../../index.html">Index</a></li><li class="chapter-item expanded "><a href="../../../Advanced/index.html">Advanced</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Advanced/Blockchain/index.html">Block Chain</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Advanced/Blockchain/Basic/index.html">区块链技术</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Advanced/Blockchain/Basic/Consensus.html">共识机制</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/Basic/Crypto.html">加密</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/Basic/Distribute.html">分布式存储</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/Basic/P2P.html">P2P</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/Basic/SmartContract.html">如何执行智能合约</a></li></ol></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/Defi/index.html">DeFi</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Advanced/Blockchain/Defi/DAO.html">Decentralized Autonomous Organization</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/Defi/Derivative.html">Decentralized Derivative</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/Defi/Exchange.html">Decentralized Exchange</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/Defi/FundManagement.html">Decentralized Fund Management</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/Defi/Insurance.html">Decentralized Insurance</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/Defi/LendBorrow.html">Decentralized Lending & Borrowing</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/Defi/Lottery.html">Decentralized Lottery</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/Defi/Payments.html">Decentralized Payments</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/Defi/StableCoin.html">Stable Coins</a></li></ol></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/Ethernet/index.html">Ethernet</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Advanced/Blockchain/Ethernet/Solidity.html">Solidity简介</a></li></ol></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/NEAR/index.html">Hello NEAR</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Advanced/Blockchain/NEAR/PoS.html">Proof-of-Stake</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/NEAR/Promise.html">异步模型</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/NEAR/Secure.html">Secure</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/NEAR/Snippets.html">Snippets</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/NEAR/Standards.html">标准实现代码分析</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/NEAR/dao.html">dao</a></li><li class="chapter-item "><a href="../../../Advanced/Blockchain/NEAR/wasm.html">wasm</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../../Advanced/Linux/index.html">Linux</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Advanced/Linux/LinuxKernel/index.html">Linux</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxKernel/Credential.html">Credential</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxKernel/Debug笔记.html">Debug笔记</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxKernel/File_System.html">File System</a></li><li class="chapter-item expanded "><a href="../../../Advanced/Linux/LinuxKernel/Linux内核设计与实现笔记.html" class="active">《Linux内核设计与实现》笔记</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxKernel/Linux设备驱动笔记.html">《Linux设备驱动》笔记</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxKernel/RCU.html">RCU</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxKernel/Rust_for_linux.html">Rust for linux</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxKernel/System_Call.html">System Call</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxKernel/context_switch.html">进程调度时的context_switch</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxKernel/内核编程笔记.html">Linux内核编程笔记</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxKernel/数据结构.html">数据结构</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxKernel/调试Linux内核环境搭建.html">调试Linux内核环境搭建</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxKernel/调试时如何获取current.html">调试Linux内核，寻找current</a></li></ol></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxPlay/index.html">LinuxPlay</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxPlay/Linux使用笔记.html">Linux使用笔记</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxPlay/使用SSH远程登录.html">Linux使用SSH远程登录</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxPlay/在Linux中找到可用的网络接口.html">在Linux中找到可用的网络接口</a></li></ol></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/index.html">Linux Program</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/Deamon.html">Daemon</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/Fanotify.html">Fanotify</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/File.html">File Program</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/IObound.html">I/O bound 程序优化</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/Linux目录结构.html">Linux目录结构</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/NetLink.html">Netlink</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/Socket.html">Socket</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/eBPF.html">eBPF</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/prctl.html">进程</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/信号.html">信号</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/共享库.html">共享库</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/凭证.html">Credential 凭证</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/反向Shell和伪终端.html">反向Shell和伪终端</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/性能监控.html">性能监控</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/桌面应用开发.html">桌面应用开发</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/管道和重定向.html">管道和重定向</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/系统限制和选项.html">系统限制和选项</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/终端.html">终端</a></li><li class="chapter-item "><a href="../../../Advanced/Linux/LinuxProgram/进程间通信.html">进程间通信</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../../Advanced/Windows/index.html">Windows Programming</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Advanced/Windows/Unicode.html">Unicode</a></li><li class="chapter-item "><a href="../../../Advanced/Windows/hungarian.html">匈牙利命名法</a></li><li class="chapter-item "><a href="../../../Advanced/Windows/文件.html">文件</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../../Basic/index.html">Basic</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/8086汇编笔记.html">8086汇编笔记</a></li><li class="chapter-item "><a href="../../../Basic/Architecture/index.html">Architecture</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/Architecture/ARM内存管理.html">AArch64 memory management</a></li><li class="chapter-item "><a href="../../../Basic/Architecture/ARM寄存器.html">ARM中的寄存器</a></li><li class="chapter-item "><a href="../../../Basic/Architecture/ARM异常.html">AArch64 Exception Model</a></li><li class="chapter-item "><a href="../../../Basic/Architecture/ARM虚拟化.html">Armv8-A virtualization</a></li><li class="chapter-item "><a href="../../../Basic/Architecture/ARM调试.html">ARM self-hosted debug</a></li><li class="chapter-item "><a href="../../../Basic/Architecture/CPU设计.html">CPU设计</a></li><li class="chapter-item "><a href="../../../Basic/Architecture/Cache.html">Cache</a></li><li class="chapter-item "><a href="../../../Basic/Architecture/ILP.html">ILP</a></li><li class="chapter-item "><a href="../../../Basic/Architecture/SIMD和MIMD.html">SIMD和MIMD</a></li><li class="chapter-item "><a href="../../../Basic/Architecture/TLP.html">TLP</a></li><li class="chapter-item "><a href="../../../Basic/Architecture/存储器设计.html">存储器设计</a></li><li class="chapter-item "><a href="../../../Basic/Architecture/数字逻辑.html">Notes-数字逻辑</a></li><li class="chapter-item "><a href="../../../Basic/Architecture/计算机体系结构.html">计算机组成&计算机体系结构</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/C/index.html">C/C++</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/C/Cpp标准库.html">C++_标准库</a></li><li class="chapter-item "><a href="../../../Basic/C/Cpp课程笔记.html">C++ 基础知识</a></li><li class="chapter-item "><a href="../../../Basic/C/GCC内嵌汇编.html">C-内嵌汇编</a></li><li class="chapter-item "><a href="../../../Basic/C/变量在ELF段中的位置.html">变量在ELF段中的位置</a></li><li class="chapter-item "><a href="../../../Basic/C/可变参数的使用和原理.html">可变参数的使用和原理</a></li><li class="chapter-item "><a href="../../../Basic/C/在C程序中调用汇编程序.html">在C程序中调用汇编程序</a></li><li class="chapter-item "><a href="../../../Basic/C/链接器.html">链接器</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/Client/index.html">Client Development</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/Client/Chromium.html">Chromium</a></li><li class="chapter-item "><a href="../../../Basic/Client/CodeReview.html">CodeReview</a></li><li class="chapter-item "><a href="../../../Basic/Client/Config.html">Config</a></li><li class="chapter-item "><a href="../../../Basic/Client/CrossLanguage.html">跨语言</a></li><li class="chapter-item "><a href="../../../Basic/Client/DataStore.html">本地存储</a></li><li class="chapter-item "><a href="../../../Basic/Client/Database.html">Database</a></li><li class="chapter-item "><a href="../../../Basic/Client/Flutter.html">Flutter</a></li><li class="chapter-item "><a href="../../../Basic/Client/Log.html">日志</a></li><li class="chapter-item "><a href="../../../Basic/Client/Multimedia/index.html">Multimedia</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/Client/Multimedia/Graph.html">图形学</a></li><li class="chapter-item "><a href="../../../Basic/Client/Multimedia/Image.html">图像处理技术</a></li><li class="chapter-item "><a href="../../../Basic/Client/Multimedia/Video.html">视频</a></li><li class="chapter-item "><a href="../../../Basic/Client/Multimedia/Voice.html">Voice</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/Client/Network.html">网络能力</a></li><li class="chapter-item "><a href="../../../Basic/Client/Performance.html">性能监控</a></li><li class="chapter-item "><a href="../../../Basic/Client/Platform/index.html">Platform</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/Client/Platform/Android.html">Android</a></li><li class="chapter-item "><a href="../../../Basic/Client/Platform/iOS.html">iOS</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/Client/SQLite.html">SQLite</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/Compiler/index.html">Compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/Compiler/Codegen.html">代码生成</a></li><li class="chapter-item "><a href="../../../Basic/Compiler/Lex.html">Lex</a></li><li class="chapter-item "><a href="../../../Basic/Compiler/Lexical.html">Lexical Analyze</a></li><li class="chapter-item "><a href="../../../Basic/Compiler/Runtime.html">Runtime</a></li><li class="chapter-item "><a href="../../../Basic/Compiler/Sematic.html">Sematic Analyzing</a></li><li class="chapter-item "><a href="../../../Basic/Compiler/Syntax.html">Syntax Analyzer</a></li><li class="chapter-item "><a href="../../../Basic/Compiler/llvm-ir.html">LLVM-IR</a></li><li class="chapter-item "><a href="../../../Basic/Compiler/llvm.html">LLVM</a></li><li class="chapter-item "><a href="../../../Basic/Compiler/pest.html">PEST</a></li><li class="chapter-item "><a href="../../../Basic/Compiler/yacc.html">Yacc</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/DataStructure/index.html">Data Structure And Algorithm</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/DataStructure/Algorithm/index.html">Algorithm</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/DataStructure/Algorithm/Approximation.html">近似算法</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Algorithm/Backtracking.html">递归回溯</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Algorithm/DivideAndConquer.html">分治算法</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Algorithm/DynamicProgramming.html">动态规划</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Algorithm/Greedy.html">贪心算法</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Algorithm/LocalSearch.html">本地搜索</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Algorithm/Parallel.html">并行算法</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Algorithm/Randomized.html">随机化算法</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Algorithm/Sort.html">排序算法</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Graph/index.html">Graph</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/DataStructure/Graph/Bipartite.html">Bipartite</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Graph/NetworkFlow.html">NetworkFlow</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Graph/ShortPath.html">最短路</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Graph/SpanningTree.html">最小生成树</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Graph/关键路径.html">关键路径</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Graph/拓扑排序.html">拓扑排序</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Hash/index.html">Hash</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/DataStructure/Hash/HashTree.html">HashTree</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Hash/Hashing.html">Hashing</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Heap/index.html">Heap</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/DataStructure/Heap/BinomialHeap.html">Binomial Heap</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Heap/FibonacciHeap.html">FibonacciHeap</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Heap/Heap.html">DS-Heap</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Heap/斜堆.html">Leftist_Heap_and_Skew_Heap</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Inverted_File_Index.html">Inverted_File_Index</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Linear/index.html">Linear</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/DataStructure/Linear/Bitmap.html">DS-Bitmap</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Linear/List.html">DS-Linear_List</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/DataStructure/NPProblem.html">DS-NP_problem</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/String/index.html">字符串匹配相关算法</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/DataStructure/String/match.html">字符串匹配算法</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Tree/index.html">Tree and BST</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/DataStructure/Tree/BTree.html">B Tree and B+ Tree</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Tree/BalancedTree.html">AVL Tree and Splay Tree</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Tree/DisjointSet.html">Disjoint Set</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Tree/HuffmanTree.html">Huffman Tree</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Tree/RBTree.html">红黑树 B树 B+树</a></li><li class="chapter-item "><a href="../../../Basic/DataStructure/Tree/ThreadedTree.html">Threaded Binary Tree</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../../Basic/Database/index.html">Database</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/Database/Object.html">Database-Object-Based_Databases</a></li><li class="chapter-item "><a href="../../../Basic/Database/PostgreSQL-Conflict-reticenceji_Win10.html">Database-PostgreSQL</a></li><li class="chapter-item "><a href="../../../Basic/Database/PostgreSQL.html">Database-PostgreSQL</a></li><li class="chapter-item "><a href="../../../Basic/Database/SQL-Conflict-reticenceji_Win10.html">基础SQL</a></li><li class="chapter-item "><a href="../../../Basic/Database/SQL.html">基础SQL</a></li><li class="chapter-item "><a href="../../../Basic/Database/XML-Conflict-reticenceji_Win10.html">Database,Web-XML</a></li><li class="chapter-item "><a href="../../../Basic/Database/XML.html">Database,Web-XML</a></li><li class="chapter-item "><a href="../../../Basic/Database/事务.html">Database-事务</a></li><li class="chapter-item "><a href="../../../Basic/Database/关系代数.html">Database-关系代数</a></li><li class="chapter-item "><a href="../../../Basic/Database/存储和查询.html">Database-存储和查询</a></li><li class="chapter-item "><a href="../../../Basic/Database/导论.html">Database-导论</a></li><li class="chapter-item "><a href="../../../Basic/Database/数据库设计.html">Database-数据库设计</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/Maths/index.html">Maths</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/Maths/大数定理和中心极限定理.html">大数定理和中心极限定理</a></li><li class="chapter-item "><a href="../../../Basic/Maths/微积分下.html">微积分下</a></li><li class="chapter-item "><a href="../../../Basic/Maths/数值计算方法.html">数值计算方法</a></li><li class="chapter-item "><a href="../../../Basic/Maths/最小二乘法.html">最小二乘法</a></li><li class="chapter-item "><a href="../../../Basic/Maths/有限自动机介绍.html">有限自动机介绍</a></li><li class="chapter-item "><a href="../../../Basic/Maths/概统复习.html">概统复习</a></li><li class="chapter-item "><a href="../../../Basic/Maths/群论简介.html">群论简介</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/Networking/index.html">Networking</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/Networking/ARP.html">Networking-ARP</a></li><li class="chapter-item "><a href="../../../Basic/Networking/CDN.html">CDN</a></li><li class="chapter-item "><a href="../../../Basic/Networking/DNS.html">DNS</a></li><li class="chapter-item "><a href="../../../Basic/Networking/FTP.html">FTP</a></li><li class="chapter-item "><a href="../../../Basic/Networking/HTTP.html">HTTP</a></li><li class="chapter-item "><a href="../../../Basic/Networking/ICMP.html">Internet Control Message Protocol</a></li><li class="chapter-item "><a href="../../../Basic/Networking/Mail.html">邮件协议</a></li><li class="chapter-item "><a href="../../../Basic/Networking/NAT.html">Network Address Translation</a></li><li class="chapter-item "><a href="../../../Basic/Networking/P2P.html">P2P</a></li><li class="chapter-item "><a href="../../../Basic/Networking/QUIC.html">QUIC</a></li><li class="chapter-item "><a href="../../../Basic/Networking/RTC.html">RTC</a></li><li class="chapter-item "><a href="../../../Basic/Networking/Socket.html">Socket</a></li><li class="chapter-item "><a href="../../../Basic/Networking/TCP.html">TCP</a></li><li class="chapter-item "><a href="../../../Basic/Networking/UDP.html">UDP</a></li><li class="chapter-item "><a href="../../../Basic/Networking/VMWare虚拟机网络配置.html">VMWare虚拟机网络配置</a></li><li class="chapter-item "><a href="../../../Basic/Networking/VPN.html">VPN</a></li><li class="chapter-item "><a href="../../../Basic/Networking/WebSocket.html">WebSocket</a></li><li class="chapter-item "><a href="../../../Basic/Networking/介质访问子层.html">Medium Access Sublayer</a></li><li class="chapter-item "><a href="../../../Basic/Networking/可靠传输.html">可靠传输</a></li><li class="chapter-item "><a href="../../../Basic/Networking/差错控制.html">差错控制</a></li><li class="chapter-item "><a href="../../../Basic/Networking/拥塞控制和流量控制.html">拥塞控制和流量控制</a></li><li class="chapter-item "><a href="../../../Basic/Networking/物理层.html">物理层</a></li><li class="chapter-item "><a href="../../../Basic/Networking/网络层.html">网络层 IP</a></li><li class="chapter-item "><a href="../../../Basic/Networking/网络设备.html">Networking-网络设备</a></li><li class="chapter-item "><a href="../../../Basic/Networking/路由协议.html">路由协议</a></li><li class="chapter-item "><a href="../../../Basic/Networking/链路层.html">链路层</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/OS/index.html">OS</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/OS/Bootloader.html">OS-Bootloader</a></li><li class="chapter-item "><a href="../../../Basic/OS/Buddy_System&Slub.html">OS-Buddy_System&Slub</a></li><li class="chapter-item "><a href="../../../Basic/OS/Deadlock.html">OS-Deadlock</a></li><li class="chapter-item "><a href="../../../Basic/OS/IO.html">OS-IO</a></li><li class="chapter-item "><a href="../../../Basic/OS/Introduction.html">OS-Introduction</a></li><li class="chapter-item "><a href="../../../Basic/OS/Memory_Management.html">OS-Memory_Management</a></li><li class="chapter-item "><a href="../../../Basic/OS/Process.html">OS-Process</a></li><li class="chapter-item "><a href="../../../Basic/OS/Q&A.html">OS-Q&A</a></li><li class="chapter-item "><a href="../../../Basic/OS/RISCV学习笔记.html">OS-RISCV学习笔记</a></li><li class="chapter-item "><a href="../../../Basic/OS/SBI.html">OS-SBI</a></li><li class="chapter-item "><a href="../../../Basic/OS/Synchronization.html">OS-Synchronization</a></li><li class="chapter-item "><a href="../../../Basic/OS/Thread.html">OS-Thread</a></li><li class="chapter-item "><a href="../../../Basic/OS/UnixLinux中的IO模型.html">Linux中的I/O模型</a></li><li class="chapter-item "><a href="../../../Basic/OS/在K210运行裸机程序.html">OS-在K210运行裸机程序</a></li><li class="chapter-item "><a href="../../../Basic/OS/地址空间(一).html">OS-地址空间(一)</a></li><li class="chapter-item "><a href="../../../Basic/OS/操作系统.html">OS-操作系统</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/Secure/index.html">Secure</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/Secure/Crypto/index.html">Crypto</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/Secure/Crypto/Federated_Learning.html">Federated Learning</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Crypto/Oblivious_RAM.html">Oblivious RAM</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Crypto/PIR.html">PIR</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Crypto/PSI.html">Private set intersection</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Crypto/加密和哈希.html">Crypto-加密和哈希</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Crypto/加密数据库.html">Encrypted Database</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Crypto/区块链技术.html">Bitcoin-区块链技术</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Crypto/可证明安全.html">可证明安全</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Crypto/安全多方计算.html">安全多方计算</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Crypto/密码学基础.html">密码学算法介绍</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Crypto/密码学进阶.html">密码学进阶</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Crypto/差分隐私.html">差分隐私</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/Secure/CryptoBasic.html">密码学基础</a></li><li class="chapter-item "><a href="../../../Basic/Secure/CtyptoProtocol.html">密码学协议</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Forensics/index.html">电子取证</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/Secure/Forensics/FAT.html">FAT文件系统</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Forensics/FileCarving.html">文件雕复</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Forensics/Linux取证.html">Linux取证</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Forensics/Memory.html">内存取证</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Forensics/NTFS.html">NTFS文件系统</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Forensics/Windows取证.html">Windows取证</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Forensics/数据隐藏.html">数据隐藏</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Forensics/文件系统取证.html">文件系统取证</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Forensics/硬盘分析.html">硬盘分析</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Forensics/移动设备取证.html">移动设备取证</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Forensics/网络取证.html">网络取证</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/Secure/IoT.html">无线与物联网安全</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Network.html">网络安全</a></li><li class="chapter-item "><a href="../../../Basic/Secure/OperatingSystem.html">操作系统安全</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Software/index.html">软件安全</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Basic/Secure/Software/ASLR.html">ASLR</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Software/CodeQL.html">CodeQL</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Software/GlibcHeap.html">glibc heap allocator</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Software/PIC.html">位置无关代码和共享库</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Software/RELRO.html">RELRO</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Software/pwntools.html">pwntools</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Software/攻击视角.html">攻击软件安全</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Software/程序分析.html">程序分析</a></li><li class="chapter-item "><a href="../../../Basic/Secure/Software/防御视角.html">软件安全防护</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/Secure/SupplyChain.html">供应链安全</a></li></ol></li><li class="chapter-item "><a href="../../../Basic/软件保护技术.html">Reverse</a></li></ol></li><li class="chapter-item "><a href="../../../Language/index.html">Language</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Language/Java/index.html">Java</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Language/Java/基础.html">Java</a></li><li class="chapter-item "><a href="../../../Language/Java/鸿蒙应用开发.html">Java-鸿蒙应用开发</a></li></ol></li><li class="chapter-item "><a href="../../../Language/JavaScript/index.html">JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Language/JavaScript/Electron.html">Electron</a></li><li class="chapter-item "><a href="../../../Language/JavaScript/JavaScript简介.html">JavaScript简介</a></li><li class="chapter-item "><a href="../../../Language/JavaScript/Runtime.html">Runtime</a></li></ol></li><li class="chapter-item "><a href="../../../Language/Python/index.html">Python</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Language/Python/0内置类型/index.html">内置对象</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Language/Python/0内置类型/1字符串.html">字符串和字节串</a></li><li class="chapter-item "><a href="../../../Language/Python/0内置类型/2数值.html">数值</a></li><li class="chapter-item "><a href="../../../Language/Python/0内置类型/3列表和元组.html">序列</a></li><li class="chapter-item "><a href="../../../Language/Python/0内置类型/4字典和集合.html">映射</a></li><li class="chapter-item "><a href="../../../Language/Python/0内置类型/5迭代器和生成器.html">迭代器和生成器</a></li><li class="chapter-item "><a href="../../../Language/Python/0内置类型/6上下文管理器.html">上下文管理器</a></li></ol></li><li class="chapter-item "><a href="../../../Language/Python/1工作原理/index.html">工作原理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Language/Python/1工作原理/0对象模型.html">OOP模型</a></li><li class="chapter-item "><a href="../../../Language/Python/1工作原理/1类型.html">类型</a></li><li class="chapter-item "><a href="../../../Language/Python/1工作原理/2变量.html">变量</a></li><li class="chapter-item "><a href="../../../Language/Python/1工作原理/3特殊方法和重载.html">特殊方法和重载</a></li><li class="chapter-item "><a href="../../../Language/Python/1工作原理/4参数.html">参数</a></li><li class="chapter-item "><a href="../../../Language/Python/1工作原理/5多继承.html">多继承</a></li></ol></li><li class="chapter-item "><a href="../../../Language/Python/3高级写法/index.html">高级写法</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Language/Python/3高级写法/1异常.html">Exception</a></li><li class="chapter-item "><a href="../../../Language/Python/3高级写法/2装饰器.html">装饰器</a></li></ol></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/index.html">PythonLib</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Language/Python/4好用的库/Argparse.html">命令行参数</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/Bisect.html">Bisect</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/Builtin.html">Builtin</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/Container.html">Container</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/Crypto.html">Crypto</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/Enum.html">enum</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/FS.html">File System</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/Flask.html">Python-Flask</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/HTTP.html">Internet</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/IO.html">File IO</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/PyQt5.html">PySide2</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/Regex.html">Regex</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/Socket.html">Socket编程</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/Thread.html">多线程</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/Time.html">时间和日期</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/Trio.html">Trio</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/format.html">Format String</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/venv.html">Virtual Environment</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/数据持久化.html">简单的数据持久化</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/文档和测试.html">文档和测试</a></li><li class="chapter-item "><a href="../../../Language/Python/4好用的库/计算器.html">把Python当计算器</a></li></ol></li><li class="chapter-item "><a href="../../../Language/Python/运算符.html">运算符</a></li></ol></li><li class="chapter-item "><a href="../../../Language/Rust/index.html">Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Language/Rust/Basic/index.html">Basic</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Language/Rust/Basic/Any.html">Any</a></li><li class="chapter-item "><a href="../../../Language/Rust/Basic/Async.html">异步编程</a></li><li class="chapter-item "><a href="../../../Language/Rust/Basic/Casting.html">Casting</a></li><li class="chapter-item "><a href="../../../Language/Rust/Basic/ClosureAndIter.html">迭代器和闭包</a></li><li class="chapter-item "><a href="../../../Language/Rust/Basic/CratesAndModules.html">Crates and Modules</a></li><li class="chapter-item "><a href="../../../Language/Rust/Basic/Error.html">Rust-错误处理</a></li><li class="chapter-item "><a href="../../../Language/Rust/Basic/Macro.html">宏</a></li><li class="chapter-item "><a href="../../../Language/Rust/Basic/Trait.html">Trait</a></li><li class="chapter-item "><a href="../../../Language/Rust/Basic/TypeAndLifetime.html">从类型系统看生命周期</a></li><li class="chapter-item "><a href="../../../Language/Rust/Basic/Unsafe.html">Unsafe</a></li><li class="chapter-item "><a href="../../../Language/Rust/Basic/pattern.html">模式匹配</a></li></ol></li><li class="chapter-item "><a href="../../../Language/Rust/Build.html">Build</a></li><li class="chapter-item "><a href="../../../Language/Rust/Cargo/index.html">Cargo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Language/Rust/Cargo/clippy.html">Clippy</a></li><li class="chapter-item "><a href="../../../Language/Rust/Cargo/fix.html">Cargo fix</a></li><li class="chapter-item "><a href="../../../Language/Rust/Cargo/make.html">Cargo make</a></li></ol></li><li class="chapter-item "><a href="../../../Language/Rust/Compiler.html">Compiler</a></li><li class="chapter-item "><a href="../../../Language/Rust/Crate/index.html">Crates</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Language/Rust/Crate/Anyhow.html">AnyHow & ThisError</a></li><li class="chapter-item "><a href="../../../Language/Rust/Crate/Cell.html">Cell</a></li><li class="chapter-item "><a href="../../../Language/Rust/Crate/Diesel.html">Diesel</a></li><li class="chapter-item "><a href="../../../Language/Rust/Crate/Dioxus.html">Dioxus</a></li><li class="chapter-item "><a href="../../../Language/Rust/Crate/EnumDispatch.html">Dispatch</a></li><li class="chapter-item "><a href="../../../Language/Rust/Crate/IO.html">IO</a></li><li class="chapter-item "><a href="../../../Language/Rust/Crate/collections.html">容器的增删改查</a></li><li class="chapter-item "><a href="../../../Language/Rust/Crate/gtk-rs.html">gtk-rs</a></li><li class="chapter-item "><a href="../../../Language/Rust/Crate/r2d2.html">r2d2</a></li><li class="chapter-item "><a href="../../../Language/Rust/Crate/stdsync.html">std::sync</a></li><li class="chapter-item "><a href="../../../Language/Rust/Crate/字符串.html">字符串/字节流</a></li><li class="chapter-item "><a href="../../../Language/Rust/Crate/打包.html">打包</a></li><li class="chapter-item "><a href="../../../Language/Rust/Crate/智能指针.html">Rust-智能指针</a></li></ol></li><li class="chapter-item "><a href="../../../Language/Rust/FFI.html">FFI</a></li><li class="chapter-item "><a href="../../../Language/Rust/IO.html">Rust-IO</a></li><li class="chapter-item "><a href="../../../Language/Rust/Practice/index.html">Practice</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Language/Rust/Practice/BestPractice.html">Rust最佳实践</a></li><li class="chapter-item "><a href="../../../Language/Rust/Practice/Debug.html">调试</a></li><li class="chapter-item "><a href="../../../Language/Rust/Practice/DesignPattern.html">设计模式</a></li><li class="chapter-item "><a href="../../../Language/Rust/Practice/Performance.html">性能优化</a></li><li class="chapter-item "><a href="../../../Language/Rust/Practice/Size.html">代码体积优化</a></li><li class="chapter-item "><a href="../../../Language/Rust/Practice/Test.html">测试最佳实践</a></li><li class="chapter-item "><a href="../../../Language/Rust/Practice/Type.html">类型转换</a></li><li class="chapter-item "><a href="../../../Language/Rust/Practice/Unsafe.html">Unsafe最佳实践</a></li></ol></li><li class="chapter-item "><a href="../../../Language/Rust/gtk.html">Rust-gtk-rs介绍</a></li><li class="chapter-item "><a href="../../../Language/Rust/函数参数匹配.html">函数参数匹配</a></li><li class="chapter-item "><a href="../../../Language/Rust/基础知识.html">基础知识</a></li><li class="chapter-item "><a href="../../../Language/Rust/多线程.html">多线程支持</a></li><li class="chapter-item "><a href="../../../Language/Rust/混合编程.html">混合编程</a></li><li class="chapter-item "><a href="../../../Language/Rust/精髓.html">Rust-精髓</a></li></ol></li><li class="chapter-item "><a href="../../../Language/Scala/index.html">Scala</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Language/Scala/0控制结构.html">控制结构</a></li><li class="chapter-item "><a href="../../../Language/Scala/1数据结构.html">数据结构</a></li><li class="chapter-item "><a href="../../../Language/Scala/2_0类和对象.html">Class</a></li><li class="chapter-item "><a href="../../../Language/Scala/2_1继承.html">继承</a></li><li class="chapter-item "><a href="../../../Language/Scala/2_2特质.html">Trait</a></li><li class="chapter-item "><a href="../../../Language/Scala/3_1花里胡哨的函数.html">花里胡哨的函数</a></li><li class="chapter-item "><a href="../../../Language/Scala/3_2匿名函数和闭包.html">函数</a></li><li class="chapter-item "><a href="../../../Language/Scala/3_3模式匹配.html">模式匹配</a></li><li class="chapter-item "><a href="../../../Language/Scala/3_4容器的函数式操作.html">容器的函数式操作</a></li><li class="chapter-item "><a href="../../../Language/Scala/ScalaDepth/index.html">ScalaDepth</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Language/Scala/ScalaDepth/Class文件.html">Class文件</a></li><li class="chapter-item "><a href="../../../Language/Scala/ScalaDepth/ScalaInDepth.html">Scala in Depth 读书笔记</a></li><li class="chapter-item "><a href="../../../Language/Scala/ScalaDepth/Spark.html">Spark</a></li><li class="chapter-item "><a href="../../../Language/Scala/ScalaDepth/jvm.html">《深入理解Java虚拟机读书》笔记</a></li><li class="chapter-item "><a href="../../../Language/Scala/ScalaDepth/函数式的一些概念.html">Scala中一些函数式概念</a></li><li class="chapter-item "><a href="../../../Language/Scala/ScalaDepth/泛型擦除.html">泛型擦除</a></li><li class="chapter-item "><a href="../../../Language/Scala/ScalaDepth/简单的类型原理.html">类型</a></li></ol></li><li class="chapter-item "><a href="../../../Language/Scala/sbt.html">sbt</a></li><li class="chapter-item "><a href="../../../Language/Scala/trait.html">trait</a></li><li class="chapter-item "><a href="../../../Language/Scala/枚举.html">枚举</a></li><li class="chapter-item "><a href="../../../Language/Scala/样例类和模式匹配.html">样例类和模式匹配</a></li><li class="chapter-item "><a href="../../../Language/Scala/测试和文档.html">测试和文档</a></li><li class="chapter-item "><a href="../../../Language/Scala/组合和继承.html">类的组合和继承</a></li></ol></li><li class="chapter-item "><a href="../../../Language/Snippet/index.html">Snippets</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Language/Snippet/c.html">c</a></li><li class="chapter-item "><a href="../../../Language/Snippet/linux.html">linux</a></li><li class="chapter-item "><a href="../../../Language/Snippet/python.html">python</a></li><li class="chapter-item "><a href="../../../Language/Snippet/rust.html">rust</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../../Tools/index.html">Tools</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../Tools/Docker.html">Docker</a></li><li class="chapter-item "><a href="../../../Tools/GDB.html">GDB</a></li><li class="chapter-item "><a href="../../../Tools/Git/index.html">Git</a></li><li class="chapter-item "><a href="../../../Tools/Git.html">Git</a></li><li class="chapter-item "><a href="../../../Tools/Githook.html">Githook</a></li><li class="chapter-item "><a href="../../../Tools/GithubCI.html">Github-CI</a></li><li class="chapter-item "><a href="../../../Tools/Latex.html">Latex</a></li><li class="chapter-item "><a href="../../../Tools/Make.html">Make与Makefile</a></li><li class="chapter-item "><a href="../../../Tools/VSCode.html">VSCode</a></li><li class="chapter-item "><a href="../../../Tools/Vim.html">Vim</a></li><li class="chapter-item "><a href="../../../Tools/WSL.html">WSL</a></li><li class="chapter-item "><a href="../../../Tools/双系统.html">双系统使用经历</a></li><li class="chapter-item "><a href="../../../Tools/软件打包.html">软件打包</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Reticence&#x27;s Notes</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="linux内核设计与实现笔记"><a class="header" href="#linux内核设计与实现笔记">《Linux内核设计与实现》笔记</a></h1>
<p>这不是一个很好的笔记。只是记录了一些我之前不知道或不明确的东西。很多我知道的重点没有记下来。</p>
<h2 id="第一二章-简介"><a class="header" href="#第一二章-简介">第一二章 简介</a></h2>
<p>我们可以将每个处理器在任何指定时间点上的活动概括为以下三者之一：</p>
<ul>
<li>运行于用户空间，执行用户进程。</li>
<li>运行于内核空间，处于进程上下文，代表某个特定进程的执行。</li>
<li>运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断。</li>
</ul>
<p>使用 GNU C 编译器。</p>
<p>内核中发生的内存错误会导致oops。内核中的内存不分页。</p>
<p>内核栈的大小是固定且不大的。这个可以在编译的时候进行配置。</p>
<h3 id="同步和并发"><a class="header" href="#同步和并发">同步和并发</a></h3>
<ul>
<li>Linux是抢占多任务操作系统，内核的进程调度程序对进程进行调度，内核必须与这些进程同步。</li>
<li>Linux支持SMP（对称多处理器系统）。所以如果没有适当保护，同时在两个及以上处理器上执行的内核代码很可能会同时访问共享的一个资源。</li>
<li>中断是异步到来的，如果不加适当的保护，中断完全有可能在代码访问资源的时候到来，访问同一段资源。</li>
<li>Linux内核可以抢占，如果不加上适当的保护，内核中一段正在执行的代码可能会被另一端代码抢占，从而有可能导致几段代码同时访问相同的资源。</li>
</ul>
<h2 id="第三章-进程"><a class="header" href="#第三章-进程">第三章 进程</a></h2>
<p>进程列表存放在一个<strong>双向循环列表</strong>中。</p>
<p>Linux通过Slab分配器分配<code>task_struct</code>结构，达到对象复用和缓存着色的目的。</p>
<p>在寄存器不多的架构，没有多余的寄存器专门存储<code>task_struct</code>的地址。栈尾的<code>thread_info</code>结构，通过偏移间接地查找<code>task_struct</code>结构。可以看<code>current</code>宏在不同架构上的实现。</p>
<p>进程的创建，<code>fork</code>是我们最熟悉的系统调用，还有<code>vfork</code>和<code>clone</code>，不过其实最后都是调用<code>clone</code>。对于内核来说进程=线程。进程<code>exit</code>之后，释放**除了内核栈、<code>thread_info</code>，<code>task_struct</code>**之外的全部资源。这些没有释放的资源交给父进程释放，如果父进程已经死了就交给<code>init</code>进程。</p>
<h2 id="第四章-进程调度"><a class="header" href="#第四章-进程调度">第四章 进程调度</a></h2>
<h2 id="第五章-系统调用"><a class="header" href="#第五章-系统调用">第五章 系统调用</a></h2>
<blockquote>
<p>关于Unix的接口设计有一句格言“提供机制而不是策略”。换句话说，Unix的系统调用抽象出了用于完成某种确定的目的的函数。至于这些函数怎么用完全不需要内核去关心。</p>
</blockquote>
<p>系统调用在出现错误的时候C库会把错误码写入<code>errno</code>&quot;全局变量&quot;。通过调用<code>perror</code>库函数，可以把该变量翻译成用户可以理解的错误字符串。</p>
<p>系统调用必须仔细检査它们所有的参数是否合法有效。系统调用在内核空间执行，如果任由用户将不合法的输入传递给内核，那么系统的安全和稳定将面临极大的考验。最重要的一种检査就是检査用户提供的指针是否有效。在接收一个用户空间的指针之前，内核必须保证：</p>
<ul>
<li>指针指向的内存区域属于用户空间。进程决不能哄骗内核去读内核空间的数据。</li>
<li>指针指向的内存区域在进程的地址空间里。进程决不能哄骗内核去读其他进程的数据。</li>
<li>如果是读，该内存应被标记为可读；如果是写，该内存应被标记为可写；如果是可执行，该内存被标记为可执行。进程决不能绕过内存访问限制。</li>
</ul>
<p>内核提供了两个方法来完成必须的检査和内核空间与用户空间之间数据的来回拷贝。注意，内核无论何时都不能轻率地接受来自用户空间的指针！这两个方法中必须经常有一个被使用。为了向用户空间写入数据，内核提供了 <code>copy_to_user()</code>。它需要三个参数。第一个参数是进程空间中的目的内存地址，第二个是内核空间内的源地址，最后一个参数是需要拷贝的数据长度(字节数)。为了从用户空间读取数据，内核提供了 <code>copy_from_user</code>，它和<code>copy_to_user()</code>相似。该函数把第二个参数指定的位置上的数据拷贝到第一个参数指定的位置上，拷贝的数据长度由第三个参数决定。如果执行失败，这两个函数返回的都是没能完成拷贝的数据的字节数。如果成功，则返回<code>0</code>。当出现上述错误时，系统调用返回<code>-EFAULT</code>。注意，<code>copy_to_user()</code>和<code>copy_from_user()</code>都有可能引起<strong>阻塞</strong>。当包含用户数据的页被换出到硬盘上而不是在物理内存上的时候，这种情况就会发生。此时，进程就会休眠，直到缺页处理程序将该页从硬盘重新换回物理内存。</p>
<h2 id="第六章-内核数据结构"><a class="header" href="#第六章-内核数据结构">第六章 内核数据结构</a></h2>
<h3 id="链表"><a class="header" href="#链表">链表</a></h3>
<p>相比普遍的链表实现方式（包括前面章节描述的通用方法），Linux内核的实现可以说独树一帜，它不是将数据结构塞入链表，而是将链表节点塞入数据结构。链表代码在头文件<code>＜linux/list.h＞</code>中声明，其数据结构很简单</p>
<pre><code class="language-c">struct list_head {
    struct list_head *next;
    struct list_head *prev;
}
</code></pre>
<p>关键在于理解<code>list_head</code>是怎么使用的，有一系列宏魔法。主要分成操作链表（复杂度为$O(1)$）和遍历链表（复杂度为$O(n)$）。Linux提供了很多链表操作方法——几乎是你所能想到的所有访问和操作链表方法，所有这些方法都可在头文件<code>＜linux/list.h＞</code>中找到。</p>
<h3 id="队列"><a class="header" href="#队列">队列</a></h3>
<p>Linux内核通用队列实现称为<code>kfifo</code>。它实现在文件<code>kemel/kfifo.c</code>中，声明在文件<code>＜linux/kfifo.h＞</code>中。</p>
<p>使用kfifo前，首先必须对它进行定义和初始化。和多数内核对象一样，有动态或者静态方法供你选择。动态方法更为普遍，有<code>kfifo_alloc</code>和<code>kfifo_init</code>两种。推入数据到队列需要通过<code>kfifo_in()</code>方法完成，摘取数据则需要通过函数<code>kfifo_out()</code>完成。不过如果仅仅想“偷窥”队列中的数据，而不真想删除它，你可以使用<code>kfifo_out_peek()</code>方法。撤销一个使用<code>kfifo_alloc()</code>分配的队列，调用<code>kfifo_free()</code>。</p>
<h3 id="映射"><a class="header" href="#映射">映射</a></h3>
<p>Linux内核提供了简单、有效的映射数据结构。但是它并非一个通用的映射。因为它的目标是：映射一个唯一的标识数(UID)到一个指针。<code>idr</code>数据结构用于映射用户空间的<code>UID</code>,比如将<code>inotify_watch</code>的描述符或者POSIX的定时器ID映射到内核中相关联的数据结构上，如<code>inotify_watch</code>或者<code>k_itimer</code>结构体。其命名仍然沿袭了内核中有些含混不清的命名体系，这个映射被命名为<code>idr</code>。</p>
<h3 id="树"><a class="header" href="#树">树</a></h3>
<p>Linux实现的红黑树称为rbtree。其定义在文件<code>lib/rbtree.c</code>中，声明在文件<code>&lt;linux/rbtree.h&gt;</code>中。除了一定的优化外，Linux的rbtree类似于前面所描述的经典红黑树，即保持了平衡性，所以插入效率和树中节点数目呈对数关系。</p>
<p>rbtree的实现并没有提供搜索和插入例程，这些例程希望由rbtree的用户自己定义。这是因为C语言不大容易进行泛型编程，同时Linux内核开发者们相信最有效的搜索和插入方法需要每个用户自己去实现。你可以使用rbtree提供的辅助函数，但你自己要实现比较操作算子。</p>
<h2 id="第七章-中断"><a class="header" href="#第七章-中断">第七章 中断</a></h2>
<p>中断本质上是一种特殊的电信号，由硬件设备发向处理器。处理器接收到中断后，会马上向操作系统反映此信号的到来，然后就由操作系统负责处理这些新到来的数据。硬件设备生成中断的时候并不考虑与处理器的时钟同换句话说就是中断随时可以产生。因此，内核随时可能因为新到来的中断而被打断。不同的设备对应的中断不同，而每个中断都通过一个唯一的数字标志。这些中断值通常被称为中断请求（IRQ）线。每个IRQ线都会被关联一个数值量。</p>
<p>中断可能随时发生，因此中断处理程序也就随时可能执行。所以必须保证中断处理程序能够<strong>快速执行</strong>，这样才能保证尽可能快地恢复中断代码的执行。</p>
<p>中断处理程序与其他内核函数的真正区别在于，中断处理程序是被内核调用来响应中断的，而它们运行于我们称之为<strong>中断上下文</strong>的特殊上下文中。</p>
<p>中断上下文和进程并没有什么瓜葛。与current宏也是不相干的(尽管它会指向被中断的进程)。因为没有后备进程，所以中断上下文<strong>不可以睡眠</strong>，否则又怎能再对它重新调度呢？因此，不能从中断上下文中调用某些函数。如果一个函数可能睡眠，就不能在你的中断处理程序中使用它。</p>
<p>有一些函数可以用来禁用/启用中断。</p>
<p><img src="../images/image-20211226155249311.png" alt="image-20211226155249311" /></p>
<h3 id="中断处理程序"><a class="header" href="#中断处理程序">中断处理程序</a></h3>
<p><strong>驱动程序</strong>可以通过<code>request_irq()</code>函数<strong>注册</strong>一个中断处理程序。注意，request_irq()函数可能会睡眠，因此，不能在中断上下文或其他不允许阻塞的代码中调用该函数。</p>
<pre><code class="language-c">request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
            const char *name, void *dev)
</code></pre>
<ul>
<li>第一个参数irq表示要分配的中断号。对某些设备，如传统PC设备上的系统时钟或键盘，这个值通常是预先确定的。而对于大多数其他设备来说，这个值要么是可以通过探测获取，要么可以通过编程动态确定。</li>
<li>第二个参数handler是一个指针，指向处理这个中断的实际中断处理程序。只要操作系统一接收到中断，该函数就被调用。</li>
<li>第五个参数dev用于共享中断线。当一个中断处理程序需要释放时（稍后讨论），dev将提供唯一的标志信息（cookie）,以便从共享中断线的诸多中断处理程序中删除指定的那一个。</li>
</ul>
<p>卸载驱动程序时，需要<strong>注销</strong>相应的中断处理程序，并释放中断线。上述动作需要调用：</p>
<pre><code class="language-c">void free_irq(unsigned int irq, void *dev)
</code></pre>
<p>如果指定的中断线不是共享的，那么，该函数删除处理程序的同时将禁用这条中断线。如果中断线是共享的，则仅删除dev所对应的处理程序，而这条中断线本身只有在删除了最后一个处理程序时才会被禁用。</p>
<p>以下是一个中断处理程序声明：</p>
<pre><code class="language-c">static irqreturn_t intr_handler(int irq, void *dev)
</code></pre>
<ul>
<li>第一个参数irq就是这个处理程序要响应的中断的中断号。如今，这个参数已经没有太大用处了。</li>
<li>第二个参数dev是一个通用指针，它与在中断处理程序注册时传递给<code>request_irq()</code>的参数dev必须一致。如果该值有唯一确定性(这样做是为了能支持共享)，那么它就相当于一个cookie，<strong>可以用来区分共享同一中断处理程序的多个设备</strong>。</li>
<li>中断处理程序的返回值是一个特殊类型：<code>irqreturn_t</code>。中断处理程序可能返回两个特殊的值：<code>IRQ_NONE</code>和<code>IRQ_HANDLED</code>。当中断处理程序检测到一个中断，但该中断对应的设备并不是在注册处理函数期间指定的产生源时，返回<code>IRQ_NONE</code>；当中断处理程序被正确调用，且确实是它所对应的设备产生了中断时，返回<code>IRQ_HANDLED</code>。</li>
</ul>
<p>内核接收一个中断后，它将<strong>依次调用在该中断线上注册的每一个处理程序</strong>。因此，一个处理程序必须知道它是否应该为这个中断负责（dev参数）。如果与它相关的设备并没有产生中断，那么处理程序应该立即退出。</p>
<p>编写中断处理程序需要注意的事情：中断处理程序运行在<strong>中断上下文</strong>。Linux中的中断处理程序是<strong>无须重入</strong>的。当一个给定的中断处理程序正在执行时，相应的中断线在所有处理器上都会被屏蔽掉，以防止在同一中断线上接收另一个新的中断。通常情况下，所有其他的中断都是打开的，所以这些不同中断线上的其他中断都能被处理，但当前中断线总是被禁止的。所有的中断处理程序必须尽可能的<strong>迅速</strong>。尽量把工作从中断处理程序中分离出来，放在<strong>下半部</strong>来执行，因为下半部可以在更合适的时间运行。为了应对栈大小的减少，中断处理程序拥有了自己的栈，每个处理器一个，大小为一页。这个栈就称为中断栈，你的中断处理程序不必关心栈如何设置，或者内核栈的大小是多少。总而言之，<strong>尽量节约内核栈空间</strong>。</p>
<h2 id="第八章-中断下半部"><a class="header" href="#第八章-中断下半部">第八章 中断下半部</a></h2>
<p>下半部的任务就是执行与中断处理密切相关但中断处理程序本身不执行的工作。在理想的情况下，最好是中断处理程序将所有工作都交给下半部分执行，因为我们希望在中断处理程序中完成的工作越少越好（也就是越快越好）。我们期望中断处理程序能够尽可能快地返回。</p>
<p>但是，中断处理程序注定要完成一部分工作。例如，中断处理程序几乎都需要通过操作硬件对中断的到达进行确认，有时它还会从硬件拷贝数据。因为这些工作对时间非常敏感，所以只能靠中断处理程序自己去完成。</p>
<ul>
<li>如果一个任务对时间非常敏感，将其放在中断处理程序中执行。</li>
<li>如果一个任务和硬件相关，将其放在中断处理程序中执行。</li>
<li>如果一个任务要保证不被其他中断（特别是相同的中断）打断，将其放在中断处理程序中执行。</li>
<li>其他所有任务，考虑放置在下半部执行。</li>
</ul>
<h3 id="softirq"><a class="header" href="#softirq">softirq</a></h3>
<p>一个注册的软中断必须在被标记后才会执行。这被称作触发软中断(raising the softirq )。通常，中断处理程序会在返回前标记它的软中断，使其在稍后被执行。于是，在合适的时刻，该软中断就会运行。</p>
<h3 id="tasklet-star"><a class="header" href="#tasklet-star">tasklet :star:</a></h3>
<p>tasklet是利用软中断实现的一种下半部机制。我们之前提到过，它和进程没有任何关系。tasklet和软中断在本质上很相似，行为表现也相近，但是，它的接口更简单，锁保护也要求较低。<strong>大多数情况下用tasklet效果都不错，而且它们还非常容易使用</strong>。因为tasklet是通过软中断实现的，所以它们本身也是软中断。</p>
<h2 id="第九章-内核同步介绍"><a class="header" href="#第九章-内核同步介绍">第九章 内核同步介绍</a></h2>
<p>如果多个执行线程同时访问和操作数据，就可能发生各线程之间互相覆盖共享数据的情况，是造成系统不稳定的隐患，而且这种错误<strong>难以跟踪和调试</strong>。</p>
<p>从2.0开始，内核开始支持对称个临界区多处理器。在这之前，只有中断发生或者内核代码明确请求重新调度执行另一个任务的时候，数据才可能被并发访问。现在，<strong>运行在两个不同处理器上的内核代码完全可能在同一时刻并发访问共享数据</strong>。2.6开始，Linux内核发展成抢占式内核，调度程序可以在任何时刻<strong>抢占正在运行的内核代码</strong>，重新调度其他的进程执行。</p>
<p><strong>临界区</strong>就是访问和操作共享数据的代码段。如果两个程序可能在一个临界区中同时执行，这就是<strong>竞争条件race condition</strong>。避免竞争条件被称为<strong>同步synchronization</strong>。</p>
<p>同步的关键是找出哪些数据需要保护。要给数据而不是代码加锁。问自己下面的问题：</p>
<ol>
<li>这个数据是不是全局的？除了当前线程外其他线程能不能访问他？</li>
<li>这个数据会不会在进程上下文和中断上下文共享？它是不是要在两个不同的中断处理程序中共享？</li>
<li>进程在访问数据的时候可不可以被抢占？被调度的新进程会不会访问同一数据？</li>
<li>当前进程会不会睡眠（阻塞）在某些资源上？如果会，他会让共享数据处于何种状态？</li>
<li>如果这个函数又在另一个处理器上被调度会发生什么呢？</li>
<li>如何确保代码远离并发威胁？</li>
</ol>
<p>如何避免死锁？有一些简单的规则：</p>
<ol>
<li>按顺序加锁。如果需要嵌套的使用多个锁，必须按照相同的顺序去获取他们，在代码使用锁的地方，对锁的获取顺序加上注释是一个好习惯。</li>
<li>设计应该尽量简单。</li>
<li>防止发生饥饿。代码的执行是否一定会正常结束？</li>
<li>不要重复请求同一个锁。</li>
</ol>
<h2 id="第十章-内核同步方法"><a class="header" href="#第十章-内核同步方法">第十章 内核同步方法</a></h2>
<p>Linux内核提供了一组相当完备的同步方法。</p>
<h3 id="atomic"><a class="header" href="#atomic">atomic</a></h3>
<p>原子操作是其他同步方法的基石。针对<strong>整数</strong>的原子操作只能对<code>atomic_t</code>类型的数据进行处理，定义在<a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/types.h">types.h</a>中。还有针对<strong>位</strong>的原子操作。</p>
<pre><code class="language-c">typedef struct {
	int counter;
} atomic_t;
</code></pre>
<p>使用原子整型操作需要的声明在<a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/atomic">atomic</a>。一些体系结构会提供一些额外的原子操作方法，比如x86。</p>
<pre><code class="language-c">atomic_t v;
atomic_set(&amp;v, 4);
atomic_add(2, &amp;v);
atomic_inc(&amp;v);
int a = atomic_read(&amp;v);
</code></pre>
<p>原子整数操作最常见的用途是实现计数器。</p>
<h3 id="spin-lock"><a class="header" href="#spin-lock">spin lock</a></h3>
<p>自旋锁最多只能被一个可执行线程持有。如果一个执行线程试图获得一个已经被持有的自旋锁，那么线程就会进行<strong>busy waiting</strong>，直到锁重新可用。如果锁没有被争用，那么请求锁的执行线程便能立刻得到它。<strong>自旋锁可以防止多于一个的线程同时进入临界区</strong>。<strong>自旋锁不应该被长时间持有，用于短时间内进行轻量级加锁</strong>。使用自旋锁需要的声明定在<a href="https://elixir.bootlin.com/linux/v5.15/source">/</a><a href="https://elixir.bootlin.com/linux/v5.15/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/v5.15/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/v5.15/source/include/linux/spinlock_types.h">spinlock_types.h</a>。</p>
<p>自旋锁可以用在中断处理程序中，不能使用信号量，因为他们会导致睡眠。在中断处理程序中使用自旋锁时，一定要在获取锁之前，先<strong>禁止本地中断</strong>。否则中断处理程序可能会打断正持有锁的内核代码，就死锁了。内核提供了禁止中断同时请求锁的接口<a href="https://elixir.bootlin.com/linux/v5.15/source/include/linux/spinlock.h#L391"><code>spin_lock_irqsave</code></a>。相应的<code>spin_unlock_irqrestore</code>。</p>
<p>要注意，锁的是代码（临界区），真正要保护的是<strong>数据</strong>。</p>
<h3 id="read-write-lock"><a class="header" href="#read-write-lock">read-write lock</a></h3>
<p>Linux内核提供了专门的读-写锁 。这种自旋为读和写分别提供了不同的锁。一个或多个 任务可以并发地持有读者锁。相反，用于写的锁最多只能被一个写任务持有，而且此时不能有并发的读操作。用于<strong>读写明确区分</strong>的场景，并且有利于读者，写者容易<strong>饥饿</strong>。</p>
<p>使用读写锁需要的定义声明在<a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/rwlock.h">rwlock.h</a>。</p>
<h3 id="semaphore"><a class="header" href="#semaphore">semaphore</a></h3>
<p>信号量是一种睡眠锁。如果有一个任务试图获得一个不可用的信号量时，信号量就会将其推进一个等待队列，然后让其睡眠。当持有的信号量可用后，处于等待队列中的那个任务将被唤醒，并获得该信号量。</p>
<ul>
<li>争用信号量的进程在等待锁重新变成可用的时候会睡眠，所以信号量适合用于锁会被长时间持有的情况。反之，如果锁被短时间持有，使用信号量就不太合适。</li>
<li>在中断上下文不可以睡眠，所以不可以使用信号量。</li>
<li>占用信号量的同时不要占用自旋锁。因为在等待信号量的时候可能会睡眠，而持有自旋锁的时候不应该睡眠。</li>
<li>往往在需要<strong>和用户空间同步</strong>的时候，你的代码会需要睡眠，这时信号量就是唯一的选择。因为持有信号量的时候可以睡眠。</li>
</ul>
<p>使用信号量需要的定义声明在<a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/semaphore.h">semaphore.h</a>。</p>
<h3 id="rw_semaphore"><a class="header" href="#rw_semaphore">rw_semaphore</a></h3>
<p>读写信号量。</p>
<h3 id="mutex"><a class="header" href="#mutex">mutex</a></h3>
<p>mutex和信号量计数为1的semaphore表现的行为一致。</p>
<p><strong>mutex上锁者必须负责给其再解锁——你不能在一个上下文中锁定一个mutex，而在另一个上下文中它解锁。这个限制使得mutex不适合内核同用户空间复杂的同步场景</strong>。mutex只能通过官方API管理，不可以被拷贝、手动初始化或者重复初始化。持有mutex的时候进程不可以退出。当打开内核配置选项<code>CONFIG_DEBUG_MUTEXES</code>后，就会有多种检测来确保这些（还有别的）约束得以遵守。</p>
<h3 id="completion"><a class="header" href="#completion">completion</a></h3>
<p>如果内核中一个任务需要发出信号，通知另一任务发生了某个特定时间，利用completion是让两个任务得以同步的简单方法。（我之前用了wait_queue，看了一下completion也是用了wait相关的数据结构）</p>
<p><a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/completion.h">completion.h</a></p>
<h3 id="bkl"><a class="header" href="#bkl">BKL</a></h3>
<p>新代码中不再使用BKL</p>
<h3 id="禁止抢占"><a class="header" href="#禁止抢占">禁止抢占</a></h3>
<h3 id="顺序和屏障"><a class="header" href="#顺序和屏障">顺序和屏障</a></h3>
<p>硬件或者编译器可能会对读写进行重新排序，比如</p>
<pre><code class="language-c">a = 1;
b = 2;
</code></pre>
<p>可能在a存放新值之前就在b存放新值。</p>
<h2 id="十一章-定时器和时间管理"><a class="header" href="#十一章-定时器和时间管理">十一章 定时器和时间管理</a></h2>
<p>定义在<a href="https://elixir.bootlin.com/linux/v5.16/source">/</a><a href="https://elixir.bootlin.com/linux/v5.16/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/v5.16/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/v5.16/source/include/linux/jiffies.h">jiffies.h</a>中的<code>jiffles</code>。</p>
<pre><code class="language-c">extern u64 __cacheline_aligned_in_smp jiffies_64;
extern unsigned long volatile __cacheline_aligned_in_smp __jiffy_arch_data jiffies;
</code></pre>
<p>实时时钟 (RTC)是 来持久存放系统时间的设备。即便系统关闭后，它也可以靠主板上微型电池提供的电力保持系统的计时。在PC体系结构中 RTC和CMOS集成在一起，且RTC的运行和BIOS保存设置都是通过同一个电池供电的。</p>
<p>在x86体系结构中 主要采用可编程中断时钟(PIT) 。</p>
<p><strong>定时器</strong>的使用很简单，我们只需要执行一个初始化工作，设置超时时间，指定超时发生后执行的函数，然后激活定时器。指定的函数将在定时器到期时自动执行。定时器由结构<code>timer_list</code>表示，定义在文件<a href="https://elixir.bootlin.com/linux/v5.16/source">/</a><a href="https://elixir.bootlin.com/linux/v5.16/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/v5.16/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/v5.16/source/include/linux/timer.h">timer.h</a>中。使用定时器并不需要深入了解该数据结构。事实上深入该结构反会使你的代码不能保证对可能发生的变化提供支持。</p>
<p><strong>不要用定时器实现任何硬实时任务</strong>。一般来说定时器在超时后会马上执行，但是也可以推迟（但是绝对不会提前）。</p>
<h2 id="第十二章-内存管理"><a class="header" href="#第十二章-内存管理">第十二章 内存管理</a></h2>
<p>在内存中分配内存比在用户控件要复杂的多。</p>
<p>内核把物理页作为内存管理的基本单位。内核用<a href="https://elixir.bootlin.com/linux/v5.16/source/include/linux/mm_types.h#L71"><code>struct page</code></a>表示系统中每个物理页。</p>
<p>必须要理解的一点是<code>page</code>结构与物理页相关，而并非与虚拟页相关。因此，该结构对页的描述只是短暂的。即使页中所包含的数据继续存在，由于交换等原因，他们可能也不再和同一个<code>page</code>结构关联。内核仅仅用这个数据结构来描述当前时刻在物理页中存放的东西。这种数据结构的目的在于描述物理内存本身，而不是描述包含在其中的数据。</p>
<p>由于硬件的限制，内核并不能对所有的页一视同仁，所以<strong>内核把页划分成不同的区zone</strong>，内核使用zone对具有相似特性的page进行分组。</p>
<p>定义在<a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/gfp.h">gfp.h</a>。</p>
<p>分配页</p>
<pre><code class="language-c">/* 分配 2^order 个 pages，返回第一页的地址 */
unsigned long __get_free_pages(gfp_t gfp_mask, usigned int order);
/* 分配 2^order 个 page，返回第一页struct page* */
struct page* alloc_pages(gfp_t gfp_mask, usigned int order);
/* 分配 1 个 pages，返回第一页的逻辑地址 */
unsigned long __get_free_page(gfp_t gfp_mask, usigned int order);
/* 分配 1 个 page，返回第一页struct page* */
struct page* alloc_page(gfp_t gfp_mask);
/* 分配 1 个 page，数据全部填充成0。返回给用户空间的页需要填充为0 */
unsigned long get_zeroed_page(unsigned int gfp_mask);
/* 把 page 转换成逻辑地址 */
void* page_address(struct page* page);
</code></pre>
<p>释放页</p>
<pre><code class="language-c">void __free_pages(struct page*page, unsigned int order);
void free_pages(unsigned long addr,unsigned int order);
void free_page(unsigned long addr);
</code></pre>
<h3 id="kmalloc"><a class="header" href="#kmalloc">kmalloc</a></h3>
<p>之前介绍的接口，对于需要分配整个页的情况可能是比<code>kmalloc</code>更好的选择。但是对于大多数的内核分配来说，<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/slab.h#L576"><code>kmalloc</code></a>用得更多。它返回一个指向内存块的指针，内存块至少有<code>size</code>大小，分配的内存在物理上是连续的。在出错时，它返回NULL，也就意味着没有足够的内存可用了。</p>
<pre><code class="language-c">static __always_inline __alloc_size(1) 
    void *kmalloc(size_t size, gfp_t flags);
</code></pre>
<p><code>gfp_t flag</code><strong>常用</strong>的宏，不知道有没有过时。在绝大多数代码中，我们只需要用到<code>GFP_KERNEL</code>和<code>GFP_ATOMIC</code>。</p>
<p><img src="../images/image-20220201133514129.png" alt="Which flag to use when" /></p>
<p>和<code>kmalloc</code>配套使用的是<code>kfree</code></p>
<pre><code class="language-c">void kfree(const void *objp);
</code></pre>
<h3 id="vmalloc"><a class="header" href="#vmalloc">vmalloc</a></h3>
<p><code>vmalloc</code>类似<code>kmalloc</code>，但是**<code>vmalloc</code>分配的虚拟地址是连续的，物理地址无需连续，这类似于用户空间分配函数<code>malloc</code>。而<code>kmalloc</code>保证物理地址和虚拟地址都是连续的**。</p>
<p>定义在<a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/vmalloc.h">vmalloc.h</a>。</p>
<pre><code class="language-c">void *vmalloc(unsigned long size) __alloc_size(1);
void vfree(const void *addr);
</code></pre>
<p>出于性能的考虑，很多内核代码即使不需要物理地址连续的内存，也使用<code>kmalloc</code>。<code>vmalloc</code>只在不得已时才会使用——比如获得大块内存时。</p>
<h3 id="slab"><a class="header" href="#slab">slab</a></h3>
<p>分配和释放数据结构是内核中最普遍的操作之一。为了便于数据的频繁分配和挥手，编程人员常常会用到空闲链表。当代码需要一个新的数据结构时，可以从空闲链表中抓取一个而不需要分配内存，再把数据放进去。当不需要这个数据结构的实例时，把它放回空闲链表而不是释放它。但是空闲链表面临的主要问题是不能全局控制，让不同的空闲链表统筹操作，释放内存出来使用。所以，Linux提供了slab，通用的数据结构缓存层。</p>
<pre><code class="language-c">struct kmem_cache *kmem_cache_create(const char *name, unsigned int size,
                                     unsigned int align, slab_flags_t flags,
                                     void (*ctor)(void *));
void kmem_cache_destroy(struct kmem_cache *s);
void *kmem_cache_alloc(struct kmem_cache *s, gfp_t flags) __assume_slab_alignment __malloc;
void kmem_cache_free(struct kmem_cache *s, void *objp);
</code></pre>
<h3 id="栈"><a class="header" href="#栈">栈</a></h3>
<p>内核栈小且固定。所以不要在栈上进行大量的静态分配（大型数组或大型结构体），否则栈溢出会覆盖掉邻接堆栈末端的东西，<code>thread_info</code>和其他的数据。</p>
<h2 id="第十三章-虚拟文件系统"><a class="header" href="#第十三章-虚拟文件系统">第十三章 虚拟文件系统</a></h2>
<p>Inode对象包含了内核在操作文件或目录时需要的全部信息。对于Unix风格的文件系统来说这些信息可以从磁盘inode节点直接读入，但是如果磁盘上文件系统没有inode，也需要从中提取信息。也就是说，无论如何inode都会在内存中创立。</p>
<p>书介绍了四大数据结构的全部的接口，可以作为参考。</p>
<p>还介绍了和进程相关的数据结构</p>
<ul>
<li><code>file_struct</code>，主要是存储打开的文件，<code>fdt</code>。</li>
<li><code>fs_struct</code>，这里存储了<code>root</code>根目录路径，<code>pwd</code>当前工作目录的路径，<code>in_exec</code>当前正在执行的文件</li>
<li><code>namespace</code>，<strong>他使得每一个进程在系统中都看到唯一的安装文件系统，不仅是唯一的根目录，而且是唯一的文件系统层次结构</strong>。</li>
</ul>
<h2 id="第十四章-块io层"><a class="header" href="#第十四章-块io层">第十四章 块I/O层</a></h2>
<p>能够随机（不按顺序）访问固定大小的数据片的设备称为<strong>块设备</strong>，比如硬盘。按照字符流的顺序被有序访问的称为<strong>字符设备</strong>，比如串口和键盘。</p>
<p>设备最小的寻址单元是<strong>扇区sector</strong>。不过内核中磁盘操作的基本单元是<strong>块block</strong>。一般来说sector是512B的大小，不过也有不同的。block的大小要求是sector的2的整数倍而小于page size（不确定现在的内核是否还有这个限制），所以一般是512B, 1KB, 4KB。</p>
<p>当一个块被调入内存时，也就是 在读入后或等待写出时，它存储在一个<strong>缓冲区</strong>中。用一个<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/buffer_head.h#L60"><code>buffer_head</code></a>结构体存储缓冲区的元信息(他曾今用来在一个page中映射一个block，但是现在我们使用bio，而将buffer_head用来extracting block mappings)。<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/blk_types.h#L237"><code>bio</code></a>结构体代表了正在或等待的以segment link list形式组织的<strong>块IO操作</strong>。</p>
<p>内核会对IO进行调度。</p>
<h2 id="十五章-进程地址空间"><a class="header" href="#十五章-进程地址空间">十五章 进程地址空间</a></h2>
<p>进程地址空间指的就是每个用户空间进程看到的内存。内核使用<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/mm_types.h#L467"><code>mm_struct</code></a>描述进程的地址空间，定义在 <a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/mm_types.h">mm_types.h</a>中。一些有趣的字段</p>
<pre><code class="language-c">/* list of VMAs */
struct vm_area_struct *mmap;
/* rb tree of VMAs */
struct rb_root mm_rb;
/* 代码段，数据段 */
unsigned long start_code, end_code, start_data, end_data;
/* 栈，堆 */
unsigned long start_brk, brk, start_stack;
/* 参数，环境变量 */
unsigned long arg_start, arg_end, env_start, env_end;
</code></pre>
<p><strong><code>mmap</code>作为链表，利于简单高效的遍历所有元素，而<code>mm_rb</code>作为红黑树，方便搜索指定元素。<code>current-&gt;mm</code>指向当前进程的内存描述符，<code>fork()</code>函数利用<code>copy_mm</code>复制父进程的内存描述符。通常每个进程都有唯一的<code>mm_struct</code>，即唯一的进程地址空间，如果父进程希望和其他子进程共享地址空间，可以在<code>clone()</code>时，设置<code>CLONE_VM</code>标识，这样就是线程了</strong>。</p>
<h2 id="十六章-页高速缓存和页回写"><a class="header" href="#十六章-页高速缓存和页回写">十六章 页高速缓存和页回写</a></h2>
<p>页高速缓存cache是Linux内核实现磁盘缓存的方式。他用来减少对磁盘的IO操作，将物理内存作为磁盘的cache。</p>
<p><code>address_space</code>用来管理新对象缓存项和页IO操作。</p>
<h2 id="十七章-模块与设备"><a class="header" href="#十七章-模块与设备">十七章 模块与设备</a></h2>
<p>设备被分为：</p>
<ul>
<li>块设备</li>
<li>字符设备</li>
<li>网络设备：打破了一切皆文件的原则，可以通过套接字API这样的特殊接口来访问。</li>
</ul>
<p>设备模型的核心部分是<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/kobject.h#L64"><code>kobject</code></a>。sysfs是处于内存中的一个虚拟文件系统，他为我们提供了<code>kobject</code>对象层次结构的视图。</p>
<p><code>BUG_ON()</code>有点类似<code>assert!</code>，提供断言的作用。</p>
<h2 id="十八章-调试"><a class="header" href="#十八章-调试">十八章 调试</a></h2>
<p>printk可以设置打印频率，否则可能会因为太多的打印让系统负载过高。</p>
<pre><code class="language-c">static unsigned long prev_jiffy = jiffies;/* 频率限制 */
if (time_after(jiffies, prev_jiffy + 2*HZ)) {
    prev_jiffy = jiffies;
    printk(KERN_ERR &quot;blah blah blah\n&quot;) 
}
</code></pre>
<p>git的二分查找</p>
<pre><code>git bisect
</code></pre>
<h2 id="十九章-移植性"><a class="header" href="#十九章-移植性">十九章 移植性</a></h2>
<ul>
<li>int的长度，在Linux当前支持的体系结构中都是32位的。（待考证）</li>
<li>short的长度，在Linux当前支持的体系结构中都是16位的。（待考证）</li>
<li>不要假设指针和long的长度。</li>
</ul>
<p>有一些用typedef定义的类型，<strong>请不要将该类型转换成C标准类型，当做一个不知道长度的类型就好</strong>。</p>
<p>对于一些 知道明确长度的变量，用</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody>
<tr><td>s8</td><td>带符号字节</td></tr>
<tr><td>u8</td><td>无符号字节</td></tr>
<tr><td>s16</td><td>带符号16位整数</td></tr>
<tr><td>u16</td><td>无符号16位整数</td></tr>
<tr><td>s32</td><td>带符号32位整数</td></tr>
<tr><td>u32</td><td>无符号32位整数</td></tr>
<tr><td>s64</td><td>带符号64位整数</td></tr>
<tr><td>u64</td><td>无符号64位整数</td></tr>
</tbody></table>
</div>
<p>注意SMP，内核抢占，高端内存的使用。</p>
<hr />
<ul>
<li>http://www.lwn.net/ Linux新闻周刊</li>
<li>http://www.kemel.org 内核代码库的官方站点</li>
<li>http://kemelnewbies.org/</li>
</ul>
<p>编码风格，使用8个字符长度的制表符缩进。K&amp;R风格。每行不超过80个字符，用下面的命令可以使用Linux编码风格。</p>
<pre><code>indent -kr -i8 -ts8 -sob -180 -ss -bs -psi &lt;file&gt;
</code></pre>
<p>注释规范：Documentation/kemel-doc-nano-HOWTO.txt</p>
<p>多用现成的东西，不要重复造轮子。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../Advanced/Linux/LinuxKernel/File_System.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../../Advanced/Linux/LinuxKernel/Linux设备驱动笔记.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../Advanced/Linux/LinuxKernel/File_System.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../../Advanced/Linux/LinuxKernel/Linux设备驱动笔记.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
