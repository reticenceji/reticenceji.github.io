<!DOCTYPE html>
<html>

<head>
    <title>Edmonds-Karp 算法演示</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1,
        h2,
        h3 {
            color: #333;
            margin-top: 0;
        }

        .graph-container {
            display: flex;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .graph-wrapper {
            flex: 1;
            min-width: 400px;
        }

        .graph-wrapper h3 {
            text-align: center;
            margin-bottom: 10px;
        }

        svg {
            width: 100%;
            height: 400px;
            border: 2px solid #ddd;
            border-radius: 5px;
            background: #fafafa;
        }

        .controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .info {
            background: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .path-info {
            background: #fff3cd;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #ffeaa7;
        }

        .step-explanation {
            background: #d1ecf1;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #bee5eb;
        }

        .node {
            cursor: pointer;
        }

        .node circle {
            fill: #007bff;
            stroke: #0056b3;
            stroke-width: 2;
        }

        .node.source circle {
            fill: #dc3545;
            stroke: #bd2130;
        }

        .node.sink circle {
            fill: #28a745;
            stroke: #1e7e34;
        }

        .node.highlighted circle {
            fill: #ffc107;
            stroke: #d39e00;
            stroke-width: 3;
        }

        .node text {
            fill: white;
            text-anchor: middle;
            dominant-baseline: middle;
            font-weight: bold;
            font-size: 20px;
            pointer-events: none;
        }

        .edge {
            fill: none;
            stroke: #666;
            stroke-width: 2;
            marker-end: url(#arrowhead);
        }

        .edge.highlighted {
            stroke: #ffc107;
            stroke-width: 4;
            marker-end: url(#arrowhead-highlighted);
        }

        .edge.saturated {
            stroke: #dc3545;
            stroke-dasharray: 5, 5;
        }

        .edge.reverse {
            stroke: #6c757d;
            stroke-dasharray: 3, 3;
        }

        .edge-label {
            font-size: 14px;
            fill: #333;
            font-weight: bold;
        }

        .edge-label.flow {
            fill: #007bff;
        }

        .stats {
            display: flex;
            gap: 30px;
            margin-top: 20px;
        }

        .stat-item {
            flex: 1;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
        }

        .stat-item h3 {
            margin: 0;
            color: #495057;
            font-size: 18px;
        }

        .stat-value {
            font-size: 36px;
            font-weight: bold;
            color: #007bff;
            margin-top: 5px;
        }

        .legend {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 14px;
        }

        .legend-item {
            display: inline-block;
            margin-right: 20px;
        }

        .config-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }

        .config-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
        }

        .node-input,
        .edge-input {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
        }

        .node-input input,
        .edge-input input {
            width: 60px;
            margin-right: 10px;
        }

        .node-input button,
        .edge-input button {
            padding: 5px 10px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Edmonds-Karp 算法演示</h1>

        <div class="info">
            <h2>算法说明</h2>
            <p>Edmonds-Karp 算法是 Ford-Fulkerson 算法的一个具体实现，它使用广度优先搜索（BFS）来寻找增广路径，从而保证总是找到最短的增广路径。这里演示从 <strong
                    style="color: #dc3545;">A（源点）</strong> 到 <strong style="color: #28a745;">D（汇点）</strong> 的最大流。</p>
            <p>算法特点：</p>
            <ul>
                <li>使用 BFS 寻找增广路径，保证找到最短路径</li>
                <li>时间复杂度为 O(VE²)，其中 V 是顶点数，E 是边数</li>
                <li>相比一般的 Ford-Fulkerson 算法，Edmonds-Karp 算法能保证在有限步数内找到最大流</li>
            </ul>
        </div>

        <div class="config-panel" style="background: #f8f9fa; padding: 20px; border-radius: 5px; margin: 20px 0;">
            <h3>图配置</h3>
            <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                <div>
                    <h4>节点配置</h4>
                    <div id="nodeConfig" style="margin-bottom: 10px;">
                        <div class="node-input" style="margin-bottom: 10px;">
                            <input type="text" placeholder="节点名称" class="node-name"
                                style="width: 60px; margin-right: 10px;">
                            <input type="number" placeholder="X坐标" class="node-x"
                                style="width: 60px; margin-right: 10px;">
                            <input type="number" placeholder="Y坐标" class="node-y"
                                style="width: 60px; margin-right: 10px;">
                            <button onclick="removeNode(this)" style="padding: 5px 10px;">删除</button>
                        </div>
                    </div>
                    <button onclick="addNodeInput()" style="padding: 5px 10px;">添加节点</button>
                </div>
                <div>
                    <h4>边配置</h4>
                    <div id="edgeConfig" style="margin-bottom: 10px;">
                        <div class="edge-input" style="margin-bottom: 10px;">
                            <input type="text" placeholder="起点" class="edge-from"
                                style="width: 60px; margin-right: 10px;">
                            <input type="text" placeholder="终点" class="edge-to"
                                style="width: 60px; margin-right: 10px;">
                            <input type="number" placeholder="容量" class="edge-capacity"
                                style="width: 60px; margin-right: 10px;">
                            <button onclick="removeEdge(this)" style="padding: 5px 10px;">删除</button>
                        </div>
                    </div>
                    <button onclick="addEdgeInput()" style="padding: 5px 10px;">添加边</button>
                </div>
                <div>
                    <h4>源点和汇点</h4>
                    <div style="margin-bottom: 10px;">
                        <label>源点：</label>
                        <input type="text" id="sourceNode" value="A" style="width: 60px; margin-right: 20px;">
                        <label>汇点：</label>
                        <input type="text" id="sinkNode" value="D" style="width: 60px;">
                    </div>
                </div>
            </div>
            <button onclick="applyConfig()" style="margin-top: 10px; padding: 10px 20px;">应用配置</button>
        </div>

        <div class="controls">
            <button onclick="reset()">重置</button>
            <button onclick="stepForward()" id="stepBtn">下一步</button>
            <button onclick="runAll()">运行完整算法</button>
        </div>

        <div class="legend">
            <span class="legend-item"><strong>原始网络：</strong>显示 流量/容量</span>
            <span class="legend-item"><strong>残余网络：</strong>显示剩余容量</span>
            <span class="legend-item" style="color: #dc3545;">红色虚线 = 饱和边</span>
            <span class="legend-item" style="color: #6c757d;">灰色虚线 = 反向边</span>
        </div>

        <div class="graph-container">
            <div class="graph-wrapper">
                <h3>原始网络（流量/容量）</h3>
                <svg id="flowGraph"></svg>
            </div>
            <div class="graph-wrapper">
                <h3>残余网络</h3>
                <svg id="residualGraph"></svg>
            </div>
        </div>

        <div id="currentPath" class="path-info" style="display: none;"></div>
        <div id="stepExplanation" class="step-explanation" style="display: none;"></div>

        <div class="stats">
            <div class="stat-item">
                <h3>当前流量</h3>
                <div class="stat-value" id="currentFlow">0</div>
            </div>
            <div class="stat-item">
                <h3>执行步骤</h3>
                <div class="stat-value" id="stepCount">0</div>
            </div>
        </div>
    </div>

    <script>
        // 默认配置
        let nodes = {
            A: { x: 100, y: 200 },
            B: { x: 250, y: 100 },
            C: { x: 400, y: 100 },
            D: { x: 550, y: 200 },
            E: { x: 400, y: 300 }
        };

        let originalCapacity = {
            A: { B: 100 },
            B: { C: 80 },
            C: { D: 40, E: 40 },
            E: { D: 40 },
            D: { B: 60 }
        };
        let src = 'A';
        let dst = 'D';

        // 当前流量、残余网络和实际流量
        let flow = {};
        let residual = {};
        let actualFlow = {};
        let maxFlow = 0;
        let step = 0;
        let currentPath = null;

        // 初始化配置面板
        function initializeConfigPanel() {
            // 清空现有配置
            document.getElementById('nodeConfig').innerHTML = '';
            document.getElementById('edgeConfig').innerHTML = '';

            // 添加现有节点
            for (let node in nodes) {
                addNodeInput(node, nodes[node].x, nodes[node].y);
            }

            // 添加现有边
            for (let from in originalCapacity) {
                for (let to in originalCapacity[from]) {
                    addEdgeInput(from, to, originalCapacity[from][to]);
                }
            }

            // 设置源点和汇点
            document.getElementById('sourceNode').value = src;
            document.getElementById('sinkNode').value = dst;
        }

        function addNodeInput(name = '', x = '', y = '') {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'node-input';
            nodeDiv.style.marginBottom = '10px';
            nodeDiv.innerHTML = `
                <input type="text" placeholder="节点名称" class="node-name" value="${name}" style="width: 60px; margin-right: 10px;">
                <input type="number" placeholder="X坐标" class="node-x" value="${x}" style="width: 60px; margin-right: 10px;">
                <input type="number" placeholder="Y坐标" class="node-y" value="${y}" style="width: 60px; margin-right: 10px;">
                <button onclick="removeNode(this)" style="padding: 5px 10px;">删除</button>
            `;
            document.getElementById('nodeConfig').appendChild(nodeDiv);
        }

        function addEdgeInput(from = '', to = '', capacity = '') {
            const edgeDiv = document.createElement('div');
            edgeDiv.className = 'edge-input';
            edgeDiv.style.marginBottom = '10px';
            edgeDiv.innerHTML = `
                <input type="text" placeholder="起点" class="edge-from" value="${from}" style="width: 60px; margin-right: 10px;">
                <input type="text" placeholder="终点" class="edge-to" value="${to}" style="width: 60px; margin-right: 10px;">
                <input type="number" placeholder="容量" class="edge-capacity" value="${capacity}" style="width: 60px; margin-right: 10px;">
                <button onclick="removeEdge(this)" style="padding: 5px 10px;">删除</button>
            `;
            document.getElementById('edgeConfig').appendChild(edgeDiv);
        }

        function removeNode(button) {
            button.parentElement.remove();
        }

        function removeEdge(button) {
            button.parentElement.remove();
        }

        function applyConfig() {
            // 收集节点配置
            nodes = {};
            document.querySelectorAll('.node-input').forEach(div => {
                const name = div.querySelector('.node-name').value;
                const x = parseInt(div.querySelector('.node-x').value);
                const y = parseInt(div.querySelector('.node-y').value);
                if (name && !isNaN(x) && !isNaN(y)) {
                    nodes[name] = { x, y };
                }
            });

            // 收集边配置
            originalCapacity = {};
            document.querySelectorAll('.edge-input').forEach(div => {
                const from = div.querySelector('.edge-from').value;
                const to = div.querySelector('.edge-to').value;
                const capacity = parseInt(div.querySelector('.edge-capacity').value);
                if (from && to && !isNaN(capacity)) {
                    if (!originalCapacity[from]) originalCapacity[from] = {};
                    originalCapacity[from][to] = capacity;
                }
            });

            // 更新源点和汇点
            src = document.getElementById('sourceNode').value;
            dst = document.getElementById('sinkNode').value;

            // 重置并重新绘制图
            reset();
        }

        function initializeFlow() {
            flow = {};
            residual = {};
            actualFlow = {};
            maxFlow = 0;
            step = 0;

            // 初始化流量和残余网络
            for (let u in originalCapacity) {
                flow[u] = {};
                residual[u] = {};
                actualFlow[u] = {};
                for (let v in originalCapacity[u]) {
                    flow[u][v] = 0;
                    actualFlow[u][v] = 0;
                    residual[u][v] = originalCapacity[u][v];
                }
            }

            // 添加反向边（初始容量为0）
            for (let u in originalCapacity) {
                for (let v in originalCapacity[u]) {
                    if (!residual[v]) residual[v] = {};
                    if (!actualFlow[v]) actualFlow[v] = {};
                    if (!(u in residual[v])) residual[v][u] = 0;
                }
            }
        }

        function createSVGElement(tag, attrs) {
            const elem = document.createElementNS('http://www.w3.org/2000/svg', tag);
            for (let attr in attrs) {
                elem.setAttribute(attr, attrs[attr]);
            }
            return elem;
        }

        function drawFlowGraph(svgId, highlightPath = null) {
            const svg = document.getElementById(svgId);
            svg.innerHTML = '';

            // 定义箭头标记
            const defs = createSVGElement('defs', {});

            const marker = createSVGElement('marker', {
                id: 'arrowhead',
                markerWidth: '10',
                markerHeight: '10',
                refX: '9',
                refY: '3',
                orient: 'auto'
            });
            const polygon = createSVGElement('polygon', {
                points: '0 0, 10 3, 0 6',
                fill: '#666'
            });
            marker.appendChild(polygon);
            defs.appendChild(marker);

            const markerHighlighted = createSVGElement('marker', {
                id: 'arrowhead-highlighted',
                markerWidth: '10',
                markerHeight: '10',
                refX: '9',
                refY: '3',
                orient: 'auto'
            });
            const polygonHighlighted = createSVGElement('polygon', {
                points: '0 0, 10 3, 0 6',
                fill: '#ffc107'
            });
            markerHighlighted.appendChild(polygonHighlighted);
            defs.appendChild(markerHighlighted);

            svg.appendChild(defs);

            // 绘制原始网络的边，显示流量/容量
            for (let u in originalCapacity) {
                for (let v in originalCapacity[u]) {
                    const from = nodes[u];
                    const to = nodes[v];
                    const capacity = originalCapacity[u][v];
                    const currentFlow = actualFlow[u] && actualFlow[u][v] ? actualFlow[u][v] : 0;
                    const isSaturated = currentFlow === capacity;

                    // 计算边的路径
                    const dx = to.x - from.x;
                    const dy = to.y - from.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const radius = 25;

                    const startX = from.x + (dx / distance) * radius;
                    const startY = from.y + (dy / distance) * radius;
                    const endX = to.x - (dx / distance) * (radius + 10);
                    const endY = to.y - (dy / distance) * (radius + 10);

                    // 创建边
                    const edge = createSVGElement('line', {
                        x1: startX,
                        y1: startY,
                        x2: endX,
                        y2: endY,
                        class: 'edge' +
                            (highlightPath && isEdgeInPath(u, v, highlightPath) ? ' highlighted' : '') +
                            (isSaturated ? ' saturated' : '')
                    });
                    svg.appendChild(edge);

                    // 边的标签（流量/容量）
                    const midX = (startX + endX) / 2;
                    const midY = (startY + endY) / 2;

                    const labelBg = createSVGElement('rect', {
                        x: midX - 25,
                        y: midY - 10,
                        width: 50,
                        height: 20,
                        fill: 'white',
                        stroke: '#ddd',
                        'stroke-width': 1,
                        rx: 3
                    });
                    svg.appendChild(labelBg);

                    const label = createSVGElement('text', {
                        x: midX,
                        y: midY,
                        class: 'edge-label flow',
                        'text-anchor': 'middle',
                        'dominant-baseline': 'middle'
                    });
                    label.textContent = `${currentFlow}/${capacity}`;
                    svg.appendChild(label);
                }
            }

            // 绘制节点
            drawNodes(svg, highlightPath);
        }

        function drawResidualGraph(svgId, highlightPath = null) {
            const svg = document.getElementById(svgId);
            svg.innerHTML = '';

            // 定义箭头标记
            const defs = createSVGElement('defs', {});

            const marker = createSVGElement('marker', {
                id: 'arrowhead-res',
                markerWidth: '10',
                markerHeight: '10',
                refX: '8',
                refY: '3',
                orient: 'auto'
            });
            const polygon = createSVGElement('polygon', {
                points: '0 0, 10 3, 0 6',
                fill: '#666'
            });
            marker.appendChild(polygon);
            defs.appendChild(marker);

            const markerHighlighted = createSVGElement('marker', {
                id: 'arrowhead-highlighted-res',
                markerWidth: '10',
                markerHeight: '10',
                refX: '8',
                refY: '3',
                orient: 'auto'
            });
            const polygonHighlighted = createSVGElement('polygon', {
                points: '0 0, 10 3, 0 6',
                fill: '#ffc107'
            });
            markerHighlighted.appendChild(polygonHighlighted);
            defs.appendChild(markerHighlighted);

            svg.appendChild(defs);

            // 绘制残余网络的边
            const drawnEdges = new Set();

            for (let u in residual) {
                for (let v in residual[u]) {
                    if (residual[u][v] > 0) {
                        const from = nodes[u];
                        const to = nodes[v];
                        const isReverse = !originalCapacity[u] || !originalCapacity[u][v];

                        // 检查是否需要绘制曲线（存在双向边）
                        const hasReverseEdge = residual[v] && residual[v][u] && residual[v][u] > 0;
                        const edgeKey = [u, v].sort().join('-');

                        if (drawnEdges.has(edgeKey) && hasReverseEdge) {
                            continue; // 如果已经绘制了双向边，跳过
                        }

                        const radius = 25;

                        if (hasReverseEdge && !drawnEdges.has(edgeKey)) {
                            // 绘制双向边
                            drawnEdges.add(edgeKey);

                            // 计算控制点偏移
                            const dx = to.x - from.x;
                            const dy = to.y - from.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const midX = (from.x + to.x) / 2;
                            const midY = (from.y + to.y) / 2;

                            // 垂直于连线的偏移
                            const offsetX = -dy / distance * 30;
                            const offsetY = dx / distance * 30;

                            // 绘制 u -> v 的曲线
                            const path1 = createSVGElement('path', {
                                d: `M ${from.x + (dx / distance) * radius} ${from.y + (dy / distance) * radius} 
                                    Q ${midX + offsetX} ${midY + offsetY} 
                                    ${to.x - (dx / distance) * radius} ${to.y - (dy / distance) * radius}`,
                                class: 'edge' +
                                    (highlightPath && isEdgeInPath(u, v, highlightPath) ? ' highlighted' : '') +
                                    (!originalCapacity[u] || !originalCapacity[u][v] ? ' reverse' : ''),
                                fill: 'none',
                                'marker-end': highlightPath && isEdgeInPath(u, v, highlightPath) ? 'url(#arrowhead-highlighted-res)' : 'url(#arrowhead-res)'
                            });
                            svg.appendChild(path1);

                            // 绘制 v -> u 的曲线
                            const path2 = createSVGElement('path', {
                                d: `M ${to.x - (dx / distance) * radius} ${to.y - (dy / distance) * radius} 
                                    Q ${midX - offsetX} ${midY - offsetY} 
                                    ${from.x + (dx / distance) * radius} ${from.y + (dy / distance) * radius}`,
                                class: 'edge' +
                                    (highlightPath && isEdgeInPath(v, u, highlightPath) ? ' highlighted' : '') +
                                    (!originalCapacity[v] || !originalCapacity[v][u] ? ' reverse' : ''),
                                fill: 'none',
                                'marker-end': highlightPath && isEdgeInPath(v, u, highlightPath) ? 'url(#arrowhead-highlighted-res)' : 'url(#arrowhead-res)'
                            });
                            svg.appendChild(path2);

                            // 标签 u -> v
                            const label1Bg = createSVGElement('rect', {
                                x: midX + offsetX / 2 - 15,
                                y: midY + offsetY / 2 - 10,
                                width: 30,
                                height: 20,
                                fill: 'white',
                                stroke: '#ddd',
                                'stroke-width': 1,
                                rx: 3
                            });
                            svg.appendChild(label1Bg);

                            const label1 = createSVGElement('text', {
                                x: midX + offsetX / 2,
                                y: midY + offsetY / 2,
                                class: 'edge-label',
                                'text-anchor': 'middle',
                                'dominant-baseline': 'middle'
                            });
                            label1.textContent = residual[u][v];
                            svg.appendChild(label1);

                            // 标签 v -> u
                            const label2Bg = createSVGElement('rect', {
                                x: midX - offsetX / 2 - 15,
                                y: midY - offsetY / 2 - 10,
                                width: 30,
                                height: 20,
                                fill: 'white',
                                stroke: '#ddd',
                                'stroke-width': 1,
                                rx: 3
                            });
                            svg.appendChild(label2Bg);

                            const label2 = createSVGElement('text', {
                                x: midX - offsetX / 2,
                                y: midY - offsetY / 2,
                                class: 'edge-label',
                                'text-anchor': 'middle',
                                'dominant-baseline': 'middle'
                            });
                            label2.textContent = residual[v][u];
                            svg.appendChild(label2);

                        } else if (!hasReverseEdge) {
                            // 绘制单向边（直线）
                            const dx = to.x - from.x;
                            const dy = to.y - from.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            const startX = from.x + (dx / distance) * radius;
                            const startY = from.y + (dy / distance) * radius;
                            const endX = to.x - (dx / distance) * (radius + 10);
                            const endY = to.y - (dy / distance) * (radius + 10);

                            const edge = createSVGElement('line', {
                                x1: startX,
                                y1: startY,
                                x2: endX,
                                y2: endY,
                                class: 'edge' +
                                    (highlightPath && isEdgeInPath(u, v, highlightPath) ? ' highlighted' : '') +
                                    (isReverse ? ' reverse' : ''),
                                'marker-end': highlightPath && isEdgeInPath(u, v, highlightPath) ? 'url(#arrowhead-highlighted-res)' : 'url(#arrowhead-res)'
                            });
                            svg.appendChild(edge);

                            // 边的标签
                            const midX = (startX + endX) / 2;
                            const midY = (startY + endY) / 2;

                            const labelBg = createSVGElement('rect', {
                                x: midX - 15,
                                y: midY - 10,
                                width: 30,
                                height: 20,
                                fill: 'white',
                                stroke: '#ddd',
                                'stroke-width': 1,
                                rx: 3
                            });
                            svg.appendChild(labelBg);

                            const label = createSVGElement('text', {
                                x: midX,
                                y: midY,
                                class: 'edge-label',
                                'text-anchor': 'middle',
                                'dominant-baseline': 'middle'
                            });
                            label.textContent = residual[u][v];
                            svg.appendChild(label);
                        }
                    }
                }
            }

            // 绘制节点
            drawNodes(svg, highlightPath);
        }

        function drawNodes(svg, highlightPath) {
            for (let nodeName in nodes) {
                const node = nodes[nodeName];
                const g = createSVGElement('g', {
                    class: 'node' +
                        (nodeName === src ? ' source' : '') +
                        (nodeName === dst ? ' sink' : '') +
                        (highlightPath && highlightPath.includes(nodeName) ? ' highlighted' : '')
                });

                const circle = createSVGElement('circle', {
                    cx: node.x,
                    cy: node.y,
                    r: 25
                });
                g.appendChild(circle);

                const text = createSVGElement('text', {
                    x: node.x,
                    y: node.y
                });
                text.textContent = nodeName;
                g.appendChild(text);

                svg.appendChild(g);
            }
        }

        function isEdgeInPath(u, v, path) {
            for (let i = 0; i < path.length - 1; i++) {
                if (path[i] === u && path[i + 1] === v) return true;
            }
            return false;
        }

        function findAugmentingPath() {
            const visited = {};
            const parent = {};
            const queue = [src];
            visited[src] = true;

            while (queue.length > 0) {
                const u = queue.shift();

                if (u === dst) {
                    const path = [];
                    let current = dst;
                    while (current) {
                        path.unshift(current);
                        current = parent[current];
                    }
                    return path;
                }

                if (residual[u]) {
                    for (let v in residual[u]) {
                        if (!visited[v] && residual[u][v] > 0) {
                            visited[v] = true;
                            parent[v] = u;
                            queue.push(v);
                        }
                    }
                }
            }

            return null;
        }

        function getPathFlow(path) {
            let minFlow = Infinity;
            for (let i = 0; i < path.length - 1; i++) {
                minFlow = Math.min(minFlow, residual[path[i]][path[i + 1]]);
            }
            return minFlow;
        }

        function updateFlowAndResidual(path, flowValue) {
            for (let i = 0; i < path.length - 1; i++) {
                const u = path[i];
                const v = path[i + 1];

                // 更新残余网络
                residual[u][v] -= flowValue;
                if (!residual[v]) residual[v] = {};
                residual[v][u] = (residual[v][u] || 0) + flowValue;

                // 更新实际流量
                if (originalCapacity[u] && originalCapacity[u][v]) {
                    // 正向边，增加流量
                    actualFlow[u][v] = (actualFlow[u][v] || 0) + flowValue;
                } else if (originalCapacity[v] && originalCapacity[v][u]) {
                    // 反向边，减少流量
                    actualFlow[v][u] = Math.max(0, (actualFlow[v][u] || 0) - flowValue);
                }
            }
        }

        function stepForward() {
            currentPath = findAugmentingPath();

            if (!currentPath) {
                document.getElementById('stepBtn').disabled = true;
                document.getElementById('currentPath').style.display = 'block';
                document.getElementById('currentPath').innerHTML = '<strong>算法结束！</strong> 找不到更多增广路径。';
                document.getElementById('stepExplanation').style.display = 'block';
                document.getElementById('stepExplanation').innerHTML =
                    `<strong>最大流计算完成!</strong><br>
                     从 A 到 D 的最大流量为: <span style="font-size: 24px; color: #007bff;">${maxFlow}</span><br>
                     共执行了 ${step} 步。`;
                return;
            }

            const pathFlow = getPathFlow(currentPath);
            step++;

            document.getElementById('currentPath').style.display = 'block';
            document.getElementById('currentPath').innerHTML =
                `<strong>第 ${step} 步：</strong>找到增广路径: ${currentPath.join(' → ')}<br>
                 路径最小残余容量: <strong>${pathFlow}</strong>`;

            // 显示路径中每条边的详细信息
            let edgeDetails = [];
            for (let i = 0; i < currentPath.length - 1; i++) {
                const u = currentPath[i];
                const v = currentPath[i + 1];
                const isReverse = !originalCapacity[u] || !originalCapacity[u][v];
                edgeDetails.push(`${u}→${v}: 剩余容量 ${residual[u][v]}${isReverse ? ' (反向边)' : ''}`);
            }

            document.getElementById('stepExplanation').style.display = 'block';
            document.getElementById('stepExplanation').innerHTML =
                `<strong>操作说明：</strong><br>
                 1. 沿路径推送 ${pathFlow} 单位流量<br>
                 2. 路径详情：${edgeDetails.join(', ')}<br>
                 3. 更新后：正向边容量减少 ${pathFlow}，反向边容量增加 ${pathFlow}`;

            updateFlowAndResidual(currentPath, pathFlow);
            maxFlow += pathFlow;

            document.getElementById('currentFlow').textContent = maxFlow;
            document.getElementById('stepCount').textContent = step;

            drawFlowGraph('flowGraph', currentPath);
            drawResidualGraph('residualGraph', currentPath);
        }

        function runAll() {
            while (findAugmentingPath()) {
                stepForward();
            }
            stepForward();
        }

        function reset() {
            initializeFlow();
            document.getElementById('currentFlow').textContent = '0';
            document.getElementById('stepCount').textContent = '0';
            document.getElementById('stepBtn').disabled = false;
            document.getElementById('currentPath').style.display = 'none';
            document.getElementById('stepExplanation').style.display = 'none';
            drawFlowGraph('flowGraph');
            drawResidualGraph('residualGraph');
        }

        // 初始化
        reset();

        // 初始化配置面板
        initializeConfigPanel();
    </script>
</body>

</html>