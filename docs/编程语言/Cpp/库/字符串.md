---
aliases: 
tags: 
date: 2025-01-06
date_modified: 2025-08-08
---

# 字符串

在C语言中，字符串就是一个以`\0`结尾的`char *`。可以说是过于简陋了。在现代C++中，`std::string`和`std::string_view`提供了更高级的字符串抽象。C++的`std::string`可以认为是char序列，类似Rust的`Vec<u8>`；C++17引入的`string_view`则类似于`&[u8]`。

## 字符串的常用方法

对于更熟悉C的选手来说，`s.data()`/`s.c_str()`方法可以获得指向string首字符的指针，然后就可以获得使用C语言操作`char*`的相同体验，吗？不一定，除非说这个字符串中没有`\0`。

回顾一下C语言操作字符串的常用方法：

| 序号  | 函数 & 目的                                                                                                                  |
| --- | ------------------------------------------------------------------------------------------------------------------------ |
| 1   | **strcpy(s1, s2);**  <br>复制字符串 s2 到字符串 s1。                                                                               |
| 2   | **strcat(s1, s2);**  <br>连接字符串 s2 到字符串 s1 的末尾。                                                                           |
| 3   | **strlen(s1);**  <br>返回字符串 s1 的长度。                                                                                       |
| 4   | **strcmp(s1, s2);**  <br>如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。<br>对应C++的compare方法。                    |
| 5   | **strchr(s1, ch);**  <br>返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。                                                               |
| 6   | **strstr(s1, s2);**  <br>返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。<br>这就是字符串匹配问题，然而C标准库的实现貌似是时间复杂度O(N^2)的朴素实现。<br>对应C++的find方法。 |

> cpp的string.find() **没有明确规定具体使用哪种字符串匹配算法**。取决于标准库的具体实现。貌似在短串使用暴力做法，长串使用Boyer-Moore。
> 字符串匹配算法有大名鼎鼎的KMP算法，然而这种算法不太实用。C++17引入了​**​Boyer-Moore**字符串匹配算法，能够在文本中快速查找子串（模式），尤其适合处理大文本或频繁搜索的场景，比KMP算法更快。

看看C++提供了哪些字符串的操作方法：

- compare