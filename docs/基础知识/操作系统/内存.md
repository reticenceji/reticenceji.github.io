---
aliases: 
tags: 
date: 2025-09-02
date_modified: 2025-09-02
---

# 内存

## 物理内存和虚拟内存

**物理内存**指的是计算机中实际存在的硬件内存。物理内存是计算机用于存储运行中程序和数据的实际内存资源，操作系统和应用程序最终都必须使用物理内存来执行。
**虚拟内存**是操作系统提供的一种内存管理技术，它使得应用程序认为自己有连续的、独立的内存空间。操作系统和硬件（MMU）负责将进程使用的虚拟地址映射到实际的物理地址。

> [!NOTE]
> 但是**物理地址**不一定真的指向**物理内存**。CPU可能会用地址来映射一些寄存器。它实际上是CPU想要在​**​系统总线上通信的唯一地址空间​**​中的某个位置。这个统一的地址空间可以映射到多种不同的物理设备。

将虚拟地址映射到物理地址到具体方式取决于硬件架构和操作系统的实现。以RISC-V Sv39为例，其他的硬件架构也大同小异。

1. 虚拟地址：一个 64 位的 Sv39 虚拟地址，实际只使用低 39 位。更高的位必须全是 0 或 1（符号扩展），如下表所示。可以注意到页内偏移有12bit，所以一页的大小是$2^{12}B=4KB$。

| 位 (Bits) | 名称                  | 作用                              |
| -------- | ------------------- | ------------------------------- |
| 63-39    |                     | 符号扩展位（必须全为 0 或全为 1）             |
| 38-30    | ​**​VPN[2]​**​      | ​**​Level-2​**​ 虚拟页号（用于索引第三级页表） |
| 29-21    | ​**​VPN[1]​**​      | ​**​Level-1​**​ 虚拟页号（用于索引第二级页表） |
| 20-12    | ​**​VPN[0]​**​      | ​**​Level-0​**​ 虚拟页号（用于索引第一级页表） |
| 11-0     | ​**​Page Offset​**​ | ​**​页内偏移​**​（4KB 页内的字节索引）       |

然后用虚拟地址的VPN到页表去寻找页表项，页表基地址存在`satp`寄存器中。

| Bits  | 名称          | 描述                                    |
| ----- | ----------- | ------------------------------------- |
| 63-54 |             | 保留位 (Reserved)                        |
| 53-10 | ​**​PPN​**​ | 物理页号                                  |
| 9-8   | ​**​RSW​**​ | 为监管者软件保留 (Reserved for Software)      |
| 7     | ​**​D​**​   | Dirty (脏) - 表示该页是否被写入过                |
| 6     | ​**​A​**​   | Accessed (访问过) - 表示该页是否被读/写过          |
| 5     | ​**​G​**​   | Global (全局) - 用于地址空间标识符 (ASID)，TLB 相关 |
| 4     | ​**​U​**​   | User (用户) - 表示用户模式是否可访问该页             |
| 3     | ​**​X​**​   | eXecutable (可执行)                      |
| 2     | ​**​W​**​   | Writable (可写)                         |
| 1     | ​**​R​**​   | Readable (可读),RWX=000表示这是页表的非叶子节点     |
| 0     | ​**​V​**​   | Valid (有效) - 这是最重要的位，表示该 PTE 是否有效     |

`PPN << 12 + Page Offset`就是每次寻址的地址了。这个过程是由硬件完成的。可以看到，如果说不考虑缓存因素，为了读一个地址可能要读4个地址的内容，还不是连续的。所以，有专门缓存内存内容的多级Cache和专门缓存页表内容的TLB。

TLB的结构可以看作一个 `(Key, Value)`对的缓存。TLB对软件来说是​**​透明​**​的，其填充由硬件自动完成。但操作系统必须负责在页表内容发生变化时，​**​手动管理 TLB 的一致性​**​。还是以RISCV为例，操作系统把一个物理页换出到磁盘后，修改对应PTE到Valid为0，之后必须调用[`sfence.vma`](https://five-embeddev.com/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#sec:sfence.vma)指令同步内存。

## 内存管理算法

[内存管理](内存管理.md)

## 内存不够了怎么办 - 时间换空间

最简单的办法，就是把进程杀掉。也就是常见的OOM。

当然，操作系统还有一些办法来尽可能避免OOM，主要有**交换**和**压缩**。

- 压缩：将一些最近最少使用的内存页，通常是匿名页，采用压缩算法，存储到一个专用的压缩内存池中。这样在后面访问对应的内存时，触发缺页异常，然后再解压。属于用CPU换内存。
- 交换：将一些最近最少使用的内存页，通常是匿名页，换出到磁盘上（通常是一个交换分区）。这样在后面访问对应的内存时，触发缺页异常，然后再从磁盘读取对应的内容。属于用磁盘换内存。

交换是比较传统简单的方式。压缩一般会更快一点。他们都是用时间换空间。如果真遇到了内存不够的问题，最好的办法是换一个大一点的内存：）